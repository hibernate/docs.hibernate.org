<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Hibernate Validator</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate Validator, Annotation based constraints for your domain model - Reference Documentation" /><meta name="keywords" content="hibernate, validator, hibernate validator, validation, bean validation" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" href="css/hibernate-single.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e3"/>Hibernate Validator</h1></div><div><h2 class="subtitle">JSR 303 Reference Implementation</h2></div><div><h2 class="subtitle">Reference Guide</h2></div><div><p class="releaseinfo">4.0.2.GA</p></div><div><p class="copyright">Copyright © 2009 Red Hat Middleware, LLC. &amp; Gunnar Morling</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#validator-gettingstarted">1. Getting started</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-gettingstarted-createproject">1.1. Setting up a new Maven project</a></span></dt><dt><span class="section"><a href="#validator-gettingstarted-createmodel">1.2. Applying constraints</a></span></dt><dt><span class="section"><a href="#d0e158">1.3. Validating constraints</a></span></dt><dt><span class="section"><a href="#validator-gettingstarted-whatsnext">1.4. Where to go next?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-usingvalidator">2. Validation step by step</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-usingvalidator-annotate">2.1. Defining constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e265">2.1.1. Field-level constraints</a></span></dt><dt><span class="section"><a href="#d0e291">2.1.2. Property-level constraints</a></span></dt><dt><span class="section"><a href="#d0e328">2.1.3. Class-level
      constraints</a></span></dt><dt><span class="section"><a href="#d0e361">2.1.4. Constraint inheritance</a></span></dt><dt><span class="section"><a href="#d0e421">2.1.5. Object graphs</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-usingvalidator-validate">2.2. Validating constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-obtaining-validator">2.2.1. Obtaining a Validator instance</a></span></dt><dt><span class="section"><a href="#d0e590">2.2.2. Validator methods</a></span></dt><dt><span class="section"><a href="#d0e688">2.2.3. ConstraintViolation methods</a></span></dt><dt><span class="section"><a href="#section-message-interpolation">2.2.4. Message interpolation</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-usingvalidator-validationgroups">2.3. Validating groups</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1015">2.3.1. Group sequences</a></span></dt><dt><span class="section"><a href="#section-default-group-class">2.3.2. Redefining the default group sequence of a class</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-defineconstraints-builtin">2.4. Built-in constraints</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-customconstraints">3. Creating custom constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-customconstraints-simple">3.1. Creating a simple constraint</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-customconstraints-constraintannotation">3.1.1. The constraint annotation</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-validator">3.1.2. The constraint
      validator</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-errormessage">3.1.3. The error message</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-using">3.1.4. Using the constraint</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-customconstraints-compound">3.2. Constraint composition</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-xmlconfiguration">4. XML configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1867">4.1. validation.xml</a></span></dt><dt><span class="section"><a href="#d0e1957">4.2. Mapping constraints</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-bootstrapping">5. Bootstrapping</a></span></dt><dd><dl><dt><span class="section"><a href="#section-validator-instance">5.1. Configuration and
    ValidatorFactory</a></span></dt><dt><span class="section"><a href="#d0e2185">5.2. ValidationProviderResolver</a></span></dt><dt><span class="section"><a href="#d0e2217">5.3. MessageInterpolator</a></span></dt><dt><span class="section"><a href="#d0e2255">5.4. TraversableResolver</a></span></dt><dt><span class="section"><a href="#d0e2303">5.5. ConstraintValidatorFactory</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-checkconstraints">6. Integration with other frameworks</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-checkconstraints-db">6.1. Database schema-level validation</a></span></dt><dt><span class="section"><a href="#validator-checkconstraints-orm">6.2. ORM integration</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-checkconstraints-orm-hibernateevent">6.2.1. Hibernate event-based validation</a></span></dt><dt><span class="section"><a href="#d0e2461">6.2.2. JPA </a></span></dt></dl></dd><dt><span class="section"><a href="#section-presentation-layer">6.3. Presentation layer validation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e2525">7. Further reading</a></span></dt></dl></div><div class="preface" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Preface</h2></div></div></div><p>Validating data is a common task that occurs throughout any
    application, from the presentation layer to the persistence layer. Often
    the same validation logic is implemented in each layer, proving time
    consuming and error-prone. To avoid duplication of these validations in
    each layer, developers often bundle validation logic directly into the
    domain model, cluttering domain classes with validation code which is
    really metadata about the class itself.</p><div class="mediaobject"><img src="application-layers.png"/></div><p>JSR 303 - Bean Validation - defines a metadata model and API for
    entity validation. The default metadata source is annotations, with the
    ability to override and extend the meta-data through the use of XML. The
    API is not tied to a specific application tier or programming model. It is
    specifically not tied to either the web tier or the persistence tier, and
    is available for both server-side application programming, as well as rich
    client Swing application developers.</p><div class="mediaobject"><img src="application-layers2.png"/></div><p>Hibernate Validator is the reference implementation of this
    JSR.</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-gettingstarted"/>Chapter 1. Getting started</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#validator-gettingstarted-createproject">1.1. Setting up a new Maven project</a></span></dt><dt><span class="section"><a href="#validator-gettingstarted-createmodel">1.2. Applying constraints</a></span></dt><dt><span class="section"><a href="#d0e158">1.3. Validating constraints</a></span></dt><dt><span class="section"><a href="#validator-gettingstarted-whatsnext">1.4. Where to go next?</a></span></dt></dl></div><p>This chapter will show you how to get started with Hibernate
  Validator, the reference implementation (RI) of Bean Validation. For the
  following quickstart you need:</p><div class="itemizedlist"><ul><li><p>A JDK &gt;= 5</p></li><li><p><a class="ulink" href="http://maven.apache.org/">Apache Maven</a></p></li><li><p>An Internet connection (Maven has to download all required
      libraries)</p></li><li><p>A properly configured remote repository. Add the following to your
      <code class="filename">settings.xml</code>: </p><div class="example"><a id="d0e67"/><p class="title"><b>Example 1.1. Configuring the JBoss Maven repository in
          <code class="filename">settings.xml</code></b></p><div class="example-contents"><pre class="programlisting">&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;jboss&lt;/id&gt;
        &lt;url&gt;http://repository.jboss.com/maven2&lt;/url&gt;
        &lt;releases&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/releases&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;false&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</pre></div></div><p><br class="example-break"/>More information about <code class="filename">settings.xml</code> can
      be found in the <a class="ulink" href="http://maven.apache.org/ref/2.0.8/maven-settings/settings.html">Maven
      Local Settings Model</a>.</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-gettingstarted-createproject"/>1.1. Setting up a new Maven project</h2></div></div></div><p>Start by creating new Maven project using the Maven archetype plugin
    as follows:</p><div class="example"><a id="d0e87"/><p class="title"><b>Example 1.2. Using Maven's archetype plugin to create a sample project using
        Hibernate Validator</b></p><div class="example-contents"><pre class="programlisting">mvn archetype:generate \
  -DarchetypeCatalog=http://repository.jboss.com/maven2/archetype-catalog.xml \
  -DgroupId=com.mycompany \
  -DartifactId=beanvalidation-gettingstarted \
  -Dversion=1.0-SNAPSHOT \
  -Dpackage=com.mycompany</pre></div></div><p><br class="example-break"/></p><p>When presented with the list of available archetypes in the JBoss
    Maven Repository select the
    <span class="emphasis"><em>hibernate-validator-quickstart-archetype. </em></span>After Maven
    has downloaded all dependencies confirm the settings by just pressing
    enter. Maven will create your project in the directory
    <code class="filename">beanvalidation-gettingstarted</code>. Change into this
    directory and run:</p><pre class="programlisting">mvn test</pre><p>Maven will compile the
    example code and run the implemented unit tests. Let's have a look at the
    actual code.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-gettingstarted-createmodel"/>1.2. Applying constraints</h2></div></div></div><p>Open the project in the IDE of your choice and have a look at the
    class <code class="classname">Car</code>:</p><div class="example"><a id="example-class-car"/><p class="title"><b>Example 1.3. Class Car annotated with constraints</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class Car {

    <span class="bold"><strong>@NotNull</strong></span>
    private String manufacturer;

    <span class="bold"><strong>@NotNull</strong></span>
    <span class="bold"><strong>@Size(min = 2, max = 14)</strong></span>
    private String licensePlate;

    <span class="bold"><strong>@Min(2)</strong></span>
    private int seatCount;
    
    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</pre></div></div><p><br class="example-break"/><code class="classname">@NotNull</code>, <code class="classname">@Size</code>
    and <code class="classname">@Min</code> are so-called constraint annotations, that
    we use to declare constraints, which shall be applied to the fields of a
    <code class="classname">Car</code> instance:</p><div class="itemizedlist"><ul><li><p><span class="property">manufacturer</span> shall never be null</p></li><li><p><span class="property">licensePlate</span> shall never be null and must
        be between 2 and 14 characters long</p></li><li><p><span class="property">seatCount</span> shall be at least 2.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e158"/>1.3. Validating constraints</h2></div></div></div><p>To perform a validation of these constraints, we use a
    <code class="classname">Validator</code> instance. Let's have a look at the
    <code class="classname">CarTest</code> class:</p><div class="example"><a id="d0e169"/><p class="title"><b>Example 1.4. Class CarTest showing validation examples</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import static org.junit.Assert.*;

import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;

import org.junit.BeforeClass;
import org.junit.Test;

public class CarTest {

    private static Validator validator;

    @BeforeClass
    public static void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void manufacturerIsNull() {
        Car car = new Car(null, "DD-AB-123", 4);

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
            validator.validate(car);

        assertEquals(1, constraintViolations.size());
        assertEquals("may not be null", constraintViolations.iterator().next().getMessage());
    }

    @Test
    public void licensePlateTooShort() {
        Car car = new Car("Morris", "D", 4);

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = 
            validator.validate(car);

        assertEquals(1, constraintViolations.size());
        assertEquals("size must be between 2 and 14", constraintViolations.iterator().next().getMessage());
    }
    
    @Test
    public void seatCountTooLow() {
        Car car = new Car("Morris", "DD-AB-123", 1);

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
            validator.validate(car);

        assertEquals(1, constraintViolations.size());
        assertEquals("must be greater than or equal to 2", constraintViolations.iterator().next().getMessage());
    }

    @Test
    public void carIsValid() {
        Car car = new Car("Morris", "DD-AB-123", 2);

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
            validator.validate(car);

        assertEquals(0, constraintViolations.size());
    }
}</pre></div></div><br class="example-break"/><p>In the <code class="methodname">setUp()</code> method we get a
    <code class="classname">Validator</code> instance from the
    <code class="classname">ValidatorFactory</code>. A
    <code class="classname">Validator</code> instance is thread-safe and may be reused
    multiple times. For this reason we store it as field of our test class. We
    can use the <code class="classname">Validator</code> now to validate the different
    car instances in the test methods.</p><p>The <code class="methodname">validate()</code> method returns a set of
    <code class="classname">ConstraintViolation</code> instances, which we can iterate
    in order to see which validation errors occurred. The first three test
    methods show some expected constraint violations:</p><div class="itemizedlist"><ul><li><p>The <code class="classname">@NotNull</code> constraint on manufacturer
        is violated in <code class="methodname">manufacturerIsNull()</code></p></li><li><p>The <code class="classname">@Size</code> constraint on licensePlate is
        violated in <code class="methodname">licensePlateTooShort()</code></p></li><li><p>The <code class="classname">@Min</code> constraint on seatCount is
        violated in <code class="methodname">seatCountTooLow()</code></p></li></ul></div><p>If the object validates successfully,
    <code class="methodname">validate()</code> returns an empty set.</p><p>Note that we only use classes from the package
    <span class="package">javax.validation</span> from the Bean Validation API. As we
    don't reference any classes of the RI directly, it would be no problem to
    switch to another implementation of the API, should that need
    arise.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-gettingstarted-whatsnext"/>1.4. Where to go next?</h2></div></div></div><p>That concludes our 5 minute tour through the world of Hibernate
    Validator. Continue exploring the code or look at further examples
    referenced in <a class="xref" href="#chapter-further-reading">Chapter 7, <i>Further reading</i></a>. To get a deeper
    understanding of the Bean Validation just continue reading.<a class="xref" href="#validator-usingvalidator" title="Chapter 2. Validation step by step">Chapter 2, <i>Validation step by step</i></a>. In case your application has
    specific validation requirements have a look at <a class="xref" href="#validator-customconstraints" title="Chapter 3. Creating custom constraints">Chapter 3, <i>Creating custom constraints</i></a>.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-usingvalidator"/>Chapter 2. Validation step by step</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#validator-usingvalidator-annotate">2.1. Defining constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e265">2.1.1. Field-level constraints</a></span></dt><dt><span class="section"><a href="#d0e291">2.1.2. Property-level constraints</a></span></dt><dt><span class="section"><a href="#d0e328">2.1.3. Class-level
      constraints</a></span></dt><dt><span class="section"><a href="#d0e361">2.1.4. Constraint inheritance</a></span></dt><dt><span class="section"><a href="#d0e421">2.1.5. Object graphs</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-usingvalidator-validate">2.2. Validating constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-obtaining-validator">2.2.1. Obtaining a Validator instance</a></span></dt><dt><span class="section"><a href="#d0e590">2.2.2. Validator methods</a></span></dt><dt><span class="section"><a href="#d0e688">2.2.3. ConstraintViolation methods</a></span></dt><dt><span class="section"><a href="#section-message-interpolation">2.2.4. Message interpolation</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-usingvalidator-validationgroups">2.3. Validating groups</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1015">2.3.1. Group sequences</a></span></dt><dt><span class="section"><a href="#section-default-group-class">2.3.2. Redefining the default group sequence of a class</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-defineconstraints-builtin">2.4. Built-in constraints</a></span></dt></dl></div><p>In this chapter we will see in more detail how to use Hibernate
  Validator to validate constraints for a given entity model. We will also
  learn which default constraints the Bean Validation specification provides
  and which additional constraints are only provided by Hibernate Validator.
  Let's start with how to add constraints to an entity.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-usingvalidator-annotate"/>2.1. Defining constraints</h2></div></div></div><p>Constraints in Bean Validation are expressed via Java annotations.
    In this section we show how to annotate an object model with these
    annotations. We have to differentiate between three different type of
    constraint annotations - field-, property-, and class-level
    annotations.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Not all constraints can be placed on all of these levels. In fact,
      none of the default constraints defined by Bean Validation can be placed
      at class level. The <code class="classname">java.lang.annotation.Target</code>
      annotation in the constraint annotation itself determines on which
      elements a constraint can be placed. See <a class="xref" href="#validator-customconstraints" title="Chapter 3. Creating custom constraints">Chapter 3, <i>Creating custom constraints</i></a> for more information.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e265"/>2.1.1. Field-level constraints</h3></div></div></div><p>Constraints can be expressed by annotating a field of a class.
      <a class="xref" href="#example-field-level" title="Example 2.1. Field level constraint">Example 2.1, “Field level constraint”</a> shows a field level configuration
      example:</p><div class="example"><a id="example-field-level"/><p class="title"><b>Example 2.1. Field level constraint</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Car {

    <span class="bold"><strong>@NotNull</strong></span>
    private String manufacturer;

    <span class="bold"><strong>@AssertTrue</strong></span>
    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }
}</pre></div></div><br class="example-break"/><p>When using field level constraints field access strategy is used
      to access the value to be validated. This means the instance variable
      directly independed of the access type.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The access type (private, protected or public) does not
        matter.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Static fields and properties cannot be validated.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e291"/>2.1.2. Property-level constraints</h3></div></div></div><p>If your model class adheres to the <a class="ulink" href="http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp">JavaBeans</a>
      standard, it is also possible to annotate the properties of a bean class
      instead of its fields. <a class="xref" href="#example-property-level" title="Example 2.2. Property level constraint">Example 2.2, “Property level constraint”</a> uses
      the same entity as in <a class="xref" href="#example-field-level" title="Example 2.1. Field level constraint">Example 2.1, “Field level constraint”</a>, however,
      property level constraints are used.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The property's getter method has to be annotated, not its
          setter.</p></div><div class="example"><a id="example-property-level"/><p class="title"><b>Example 2.2. Property level constraint</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.NotNull;

public class Car {

    private String manufacturer;

    private boolean isRegistered;
      
    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    <span class="bold"><strong>@NotNull</strong></span>
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    <span class="bold"><strong>@AssertTrue</strong></span>
    public boolean isRegistered() {
        return isRegistered;
    }

    public void setRegistered(boolean isRegistered) {
        this.isRegistered = isRegistered;
    }
}</pre></div></div><br class="example-break"/><p>When using property level constraints property access strategy is
      used to access the value to be validated. This means the bean validation
      provider accesses the state via the property accessor method.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>It is recommended to stick either to field
        <span class="emphasis"><em>or</em></span> property annotation within one class. It is
        not recommended to annotate a field <span class="emphasis"><em>and</em></span> the
        accompanying getter method as this would cause the field to be
        validated twice.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e328"/>2.1.3. Class-level
      constraints</h3></div></div></div><p>Last but not least, a constraint can also be placed on class
      level. When a constraint annotation is placed on this level the class
      instance itself passed to the
      <code class="classname">ConstraintValidator</code>. Class level constraints are
      useful if it is necessary to inspect more than a single property of the
      class to validate it or if a correlation between different state
      variables has to be evaluated. In <a class="xref" href="#example-class-level" title="Example 2.3. Class level constraint">Example 2.3, “Class level constraint”</a>
      we add the property <span class="property">passengers</span> to the class
      <code class="classname">Car</code>. We also add the constraint
      <code class="classname">PassengerCount</code> on the class level. We will later
      see how we can actually create this custom constraint (see <a class="xref" href="#validator-customconstraints" title="Chapter 3. Creating custom constraints">Chapter 3, <i>Creating custom constraints</i></a>). For now we it is enough to
      know that <code class="classname">PassengerCount</code> will ensure that there
      cannot be more passengers in a car than there are seats.</p><div class="example"><a id="example-class-level"/><p class="title"><b>Example 2.3. Class level constraint</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

<span class="bold"><strong>@PassengerCount</strong></span>
public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;
    
    private List&lt;Person&gt; passengers;
    
    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e361"/>2.1.4. Constraint inheritance</h3></div></div></div><p>When validating an object that implements an interface or extends
      another class, all constraint annotations on the implemented interface
      and parent class apply in the same manner as the constraints specified
      on the validated object itself. To make things clearer let's have a look
      at the following example:</p><div class="example"><a id="d0e366"/><p class="title"><b>Example 2.4. Constraint inheritance using RentalCar</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.NotNull;

public class RentalCar extends Car {

    private String rentalStation;
    
    public RentalCar(String manufacturer, String rentalStation) {
        super(manufacturer);
        this.rentalStation = rentalStation;
    }
    
    <span class="bold"><strong>@NotNull</strong></span>
    public String getRentalStation() {
        return rentalStation;
    }

    public void setRentalStation(String rentalStation) {
        this.rentalStation = rentalStation;
    }
}</pre></div></div><br class="example-break"/><p>Our well-known class <code class="classname">Car</code> from <a class="xref" href="#">???</a> is now extended by
      <code class="classname">RentalCar</code> with the additional property
      <span class="property">rentalStation</span>. If an instance of
      <code class="classname">RentalCar</code> is validated, not only the
      <code class="classname">@NotNull</code> constraint on
      <span class="property">rentalStation</span> is validated, but also the constraint
      on <span class="property">manufacturer</span> from the parent class.</p><p>The same would hold true, if <code class="classname">Car</code> were an
      interface implemented by <code class="classname">RentalCar</code>.</p><p>Constraint annotations are aggregated if methods are overridden.
      If <code class="classname">RentalCar</code> would override the
      <code class="methodname">getManufacturer()</code> method from
      <code class="classname">Car</code> any constraints annotated at the overriding
      method would be evaluated in addition to the
      <code class="classname">@NotNull</code> constraint from the super-class.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e421"/>2.1.5. Object graphs</h3></div></div></div><p>The Bean Validation API does not only allow to validate single
      class instances but also complete object graphs. To do so, just annotate
      a field or property representing a reference to another object with
      <code class="classname">@Valid</code>. If the parent object is validated, all
      referenced objects annotated with <code class="classname">@Valid</code> will be
      validated as well (as will be their children etc.). See <a class="xref" href="#example-car-with-driver" title="Example 2.6. Adding a driver to the car">Example 2.6, “Adding a driver to the car”</a>.</p><div class="example"><a id="d0e434"/><p class="title"><b>Example 2.5. Class Person</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Person {

    <span class="bold"><strong>@NotNull</strong></span>
    private String name;
    
    public Person(String name) {
        super();
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre></div></div><br class="example-break"/><div class="example"><a id="example-car-with-driver"/><p class="title"><b>Example 2.6. Adding a driver to the car</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    <span class="bold"><strong>@NotNull</strong></span>
    <span class="bold"><strong>@Valid</strong></span>
    private Person driver;
    
    public Car(Person driver) {
        this.driver = driver;
    }

    //getters and setters ...
}</pre></div></div><br class="example-break"/><p>If an instance of <code class="classname">Car</code> is validated, the
      referenced <code class="classname">Person</code> object will be validated as
      well, as the <span class="property">driver</span> field is annotated with
      <code class="classname">@Valid</code>. Therefore the validation of a
      <code class="classname">Car</code> will fail if the <span class="property">name</span>
      field of the referenced <code class="classname">Person</code> instance is
      <code class="code">null</code>.</p><p>Object graph validation also works for collection-typed fields.
      That means any attributes that are</p><div class="itemizedlist"><ul><li><p>arrays</p></li><li><p>implement <code class="classname">java.lang.Iterable</code>
          (especially <code class="classname">Collection</code>,
          <code class="classname">List</code> and <code class="classname">Set</code>)</p></li><li><p>implement <code class="classname">java.util.Map</code></p></li></ul></div><p>can be annotated with <code class="classname">@Valid</code>, which will
      cause each contained element to be validated, when the parent object is
      validated.</p><div class="example"><a id="d0e510"/><p class="title"><b>Example 2.7. Car with a list of passengers</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import java.util.ArrayList;
import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    <span class="bold"><strong>@Valid
    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();</strong></span>

    public Car(List&lt;Person&gt; passengers) {
        this.passengers = passengers;
    }

    //getters and setters ...
}</pre></div></div><br class="example-break"/><p>If a <code class="classname">Car</code> instance is validated, a
      <code class="classname">ConstraintValidation</code> will be created, if any of
      the <code class="classname">Person</code> objects contained in the
      <span class="property">passengers</span> list has a <code class="code">null</code> name.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="classname">null</code> values are getting ignored when
          validating object graphs.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-usingvalidator-validate"/>2.2. Validating constraints</h2></div></div></div><p>The <code class="classname">Validator</code> interface is the main entry
    point to Bean Validation. In <a class="xref" href="#section-validator-instance" title="5.1. Configuration and ValidatorFactory">Section 5.1, “Configuration and
    ValidatorFactory”</a>
    we will first show how to obtain an <code class="classname">Validator</code>
    instance. Afterwards we will learn how to use the different methods of the
    <code class="classname">Validator</code> interface.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="section-obtaining-validator"/>2.2.1. Obtaining a <code class="classname">Validator</code> instance</h3></div></div></div><p>The first step towards validating an entity instance is to get
      hold of a <code class="classname">Validator</code> instance. The road to this
      instance leads via the <code class="classname">Validation</code> class and a
      <code class="classname">ValidatorFactory</code>. The easiest way is to use the
      static
      <code class="methodname">Validation.buildDefaultValidatorFactory()</code>
      method:</p><div class="example"><a id="d0e576"/><p class="title"><b>Example 2.8. Validation.buildDefaultValidatorFactory()</b></p><div class="example-contents"><pre class="programlisting">ValidatorFactory factory = <span class="bold"><strong>Validation.buildDefaultValidatorFactory()</strong></span>;
Validator validator = factory.getValidator();</pre></div></div><p><br class="example-break"/>For other ways of obtaining a Validator instance see <a class="xref" href="#validator-bootstrapping" title="Chapter 5. Bootstrapping">Chapter 5, <i>Bootstrapping</i></a>. For now we just want to see how we
      can use the <code class="classname">Validator</code> instance to validate entity
      instances.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e590"/>2.2.2. Validator methods</h3></div></div></div><p>The <code class="classname">Validator</code> interface contains three
      methods that can be used to either validate entire entities or just a
      single properties of the entity.</p><p>All three methods return a
      <code class="classname">Set&lt;ConstraintViolation&gt;</code>. The set is empty,
      if the validation succeeds. Otherwise a
      <code class="classname">ConstraintViolation</code> instance is added for each
      violated constraint.</p><p>All the validation methods have a var-args parameter which can be
      used to specify, which validation groups shall be considered when
      performing the validation. If the parameter is not specified the default
      validation group (<code class="classname">javax.validation.Default</code>) will
      be used. We will go into more detail on the topic of validation groups
      in <a class="xref" href="#validator-usingvalidator-validationgroups" title="2.3. Validating groups">Section 2.3, “Validating groups”</a></p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e612"/>2.2.2.1. <code class="methodname">validate</code></h4></div></div></div><p>Use the <code class="methodname">validate()</code> method to perform
        validation of all constraints of a given entity instance (see <a class="xref" href="#example-validator-validate" title="Example 2.9. Usage of Validator.validate()">Example 2.9, “Usage of
          Validator.validate()”</a> ).</p><div class="example"><a id="example-validator-validate"/><p class="title"><b>Example 2.9. Usage of
          <code class="methodname">Validator.validate()</code></b></p><div class="example-contents"><pre class="programlisting">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = <span class="bold"><strong>validator.validate(car)</strong></span>;

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e633"/>2.2.2.2. <code class="methodname">validateProperty</code></h4></div></div></div><p>With help of the <code class="methodname">validateProperty()</code> a
        single named property of a given object can be validated. The property
        name is the JavaBeans property name.</p><div class="example"><a id="d0e642"/><p class="title"><b>Example 2.10. Usage of
          <code class="methodname">Validator.validateProperty()</code></b></p><div class="example-contents"><pre class="programlisting">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = <span class="bold"><strong>validator.validateProperty(car, "manufacturer")</strong></span>;

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</pre></div></div><br class="example-break"/><p><code class="methodname">Validator.validateProperty</code> is for
        example used in the integration of Bean Validation into JSF 2 (see
        <a class="xref" href="#section-presentation-layer" title="6.3. Presentation layer validation">Section 6.3, “Presentation layer validation”</a>).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e658"/>2.2.2.3. <code class="methodname">validateValue</code></h4></div></div></div><p>Using the <code class="methodname">validateValue() </code>method you
        can check, whether a single property of a given class can be validated
        successfully, if the property had the specified value:</p><div class="example"><a id="d0e667"/><p class="title"><b>Example 2.11. Usage of
          <code class="methodname">Validator.validateValue()</code></b></p><div class="example-contents"><pre class="programlisting">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = <span class="bold"><strong>validator.validateValue(Car.class, "manufacturer", null)</strong></span>;

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="classname">@Valid</code> is not honored by
          <code class="methodname">validateProperty()</code> or
          <code class="methodname">validateValue()</code>.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e688"/>2.2.3. <code class="classname">ConstraintViolation</code> methods</h3></div></div></div><p>Now it is time to have a closer look at what a
      <code class="classname">ConstraintViolation</code>. Using the different methods
      of <code class="classname">ConstraintViolation</code> a lot of useful
      information about the cause of the validation failure can be determined.
      <a class="xref" href="#table-constraint-violation" title="Table 2.1. The various ConstraintViolation methods">Table 2.1, “The various ConstraintViolation
        methods”</a> gives an overview of these
      methods:</p><div class="table"><a id="table-constraint-violation"/><p class="title"><b>Table 2.1. The various <code class="classname">ConstraintViolation</code>
        methods</b></p><div class="table-contents"><table summary="The various ConstraintViolation&#xA;        methods" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Method</th><th>Usage</th><th>Example (refering to <a class="xref" href="#example-validator-validate" title="Example 2.9. Usage of Validator.validate()">Example 2.9, “Usage of
          Validator.validate()”</a>)</th></tr></thead><tbody><tr><td><code class="methodname">getMessage()</code></td><td>The interpolated error message.</td><td>may not be null</td></tr><tr><td><code class="methodname">getMessageTemplate()</code></td><td>The non-interpolated error message.</td><td>{javax.validation.constraints.NotNull.message}</td></tr><tr><td><code class="methodname">getRootBean()</code></td><td>The root bean being validated.</td><td>car</td></tr><tr><td><code class="methodname">getRootBeanClass()</code></td><td>The class of the root bean being validated.</td><td>Car.class</td></tr><tr><td><code class="methodname">getLeafBean()</code></td><td>If a bean constraint, the bean instance the constraint is
              applied on. If a property constraint, the bean instance hosting
              the property the constraint is applied on.</td><td>car</td></tr><tr><td><code class="methodname">getPropertyPath()</code></td><td>The property path to the value from root bean.</td><td> </td></tr><tr><td><code class="methodname">getInvalidValue()</code></td><td>The value failing to pass the constraint.</td><td>passengers</td></tr><tr><td><code class="methodname">getConstraintDescriptor()</code></td><td>Constraint metadata reported to fail.</td><td> </td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="section-message-interpolation"/>2.2.4. Message interpolation</h3></div></div></div><p>As we will see in <a class="xref" href="#validator-customconstraints" title="Chapter 3. Creating custom constraints">Chapter 3, <i>Creating custom constraints</i></a>
      each constraint definition must define a default message descriptor.
      This message can be overridden at declaration time using the
      <code class="methodname">message</code> attribute of the constraint. You can
      see this in <a class="xref" href="#example-driver" title="Example 2.13. Driver">Example 2.13, “Driver”</a>. This message descriptors
      get interpolated when a constraint validation fails using the configured
      <code class="classname">MessageInterpolator</code>. The interpolator will try to
      resolve any message parameters, meaning string literals enclosed in
      braces. In order to resolve these parameters Hibernate Validator's
      default <code class="classname">MessageInterpolator</code> first recursively
      resolves parameters against a custom
      <code class="classname">ResourceBundle</code> called
      <code class="filename">ValidationMessages.properties</code> at the root of the
      classpath (It is up to you to create this file). If no further
      replacements are possible against the custom bundle the default
      <code class="classname">ResourceBundle</code> under
      <code class="filename">/org/hibernate/validator/ValidationMessages.properties</code>
      gets evaluated. If a replacement occurs against the default bundle the
      algorithm looks again at the custom bundle (and so on). Once no further
      replacements against these two resource bundles are possible remaining
      parameters are getting resolved against the attributes of the constraint
      to be validated.</p><p>Since the braces { and } have special meaning in the messages they
      need to be escaped if they are used literally. The following The
      following rules apply:</p><div class="itemizedlist"><ul><li><p>\{ is considered as the literal {</p></li><li><p>\} is considered as the literal }</p></li><li><p>\\ is considered as the literal \</p></li></ul></div><p>If the default message interpolator does not fit your requirements
      it is possible to plug a custom
      <code class="classname">MessageInterpolator</code> when the
      <code class="classname">ValidatorFactory</code> gets created. This can be seen
      in <a class="xref" href="#validator-bootstrapping" title="Chapter 5. Bootstrapping">Chapter 5, <i>Bootstrapping</i></a>.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-usingvalidator-validationgroups"/>2.3. Validating groups</h2></div></div></div><p>Groups allow you to restrict the set of constraints applied during
    validation. This makes for example wizard like validation possible where
    in each step only a specified subset of constraints get validated. The
    groups targeted are passed as var-args parameters to
    <code class="methodname">validate</code>,
    <code class="methodname">validateProperty</code> and
    <code class="methodname">validateValue</code>. Let's have a look at an extended
    <code class="classname">Car</code> with <code class="classname">Driver</code> example.
    First we have the class <code class="classname">Person</code> (<a class="xref" href="#example-person" title="Example 2.12. Person">Example 2.12, “Person”</a>) which has a <code class="classname">@NotNull
    </code>constraint on <span class="property">name</span>. Since no group is
    specified for this annotation its default group is
    <code class="classname">javax.validation.Default</code>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>When more than one group is requested, the order in which the
      groups are evaluated is not deterministic. If no group is specified the
      default group <code class="classname">javax.validation.Default</code> is
      assumed.</p></div><div class="example"><a id="example-person"/><p class="title"><b>Example 2.12. Person</b></p><div class="example-contents"><pre class="programlisting">public class Person {
    <span class="bold"><strong>@NotNull</strong></span>
    private String name;

    public Person(String name) {
        this.name = name;
    }
    // getters and setters ...
}</pre></div></div><p><br class="example-break"/>Next we have the class <code class="classname">Driver</code> (<a class="xref" href="#example-driver" title="Example 2.13. Driver">Example 2.13, “Driver”</a>) extending <code class="classname">Person</code>. Here
    we are adding the properties <span class="property">age</span> and
    <span class="property">hasDrivingLicense</span>. In order to drive you must be at
    least 18 (<code class="classname">@Min(18)</code>) and you must have a driving
    license (<code class="classname">@AssertTrue</code>). Both constraints defined on
    these properties belong to the group <code class="classname">DriverChecks</code>.
    As you can see in <a class="xref" href="#example-group-interfaces" title="Example 2.14. Group interfaces">Example 2.14, “Group interfaces”</a> the group
    <code class="classname">DriverChecks</code> is just a simple tagging interface.
    Using interfaces makes the usage of groups type safe and allows for easy
    refactoring. It also means that groups can inherit from each other via
    class inheritance.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The Bean Validation specification does not enforce that groups
        have to be interfaces. Non interface classes could be used as well,
        but we recommend to stick to interfaces.</p></div><div class="example"><a id="example-driver"/><p class="title"><b>Example 2.13. Driver</b></p><div class="example-contents"><pre class="programlisting">public class Driver extends Person {
    <span class="bold"><strong>@Min(value = 18, message = "You have to be 18 to drive a car", groups = DriverChecks.class)</strong></span>
    public int age;

    <span class="bold"><strong>@AssertTrue(message = "You first have to pass the driving test", groups = DriverChecks.class)</strong></span>
    public boolean hasDrivingLicense;

    public Driver(String name) {
        super( name );
    }

    public void passedDrivingTest(boolean b) {
        hasDrivingLicense = b;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}</pre></div></div><p><br class="example-break"/></p><div class="example"><a id="example-group-interfaces"/><p class="title"><b>Example 2.14. Group interfaces</b></p><div class="example-contents"><pre class="programlisting">public interface DriverChecks {
}

public interface CarChecks {
}</pre></div></div><p><br class="example-break"/>Last but not least we add the property
    <span class="property">passedVehicleInspection</span> to the
    <code class="classname">Car</code> class (<a class="xref" href="#example-car" title="Example 2.15. Car">Example 2.15, “Car”</a>)
    indicating whether a car passed the road worthy tests.</p><div class="example"><a id="example-car"/><p class="title"><b>Example 2.15. Car</b></p><div class="example-contents"><pre class="programlisting">public class Car {
    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    <span class="bold"><strong>@AssertTrue(message = "The car has to pass the vehicle inspection first", groups = CarChecks.class)</strong></span>
    private boolean passedVehicleInspection;

    @Valid
    private Driver driver;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }
}</pre></div></div><p><br class="example-break"/>Overall three different groups are used in our example.
    <span class="property">Person.name</span>, <span class="property">Car.manufacturer</span>,
    <span class="property">Car.licensePlate</span> and
    <span class="property">Car.seatCount</span> all belong to the
    <code class="classname">Default</code> group. <span class="property">Driver.age</span> and
    <span class="property">Driver.hasDrivingLicense</span> belong to
    <code class="classname">DriverChecks</code> and last but not least
    <span class="property">Car.passedVehicleInspection</span> belongs to the group
    <code class="classname">CarChecks</code>. <a class="xref" href="#example-drive-away" title="Example 2.16. Drive away">Example 2.16, “Drive away”</a>
    shows how passing different group combinations to the
    <code class="methodname">Validator.validate</code> method result in different
    validation results.</p><div class="example"><a id="example-drive-away"/><p class="title"><b>Example 2.16. Drive away</b></p><div class="example-contents"><pre class="programlisting">public class GroupTest {

    private static Validator validator;

    @BeforeClass
    public static void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void driveAway() {
        // create a car and check that everything is ok with it.
        Car car = new Car( "Morris", "DD-AB-123", 2 );
        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
        assertEquals( 0, constraintViolations.size() );

        // but has it passed the vehicle inspection?
        constraintViolations = validator.validate( car, CarChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals("The car has to pass the vehicle inspection first", constraintViolations.iterator().next().getMessage());

        // let's go to the vehicle inspection
        car.setPassedVehicleInspection( true );
        assertEquals( 0, validator.validate( car ).size() );

        // now let's add a driver. He is 18, but has not passed the driving test yet
        Driver john = new Driver( "John Doe" );
        john.setAge( 18 );
        car.setDriver( john );
        constraintViolations = validator.validate( car, DriverChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals( "You first have to pass the driving test", constraintViolations.iterator().next().getMessage() );

        // ok, John passes the test
        john.passedDrivingTest( true );
        assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

        // just checking that everything is in order now
        assertEquals( 0, validator.validate( car, Default.class, CarChecks.class, DriverChecks.class ).size() );
    }
}</pre></div></div><p><br class="example-break"/>First we create a car and validate it using no explicit group.
    There are no validation errors, even though the property
    <span class="property">passedVehicleInspection</span> is per default
    <code class="constant">false</code>. However, the constraint defined on this
    property does not belong to the default group.</p><p>Next we just validate the <code class="classname">CarChecks</code> group
    which will fail until we make sure that the car passes the vehicle
    inspection.</p><p>When we then add a driver to the car and validate against
    <code class="classname">DriverChecks</code> we get again a constraint violation
    due to the fact that the driver has not yet passed the driving test. Only
    after setting <span class="property">passedDrivingTest</span> to true the
    validation against <code class="classname">DriverChecks</code> will pass.</p><p>Last but not least, we show that all constraints are passing by
    validating against all defined groups.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1015"/>2.3.1. Group sequences</h3></div></div></div><p>By default, constraints are evaluated in no particular order and
      this regardless of which groups they belong to. In some situations,
      however, it is useful to control the order of the constraints
      evaluation. In our example from <a class="xref" href="#validator-usingvalidator-validationgroups" title="2.3. Validating groups">Section 2.3, “Validating groups”</a> we could for
      example require that first all default car constraints are passing
      before we check the road worthiness of the car. Finally before we drive
      away we check the actual driver constraints. In order to implement such
      an order one would define a new interface and annotate it with
      <code class="classname">@GroupSequence</code> defining the order in which the
      groups have to be validated.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If at least one constraints fails in a sequenced group none of
        the constraints of the follwoing groups in the sequence get
        validated.</p></div><div class="example"><a id="d0e1029"/><p class="title"><b>Example 2.17. Interface with @GroupSequence</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})</strong></span>
public interface OrderedChecks {
}</pre></div></div><p><br class="example-break"/></p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Groups defining a sequence and groups composing a sequence
          must not be involved in a cyclic dependency either directly or
          indirectly, either through cascaded sequence definition or group
          inheritance. If a group containing such a circularity is evaluated,
          a <code class="classname">GroupDefinitionException</code> is raised.</p></div><p>The usage of the new sequence could then look like in <a class="xref" href="#example-group-sequence" title="Example 2.18. Usage of a group sequence">Example 2.18, “Usage of a group sequence”</a>.</p><div class="example"><a id="example-group-sequence"/><p class="title"><b>Example 2.18. Usage of a group sequence</b></p><div class="example-contents"><pre class="programlisting">@Test
public void testOrderedChecks() {
    Car car = new Car( "Morris", "DD-AB-123", 2 );
    car.setPassedVehicleInspection( true );

    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    john.passedDrivingTest( true );
    car.setDriver( john );

    assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );
}</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="section-default-group-class"/>2.3.2. Redefining the default group sequence of a class</h3></div></div></div><p>The @GroupSequence annotation also fulfills a second purpose. It
      allows you to redefine what the Default group means for a given class.
      To redefine <code class="classname">Default</code> for a class, place a
      <code class="classname">@GroupSequence</code> annotation on the class. The
      defined groups in the annotation express the sequence of groups that
      substitute <code class="classname">Default</code> for this class. <a class="xref" href="#example-rental-car" title="Example 2.19. RentalCar">Example 2.19, “RentalCar”</a> introduces a new class RentalCar with a
      redfined default group. With this definition the check for all three
      groups can be rewritten as seen in <a class="xref" href="#example-testOrderedChecksWithRedefinedDefault" title="Example 2.20. testOrderedChecksWithRedefinedDefault">Example 2.20, “testOrderedChecksWithRedefinedDefault”</a>.</p><div class="example"><a id="example-rental-car"/><p class="title"><b>Example 2.19. RentalCar</b></p><div class="example-contents"><pre class="programlisting">@GroupSequence({ RentalCar.class, CarChecks.class })
public class RentalCar extends Car {
    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }
}</pre></div></div><br class="example-break"/><div class="example"><a id="example-testOrderedChecksWithRedefinedDefault"/><p class="title"><b>Example 2.20. testOrderedChecksWithRedefinedDefault</b></p><div class="example-contents"><pre class="programlisting">@Test
public void testOrderedChecksWithRedefinedDefault() {
    RentalCar rentalCar = new RentalCar( "Morris", "DD-AB-123", 2 );
    rentalCar.setPassedVehicleInspection( true );

    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    john.passedDrivingTest( true );
    rentalCar.setDriver( john );

    assertEquals( 0, validator.validate( rentalCar, Default.class, DriverChecks.class ).size() );
}</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Due to the fact that there cannot be a cyclic dependency in the
        group and group sequence definitions one cannot just add
        <code class="classname">Default</code> to the sequence redefining
        <code class="classname">Default</code> for a class. Instead the class itself
        should be added!</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-defineconstraints-builtin"/>2.4. Built-in constraints</h2></div></div></div><p>Hibernate Validator implements all of the default constraints
    specified in Bean Validation as well as some custom ones. <a class="xref" href="#table-builtin-constraints" title="Table 2.2. Built-in constraints">Table 2.2, “Built-in constraints”</a> list all constraints available in
    Hibernate Validator.</p><div class="table"><a id="table-builtin-constraints"/><p class="title"><b>Table 2.2. Built-in constraints</b></p><div class="table-contents"><table summary="Built-in constraints" border="1"><colgroup><col align="left"/><col/><col/><col/><col/></colgroup><thead><tr><th align="left">Annotation</th><th>Part of Bean Validation Specification</th><th>Apply on</th><th>Use</th><th>Hibernate Metadata impact</th></tr></thead><tbody><tr><td align="left">@AssertFalse</td><td>yes</td><td>field/property</td><td>check that the annotated element is
            <code class="constant">false</code>.</td><td>none</td></tr><tr><td align="left">@AssertTrue</td><td>yes</td><td>field/property</td><td>check that the annotated element is
            <code class="constant">true</code>.</td><td>none</td></tr><tr><td align="left">@DecimalMax</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>The annotated element must be a number whose value must be
            lower or equal to the specified maximum. The parameter value is
            the string representation of the max value according to the
            <code class="classname">BigDecimal</code> string representation.</td><td>none</td></tr><tr><td align="left">@DecimalMin</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>The annotated element must be a number whose value must be
            higher or equal to the specified minimum. The parameter value is
            the string representation of the min value according to the
            <code class="classname">BigDecimal</code> string representation.</td><td>none</td></tr><tr><td align="left">@Digits(integer=, fraction=)</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>Check whether the property is a number having up to
            <code class="literal">integer</code> digits and <code class="literal">fraction</code>
            fractional digits.</td><td>Define column precision and scale.</td></tr><tr><td align="left">@Email</td><td>no</td><td>field/property. Needs to be a string.</td><td>Check whether the specified string is a valid email
            address.</td><td>none</td></tr><tr><td align="left">@Future</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">java.util.Date</code> and
            <code class="classname">java.util.Calendar</code>.</td><td>Checks whether the annotated date is in the future.</td><td>none</td></tr><tr><td align="left">@Length(min=, max=)</td><td>no</td><td>field/property. Needs to be a string.</td><td>Validate that the annotated string is between
            <em class="parameter"><code>min</code></em> and <em class="parameter"><code>max</code></em>
            included.</td><td>none</td></tr><tr><td align="left">@Max</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>Checks whether the annotated value is less than or equal to
            the specified maximum.</td><td>Add a check constraint on the column.</td></tr><tr><td align="left">@Min</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>Check whether the annotated value is higher than or equal
            to the specified minimum.</td><td>Add a check constraint on the column.</td></tr><tr><td align="left">@NotNull</td><td>yes</td><td>field/property</td><td>Check that the annotated value is not
            <code class="constant">null.</code></td><td>Column(s) are not null.</td></tr><tr><td align="left">@NotEmpty</td><td>no</td><td>field/property. Needs to be a string.</td><td>Check if the string is not <code class="constant">null</code> nor
            empty.</td><td>none</td></tr><tr><td align="left">@Null</td><td>yes</td><td>field/property</td><td>Check that the annotated value is
            <code class="constant">null.</code></td><td>none</td></tr><tr><td align="left">@Past</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">java.util.Date</code> and
            <code class="classname">java.util.Calendar</code>.</td><td>Checks whether the annotated date is in the past.</td><td>none</td></tr><tr><td align="left">@Pattern(regex=, flag=)</td><td>yes</td><td>field/property. Needs to be a string.</td><td>Check if the annotated string match the regular expression
            <em class="parameter"><code>regex</code></em>.</td><td>none</td></tr><tr><td align="left">@Range(min=, max=)</td><td>no</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>Check whether the annotated value lies between (inclusive)
            the specified minimum and maximum.</td><td>none</td></tr><tr><td align="left">@Size(min=, max=)</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">String</code>, <code class="classname">Collection</code>,
            <code class="classname">Map</code> and
            <code class="classname">arrays</code>.</td><td>Check if the annotated element size is between min and max
            (inclusive).</td><td>Column length will be set to max.</td></tr><tr><td align="left">@Valid</td><td>yes</td><td>field/property</td><td>Perform validation recursively on the associated
            object.</td><td>none</td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>On top of the parameters indicated in <a class="xref" href="#table-builtin-constraints" title="Table 2.2. Built-in constraints">Table 2.2, “Built-in constraints”</a> each constraint supports the
      parameters <em class="parameter"><code>message</code></em>, <em class="parameter"><code>groups</code></em>
      and <em class="parameter"><code>payload</code></em>. This is a requirement of the Bean
      Validation specification.</p></div><p>In some cases these built-in constraints will not fulfill your
    requirements. In this case you can literally in a minute write your own
    constraints. We will discuss this in <a class="xref" href="#validator-customconstraints" title="Chapter 3. Creating custom constraints">Chapter 3, <i>Creating custom constraints</i></a></p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-customconstraints"/>Chapter 3. Creating custom constraints</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#validator-customconstraints-simple">3.1. Creating a simple constraint</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-customconstraints-constraintannotation">3.1.1. The constraint annotation</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-validator">3.1.2. The constraint
      validator</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-errormessage">3.1.3. The error message</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-using">3.1.4. Using the constraint</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-customconstraints-compound">3.2. Constraint composition</a></span></dt></dl></div><p>Though the Bean Validation API defines a whole set of standard
  constraint annotations one can easily think of situations in which these
  standard annotations won't suffice. For these cases you are able to create
  custom constraints tailored to your specific validation requirements in a
  simple manner.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-customconstraints-simple"/>3.1. Creating a simple constraint</h2></div></div></div><p>To create a custom constraint, the following three steps are
    required:</p><div class="itemizedlist"><ul><li><p>Create a constraint annotation</p></li><li><p>Implement a validator</p></li><li><p>Define a default error message</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="validator-customconstraints-constraintannotation"/>3.1.1. The constraint annotation</h3></div></div></div><p>Let's write a constraint annotation, that can be used to express
      that a given string shall either be upper case or lower case. We'll
      apply it later on to the <span class="property">licensePlate</span> field of the
      <code class="classname">Car</code> class from <a class="xref" href="#validator-gettingstarted" title="Chapter 1. Getting started">Chapter 1, <i>Getting started</i></a> to ensure, that the field is
      always an upper-case string.</p><p>First we need a way to express the two case modes. We might use
      <code class="classname">String</code> constants, but a better way to go is to
      use a Java 5 enum for that purpose:</p><div class="example"><a id="d0e1552"/><p class="title"><b>Example 3.1. Enum <code class="classname">CaseMode</code> to express upper vs. lower
        case</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

public enum CaseMode {
    UPPER, 
    LOWER;
}</pre></div></div><br class="example-break"/><p>Now we can define the actual constraint annotation. If you've
      never designed an annotation before, this may look a bit scary, but
      actually it's not that hard:</p><div class="example"><a id="d0e1562"/><p class="title"><b>Example 3.2. Defining CheckCase constraint annotation</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import javax.validation.Constraint;
import javax.validation.ConstraintPayload;

@Target( { METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = CheckCaseValidator.class)
@Documented
public @interface CheckCase {

    String message() default "{com.mycompany.constraints.checkcase}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};
    
    CaseMode value();

}</pre></div></div><br class="example-break"/><p>An annotation type is defined using the <code class="code">@interface</code>
      keyword. All attributes of an annotation type are declared in a
      method-like manner. The specification of the Bean Validation API
      demands, that any constraint annotation defines</p><div class="itemizedlist"><ul><li><p>an attribute <span class="property">message</span> that returns the
          default key for creating error messages in case the constraint is
          violated</p></li><li><p>an attribute <span class="property">groups</span> that allows the
          specification of validation groups, to which this constraint belongs
          (see <a class="xref" href="#validator-usingvalidator-validationgroups" title="2.3. Validating groups">Section 2.3, “Validating groups”</a>).
          This must default to an empty array of type
          <code class="classname">Class&lt;?&gt;</code>.</p></li><li><p>an attribute <code class="classname">payload</code> that can be used
          by clients of the Bean Validation API to asign custom payload
          objects to a constraint. This attribute is not used by the API
          itself. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>An examle for a custom payload could be the definition of
              a severity. </p><pre class="programlisting">public class Severity {
    public static class Info extends ConstraintPayload {};
    public static class Error extends ConstraintPayload {};
}

public class ContactDetails {
    @NotNull(message="Name is mandatory", payload=Severity.Error.class)
    private String name;

    @NotNull(message="Phone number not specified, but not mandatory", payload=Severity.Info.class)
    private String phoneNumber;

    // ...
}</pre><p>Now a client can after the validation of a
              <code class="classname">ContactDetails</code> instance access the
              severity of a constraint using
              <code class="methodname">ConstraintViolation.getConstraintDescriptor().getPayload()</code>
              and adjust its behaviour depending on the severity.</p></div></li></ul></div><p>Besides those three mandatory attributes
      (<span class="property">messge</span>, <span class="property">groups</span> and
      <span class="property">payload</span>) we add another one allowing for the
      required case mode to be specified. The name <span class="property">value</span>
      is a special one, which can be omitted upon using the annotation, if it
      is the only attribute specified, as e.g. in
      <code class="code">@CheckCase(CaseMode.UPPER)</code>.</p><p>In addition we annotate the annotation type with a couple of
      so-called meta annotations:</p><div class="itemizedlist"><ul><li><p><code class="code">@Target({ METHOD, FIELD, ANNOTATION_TYPE })</code>:
          Says, that methods, fields and annotation declarations may be
          annotated with @CheckCase (but not type declarations e.g.)</p></li><li><p><code class="code">@Retention(RUNTIME)</code>: Specifies, that annotations
          of this type will be available at runtime by the means of
          reflection</p></li><li><p><code class="code">@Constraint(validatedBy =
          CheckCaseValidator.class)</code>: Specifies the validator to be used
          to validate elements annotated with @CheckCase</p></li><li><p><code class="code">@Documented</code>: Says, that the use of
          <code class="code">@CheckCase</code> will be contained in the JavaDoc of elements
          annotated with it</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="validator-customconstraints-validator"/>3.1.2. The constraint
      validator</h3></div></div></div><p>Next, we need to implement a constraint validator, that's able to
      validate elements with a <code class="classname">@CheckCase</code> annotation.
      To do so, we implement the interface ConstraintValidator as shown
      below:</p><div class="example"><a id="d0e1659"/><p class="title"><b>Example 3.3. Implementing a constraint validator for the constraint
        <code class="classname">CheckCase</code></b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

public class CheckCaseValidator implements ConstraintValidator&lt;CheckCase, String&gt; {

    private CaseMode caseMode;

    public void initialize(CheckCase constraintAnnotation) {
        this.caseMode = constraintAnnotation.value();
    }

    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {

        if (object == null)
            return true;

        if (caseMode == CaseMode.UPPER)
            return object.equals(object.toUpperCase());
        else
            return object.equals(object.toLowerCase());
    }

}</pre></div></div><br class="example-break"/><p>The <code class="classname">ConstraintValidator</code> interface defines
      two type parameters, which we set in our implementation. The first one
      specifies the annotation type to be validated (in our example
      <code class="classname">CheckCase</code>), the second one the type of elements,
      which the validator can handle (here
      <code class="classname">String</code>).</p><p>In case a constraint annotation is allowed at elements of
      different types, a <code class="classname">ConstraintValidator</code> for each
      allowed type has to be implemented and registered at the constraint
      annotation as shown above.</p><p>The implementation of the validator is straightforward. The
      <code class="methodname">initialize()</code> method gives us access to the
      attribute values of the annotation to be validated. In the example we
      store the <code class="classname">CaseMode</code> in a field of the validator
      for further usage.</p><p>In the <code class="methodname">isValid()</code> method we implement the
      logic, that determines, whether a <code class="classname">String</code> is valid
      according to a given <code class="classname">@CheckCase</code> annotation or
      not. This decision depends on the case mode retrieved in
      <code class="classname">initialize()</code>. As the Bean Validation
      specification recommends, we consider <code class="code">null</code> values as being
      valid. If <code class="code">null</code> is not a valid value for an element, it
      should be annotated with <code class="code">@NotNull</code> explicitely.</p><p>The passed-in <code class="classname">ConstraintValidatorContext</code>
      could be used to raise any custom validation errors, but as we are fine
      with the default behavior, we can ignore that parameter for now.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="validator-customconstraints-errormessage"/>3.1.3. The error message</h3></div></div></div><p>Finally we need to specify the error message, that shall be used,
      in case a <code class="classname">@CheckCase</code> constraint is violated. To
      do so, we add the following to our custom
      <code class="filename">ValidationMessages.properties</code> (see also <a class="xref" href="#section-message-interpolation" title="2.2.4. Message interpolation">Section 2.2.4, “Message interpolation”</a>)</p><div class="example"><a id="d0e1731"/><p class="title"><b>Example 3.4. Defining a custom error message for the
        <code class="classname">CheckCase</code> constraint</b></p><div class="example-contents"><pre class="programlisting">com.mycompany.constraints.CheckCase.message=Case mode must be {value}.</pre></div></div><br class="example-break"/><p>If a validation error occurs, the validation runtime will use the
      default value, that we specified for the message attribute of the
      <code class="classname">@CheckCase</code> annotation to look up the error
      message in this file.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="validator-customconstraints-using"/>3.1.4. Using the constraint</h3></div></div></div><p>Now that our first custom constraint is completed, we can use it
      in the <code class="classname">Car</code> class from the <a class="xref" href="#validator-gettingstarted" title="Chapter 1. Getting started">Chapter 1, <i>Getting started</i></a> chapter to specify that the
      <span class="property">licensePlate</span> field shall only contain upper-case
      strings:</p><div class="example"><a id="example-car-with-checkcase"/><p class="title"><b>Example 3.5. Applying the <code class="classname">CheckCase</code>
        constraint</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    @CheckCase(CaseMode.UPPER)
    private String licensePlate;

    @Min(2)
    private int seatCount;
    
    public Car(String manufacturer, String licencePlate, int seatCount) {

        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...

}</pre></div></div><br class="example-break"/><p>Finally let's demonstrate in a little test that the
      <code class="classname">@CheckCase</code> constraint is properly
      validated:</p><div class="example"><a id="d0e1770"/><p class="title"><b>Example 3.6. Testcase demonstrating the <code class="classname">CheckCase</code>
        validation</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import static org.junit.Assert.*;

import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;

import org.junit.BeforeClass;
import org.junit.Test;

public class CarTest {

    private static Validator validator;

    @BeforeClass
    public static void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void testLicensePlateNotUpperCase() {

        Car car = new Car("Morris", "dd-ab-123", 4);

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
            validator.validate(car);
        assertEquals(1, constraintViolations.size());
        assertEquals(
            "Case mode must be UPPER.", 
            constraintViolations.iterator().next().getMessage());
    }

    @Test
    public void carIsValid() {

        Car car = new Car("Morris", "DD-AB-123", 4);

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
            validator.validate(car);

        assertEquals(0, constraintViolations.size());
    }
}</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-customconstraints-compound"/>3.2. Constraint composition</h2></div></div></div><p>Looking at the <span class="property">licensePlate</span> field of the
    <code class="classname">Car</code> class in <a class="xref" href="#example-car-with-checkcase" title="Example 3.5. Applying the CheckCase constraint">Example 3.5, “Applying the CheckCase
        constraint”</a>, we see three constraint
    annotations already. In complexer scenarios, where even more constraints
    could be applied to one element, this might become a bit confusing easily.
    Furthermore, if we had a <span class="property">licensePlate</span> field in
    another class, we would have to copy all constraint declarations to the
    other class as well, violating the DRY principle.</p><p>This problem can be tackled using compound constraints. In the
    following we create a new constraint annotation
    <code class="classname">@ValidLicensePlate</code>, that comprises the constraints
    <code class="classname">@NotNull</code>, <code class="classname">@Size</code> and
    <code class="classname">@CheckCase</code>:</p><div class="example"><a id="d0e1808"/><p class="title"><b>Example 3.7. Creating a composing constraint
      <code class="classname">ValidLicensePlate</code></b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import javax.validation.Constraint;
import javax.validation.ConstraintPayload;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

@NotNull
@Size(min = 2, max = 14)
@CheckCase(CaseMode.UPPER)
@Target( { METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = {})
@Documented
public @interface ValidLicensePlate {

    String message() default "{com.mycompany.constraints.validlicenseplate}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

}</pre></div></div><br class="example-break"/><p>To do so, we just have to annotate the constraint declaration with
    its comprising constraints (btw. that's exactly why we allowed annotation
    types as target for the <code class="classname">@CheckCase</code> annotation). As
    no additional validation is required for the
    <code class="classname">@ValidLicensePlate</code> annotation itself, we don't
    declare a validator within the <code class="classname">@Constraint </code>meta
    annotation.</p><p>Using the new compound constraint at the
    <span class="property">licensePlate</span> field now is fully equivalent to the
    previous version, where we declared the three constraints directly at the
    field itself:</p><div class="example"><a id="d0e1831"/><p class="title"><b>Example 3.8. Application of composing constraint
      <code class="classname">ValidLicensePlate</code></b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

public class Car {

    @ValidLicensePlate
    private String licensePlate;

    //...

}</pre></div></div><br class="example-break"/><p>The set of <code class="classname">ConstraintViolations</code> retrieved
    when validating a <code class="classname">Car</code> instance will contain an
    entry for each violated composing constraint of the
    <code class="classname">@ValidLicensePlate</code> constraint. If you rather prefer
    a single <code class="classname">ConstraintViolation</code> in case any of the
    composing constraints is violated, the
    <code class="classname">@ReportAsSingleViolation</code> meta constraint can be
    used as follows:</p><div class="example"><a id="d0e1855"/><p class="title"><b>Example 3.9. Usage of <code class="classname">@ReportAsSingleViolation</code></b></p><div class="example-contents"><pre class="programlisting">//...
@ReportAsSingleViolation
public @interface ValidLicensePlate {

    String message() default "{com.mycompany.constraints.validlicenseplate}";

    Class&lt;?&gt;[] groups() default {};

    Class&lt;? extends Payload&gt;[] payload() default {};

}</pre></div></div><br class="example-break"/></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-xmlconfiguration"/>Chapter 4. XML configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1867">4.1. validation.xml</a></span></dt><dt><span class="section"><a href="#d0e1957">4.2. Mapping constraints</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1867"/>4.1. <code class="filename">validation.xml</code></h2></div></div></div><p>The key to enable XML configuration for Hibernate Validator is the
    file <code class="filename">validation.xml</code>. If this file exists in the
    classpath its configuration will be applied when the
    <code class="classname">ValidationFactory</code> gets created. <a class="xref" href="#image-validation-configuration" title="Example 4.1. validation-configuration-1.0.xsd">Example 4.1, “validation-configuration-1.0.xsd”</a> shows a model view of the xsd
    <code class="filename">valiation.xml</code> has to adhere to.</p><div class="example"><a id="image-validation-configuration"/><p class="title"><b>Example 4.1. validation-configuration-1.0.xsd</b></p><div class="example-contents"><div class="mediaobject"><img src="validation-configuration-1.0.png"/></div></div></div><p><br class="example-break"/></p><p><a class="xref" href="#example-validation-xml" title="Example 4.2. validation.xml">Example 4.2, “validation.xml”</a> shows the several
    configuration options of <code class="filename">validation.xml</code>.</p><div class="example"><a id="example-validation-xml"/><p class="title"><b>Example 4.2. validation.xml</b></p><div class="example-contents"><pre class="programlisting">&lt;validation-config xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/configuration"&gt;
    &lt;default-provider&gt;org.hibernate.validator.HibernateValidator&lt;/default-provider&gt;
    &lt;message-interpolator&gt;org.hibernate.validator.engine.ResourceBundleMessageInterpolator&lt;/message-interpolator&gt;
    &lt;traversable-resolver&gt;org.hibernate.validator.engine.resolver.DefaultTraversableResolver&lt;/traversable-resolver&gt;
    &lt;constraint-validator-factory&gt;org.hibernate.validator.engine.ConstraintValidatorFactoryImpl&lt;/constraint-validator-factory&gt;
    &lt;constraint-mapping&gt;/constraints-car.xml&lt;/constraint-mapping&gt;
    &lt;property name="prop1"&gt;value1&lt;/property&gt;
    &lt;property name="prop2"&gt;value2&lt;/property&gt;
&lt;/validation-config&gt;</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>There can only be one <code class="filename">validation.xml</code> in the
      classpath. If more than one is found an exception is thrown.</p></div><p>All settings shown in the <code class="filename">validation.xml</code> are
    optional and in the case of <a class="xref" href="#example-validation-xml" title="Example 4.2. validation.xml">Example 4.2, “validation.xml”</a> show
    the defaults used within Hibernate Validator. The node
    <span class="property">default-provider</span> allows to choose the Bean Validation
    provider. This is useful if there is more than one provider in the
    classpath. <span class="property">message-interpolator</span>,
    <span class="property">traversable-resolver</span> and
    <span class="property">constraint-validator-factory</span> allow to customize the
    <code class="classname">javax.validation.MessageInterpolator</code>,
    <code class="classname">javax.validation.TraversableResolver</code> resp.
    <code class="classname">javax.validation.ConstraintValidatorFactory</code>. The
    same configuration options are also available programmatically through the
    <code class="classname">javax.validation.Configuration</code>. In fact XML
    configuration will be overriden by values explicitly specified via the
    API. It is even possible to ignore the XML configuration completely via
    <code class="methodname"> Configuration.ignoreXmlConfiguration()</code>. See also
    <a class="xref" href="#validator-bootstrapping" title="Chapter 5. Bootstrapping">Chapter 5, <i>Bootstrapping</i></a>.</p><p>Via the <span class="property">constraint-mapping</span> you can list an
    arbitrary number of additional XML files containing the actual constraint
    configuration. See <a class="xref" href="#section-mapping-constraints">Section 4.2, “Mapping constraints”</a>.</p><p>Last but not least, you can specify provider specific properties via
    the <span class="property">property</span> nodes. Hibernate Validator does
    currently not make use of any custom properties.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1957"/>4.2. Mapping constraints</h2></div></div></div><p>Expressing constraints in XML is possible via files adhering to the
    xsd seen in <a class="xref" href="#image-mapping-configuration" title="Example 4.3. validation-mapping-1.0.xsd">Example 4.3, “validation-mapping-1.0.xsd”</a>. Note that
    these mapping files are only processed if listed via
    <span class="property">constraint-mapping</span> in your
    <code class="filename">validation.xml</code>.</p><div class="example"><a id="image-mapping-configuration"/><p class="title"><b>Example 4.3. validation-mapping-1.0.xsd</b></p><div class="example-contents"><div class="mediaobject"><img src="validation-mapping-1.0.png"/></div></div></div><br class="example-break"/><p><a class="xref" href="#example-constraints-car" title="Example 4.4. constraints-car.xml">Example 4.4, “constraints-car.xml”</a> shows how our classes Car
    and RentalCar from <a class="xref" href="#example-car" title="Example 2.15. Car">Example 2.15, “Car”</a> resp. <a class="xref" href="#example-rental-car" title="Example 2.19. RentalCar">Example 2.19, “RentalCar”</a> could be mapped in XML.</p><div class="example"><a id="example-constraints-car"/><p class="title"><b>Example 4.4. constraints-car.xml</b></p><div class="example-contents"><pre class="programlisting">&lt;constraint-mappings xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                     xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.0.xsd"
                     xmlns="http://jboss.org/xml/ns/javax/validation/mapping"&gt;
    &lt;default-package&gt;org.hibernate.validator.quickstart&lt;/default-package&gt;
    &lt;bean class="Car" ignore-annotations="true"&gt;
        &lt;field name="manufacturer"&gt;
            &lt;constraint annotation="javax.validation.constraints.NotNull"/&gt;
        &lt;/field&gt;
        &lt;field name="licensePlate"&gt;
            &lt;constraint annotation="javax.validation.constraints.NotNull"/&gt;
        &lt;/field&gt;
        &lt;field name="seatCount"&gt;
            &lt;constraint annotation="javax.validation.constraints.Min"&gt;
                &lt;element name="value"&gt;2&lt;/element&gt;
            &lt;/constraint&gt;
        &lt;/field&gt;
        &lt;field name="driver"&gt;
            &lt;valid/&gt;
        &lt;/field&gt;
        &lt;getter name="passedVehicleInspection" ignore-annotations="true"&gt;
            &lt;constraint annotation="javax.validation.constraints.AssertTrue"&gt;
                &lt;message&gt;The car has to pass the vehicle inspection first&lt;/message&gt;
                &lt;groups&gt;
                    &lt;value&gt;CarChecks&lt;/value&gt;
                &lt;/groups&gt;
                &lt;element name="max"&gt;10&lt;/element&gt;
            &lt;/constraint&gt;
        &lt;/getter&gt;
    &lt;/bean&gt;
    &lt;bean class="RentalCar" ignore-annotations="true"&gt;
        &lt;class ignore-annotations="true"&gt;
            &lt;group-sequence&gt;
                &lt;value&gt;RentalCar&lt;/value&gt;
                &lt;value&gt;CarChecks&lt;/value&gt;
            &lt;/group-sequence&gt;
        &lt;/class&gt;
    &lt;/bean&gt;
    &lt;constraint-definition annotation="org.mycompany.CheckCase" include-existing-validator="false"&gt;
        &lt;validated-by include-existing-validators="false"&gt;
            &lt;value&gt;org.mycompany.CheckCaseValidator&lt;/value&gt;
        &lt;/validated-by&gt;
    &lt;/constraint-definition&gt;
&lt;/constraint-mappings&gt;</pre></div></div><br class="example-break"/><p>The XML configuration is closely mirroring the programmatic API. For
    this reason it should suffice to just add some comments.
    <span class="property">default-package</span> is used for all fields where a
    classname is expected. If the specified class is not fully qualified the
    configured default package will be used. Every mapping file can then have
    several <span class="property">bean</span> nodes, each describing the constraints
    on the entity with the specified class name.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>A given entity can only be configured once across all
        configuration files. If the same class is configured more than once an
        exception is thrown.</p></div><p>Settings <span class="property">ignore-annotations</span> to true means
    that constraint annotations placed on the configured bean are ignored. The
    default for this value is <code class="constant">true</code>. ignore-annotations is
    also available for the nodes <span class="property">class</span>,
    <span class="property">fields</span> and <span class="property">getter</span>. If not
    explicitly specified on these levels the configured
    <span class="property">bean</span> value applies. Otherwise do the nodes
    <span class="property">class</span>, <span class="property">fields</span> and
    <span class="property">getter</span> determine on which level the constraints are
    placed (see <a class="xref" href="#validator-usingvalidator-annotate" title="2.1. Defining constraints">Section 2.1, “Defining constraints”</a>). The
    <span class="property">constraint</span> node is then used to add a constraint on
    the corresponding level. Each constraint definition must define the class
    via the annotation attribute. The constraint attributes required by the
    Bean Validation specification (<span class="property">message</span>,
    <span class="property">groups</span> and <span class="property">payload</span>) have
    dedicated nodes. All other constraint specific attributes are configured
    using the the <span class="property">element</span> node.</p><p>The class node also allows to reconfigure the default group sequence
    (see <a class="xref" href="#section-default-group-class" title="2.3.2. Redefining the default group sequence of a class">Section 2.3.2, “Redefining the default group sequence of a class”</a>) via the
    <span class="property">group-sequence</span> node.</p><p>Last but not least, the list of
    <code class="classname">ConstraintValidator</code>s associated to a given
    constraint can be altered via the
    <span class="property">constraint-definition</span> node. The
    <span class="property">annotation</span> attribute represents the constraint
    annotation being altered. The <span class="property">validated-by</span> elements
    represent the (ordered) list of <code class="classname">ConstraintValidator</code>
    implementations associated to the constraint. If
    <span class="property">include-existing-validator</span> is set to
    <code class="constant">false</code>, validators defined on the constraint
    annotation are ignored. If set to <code class="constant">true</code>, the list of
    ConstraintValidators described in XML are concatenated to the list of
    validators described on the annotation.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-bootstrapping"/>Chapter 5. Bootstrapping</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#section-validator-instance">5.1. Configuration and
    ValidatorFactory</a></span></dt><dt><span class="section"><a href="#d0e2185">5.2. ValidationProviderResolver</a></span></dt><dt><span class="section"><a href="#d0e2217">5.3. MessageInterpolator</a></span></dt><dt><span class="section"><a href="#d0e2255">5.4. TraversableResolver</a></span></dt><dt><span class="section"><a href="#d0e2303">5.5. ConstraintValidatorFactory</a></span></dt></dl></div><p>We already seen in <a class="xref" href="#section-validator-instance" title="5.1. Configuration and ValidatorFactory">Section 5.1, “Configuration and
    ValidatorFactory”</a> the
  easiest way to create a <code class="classname">Validator</code> instance -
  <code class="methodname">Validation.buildDefaultValidatorFactory</code>. In this
  chapter we have a look at the other methods in
  <code class="classname">javax.validation.Validation</code> and how they allow to
  configure several aspects of Bean Validation at bootstrapping time.</p><p>The different bootstrapping options allwow, amongst other things, to
  bootstrap any Bean Validation implementation on the classpath. Generally, an
  available provider is discovered by the <a class="ulink" href="http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html#Service%20Provider">Java
  Service Provider</a> mechanism. A Bean Validation implementation
  includes the file
  <code class="filename">javax.validation.spi.ValidationProvider</code> in
  <code class="filename">META-INF/services</code>. This file contains the fully
  qualified classname of the <code class="classname">ValidationProvider</code> of the
  implementation. In the case of Hibernate Validator this is
  <code class="classname">org.hibernate.validator.HibernateValidator</code>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If there are more than one Bean Validation implementation
      providers in the classpath and
      <code class="methodname">Validation.buildDefaultValidatorFactory()</code> is
      used, there is no guarantee which provider will be chosen. To enforce
      the provider <code class="methodname">Validation.byProvider()</code> should be
      used.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="section-validator-instance"/>5.1. <code class="classname">Configuration</code> and
    <code class="classname">ValidatorFactory</code></h2></div></div></div><p>There are three different methods in the Validation class to create
    a Validator instance. The easiest in shown in <a class="xref" href="#example-build-default-validator-factory" title="Example 5.1. Validation.buildDefaultValidatorFactory()">Example 5.1, “Validation.buildDefaultValidatorFactory()”</a>.</p><div class="example"><a id="example-build-default-validator-factory"/><p class="title"><b>Example 5.1. Validation.buildDefaultValidatorFactory()</b></p><div class="example-contents"><pre class="programlisting">ValidatorFactory factory = <span class="bold"><strong>Validation.buildDefaultValidatorFactory()</strong></span>;
Validator validator = factory.getValidator();</pre></div></div><p><br class="example-break"/>You can also use the method
    <code class="methodname">Validation.byDefaultProvider()</code> which will allow
    you to configure several aspects of the created Validator
    instance:</p><div class="example"><a id="d0e2147"/><p class="title"><b>Example 5.2. Validation.byDefaultProvider()</b></p><div class="example-contents"><pre class="programlisting">Configuration&lt;?&gt; config = <span class="bold"><strong>Validation.byDefaultProvider()</strong></span>.configure();
config.messageInterpolator(new MyMessageInterpolator())
    .traversableResolver( new MyTraversableResolver())
    .constraintValidatorFactory(new MyConstraintValidatorFactory());

ValidatorFactory factory = config.buildValidatorFactory();
Validator validator = factory.getValidator();
</pre></div></div><p><br class="example-break"/>We will learn more about
    <code class="classname">MessageInterpolator</code>,
    <code class="classname">TraversableResolver</code> and
    <code class="classname">ConstraintValidatorFactory</code> in the following
    sections.</p><p>Last but not least you can ask for a Configuration object of a
    specific Bean Validation provider. This is useful if you have more than
    one Bean Validation provider in your classpath. In this situation you can
    make an explicit choice about which implementation to use. In the case of
    Hibernate Validator the <code class="classname">Validator</code> creation looks
    like:</p><div class="example"><a id="d0e2170"/><p class="title"><b>Example 5.3. Validation.byProvider( HibernateValidator.class )</b></p><div class="example-contents"><pre class="programlisting">ValidatorConfiguration config = <span class="bold"><strong>Validation.byProvider( HibernateValidator.class )</strong></span>.configure();
config.messageInterpolator(new MyMessageInterpolator())
    .traversableResolver( new MyTraversableResolver())
    .constraintValidatorFactory(new MyConstraintValidatorFactory());

ValidatorFactory factory = config.buildValidatorFactory();
Validator validator = factory.getValidator();</pre></div></div><p><br class="example-break"/></p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>The generated <code class="classname">Validator</code> instance is
        thread safe and can be cached.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2185"/>5.2. <code class="classname">ValidationProviderResolver</code></h2></div></div></div><p>In the case that the Java Service Provider mechanism does not work
    in your environment or you have a special classloader setup, you are able
    to provide a custom <code class="classname">ValidationProviderResolver</code>. An
    example in an OSGi environment you could plug your custom provider
    resolver like seen in <a class="xref" href="#example-provider-resolver" title="Example 5.4. Providing a custom ValidationProviderResolver">Example 5.4, “Providing a custom ValidationProviderResolver”</a>.</p><div class="example"><a id="example-provider-resolver"/><p class="title"><b>Example 5.4. Providing a custom ValidationProviderResolver</b></p><div class="example-contents"><pre class="programlisting">Configuration&lt;?&gt; config = Validation.byDefaultProvider()
    <span class="bold"><strong>.providerResolver( new OSGiServiceDiscoverer() )</strong></span>
    .configure();

ValidatorFactory factory = config.buildValidatorFactory();
Validator validator = factory.getValidator();
</pre></div></div><p><br class="example-break"/>Your <code class="classname">OSGiServiceDiscoverer</code> must in this
    case implement the interface
    <code class="classname">ValidationProviderResolver</code>:</p><div class="example"><a id="d0e2212"/><p class="title"><b>Example 5.5. ValidationProviderResolver interface</b></p><div class="example-contents"><pre class="programlisting">public interface ValidationProviderResolver {
    /**
     * Returns a list of ValidationProviders available in the runtime environment.
     *
     * @return list of validation providers.  
     */
    List&lt;ValidationProvider&lt;?&gt;&gt; getValidationProviders();
}
</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2217"/>5.3. <code class="classname">MessageInterpolator</code></h2></div></div></div><p><a class="xref" href="#section-message-interpolation" title="2.2.4. Message interpolation">Section 2.2.4, “Message interpolation”</a> already discussed
    the default message interpolation algorithm. If you have special
    requirements for your message interpolation you can provide a custom
    interpolator using
    <code class="methodname">Configuration.messageInterpolator()</code>. This message
    interpolator will be shared by all validators generated by the
    <code class="classname">ValidatorFactory</code> created from this
    <code class="classname">Configuration</code>(see <a class="xref" href="#example-message-interpolator" title="Example 5.6. Providing a custom MessageInterpolator">Example 5.6, “Providing a custom MessageInterpolator”</a>).</p><div class="example"><a id="example-message-interpolator"/><p class="title"><b>Example 5.6. Providing a custom MessageInterpolator</b></p><div class="example-contents"><pre class="programlisting">Configuration&lt;?&gt; configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    <span class="bold"><strong>.messageInterpolator(new ContextualMessageInterpolator(configuration.getDefaultMessageInterpolator()))</strong></span>
    .buildValidatorFactory();

Validator validator = factory.getValidator();
</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>It is recommended that <code class="classname">MessageInterpolator</code>
      implementations delegate final interpolation to the Bean Validation
      default <code class="classname">MessageInterpolator</code> to ensure standard
      Bean Validation interpolation rules are followed. The default
      implementation is accessible through
      <code class="methodname">Configuration.getDefaultMessageInterpolator()</code>.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2255"/>5.4. <code class="classname">TraversableResolver</code></h2></div></div></div><p>The usage of the <code class="classname">TraversableResolver</code> has so
    far not been discussed. The idea is that in some cases, the state of a
    property should not be accessed. The most obvious example for that is a
    lazy loaded property or association of a Java Persistence provider.
    Validating this lazy property or association would mean that its state
    would have to be accessed triggering a load from the database. Bean
    Validation controls which property can and cannot be accessed via the
    <code class="classname">TraversableResolver</code> interface (see <a class="xref" href="#example-traversable-resolver" title="Example 5.7. TraversableResolver interface">Example 5.7, “TraversableResolver interface”</a>).</p><div class="example"><a id="example-traversable-resolver"/><p class="title"><b>Example 5.7. TraversableResolver interface</b></p><div class="example-contents"><pre class="programlisting">/**
 * Contract determining if a property can be accessed by the Bean Validation provider
 * This contract is called for each property that is being either validated or cascaded.
 *
 * A traversable resolver implementation must be thread-safe.
 *
 */
public interface TraversableResolver {
    /**
     * Determine if the Bean Validation provider is allowed to reach the property state
     *
     * @param traversableObject object hosting &lt;code&gt;traversableProperty&lt;/code&gt; or null  
     *                          if validateValue is called
     * @param traversableProperty the traversable property.
     * @param rootBeanType type of the root object passed to the Validator.
     * @param pathToTraversableObject path from the root object to
     *        &lt;code&gt;traversableObject&lt;/code&gt;
     *        (using the path specification defined by Bean Validator).
     * @param elementType either &lt;code&gt;FIELD&lt;/code&gt; or &lt;code&gt;METHOD&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the Bean Validation provider is allowed to
     *         reach the property state, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
     boolean isReachable(Object traversableObject,
                         Path.Node traversableProperty,
                         Class&lt;?&gt; rootBeanType,
                         Path pathToTraversableObject,
                         ElementType elementType);

    /**
     * Determine if the Bean Validation provider is allowed to cascade validation on
     * the bean instance returned by the property value
     * marked as &lt;code&gt;@Valid&lt;/code&gt;.
     * Note that this method is called only if isReachable returns true for the same set of
     * arguments and if the property is marked as &lt;code&gt;@Valid&lt;/code&gt;
     *
     * @param traversableObject object hosting &lt;code&gt;traversableProperty&lt;/code&gt; or null
     *                          if validateValue is called
     * @param traversableProperty the traversable property.
     * @param rootBeanType type of the root object passed to the Validator.
     * @param pathToTraversableObject path from the root object to
     *        &lt;code&gt;traversableObject&lt;/code&gt;
     *        (using the path specification defined by Bean Validator).
     * @param elementType either &lt;code&gt;FIELD&lt;/code&gt; or &lt;code&gt;METHOD&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the Bean Validation provider is allowed to
     *         cascade validation, &lt;code&gt;false&lt;/code&gt; otherwise.
     */
     boolean isCascadable(Object traversableObject,
                          Path.Node traversableProperty,
                          Class&lt;?&gt; rootBeanType,
                          Path pathToTraversableObject,
                          ElementType elementType);
}
</pre></div></div><p><br class="example-break"/>Hibernate Validator provides two
    <code class="classname">TraversableResolver</code>s out of the box which will be
    enabled automatically depending on your environment. The first is the
    <code class="classname">DefaultTraversableResolver</code> which will always return
    true for <code class="methodname">isReachable()</code> and
    i<code class="methodname">sTraversable()</code>. The second is the
    <code class="classname">JPATraversableResolver</code> which gets enabled when
    Hibernate Validator gets used in combination with JPA 2. In case you have
    to provide your own resolver you can do so again using the
    <code class="classname">Configuration</code> object as seen in <a class="xref" href="#example-traversable-resolver-config" title="Example 5.8. Providing a custom TraversableResolver">Example 5.8, “Providing a custom TraversableResolver”</a>.</p><div class="example"><a id="example-traversable-resolver-config"/><p class="title"><b>Example 5.8. Providing a custom TraversableResolver</b></p><div class="example-contents"><pre class="programlisting">Configuration&lt;?&gt; configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    <span class="bold"><strong>.traversableResolver(new MyTraversableResolver())</strong></span>
    .buildValidatorFactory();

Validator validator = factory.getValidator();
</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2303"/>5.5. <code class="classname">ConstraintValidatorFactory</code></h2></div></div></div><p>Last but not least, there is one more configuration option to
    discuss, the <code class="classname">ConstraintValidatorFactory</code>. The
    default <code class="classname">ConstraintValidatorFactory</code> provided by
    Hibernate Validator requires a public no-arg constructor to instantiate
    <code class="classname">ConstraintValidator</code> instances (see <a class="xref" href="#section-constraint-validator">Section 3.1.2, “The constraint
      validator”</a>). Using a custom
    <code class="classname">ConstraintValidatorFactory</code> offers for example the
    possibility to use dependency injection in constraint implementations. The
    configuration of the custom factory is once more via the
    <code class="classname">Configuration</code> (<a class="xref" href="#example-constraint-validator-factory" title="Example 5.9. Providing a custom ConstraintValidatorFactory">Example 5.9, “Providing a custom ConstraintValidatorFactory”</a>).</p><div class="example"><a id="example-constraint-validator-factory"/><p class="title"><b>Example 5.9. Providing a custom ConstraintValidatorFactory</b></p><div class="example-contents"><pre class="programlisting">Configuration&lt;?&gt; configuration = Validation.byDefaultProvider().configure();
ValidatorFactory factory = configuration
    <span class="bold"><strong>.constraintValidatorFactory(new IOCConstraintValidatorFactory())</strong></span>
    .buildValidatorFactory();

Validator validator = factory.getValidator();
</pre></div></div><p><br class="example-break"/>The interface you have to implement is:</p><div class="example"><a id="d0e2339"/><p class="title"><b>Example 5.10. ConstraintValidatorFactory interface</b></p><div class="example-contents"><pre class="programlisting">public interface ConstraintValidatorFactory {
    /**
     * @param key The class of the constraint validator to instantiate.
     *
     * @return A constraint validator instance of the specified class.
     */
     &lt;T extends ConstraintValidator&lt;?,?&gt;&gt; T getInstance(Class&lt;T&gt; key);
}
</pre></div></div><p><br class="example-break"/></p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Any constraint implementation relying on
        <code class="classname">ConstraintValidatorFactory</code> behaviors specific
        to an implementation (dependency injection, no no-arg constructor and
        so on) are not considered portable.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>ConstraintValidatorFactory should not cache instances as the
        state of each instance can be altered in the initialize method.</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-checkconstraints"/>Chapter 6. Integration with other frameworks</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#validator-checkconstraints-db">6.1. Database schema-level validation</a></span></dt><dt><span class="section"><a href="#validator-checkconstraints-orm">6.2. ORM integration</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-checkconstraints-orm-hibernateevent">6.2.1. Hibernate event-based validation</a></span></dt><dt><span class="section"><a href="#d0e2461">6.2.2. JPA </a></span></dt></dl></dd><dt><span class="section"><a href="#section-presentation-layer">6.3. Presentation layer validation</a></span></dt></dl></div><p>Hibernate Validator is intended to be used to implement multi-layered
  data validation, where constraints are expressed in a single place (the
  annotated domain model) and checked in various different layers of the
  application.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-checkconstraints-db"/>6.1. Database schema-level validation</h2></div></div></div><p>Out of the box, Hibernate Annotations (as of Hibernate 3.5.x) will
    translate the constraints you have defined for your entities into mapping
    metadata. For example, if a property of your entity is annotated
    <code class="literal">@NotNull</code>, its columns will be declared as <code class="literal">not
    null</code> in the DDL schema generated by Hibernate.</p><p>If, for some reason, the feature needs to be disabled, set
    <code class="literal">hibernate.validator.apply_to_ddl</code> to
    <code class="literal">false</code>. See also <a class="xref" href="#table-builtin-constraints" title="Table 2.2. Built-in constraints">Table 2.2, “Built-in constraints”</a>.</p><p>You can also limit the DDL constraint generation to a subset of the
    defined constraints by setting the property
    <span class="property">org.hibernate.validator.group.ddl</span>. The property
    specifies the comma seperated, fully specified classnames of the groups a
    constraint has to be part of in order to be considered for DDL schema
    generation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-checkconstraints-orm"/>6.2. ORM integration</h2></div></div></div><p>Hibernate Validator integrates with both Hibernate and all pure Java
    Persistence providers.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="validator-checkconstraints-orm-hibernateevent"/>6.2.1. Hibernate event-based validation</h3></div></div></div><p>Hibernate Validator has a built-in Hibernate event listener -
      <a class="ulink" href="http://fisheye.jboss.org/browse/Hibernate/core/trunk/annotations/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java"><code class="classname">org.hibernate.cfg.beanvalidation.BeanValidationEventListener</code></a>
      - which is part of Hibernate Annotations (as of Hibernate 3.5.x).
      Whenever a <code class="literal">PreInsertEvent</code>,
      <code class="literal">PreUpdateEvent</code> or
      <code class="classname">PreDeleteEvent</code> occurs, the listener will verify
      all constraints of the entity instance and throw an exception if any
      constraint is violated. Per default objects will be checked before any
      inserts or updates are made by Hibernate. Pre deletion events will per
      default not trigger a validation. You can configure the groups to be
      validated per event type using the properties
      <span class="property">javax.persistence.validation.group.pre-persist</span>,
      <span class="property">javax.persistence.validation.group.pre-update</span> and
      <span class="property">javax.persistence.validation.group.pre-remove</span>. The
      values of these properties are the comma seperated, fully specified
      class names of the groups to validate. <a class="xref" href="#example-beanvalidationeventlistener-config" title="Example 6.1. Manual configuration of BeanValidationEvenListener">Example 6.1, “Manual configuration of
        BeanValidationEvenListener”</a> shows the
      default values for these properties. In this case they could also be
      omitted.</p><p>On constraint violation, the event will raise a runtime
      <code class="classname">ConstraintViolationException</code> which contains a set
      of <code class="literal">ConstraintViolation</code>s describing each
      failure.</p><p>If Hibernate Validator is present in the classpath, Hibernate
      Annotations (or Hibernate EntityManager) will use it transparently. To
      avoid validation even though Hibernate Validator is in the classpath set
      <span class="property">javax.persistence.validation.mode</span> to
      <code class="constant">none</code>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If the beans are not annotated with validation annotations,
          there is no runtime performance cost.</p></div><p>In case you need to manually set the event listeners for Hibernate
      Core, use the following configuration in
      <code class="literal">hibernate.cfg.xml</code>:</p><div class="example"><a id="example-beanvalidationeventlistener-config"/><p class="title"><b>Example 6.1. Manual configuration of
        <code class="classname">BeanValidationEvenListener</code></b></p><div class="example-contents"><pre class="programlisting">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
       ...
       &lt;property name="javax.persistence.validation.group.pre-persist"&gt;javax.validation.Default&lt;/property&gt;
       &lt;property name="javax.persistence.validation.group.pre-update"&gt;javax.validation.Default&lt;/property&gt;
       &lt;property name="javax.persistence.validation.group.pre-remove"&gt;&lt;/property&gt;
    &lt;/session-factory&gt;
    &lt;event type="pre-update"&gt;
       &lt;listener class="<code class="classname">org.hibernate.cfg.beanvalidation.BeanValidationEventListener</code>"/&gt;
    &lt;/event&gt;
    &lt;event type="pre-insert"&gt;
        &lt;listener class="<code class="classname">org.hibernate.cfg.beanvalidation.BeanValidationEventListener</code>"/&gt;
    &lt;/event&gt;
    &lt;event type="pre-delete"&gt;
        &lt;listener class="<code class="classname">org.hibernate.cfg.beanvalidation.BeanValidationEventListener</code>"/&gt;
    &lt;/event&gt;
&lt;/hibernate-configuration&gt;</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2461"/>6.2.2. JPA </h3></div></div></div><p>If you are using JPA 2 and Hibernate Validator is in the classpath
      the JPA2 specification requires that Bean Validation gets enabled. The
      properties
      <span class="property">javax.persistence.validation.group.pre-persist</span>,
      <span class="property">javax.persistence.validation.group.pre-update</span> and
      <span class="property">javax.persistence.validation.group.pre-remove</span> as
      described in <a class="xref" href="#validator-checkconstraints-orm-hibernateevent" title="6.2.1. Hibernate event-based validation">Section 6.2.1, “Hibernate event-based validation”</a> can in this
      case be configured in <code class="filename">persistence.xml</code>.
      <code class="filename">persistence.xml</code> also defines a node validation-mode
      while can be set to <code class="constant">AUTO</code>,
      <code class="constant">CALLBACK</code>, <code class="constant">NONE</code>. The default is
      <code class="constant">AUTO</code>. </p><p>In a JPA 1 you will have to create and register Hibernate
      Validator yourself. In case you are using Hibernate EntityManager you
      can add a customized version of the
      <code class="classname">BeanValidationEventListener</code> described in <a class="xref" href="#validator-checkconstraints-orm-hibernateevent" title="6.2.1. Hibernate event-based validation">Section 6.2.1, “Hibernate event-based validation”</a> to your
      project and register it manually.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="section-presentation-layer"/>6.3. Presentation layer validation</h2></div></div></div><p>When working with JSF2 or <span class="productname">JBoss Seam</span> and
    Hibernate Validator (Bean Validation) is present in the runtime
    environment validation is triggered for every field in the application.
    <a class="xref" href="#">???</a> shows an example of the f:validateBean tag
    in a JSF page. For more information refer to the Seam documentation or the
    JSF 2 specification.</p><div class="example"><a id="example-jsf2"/><p class="title"><b>Example 6.2. Usage of Bean Validation within JSF2</b></p><div class="example-contents"><pre class="programlisting">&lt;h:form&gt;
  <span class="bold"><strong>&lt;f:validateBean&gt;</strong></span>
    &lt;h:inputText value=”#{model.property}” /&gt;
    &lt;h:selectOneRadio value=”#{model.radioProperty}” &gt; ... &lt;/h:selectOneRadio&gt;
    &lt;!-- other input components here --&gt;
  <span class="bold"><strong>&lt;/f:validateBean&gt;</strong></span>
&lt;/h:form&gt;
</pre></div></div><br class="example-break"/></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2525"/>Chapter 7. Further reading</h2></div></div></div><p>Last but not least, a few pointers to further information. A great
  source for examples is the Bean Validation TCK which can is available for
  anonymous access in the Hibernate <a class="ulink" href="http://anonsvn.jboss.org/repos/hibernate/validator/trunk">SVN
  repository</a>. Alternatively you can view the tests using <a class="ulink" href="http://fisheye.jboss.org/browse/Hibernate/beanvalidation/trunk/validation-tck/src/main/java/org/hibernate/jsr303/tck/tests">Hibernate's
  fisheye</a> installation. <a class="ulink" href="http://jcp.org/en/jsr/detail?id=303">The JSR 303</a> specification
  itself is also a great way to deepen your understanding of Bean Validation
  resp. Hibernate Validator.</p><p>If you have any furhter questions to Hibernate Validator or want to
  share some of your use cases have a look at the <a class="ulink" href="http://www.hibernate.org/469.html">Hibernate Validator Wiki</a> and
  the <a class="ulink" href="https://forum.hibernate.org/viewforum.php?f=9">Hibernate
  Validator Forum</a>.</p><p>In case you would like to report a bug use <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/HV">Hibernate's
  Jira</a> instance. Feedback is always welcome!</p></div></div><HR xmlns=""/><a xmlns="" href=""><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2009 Red Hat Middleware, LLC. &amp; Gunnar Morling</p></a><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("validator"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>