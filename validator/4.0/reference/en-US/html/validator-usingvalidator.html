<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 2. Validation step by step</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate Validator, Annotation based constraints for your domain model - Reference Documentation" /><meta name="keywords" content="hibernate, validator, hibernate validator, validation, bean validation" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="Hibernate Validator"/><link rel="up" href="index.html" title="Hibernate Validator"/><link rel="prev" href="validator-gettingstarted.html" title="Chapter 1. Getting started"/><link rel="next" href="validator-customconstraints.html" title="Chapter 3. Creating custom constraints"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="validator-gettingstarted.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="validator-customconstraints.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-usingvalidator"/>Chapter 2. Validation step by step</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="validator-usingvalidator.html#validator-usingvalidator-annotate">2.1. Defining constraints</a></span></dt><dd><dl><dt><span class="section"><a href="validator-usingvalidator.html#d0e265">2.1.1. Field-level constraints</a></span></dt><dt><span class="section"><a href="validator-usingvalidator.html#d0e291">2.1.2. Property-level constraints</a></span></dt><dt><span class="section"><a href="validator-usingvalidator.html#d0e328">2.1.3. Class-level
      constraints</a></span></dt><dt><span class="section"><a href="validator-usingvalidator.html#d0e361">2.1.4. Constraint inheritance</a></span></dt><dt><span class="section"><a href="validator-usingvalidator.html#d0e421">2.1.5. Object graphs</a></span></dt></dl></dd><dt><span class="section"><a href="validator-usingvalidator.html#validator-usingvalidator-validate">2.2. Validating constraints</a></span></dt><dd><dl><dt><span class="section"><a href="validator-usingvalidator.html#section-obtaining-validator">2.2.1. Obtaining a Validator instance</a></span></dt><dt><span class="section"><a href="validator-usingvalidator.html#d0e590">2.2.2. Validator methods</a></span></dt><dt><span class="section"><a href="validator-usingvalidator.html#d0e688">2.2.3. ConstraintViolation methods</a></span></dt><dt><span class="section"><a href="validator-usingvalidator.html#section-message-interpolation">2.2.4. Message interpolation</a></span></dt></dl></dd><dt><span class="section"><a href="validator-usingvalidator.html#validator-usingvalidator-validationgroups">2.3. Validating groups</a></span></dt><dd><dl><dt><span class="section"><a href="validator-usingvalidator.html#d0e1015">2.3.1. Group sequences</a></span></dt><dt><span class="section"><a href="validator-usingvalidator.html#section-default-group-class">2.3.2. Redefining the default group sequence of a class</a></span></dt></dl></dd><dt><span class="section"><a href="validator-usingvalidator.html#validator-defineconstraints-builtin">2.4. Built-in constraints</a></span></dt></dl></div><p>In this chapter we will see in more detail how to use Hibernate
  Validator to validate constraints for a given entity model. We will also
  learn which default constraints the Bean Validation specification provides
  and which additional constraints are only provided by Hibernate Validator.
  Let's start with how to add constraints to an entity.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-usingvalidator-annotate"/>2.1. Defining constraints</h2></div></div></div><p>Constraints in Bean Validation are expressed via Java annotations.
    In this section we show how to annotate an object model with these
    annotations. We have to differentiate between three different type of
    constraint annotations - field-, property-, and class-level
    annotations.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Not all constraints can be placed on all of these levels. In fact,
      none of the default constraints defined by Bean Validation can be placed
      at class level. The <code class="classname">java.lang.annotation.Target</code>
      annotation in the constraint annotation itself determines on which
      elements a constraint can be placed. See <a class="xref" href="validator-customconstraints.html" title="Chapter 3. Creating custom constraints">Chapter 3, <i>Creating custom constraints</i></a> for more information.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e265"/>2.1.1. Field-level constraints</h3></div></div></div><p>Constraints can be expressed by annotating a field of a class.
      <a class="xref" href="validator-usingvalidator.html#example-field-level" title="Example 2.1. Field level constraint">Example 2.1, “Field level constraint”</a> shows a field level configuration
      example:</p><div class="example"><a id="example-field-level"/><p class="title"><b>Example 2.1. Field level constraint</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Car {

    <span class="bold"><strong>@NotNull</strong></span>
    private String manufacturer;

    <span class="bold"><strong>@AssertTrue</strong></span>
    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }
}</pre></div></div><br class="example-break"/><p>When using field level constraints field access strategy is used
      to access the value to be validated. This means the instance variable
      directly independed of the access type.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The access type (private, protected or public) does not
        matter.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Static fields and properties cannot be validated.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e291"/>2.1.2. Property-level constraints</h3></div></div></div><p>If your model class adheres to the <a class="ulink" href="http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp">JavaBeans</a>
      standard, it is also possible to annotate the properties of a bean class
      instead of its fields. <a class="xref" href="validator-usingvalidator.html#example-property-level" title="Example 2.2. Property level constraint">Example 2.2, “Property level constraint”</a> uses
      the same entity as in <a class="xref" href="validator-usingvalidator.html#example-field-level" title="Example 2.1. Field level constraint">Example 2.1, “Field level constraint”</a>, however,
      property level constraints are used.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The property's getter method has to be annotated, not its
          setter.</p></div><div class="example"><a id="example-property-level"/><p class="title"><b>Example 2.2. Property level constraint</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.NotNull;

public class Car {

    private String manufacturer;

    private boolean isRegistered;
      
    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    <span class="bold"><strong>@NotNull</strong></span>
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    <span class="bold"><strong>@AssertTrue</strong></span>
    public boolean isRegistered() {
        return isRegistered;
    }

    public void setRegistered(boolean isRegistered) {
        this.isRegistered = isRegistered;
    }
}</pre></div></div><br class="example-break"/><p>When using property level constraints property access strategy is
      used to access the value to be validated. This means the bean validation
      provider accesses the state via the property accessor method.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>It is recommended to stick either to field
        <span class="emphasis"><em>or</em></span> property annotation within one class. It is
        not recommended to annotate a field <span class="emphasis"><em>and</em></span> the
        accompanying getter method as this would cause the field to be
        validated twice.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e328"/>2.1.3. Class-level
      constraints</h3></div></div></div><p>Last but not least, a constraint can also be placed on class
      level. When a constraint annotation is placed on this level the class
      instance itself passed to the
      <code class="classname">ConstraintValidator</code>. Class level constraints are
      useful if it is necessary to inspect more than a single property of the
      class to validate it or if a correlation between different state
      variables has to be evaluated. In <a class="xref" href="validator-usingvalidator.html#example-class-level" title="Example 2.3. Class level constraint">Example 2.3, “Class level constraint”</a>
      we add the property <span class="property">passengers</span> to the class
      <code class="classname">Car</code>. We also add the constraint
      <code class="classname">PassengerCount</code> on the class level. We will later
      see how we can actually create this custom constraint (see <a class="xref" href="validator-customconstraints.html" title="Chapter 3. Creating custom constraints">Chapter 3, <i>Creating custom constraints</i></a>). For now we it is enough to
      know that <code class="classname">PassengerCount</code> will ensure that there
      cannot be more passengers in a car than there are seats.</p><div class="example"><a id="example-class-level"/><p class="title"><b>Example 2.3. Class level constraint</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

<span class="bold"><strong>@PassengerCount</strong></span>
public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;
    
    private List&lt;Person&gt; passengers;
    
    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e361"/>2.1.4. Constraint inheritance</h3></div></div></div><p>When validating an object that implements an interface or extends
      another class, all constraint annotations on the implemented interface
      and parent class apply in the same manner as the constraints specified
      on the validated object itself. To make things clearer let's have a look
      at the following example:</p><div class="example"><a id="d0e366"/><p class="title"><b>Example 2.4. Constraint inheritance using RentalCar</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.NotNull;

public class RentalCar extends Car {

    private String rentalStation;
    
    public RentalCar(String manufacturer, String rentalStation) {
        super(manufacturer);
        this.rentalStation = rentalStation;
    }
    
    <span class="bold"><strong>@NotNull</strong></span>
    public String getRentalStation() {
        return rentalStation;
    }

    public void setRentalStation(String rentalStation) {
        this.rentalStation = rentalStation;
    }
}</pre></div></div><br class="example-break"/><p>Our well-known class <code class="classname">Car</code> from <a class="xref" href="">???</a> is now extended by
      <code class="classname">RentalCar</code> with the additional property
      <span class="property">rentalStation</span>. If an instance of
      <code class="classname">RentalCar</code> is validated, not only the
      <code class="classname">@NotNull</code> constraint on
      <span class="property">rentalStation</span> is validated, but also the constraint
      on <span class="property">manufacturer</span> from the parent class.</p><p>The same would hold true, if <code class="classname">Car</code> were an
      interface implemented by <code class="classname">RentalCar</code>.</p><p>Constraint annotations are aggregated if methods are overridden.
      If <code class="classname">RentalCar</code> would override the
      <code class="methodname">getManufacturer()</code> method from
      <code class="classname">Car</code> any constraints annotated at the overriding
      method would be evaluated in addition to the
      <code class="classname">@NotNull</code> constraint from the super-class.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e421"/>2.1.5. Object graphs</h3></div></div></div><p>The Bean Validation API does not only allow to validate single
      class instances but also complete object graphs. To do so, just annotate
      a field or property representing a reference to another object with
      <code class="classname">@Valid</code>. If the parent object is validated, all
      referenced objects annotated with <code class="classname">@Valid</code> will be
      validated as well (as will be their children etc.). See <a class="xref" href="validator-usingvalidator.html#example-car-with-driver" title="Example 2.6. Adding a driver to the car">Example 2.6, “Adding a driver to the car”</a>.</p><div class="example"><a id="d0e434"/><p class="title"><b>Example 2.5. Class Person</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Person {

    <span class="bold"><strong>@NotNull</strong></span>
    private String name;
    
    public Person(String name) {
        super();
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre></div></div><br class="example-break"/><div class="example"><a id="example-car-with-driver"/><p class="title"><b>Example 2.6. Adding a driver to the car</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    <span class="bold"><strong>@NotNull</strong></span>
    <span class="bold"><strong>@Valid</strong></span>
    private Person driver;
    
    public Car(Person driver) {
        this.driver = driver;
    }

    //getters and setters ...
}</pre></div></div><br class="example-break"/><p>If an instance of <code class="classname">Car</code> is validated, the
      referenced <code class="classname">Person</code> object will be validated as
      well, as the <span class="property">driver</span> field is annotated with
      <code class="classname">@Valid</code>. Therefore the validation of a
      <code class="classname">Car</code> will fail if the <span class="property">name</span>
      field of the referenced <code class="classname">Person</code> instance is
      <code class="code">null</code>.</p><p>Object graph validation also works for collection-typed fields.
      That means any attributes that are</p><div class="itemizedlist"><ul><li><p>arrays</p></li><li><p>implement <code class="classname">java.lang.Iterable</code>
          (especially <code class="classname">Collection</code>,
          <code class="classname">List</code> and <code class="classname">Set</code>)</p></li><li><p>implement <code class="classname">java.util.Map</code></p></li></ul></div><p>can be annotated with <code class="classname">@Valid</code>, which will
      cause each contained element to be validated, when the parent object is
      validated.</p><div class="example"><a id="d0e510"/><p class="title"><b>Example 2.7. Car with a list of passengers</b></p><div class="example-contents"><pre class="programlisting">package com.mycompany;

import java.util.ArrayList;
import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    <span class="bold"><strong>@Valid
    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();</strong></span>

    public Car(List&lt;Person&gt; passengers) {
        this.passengers = passengers;
    }

    //getters and setters ...
}</pre></div></div><br class="example-break"/><p>If a <code class="classname">Car</code> instance is validated, a
      <code class="classname">ConstraintValidation</code> will be created, if any of
      the <code class="classname">Person</code> objects contained in the
      <span class="property">passengers</span> list has a <code class="code">null</code> name.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="classname">null</code> values are getting ignored when
          validating object graphs.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-usingvalidator-validate"/>2.2. Validating constraints</h2></div></div></div><p>The <code class="classname">Validator</code> interface is the main entry
    point to Bean Validation. In <a class="xref" href="validator-bootstrapping.html#section-validator-instance" title="5.1. Configuration and ValidatorFactory">Section 5.1, “Configuration and
    ValidatorFactory”</a>
    we will first show how to obtain an <code class="classname">Validator</code>
    instance. Afterwards we will learn how to use the different methods of the
    <code class="classname">Validator</code> interface.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="section-obtaining-validator"/>2.2.1. Obtaining a <code class="classname">Validator</code> instance</h3></div></div></div><p>The first step towards validating an entity instance is to get
      hold of a <code class="classname">Validator</code> instance. The road to this
      instance leads via the <code class="classname">Validation</code> class and a
      <code class="classname">ValidatorFactory</code>. The easiest way is to use the
      static
      <code class="methodname">Validation.buildDefaultValidatorFactory()</code>
      method:</p><div class="example"><a id="d0e576"/><p class="title"><b>Example 2.8. Validation.buildDefaultValidatorFactory()</b></p><div class="example-contents"><pre class="programlisting">ValidatorFactory factory = <span class="bold"><strong>Validation.buildDefaultValidatorFactory()</strong></span>;
Validator validator = factory.getValidator();</pre></div></div><p><br class="example-break"/>For other ways of obtaining a Validator instance see <a class="xref" href="validator-bootstrapping.html" title="Chapter 5. Bootstrapping">Chapter 5, <i>Bootstrapping</i></a>. For now we just want to see how we
      can use the <code class="classname">Validator</code> instance to validate entity
      instances.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e590"/>2.2.2. Validator methods</h3></div></div></div><p>The <code class="classname">Validator</code> interface contains three
      methods that can be used to either validate entire entities or just a
      single properties of the entity.</p><p>All three methods return a
      <code class="classname">Set&lt;ConstraintViolation&gt;</code>. The set is empty,
      if the validation succeeds. Otherwise a
      <code class="classname">ConstraintViolation</code> instance is added for each
      violated constraint.</p><p>All the validation methods have a var-args parameter which can be
      used to specify, which validation groups shall be considered when
      performing the validation. If the parameter is not specified the default
      validation group (<code class="classname">javax.validation.Default</code>) will
      be used. We will go into more detail on the topic of validation groups
      in <a class="xref" href="validator-usingvalidator.html#validator-usingvalidator-validationgroups" title="2.3. Validating groups">Section 2.3, “Validating groups”</a></p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e612"/>2.2.2.1. <code class="methodname">validate</code></h4></div></div></div><p>Use the <code class="methodname">validate()</code> method to perform
        validation of all constraints of a given entity instance (see <a class="xref" href="validator-usingvalidator.html#example-validator-validate" title="Example 2.9. Usage of Validator.validate()">Example 2.9, “Usage of
          Validator.validate()”</a> ).</p><div class="example"><a id="example-validator-validate"/><p class="title"><b>Example 2.9. Usage of
          <code class="methodname">Validator.validate()</code></b></p><div class="example-contents"><pre class="programlisting">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = <span class="bold"><strong>validator.validate(car)</strong></span>;

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e633"/>2.2.2.2. <code class="methodname">validateProperty</code></h4></div></div></div><p>With help of the <code class="methodname">validateProperty()</code> a
        single named property of a given object can be validated. The property
        name is the JavaBeans property name.</p><div class="example"><a id="d0e642"/><p class="title"><b>Example 2.10. Usage of
          <code class="methodname">Validator.validateProperty()</code></b></p><div class="example-contents"><pre class="programlisting">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = <span class="bold"><strong>validator.validateProperty(car, "manufacturer")</strong></span>;

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</pre></div></div><br class="example-break"/><p><code class="methodname">Validator.validateProperty</code> is for
        example used in the integration of Bean Validation into JSF 2 (see
        <a class="xref" href="validator-checkconstraints.html#section-presentation-layer" title="6.3. Presentation layer validation">Section 6.3, “Presentation layer validation”</a>).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e658"/>2.2.2.3. <code class="methodname">validateValue</code></h4></div></div></div><p>Using the <code class="methodname">validateValue() </code>method you
        can check, whether a single property of a given class can be validated
        successfully, if the property had the specified value:</p><div class="example"><a id="d0e667"/><p class="title"><b>Example 2.11. Usage of
          <code class="methodname">Validator.validateValue()</code></b></p><div class="example-contents"><pre class="programlisting">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = <span class="bold"><strong>validator.validateValue(Car.class, "manufacturer", null)</strong></span>;

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="classname">@Valid</code> is not honored by
          <code class="methodname">validateProperty()</code> or
          <code class="methodname">validateValue()</code>.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e688"/>2.2.3. <code class="classname">ConstraintViolation</code> methods</h3></div></div></div><p>Now it is time to have a closer look at what a
      <code class="classname">ConstraintViolation</code>. Using the different methods
      of <code class="classname">ConstraintViolation</code> a lot of useful
      information about the cause of the validation failure can be determined.
      <a class="xref" href="validator-usingvalidator.html#table-constraint-violation" title="Table 2.1. The various ConstraintViolation methods">Table 2.1, “The various ConstraintViolation
        methods”</a> gives an overview of these
      methods:</p><div class="table"><a id="table-constraint-violation"/><p class="title"><b>Table 2.1. The various <code class="classname">ConstraintViolation</code>
        methods</b></p><div class="table-contents"><table summary="The various ConstraintViolation&#xA;        methods" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Method</th><th>Usage</th><th>Example (refering to <a class="xref" href="validator-usingvalidator.html#example-validator-validate" title="Example 2.9. Usage of Validator.validate()">Example 2.9, “Usage of
          Validator.validate()”</a>)</th></tr></thead><tbody><tr><td><code class="methodname">getMessage()</code></td><td>The interpolated error message.</td><td>may not be null</td></tr><tr><td><code class="methodname">getMessageTemplate()</code></td><td>The non-interpolated error message.</td><td>{javax.validation.constraints.NotNull.message}</td></tr><tr><td><code class="methodname">getRootBean()</code></td><td>The root bean being validated.</td><td>car</td></tr><tr><td><code class="methodname">getRootBeanClass()</code></td><td>The class of the root bean being validated.</td><td>Car.class</td></tr><tr><td><code class="methodname">getLeafBean()</code></td><td>If a bean constraint, the bean instance the constraint is
              applied on. If a property constraint, the bean instance hosting
              the property the constraint is applied on.</td><td>car</td></tr><tr><td><code class="methodname">getPropertyPath()</code></td><td>The property path to the value from root bean.</td><td> </td></tr><tr><td><code class="methodname">getInvalidValue()</code></td><td>The value failing to pass the constraint.</td><td>passengers</td></tr><tr><td><code class="methodname">getConstraintDescriptor()</code></td><td>Constraint metadata reported to fail.</td><td> </td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="section-message-interpolation"/>2.2.4. Message interpolation</h3></div></div></div><p>As we will see in <a class="xref" href="validator-customconstraints.html" title="Chapter 3. Creating custom constraints">Chapter 3, <i>Creating custom constraints</i></a>
      each constraint definition must define a default message descriptor.
      This message can be overridden at declaration time using the
      <code class="methodname">message</code> attribute of the constraint. You can
      see this in <a class="xref" href="validator-usingvalidator.html#example-driver" title="Example 2.13. Driver">Example 2.13, “Driver”</a>. This message descriptors
      get interpolated when a constraint validation fails using the configured
      <code class="classname">MessageInterpolator</code>. The interpolator will try to
      resolve any message parameters, meaning string literals enclosed in
      braces. In order to resolve these parameters Hibernate Validator's
      default <code class="classname">MessageInterpolator</code> first recursively
      resolves parameters against a custom
      <code class="classname">ResourceBundle</code> called
      <code class="filename">ValidationMessages.properties</code> at the root of the
      classpath (It is up to you to create this file). If no further
      replacements are possible against the custom bundle the default
      <code class="classname">ResourceBundle</code> under
      <code class="filename">/org/hibernate/validator/ValidationMessages.properties</code>
      gets evaluated. If a replacement occurs against the default bundle the
      algorithm looks again at the custom bundle (and so on). Once no further
      replacements against these two resource bundles are possible remaining
      parameters are getting resolved against the attributes of the constraint
      to be validated.</p><p>Since the braces { and } have special meaning in the messages they
      need to be escaped if they are used literally. The following The
      following rules apply:</p><div class="itemizedlist"><ul><li><p>\{ is considered as the literal {</p></li><li><p>\} is considered as the literal }</p></li><li><p>\\ is considered as the literal \</p></li></ul></div><p>If the default message interpolator does not fit your requirements
      it is possible to plug a custom
      <code class="classname">MessageInterpolator</code> when the
      <code class="classname">ValidatorFactory</code> gets created. This can be seen
      in <a class="xref" href="validator-bootstrapping.html" title="Chapter 5. Bootstrapping">Chapter 5, <i>Bootstrapping</i></a>.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-usingvalidator-validationgroups"/>2.3. Validating groups</h2></div></div></div><p>Groups allow you to restrict the set of constraints applied during
    validation. This makes for example wizard like validation possible where
    in each step only a specified subset of constraints get validated. The
    groups targeted are passed as var-args parameters to
    <code class="methodname">validate</code>,
    <code class="methodname">validateProperty</code> and
    <code class="methodname">validateValue</code>. Let's have a look at an extended
    <code class="classname">Car</code> with <code class="classname">Driver</code> example.
    First we have the class <code class="classname">Person</code> (<a class="xref" href="validator-usingvalidator.html#example-person" title="Example 2.12. Person">Example 2.12, “Person”</a>) which has a <code class="classname">@NotNull
    </code>constraint on <span class="property">name</span>. Since no group is
    specified for this annotation its default group is
    <code class="classname">javax.validation.Default</code>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>When more than one group is requested, the order in which the
      groups are evaluated is not deterministic. If no group is specified the
      default group <code class="classname">javax.validation.Default</code> is
      assumed.</p></div><div class="example"><a id="example-person"/><p class="title"><b>Example 2.12. Person</b></p><div class="example-contents"><pre class="programlisting">public class Person {
    <span class="bold"><strong>@NotNull</strong></span>
    private String name;

    public Person(String name) {
        this.name = name;
    }
    // getters and setters ...
}</pre></div></div><p><br class="example-break"/>Next we have the class <code class="classname">Driver</code> (<a class="xref" href="validator-usingvalidator.html#example-driver" title="Example 2.13. Driver">Example 2.13, “Driver”</a>) extending <code class="classname">Person</code>. Here
    we are adding the properties <span class="property">age</span> and
    <span class="property">hasDrivingLicense</span>. In order to drive you must be at
    least 18 (<code class="classname">@Min(18)</code>) and you must have a driving
    license (<code class="classname">@AssertTrue</code>). Both constraints defined on
    these properties belong to the group <code class="classname">DriverChecks</code>.
    As you can see in <a class="xref" href="validator-usingvalidator.html#example-group-interfaces" title="Example 2.14. Group interfaces">Example 2.14, “Group interfaces”</a> the group
    <code class="classname">DriverChecks</code> is just a simple tagging interface.
    Using interfaces makes the usage of groups type safe and allows for easy
    refactoring. It also means that groups can inherit from each other via
    class inheritance.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The Bean Validation specification does not enforce that groups
        have to be interfaces. Non interface classes could be used as well,
        but we recommend to stick to interfaces.</p></div><div class="example"><a id="example-driver"/><p class="title"><b>Example 2.13. Driver</b></p><div class="example-contents"><pre class="programlisting">public class Driver extends Person {
    <span class="bold"><strong>@Min(value = 18, message = "You have to be 18 to drive a car", groups = DriverChecks.class)</strong></span>
    public int age;

    <span class="bold"><strong>@AssertTrue(message = "You first have to pass the driving test", groups = DriverChecks.class)</strong></span>
    public boolean hasDrivingLicense;

    public Driver(String name) {
        super( name );
    }

    public void passedDrivingTest(boolean b) {
        hasDrivingLicense = b;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}</pre></div></div><p><br class="example-break"/></p><div class="example"><a id="example-group-interfaces"/><p class="title"><b>Example 2.14. Group interfaces</b></p><div class="example-contents"><pre class="programlisting">public interface DriverChecks {
}

public interface CarChecks {
}</pre></div></div><p><br class="example-break"/>Last but not least we add the property
    <span class="property">passedVehicleInspection</span> to the
    <code class="classname">Car</code> class (<a class="xref" href="validator-usingvalidator.html#example-car" title="Example 2.15. Car">Example 2.15, “Car”</a>)
    indicating whether a car passed the road worthy tests.</p><div class="example"><a id="example-car"/><p class="title"><b>Example 2.15. Car</b></p><div class="example-contents"><pre class="programlisting">public class Car {
    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    <span class="bold"><strong>@AssertTrue(message = "The car has to pass the vehicle inspection first", groups = CarChecks.class)</strong></span>
    private boolean passedVehicleInspection;

    @Valid
    private Driver driver;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }
}</pre></div></div><p><br class="example-break"/>Overall three different groups are used in our example.
    <span class="property">Person.name</span>, <span class="property">Car.manufacturer</span>,
    <span class="property">Car.licensePlate</span> and
    <span class="property">Car.seatCount</span> all belong to the
    <code class="classname">Default</code> group. <span class="property">Driver.age</span> and
    <span class="property">Driver.hasDrivingLicense</span> belong to
    <code class="classname">DriverChecks</code> and last but not least
    <span class="property">Car.passedVehicleInspection</span> belongs to the group
    <code class="classname">CarChecks</code>. <a class="xref" href="validator-usingvalidator.html#example-drive-away" title="Example 2.16. Drive away">Example 2.16, “Drive away”</a>
    shows how passing different group combinations to the
    <code class="methodname">Validator.validate</code> method result in different
    validation results.</p><div class="example"><a id="example-drive-away"/><p class="title"><b>Example 2.16. Drive away</b></p><div class="example-contents"><pre class="programlisting">public class GroupTest {

    private static Validator validator;

    @BeforeClass
    public static void setUp() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void driveAway() {
        // create a car and check that everything is ok with it.
        Car car = new Car( "Morris", "DD-AB-123", 2 );
        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
        assertEquals( 0, constraintViolations.size() );

        // but has it passed the vehicle inspection?
        constraintViolations = validator.validate( car, CarChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals("The car has to pass the vehicle inspection first", constraintViolations.iterator().next().getMessage());

        // let's go to the vehicle inspection
        car.setPassedVehicleInspection( true );
        assertEquals( 0, validator.validate( car ).size() );

        // now let's add a driver. He is 18, but has not passed the driving test yet
        Driver john = new Driver( "John Doe" );
        john.setAge( 18 );
        car.setDriver( john );
        constraintViolations = validator.validate( car, DriverChecks.class );
        assertEquals( 1, constraintViolations.size() );
        assertEquals( "You first have to pass the driving test", constraintViolations.iterator().next().getMessage() );

        // ok, John passes the test
        john.passedDrivingTest( true );
        assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

        // just checking that everything is in order now
        assertEquals( 0, validator.validate( car, Default.class, CarChecks.class, DriverChecks.class ).size() );
    }
}</pre></div></div><p><br class="example-break"/>First we create a car and validate it using no explicit group.
    There are no validation errors, even though the property
    <span class="property">passedVehicleInspection</span> is per default
    <code class="constant">false</code>. However, the constraint defined on this
    property does not belong to the default group.</p><p>Next we just validate the <code class="classname">CarChecks</code> group
    which will fail until we make sure that the car passes the vehicle
    inspection.</p><p>When we then add a driver to the car and validate against
    <code class="classname">DriverChecks</code> we get again a constraint violation
    due to the fact that the driver has not yet passed the driving test. Only
    after setting <span class="property">passedDrivingTest</span> to true the
    validation against <code class="classname">DriverChecks</code> will pass.</p><p>Last but not least, we show that all constraints are passing by
    validating against all defined groups.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1015"/>2.3.1. Group sequences</h3></div></div></div><p>By default, constraints are evaluated in no particular order and
      this regardless of which groups they belong to. In some situations,
      however, it is useful to control the order of the constraints
      evaluation. In our example from <a class="xref" href="validator-usingvalidator.html#validator-usingvalidator-validationgroups" title="2.3. Validating groups">Section 2.3, “Validating groups”</a> we could for
      example require that first all default car constraints are passing
      before we check the road worthiness of the car. Finally before we drive
      away we check the actual driver constraints. In order to implement such
      an order one would define a new interface and annotate it with
      <code class="classname">@GroupSequence</code> defining the order in which the
      groups have to be validated.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>If at least one constraints fails in a sequenced group none of
        the constraints of the follwoing groups in the sequence get
        validated.</p></div><div class="example"><a id="d0e1029"/><p class="title"><b>Example 2.17. Interface with @GroupSequence</b></p><div class="example-contents"><pre class="programlisting"><span class="bold"><strong>@GroupSequence({Default.class, CarChecks.class, DriverChecks.class})</strong></span>
public interface OrderedChecks {
}</pre></div></div><p><br class="example-break"/></p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Groups defining a sequence and groups composing a sequence
          must not be involved in a cyclic dependency either directly or
          indirectly, either through cascaded sequence definition or group
          inheritance. If a group containing such a circularity is evaluated,
          a <code class="classname">GroupDefinitionException</code> is raised.</p></div><p>The usage of the new sequence could then look like in <a class="xref" href="validator-usingvalidator.html#example-group-sequence" title="Example 2.18. Usage of a group sequence">Example 2.18, “Usage of a group sequence”</a>.</p><div class="example"><a id="example-group-sequence"/><p class="title"><b>Example 2.18. Usage of a group sequence</b></p><div class="example-contents"><pre class="programlisting">@Test
public void testOrderedChecks() {
    Car car = new Car( "Morris", "DD-AB-123", 2 );
    car.setPassedVehicleInspection( true );

    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    john.passedDrivingTest( true );
    car.setDriver( john );

    assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );
}</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="section-default-group-class"/>2.3.2. Redefining the default group sequence of a class</h3></div></div></div><p>The @GroupSequence annotation also fulfills a second purpose. It
      allows you to redefine what the Default group means for a given class.
      To redefine <code class="classname">Default</code> for a class, place a
      <code class="classname">@GroupSequence</code> annotation on the class. The
      defined groups in the annotation express the sequence of groups that
      substitute <code class="classname">Default</code> for this class. <a class="xref" href="validator-usingvalidator.html#example-rental-car" title="Example 2.19. RentalCar">Example 2.19, “RentalCar”</a> introduces a new class RentalCar with a
      redfined default group. With this definition the check for all three
      groups can be rewritten as seen in <a class="xref" href="validator-usingvalidator.html#example-testOrderedChecksWithRedefinedDefault" title="Example 2.20. testOrderedChecksWithRedefinedDefault">Example 2.20, “testOrderedChecksWithRedefinedDefault”</a>.</p><div class="example"><a id="example-rental-car"/><p class="title"><b>Example 2.19. RentalCar</b></p><div class="example-contents"><pre class="programlisting">@GroupSequence({ RentalCar.class, CarChecks.class })
public class RentalCar extends Car {
    public RentalCar(String manufacturer, String licencePlate, int seatCount) {
        super( manufacturer, licencePlate, seatCount );
    }
}</pre></div></div><br class="example-break"/><div class="example"><a id="example-testOrderedChecksWithRedefinedDefault"/><p class="title"><b>Example 2.20. testOrderedChecksWithRedefinedDefault</b></p><div class="example-contents"><pre class="programlisting">@Test
public void testOrderedChecksWithRedefinedDefault() {
    RentalCar rentalCar = new RentalCar( "Morris", "DD-AB-123", 2 );
    rentalCar.setPassedVehicleInspection( true );

    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    john.passedDrivingTest( true );
    rentalCar.setDriver( john );

    assertEquals( 0, validator.validate( rentalCar, Default.class, DriverChecks.class ).size() );
}</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Due to the fact that there cannot be a cyclic dependency in the
        group and group sequence definitions one cannot just add
        <code class="classname">Default</code> to the sequence redefining
        <code class="classname">Default</code> for a class. Instead the class itself
        should be added!</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="validator-defineconstraints-builtin"/>2.4. Built-in constraints</h2></div></div></div><p>Hibernate Validator implements all of the default constraints
    specified in Bean Validation as well as some custom ones. <a class="xref" href="validator-usingvalidator.html#table-builtin-constraints" title="Table 2.2. Built-in constraints">Table 2.2, “Built-in constraints”</a> list all constraints available in
    Hibernate Validator.</p><div class="table"><a id="table-builtin-constraints"/><p class="title"><b>Table 2.2. Built-in constraints</b></p><div class="table-contents"><table summary="Built-in constraints" border="1"><colgroup><col align="left"/><col/><col/><col/><col/></colgroup><thead><tr><th align="left">Annotation</th><th>Part of Bean Validation Specification</th><th>Apply on</th><th>Use</th><th>Hibernate Metadata impact</th></tr></thead><tbody><tr><td align="left">@AssertFalse</td><td>yes</td><td>field/property</td><td>check that the annotated element is
            <code class="constant">false</code>.</td><td>none</td></tr><tr><td align="left">@AssertTrue</td><td>yes</td><td>field/property</td><td>check that the annotated element is
            <code class="constant">true</code>.</td><td>none</td></tr><tr><td align="left">@DecimalMax</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>The annotated element must be a number whose value must be
            lower or equal to the specified maximum. The parameter value is
            the string representation of the max value according to the
            <code class="classname">BigDecimal</code> string representation.</td><td>none</td></tr><tr><td align="left">@DecimalMin</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>The annotated element must be a number whose value must be
            higher or equal to the specified minimum. The parameter value is
            the string representation of the min value according to the
            <code class="classname">BigDecimal</code> string representation.</td><td>none</td></tr><tr><td align="left">@Digits(integer=, fraction=)</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>Check whether the property is a number having up to
            <code class="literal">integer</code> digits and <code class="literal">fraction</code>
            fractional digits.</td><td>Define column precision and scale.</td></tr><tr><td align="left">@Email</td><td>no</td><td>field/property. Needs to be a string.</td><td>Check whether the specified string is a valid email
            address.</td><td>none</td></tr><tr><td align="left">@Future</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">java.util.Date</code> and
            <code class="classname">java.util.Calendar</code>.</td><td>Checks whether the annotated date is in the future.</td><td>none</td></tr><tr><td align="left">@Length(min=, max=)</td><td>no</td><td>field/property. Needs to be a string.</td><td>Validate that the annotated string is between
            <em class="parameter"><code>min</code></em> and <em class="parameter"><code>max</code></em>
            included.</td><td>none</td></tr><tr><td align="left">@Max</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>Checks whether the annotated value is less than or equal to
            the specified maximum.</td><td>Add a check constraint on the column.</td></tr><tr><td align="left">@Min</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>Check whether the annotated value is higher than or equal
            to the specified minimum.</td><td>Add a check constraint on the column.</td></tr><tr><td align="left">@NotNull</td><td>yes</td><td>field/property</td><td>Check that the annotated value is not
            <code class="constant">null.</code></td><td>Column(s) are not null.</td></tr><tr><td align="left">@NotEmpty</td><td>no</td><td>field/property. Needs to be a string.</td><td>Check if the string is not <code class="constant">null</code> nor
            empty.</td><td>none</td></tr><tr><td align="left">@Null</td><td>yes</td><td>field/property</td><td>Check that the annotated value is
            <code class="constant">null.</code></td><td>none</td></tr><tr><td align="left">@Past</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">java.util.Date</code> and
            <code class="classname">java.util.Calendar</code>.</td><td>Checks whether the annotated date is in the past.</td><td>none</td></tr><tr><td align="left">@Pattern(regex=, flag=)</td><td>yes</td><td>field/property. Needs to be a string.</td><td>Check if the annotated string match the regular expression
            <em class="parameter"><code>regex</code></em>.</td><td>none</td></tr><tr><td align="left">@Range(min=, max=)</td><td>no</td><td>field/property. Supported types are
            <code class="classname">BigDecimal</code>,
            <code class="classname">BigInteger</code>, <code class="classname">String</code>,
            <code class="classname">byte</code>, <code class="classname">short</code>,
            <code class="classname">int</code>, <code class="classname">long</code> and the
            respective wrappers of the primitive types.</td><td>Check whether the annotated value lies between (inclusive)
            the specified minimum and maximum.</td><td>none</td></tr><tr><td align="left">@Size(min=, max=)</td><td>yes</td><td>field/property. Supported types are
            <code class="classname">String</code>, <code class="classname">Collection</code>,
            <code class="classname">Map</code> and
            <code class="classname">arrays</code>.</td><td>Check if the annotated element size is between min and max
            (inclusive).</td><td>Column length will be set to max.</td></tr><tr><td align="left">@Valid</td><td>yes</td><td>field/property</td><td>Perform validation recursively on the associated
            object.</td><td>none</td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>On top of the parameters indicated in <a class="xref" href="validator-usingvalidator.html#table-builtin-constraints" title="Table 2.2. Built-in constraints">Table 2.2, “Built-in constraints”</a> each constraint supports the
      parameters <em class="parameter"><code>message</code></em>, <em class="parameter"><code>groups</code></em>
      and <em class="parameter"><code>payload</code></em>. This is a requirement of the Bean
      Validation specification.</p></div><p>In some cases these built-in constraints will not fulfill your
    requirements. In this case you can literally in a minute write your own
    constraints. We will discuss this in <a class="xref" href="validator-customconstraints.html" title="Chapter 3. Creating custom constraints">Chapter 3, <i>Creating custom constraints</i></a></p></div></div><HR xmlns=""/><a xmlns="" href=""><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2009 Red Hat Middleware, LLC. &amp; Gunnar Morling</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="validator-gettingstarted.html"><strong>Prev</strong>Chapter 1. Getting started</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="validator-customconstraints.html"><strong>Next</strong>Chapter 3. Creating custom constraints</a></li></ul><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("validator"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>