<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 11. Hibernate Validator Specifics</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate Validator, Annotation based constraints for your domain model - Reference Documentation" /><meta name="keywords" content="hibernate, validator, hibernate validator, validation, bean validation" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" type="text/css" href="docbook.css"/><link rel="stylesheet" type="text/css" href="css/hibernate.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/><link rel="prev" href="ch10.html" title="Chapter 10. Integrating with other frameworks"/><link rel="next" href="ch12.html" title="Chapter 12. Annotation Processor"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-282CVRCQHZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-282CVRCQHZ');
</script>
<!-- /Google Analytics -->
</head><body><header><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch10.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch12.html"><strong>Next</strong></a></li></ul></header><section class="chapter" id="validator-specifics"><div class="titlepage"><div><div><h1 class="title">Chapter 11. Hibernate Validator Specifics</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="ch11.html#_public_api">11.1. Public API</a></span></li><li><span class="section"><a href="ch11.html#section-fail-fast">11.2. Fail fast mode</a></span></li><li><span class="section"><a href="ch11.html#section-method-validation-prerequisite-relaxation">11.3. Relaxation of requirements for method validation in class hierarchies</a></span></li><li><span class="section"><a href="ch11.html#section-programmatic-api">11.4. Programmatic constraint definition and declaration</a></span></li><li><span class="section"><a href="ch11.html#section-programmatic-api-contributor">11.5. Applying programmatic constraint declarations to the default validator factory</a></span></li><li><span class="section"><a href="ch11.html#section-advanced-constraint-composition">11.6. Advanced constraint composition features</a></span><ul><li><span class="section"><a href="ch11.html#_validation_target_specification_for_purely_composed_constraints">11.6.1. Validation target specification for purely composed constraints</a></span></li><li><span class="section"><a href="ch11.html#section-boolean-constraint-composition">11.6.2. Boolean composition of constraints</a></span></li></ul></li><li><span class="section"><a href="ch11.html#section-extensions-path-api">11.7. Extensions of the Path API</a></span></li><li><span class="section"><a href="ch11.html#section-dynamic-payload">11.8. Dynamic payload as part of ConstraintViolation</a></span></li><li><span class="section"><a href="ch11.html#non-el-message-interpolator">11.9. <code class="literal">ParameterMessageInterpolator</code></a></span></li><li><span class="section"><a href="ch11.html#__literal_resourcebundlelocator_literal">11.10. <code class="literal">ResourceBundleLocator</code></a></span></li><li><span class="section"><a href="ch11.html#_custom_contexts">11.11. Custom contexts</a></span><ul><li><span class="section"><a href="ch11.html#section-hibernateconstraintvalidatorcontext">11.11.1. <code class="literal">HibernateConstraintValidatorContext</code></a></span></li><li><span class="section"><a href="ch11.html#__literal_hibernatemessageinterpolatorcontext_literal">11.11.2. <code class="literal">HibernateMessageInterpolatorContext</code></a></span></li></ul></li><li><span class="section"><a href="ch11.html#section-paranamer-parameternameprovider">11.12. ParaNamer based <code class="literal">ParameterNameProvider</code></a></span></li><li><span class="section"><a href="ch11.html#section-value-handling">11.13. Unwrapping values</a></span><ul><li><span class="section"><a href="ch11.html#section-optional-unwrapper">11.13.1. Optional unwrapper</a></span></li><li><span class="section"><a href="ch11.html#section-javafx-unwrapper">11.13.2. JavaFX unwrapper</a></span></li><li><span class="section"><a href="ch11.html#_unwrapping_object_graphs">11.13.3. Unwrapping object graphs</a></span></li></ul></li><li><span class="section"><a href="ch11.html#section-constraint-definition-contribution">11.14. Providing constraint definitions</a></span><ul><li><span class="section"><a href="ch11.html#_constraint_definitions_via_literal_serviceloader_literal">11.14.1. Constraint definitions via <code class="literal">ServiceLoader</code></a></span></li><li><span class="section"><a href="ch11.html#section-programmatic-constraint-definition">11.14.2. Adding constraint definitions programmatically</a></span></li></ul></li><li><span class="section"><a href="ch11.html#section-constraint-customizing-class-loading">11.15. Customizing class-loading</a></span></li><li><span class="section"><a href="ch11.html#section-time-provider">11.16. Time providers for @Future and @Past</a></span></li></ul></div><p>In this chapter you will learn how to make use of several features provided by Hibernate Validator
in addition to the functionality defined by the Bean Validation specification. This includes the
fail fast mode, the API for programmatic constraint configuration and the boolean composition of
constraints.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Using the features described in the following sections may result in application code which is not
portable between Bean Validation providers.</p></div><section class="section" id="_public_api"><div class="titlepage"><div><div><h2 class="title">11.1. Public API</h2></div></div></div><p>Let’s start, however, with a look at the public API of Hibernate Validator. <a class="xref" href="ch11.html#validator-public-api" title="Table 11.1. Hibernate Validator public API">Table 11.1, “Hibernate Validator public API”</a>
lists all packages belonging to this API and describes their purpose. Note that when a package is
part of the public this is not necessarily true for its sub-packages.</p><div class="table" id="validator-public-api"><div class="table-title">Table 11.1. Hibernate Validator public API</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Packages</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Description</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Classes used by the Bean Validation bootstrap mechanism
            (eg. validation provider, configuration class); For more details
            see <a class="xref" href="ch08.html" title="Chapter 8. Bootstrapping">Chapter 8, <em>Bootstrapping</em></a>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator.cfg</code>,
            <code class="literal">org.hibernate.validator.cfg.context</code>,
            <code class="literal">org.hibernate.validator.cfg.defs</code>,
            <code class="literal">org.hibernate.validator.spi.cfg</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Hibernate Validator’s fluent API for constraint
            declaration; In <code class="literal">org.hibernate.validator.cfg</code> you
            will find the <code class="literal">ConstraintMapping</code> interface,
            in <code class="literal">org.hibernate.validator.cfg.defs</code> all
            constraint definitions and in <code class="literal">org.hibernate.validator.spi.cfg</code> a
            callback for using the API for configuring the default validator factory.
            Refer to <a class="xref" href="ch11.html#section-programmatic-api" title="11.4. Programmatic constraint definition and declaration">Section 11.4, “Programmatic constraint definition and declaration”</a> for the details.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator.constraints</code>,
            <code class="literal">org.hibernate.validator.constraints.br</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Some useful custom constraints provided by Hibernate
            Validator in addition to the built-in constraints defined by the
            Bean Validation specification; The constraints are described in
            detail in <a class="xref" href="ch02.html#validator-defineconstraints-hv-constraints" title="2.3.2. Additional constraints">Section 2.3.2, “Additional constraints”</a>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator.constraintvalidation</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Extended constraint validator context which allows to set
            custom attributes for message interpolation. <a class="xref" href="ch11.html#section-hibernateconstraintvalidatorcontext" title="11.11.1. HibernateConstraintValidatorContext">Section 11.11.1, “<code class="literal">HibernateConstraintValidatorContext</code>”</a> describes
            how to make use of that feature.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator.group</code>,
            <code class="literal">org.hibernate.validator.spi.group</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>The group sequence provider feature which allows you to
            define dynamic default group sequences in function of the
            validated object state; The specifics can be found in <a class="xref" href="ch05.html#section-default-group-class" title="5.3. Redefining the default group sequence">Section 5.3, “Redefining the default group sequence”</a>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator.messageinterpolation</code>,
            <code class="literal">org.hibernate.validator.resourceloading</code>,
            <code class="literal">org.hibernate.validator.spi.resourceloading</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Classes related to constraint message interpolation; The
            first package contains Hibernate Validator’s default message
            interpolator,
            <code class="literal">ResourceBundleMessageInterpolator</code>. The
            latter two packages provide the
            <code class="literal">ResourceBundleLocator</code> SPI for the loading of resource
            bundles (see <a class="xref" href="ch04.html#section-resource-bundle-locator" title="4.2.1. ResourceBundleLocator">Section 4.2.1, “<code class="literal">ResourceBundleLocator</code>”</a>)
            and its default implementation.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator.parameternameprovider</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>A <code class="literal">ParameterNameProvider</code> based on the
            ParaNamer library, see <a class="xref" href="ch11.html#section-paranamer-parameternameprovider" title="11.12. ParaNamer based ParameterNameProvider">Section 11.12, “ParaNamer based <code class="literal">ParameterNameProvider</code>”</a>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator.propertypath</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Extensions to the <code class="literal">javax.validation.Path</code> API,
            see <a class="xref" href="ch11.html#section-extensions-path-api" title="11.7. Extensions of the Path API">Section 11.7, “Extensions of the Path API”</a>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator.spi.constraintdefinition</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>An SPI for registering additional constraint validators programmatically,
            see <a class="xref" href="ch11.html#section-constraint-definition-contribution" title="11.14. Providing constraint definitions">Section 11.14, “Providing constraint definitions”</a>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">org.hibernate.validator.spi.time</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>An SPI for customizing the retrieval of the current time when validating <code class="literal">@Future</code> and <code class="literal">@Past</code>,
            see <a class="xref" href="ch11.html#section-time-provider" title="11.16. Time providers for @Future and @Past">Section 11.16, “Time providers for @Future and @Past”</a>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p><code class="literal">org.hibernate.validator.valuehandling</code>, <code class="literal">org.hibernate.validator.spi.valuehandling</code></p></td><td style="text-align: left; vertical-align: top; "><p>Classes related to the processing
            of values prior to thei validation, see <a class="xref" href="ch11.html#section-value-handling" title="11.13. Unwrapping values">Section 11.13, “Unwrapping values”</a>.</p></td></tr></tbody></table></div></div><br class="table-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The public packages of Hibernate Validator fall into two categories: while the actual API parts are
intended to be <span class="emphasis"><em>invoked</em></span> or <span class="emphasis"><em>used</em></span> by clients (e.g. the API for programmatic constraint declaration
or the custom constraints), the SPI (service provider interface) packages contain interfaces which
are intended to be <span class="emphasis"><em>implemented</em></span> by clients (e.g. <code class="literal">ResourceBundleLocator</code>).</p></div><p>Any packages not listed in that table are internal packages of Hibernate Validator and are not
intended to be accessed by clients. The contents of these internal packages can change from release
to release without notice, thus possibly breaking any client code relying on it.</p></section><section class="section" id="section-fail-fast"><div class="titlepage"><div><div><h2 class="title">11.2. Fail fast mode</h2></div></div></div><p>Using the fail fast mode, Hibernate Validator allows to return from the current validation as soon
as the first constraint violation occurs. This can be useful for the validation of large object
graphs where you are only interested in a quick check whether there is any constraint violation at
all.</p><p><a class="xref" href="ch11.html#example-using-fail-fast" title="Example 11.1. Using the fail fast validation mode">Example 11.1, “Using the fail fast validation mode”</a> shows how to bootstrap and use a fail fast enabled validator.</p><div class="example" id="example-using-fail-fast"><div class="example-title">Example 11.1. Using the fail fast validation mode</div><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter11.failfast;

public class Car {

	@NotNull
	private String manufacturer;

	@AssertTrue
	private boolean isRegistered;

	public Car(String manufacturer, boolean isRegistered) {
		this.manufacturer = manufacturer;
		this.isRegistered = isRegistered;
	}

	//getters and setters...
}</code></pre><pre><code class="language-java">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.failFast( true )
		.buildValidatorFactory()
		.getValidator();

Car car = new Car( null, false );

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );</code></pre></div></div><br class="example-break"/><p>Here the validated object actually fails to satisfy both the constraints declared on the <code class="literal">Car</code> class,
yet the validation call yields only one <code class="literal">ConstraintViolation</code> since the fail fast mode is enabled.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>There is no guarantee in which order the constraints are evaluated, i.e. it is not deterministic
whether the returned violation originates from the <code class="literal">@NotNull</code> or the <code class="literal">@AssertTrue</code> constraint. If
required, a deterministic evaluation order can be enforced using group sequences as described in
<a class="xref" href="ch05.html#section-defining-group-sequences" title="5.2. Defining group sequences">Section 5.2, “Defining group sequences”</a>.</p></div><p>Refer to <a class="xref" href="ch08.html#section-provider-specific-settings" title="8.2.6. Provider-specific settings">Section 8.2.6, “Provider-specific settings”</a> to learn about the different ways of enabling the
fail fast mode when bootstrapping a validator.</p></section><section class="section" id="section-method-validation-prerequisite-relaxation"><div class="titlepage"><div><div><h2 class="title">11.3. Relaxation of requirements for method validation in class hierarchies</h2></div></div></div><p>The Bean Validation specification defines a set of preconditions which apply when defining
constraints on methods within class hierarchies. These preconditions are defined in
<a class="link" href="http://beanvalidation.org/1.1/spec/#constraintdeclarationvalidationprocess-methodlevelconstraints-inheritance">section 4.5.5</a>
of the Bean Validation 1.1 specification. See also <a class="xref" href="ch03.html#section-method-constraints-inheritance-hierarchies" title="3.1.4. Method constraints in inheritance hierarchies">Section 3.1.4, “Method constraints in inheritance hierarchies”</a>
in this guide.</p><p>As per specification a Bean Validation provider is allowed to relax these preconditions.
With Hibernate Validator you can do this in one of two ways.</p><p>First you can use the configuration properties <span class="emphasis"><em>hibernate.validator.allow_parameter_constraint_override</em></span>,
<span class="emphasis"><em>hibernate.validator.allow_multiple_cascaded_validation_on_result</em></span> and
<span class="emphasis"><em>hibernate.validator.allow_parallel_method_parameter_constraint</em></span> in <span class="emphasis"><em>validation.xml</em></span>. See example
<a class="xref" href="ch11.html#example-relaxing-method-validation-xml" title="Example 11.2. Configuring method validation behaviour in class hierarchies via properties">Example 11.2, “Configuring method validation behaviour in class hierarchies via properties”</a>.</p><div class="example" id="example-relaxing-method-validation-xml"><div class="example-title">Example 11.2. Configuring method validation behaviour in class hierarchies via properties</div><div class="example-contents"><pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;validation-config
        xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/configuration validation-configuration-1.0.xsd"&gt;
    &lt;default-provider&gt;org.hibernate.validator.HibernateValidator&lt;/default-provider&gt;

    &lt;property name="hibernate.validator.allow_parameter_constraint_override"&gt;true&lt;/property&gt;
    &lt;property name="hibernate.validator.allow_multiple_cascaded_validation_on_result"&gt;true&lt;/property&gt;
    &lt;property name="hibernate.validator.allow_parallel_method_parameter_constraint"&gt;true&lt;/property&gt;
&lt;/validation-config&gt;</code></pre></div></div><br class="example-break"/><p>Alternatively these settings can be applied during programmatic bootstrapping.</p><div class="example" id="example-relaxing-method-validation"><div class="example-title">Example 11.3. Configuring method validation behaviour in class hierarchies</div><div class="example-contents"><pre><code class="language-java">HibernateValidatorConfiguration configuration = Validation.byProvider(HibernateValidator.class).configure();

configuration.allowMultipleCascadedValidationOnReturnValues(true)
    .allowOverridingMethodAlterParameterConstraint(true)
    .allowParallelMethodsDefineParameterConstraints(true);</code></pre></div></div><br class="example-break"/><p>By default, all of these properties are false, implementing the default behavior as defined in the
Bean Validation specification.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>Changing the default behaviour for method validation will result in non specification conform and non
portable application. Make sure to understand what you are doing and that your use case really
requires changes to the default behaviour.</p></div></section><section class="section" id="section-programmatic-api"><div class="titlepage"><div><div><h2 class="title">11.4. Programmatic constraint definition and declaration</h2></div></div></div><p>As per the Bean Validation specification, you can define and declare constraints using Java annotations and XML
based constraint mappings.</p><p>In addition, Hibernate Validator provides a fluent API which allows for the programmatic
configuration of constraints. Use cases include the dynamic addition of constraints at runtime
depending on some application state or tests where you need entities with different constraints in
different scenarios but don’t want to implement actual Java classes for each test case.</p><p>By default, constraints added via the fluent API are additive to constraints configured via the
standard configuration capabilities. But it is also possible to ignore annotation and XML configured
constraints where required.</p><p>The API is centered around the <code class="literal">ConstraintMapping</code> interface. You obtain a new mapping via
<code class="literal">HibernateValidatorConfiguration#createConstraintMapping()</code> which you then can configure in a fluent
manner as shown in <a class="xref" href="ch11.html#example-constraint-mapping" title="Example 11.4. Programmatic constraint declaration">Example 11.4, “Programmatic constraint declaration”</a>.</p><div class="example" id="example-constraint-mapping"><div class="example-title">Example 11.4. Programmatic constraint declaration</div><div class="example-contents"><pre><code class="language-java">HibernateValidatorConfiguration configuration = Validation
		.byProvider( HibernateValidator.class )
		.configure();

ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.property( "manufacturer", FIELD )
			.constraint( new NotNullDef() )
		.property( "licensePlate", FIELD )
			.ignoreAnnotations()
			.constraint( new NotNullDef() )
			.constraint( new SizeDef().min( 2 ).max( 14 ) )
	.type( RentalCar.class )
		.property( "rentalStation", METHOD )
			.constraint( new NotNullDef() );

Validator validator = configuration.addMapping( constraintMapping )
		.buildValidatorFactory()
		.getValidator();</code></pre></div></div><br class="example-break"/><p>Constraints can be configured on multiple classes and properties using method chaining. The
constraint definition classes <code class="literal">NotNullDef</code> and SizeDef are helper classes which allow to configure
constraint parameters in a type-safe fashion. Definition classes exist for all built-in constraints
in the <code class="literal">org.hibernate.validator.cfg.defs</code> package. By calling <code class="literal">ignoreAnnotations()</code> any constraints
configured via annotations or XML are ignored for the given element.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Each element (type, property, method etc.) may only be configured once within all the constraint
mappings used to set up one validator factory. Otherwise a <code class="literal">ValidationException</code> is raised.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>It is not supported to add constraints to non-overridden supertype properties and methods by
configuring a subtype. Instead you need to configure the supertype in this case.</p></div><p>Having configured the mapping, you must add it back to the configuration object from which you then
can obtain a validator factory.</p><p>For custom constraints you can either create your own definition classes extending <code class="literal">ConstraintDef</code> or
you can use <code class="literal">GenericConstraintDef</code> as seen in <a class="xref" href="ch11.html#example-generic-constraint-mapping" title="Example 11.5. Programmatic declaration of a custom constraint">Example 11.5, “Programmatic declaration of a custom constraint”</a>.</p><div class="example" id="example-generic-constraint-mapping"><div class="example-title">Example 11.5. Programmatic declaration of a custom constraint</div><div class="example-contents"><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.property( "licensePlate", FIELD )
			.constraint( new GenericConstraintDef&lt;CheckCase&gt;( CheckCase.class )
				.param( "value", CaseMode.UPPER )
			);</code></pre></div></div><br class="example-break"/><p>By invoking <code class="literal">valid()</code> you can mark a member for cascaded validation which is equivalent to annotating
it with <code class="literal">@Valid</code>. Configure any group conversions to be applied during cascaded validation using the
<code class="literal">convertGroup()</code> method (equivalent to <code class="literal">@ConvertGroup</code>). An example can be seen in
<a class="xref" href="ch11.html#example-cascading-constraints" title="Example 11.6. Marking a property for cascaded validation">Example 11.6, “Marking a property for cascaded validation”</a>.</p><div class="example" id="example-cascading-constraints"><div class="example-title">Example 11.6. Marking a property for cascaded validation</div><div class="example-contents"><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.property( "driver", FIELD )
			.constraint( new NotNullDef() )
			.valid()
			.convertGroup( Default.class ).to( PersonDefault.class )
	.type( Person.class )
		.property( "name", FIELD )
			.constraint( new NotNullDef().groups( PersonDefault.class ) );</code></pre></div></div><br class="example-break"/><p>You can not only configure bean constraints using the fluent API but also method and constructor
constraints. As shown in <a class="xref" href="ch11.html#example-method-constraint-mapping" title="Example 11.7. Programmatic declaration of method and constructor constraints">Example 11.7, “Programmatic declaration of method and constructor constraints”</a> constructors are identified by their
parameter types and methods by their name and parameter types. Having selected a method or
constructor, you can mark its parameters and/or return value for cascaded validation and add
constraints as well as cross-parameter constraints.</p><div class="example" id="example-method-constraint-mapping"><div class="example-title">Example 11.7. Programmatic declaration of method and constructor constraints</div><div class="example-contents"><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.constructor( String.class )
			.parameter( 0 )
				.constraint( new SizeDef().min( 3 ).max( 50 ) )
			.returnValue()
				.valid()
		.method( "drive", int.class )
			.parameter( 0 )
				.constraint( new MaxDef().value( 75 ) )
		.method( "load", List.class, List.class )
			.crossParameter()
				.constraint( new GenericConstraintDef&lt;LuggageCountMatchesPassengerCount&gt;(
						LuggageCountMatchesPassengerCount.class ).param(
							"piecesOfLuggagePerPassenger", 2
						)
				)
		.method( "getDriver" )
			.returnValue()
				.constraint( new NotNullDef() )
				.valid();</code></pre></div></div><br class="example-break"/><p>Last but not least you can configure the default group sequence or the default group sequence
provider of a type as shown in the following example.</p><div class="example" id="example-sequences"><div class="example-title">Example 11.8. Configuration of default group sequence and default group sequence provider</div><div class="example-contents"><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
	.type( Car.class )
		.defaultGroupSequence( Car.class, CarChecks.class )
	.type( RentalCar.class )
		.defaultGroupSequenceProviderClass( RentalCarGroupSequenceProvider.class );</code></pre></div></div><br class="example-break"/></section><section class="section" id="section-programmatic-api-contributor"><div class="titlepage"><div><div><h2 class="title">11.5. Applying programmatic constraint declarations to the default validator factory</h2></div></div></div><p>If you are not bootstrapping a validator factory manually
but work with the default factory as configured via <span class="emphasis"><em>META-INF/validation.xml</em></span>
(see <a class="xref" href="ch07.html" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>),
you can add one or more constraint mappings by creating one or several constraint mapping contributors.
To do so, implement the <code class="literal">ConstraintMappingContributor</code> contract:</p><div class="example" id="example-constraint-mapping-contributor"><div class="example-title">Example 11.9. Custom <code class="literal">ConstraintMappingContributor</code> implementation</div><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter11.constraintapi;

public class MyConstraintMappingContributor implements ConstraintMappingContributor {

	@Override
	public void createConstraintMappings(ConstraintMappingBuilder builder) {
		builder.addConstraintMapping()
			.type( Marathon.class )
				.property( "name", METHOD )
					.constraint( new NotNullDef() )
				.property( "numberOfHelpers", FIELD )
					.constraint( new MinDef().value( 1 ) );

		builder.addConstraintMapping()
			.type( Runner.class )
				.property( "paidEntryFee", FIELD )
					.constraint( new AssertTrueDef() );
	}
}</code></pre></div></div><br class="example-break"/><p>You then need to specify the fully-qualified class name of the contributor implementation in <span class="emphasis"><em>META-INF/validation.xml</em></span>,
using the property key <code class="literal">hibernate.validator.constraint_mapping_contributors</code>. You can specify several
contributors by separating them with a comma.</p></section><section class="section" id="section-advanced-constraint-composition"><div class="titlepage"><div><div><h2 class="title">11.6. Advanced constraint composition features</h2></div></div></div><section class="section" id="_validation_target_specification_for_purely_composed_constraints"><div class="titlepage"><div><div><h3 class="title">11.6.1. Validation target specification for purely composed constraints</h3></div></div></div><p>In case you specify a purely composed constraint - i.e. a constraint which has no validator itself but is solely made
up from other, composing constraints - on a method declaration, the validation engine cannot determine whether that
constraint is to be applied as a return value constraint or as a cross-parameter constraint.</p><p>Hibernate Validator allows to resolve such ambiguities by specifying the <code class="literal">@SupportedValidationTarget</code> annotation on the
declaration of the composed constraint type as shown in <a class="xref" href="ch11.html#example-purely-composed-constraint-validation-target" title="Example 11.10. Specifying the validation target of a purely composed constraint">Example 11.10, “Specifying the validation target of a purely composed constraint”</a>.
The <code class="literal">@ValidInvoiceAmount</code> does not declare any validator, but it is solely composed by the <code class="literal">@Min</code> and <code class="literal">@NotNull</code>
constraints. The <code class="literal">@SupportedValidationTarget</code> ensures that the constraint is applied to the method return value when
given on a method declaration.</p><div class="example" id="example-purely-composed-constraint-validation-target"><div class="example-title">Example 11.10. Specifying the validation target of a purely composed constraint</div><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter11.purelycomposed;

@Min(value = 0)
@NotNull
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
@SupportedValidationTarget(ValidationTarget.ANNOTATED_ELEMENT)
@ReportAsSingleViolation
public @interface ValidInvoiceAmount {

	String message() default "{org.hibernate.validator.referenceguide.chapter11.purelycomposed."
			+ "ValidInvoiceAmount.message}";

	Class&lt;?&gt;[] groups() default {};

	Class&lt;? extends Payload&gt;[] payload() default {};

	@OverridesAttribute(constraint = Min.class, name = "value")
	long value();
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="section-boolean-constraint-composition"><div class="titlepage"><div><div><h3 class="title">11.6.2. Boolean composition of constraints</h3></div></div></div><p>Bean Validation specifies that the constraints of a composed constraint (see
<a class="xref" href="ch06.html#section-constraint-composition" title="6.4. Constraint composition">Section 6.4, “Constraint composition”</a>) are all combined via a logical <span class="emphasis"><em>AND</em></span>. This means all of the
composing constraints need to return true in order for an overall successful validation.</p><p>Hibernate Validator offers an extension to this and allows you to compose constraints via a logical
<span class="emphasis"><em>OR</em></span> or <span class="emphasis"><em>NOT</em></span>. To do so you have to use the ConstraintComposition annotation and the enum
CompositionType with its values <span class="emphasis"><em>AND</em></span>, <span class="emphasis"><em>OR</em></span> and <span class="emphasis"><em>ALL_FALSE</em></span>.</p><p><a class="xref" href="ch11.html#example-boolean-constraint-composition" title="Example 11.11. OR composition of constraints">Example 11.11, “OR composition of constraints”</a> shows how to build a composed constraint <code class="literal">@PatternOrSize</code>
where only one of the composing constraints needs to be valid in order to pass the validation.
Either the validated string is all lower-cased or it is between two and three characters long.</p><div class="example" id="example-boolean-constraint-composition"><div class="example-title">Example 11.11. OR composition of constraints</div><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter11.booleancomposition;

@ConstraintComposition(OR)
@Pattern(regexp = "[a-z]")
@Size(min = 2, max = 3)
@ReportAsSingleViolation
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
@Constraint(validatedBy = { })
public @interface PatternOrSize {
	String message() default "{org.hibernate.validator.referenceguide.chapter11." +
			"booleancomposition.PatternOrSize.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Using <span class="emphasis"><em>ALL_FALSE</em></span> as composition type implicitly enforces that only a single violation will get
reported in case validation of the constraint composition fails.</p></div></section></section><section class="section" id="section-extensions-path-api"><div class="titlepage"><div><div><h2 class="title">11.7. Extensions of the Path API</h2></div></div></div><p>Hibernate Validator provides an extension to the <code class="literal">javax.validation.Path</code> API.
For nodes of <code class="literal">ElementKind.PROPERTY</code> it allows to obtain the value of the represented property.
To do so, narrow down a given node to the type <code class="literal">org.hibernate.validator.path.PropertyNode</code> using <code class="literal">Node#as()</code>, as shown in the following example:</p><div class="example" id="example-property-node-get-value"><div class="example-title">Example 11.12. Getting the value from property nodes</div><div class="example-contents"><pre><code class="language-java">Building building = new Building();

// Assume the name of the person violates a @Size constraint
Person bob = new Person( "Bob" );
Apartment bobsApartment = new Apartment( bob );
building.getApartments().add( bobsApartment );

Set&lt;ConstraintViolation&lt;Building&gt;&gt; constraintViolations = validator.validate( building );

Path path = constraintViolations.iterator().next().getPropertyPath();
Iterator&lt;Path.Node&gt; nodeIterator = path.iterator();

Path.Node node = nodeIterator.next();
assertEquals( node.getName(), "apartments" );
assertSame( node.as( PropertyNode.class ).getValue(), bobsApartment );

node = nodeIterator.next();
assertEquals( node.getName(), "resident" );
assertSame( node.as( PropertyNode.class ).getValue(), bob );

node = nodeIterator.next();
assertEquals( node.getName(), "name" );
assertEquals( node.as( PropertyNode.class ).getValue(), "Bob" );</code></pre></div></div><br class="example-break"/><p>This is specifically useful to obtain the element of <code class="literal">Set</code> properties on the property path (e.g. <code class="literal">apartments</code> in the example) which otherwise could not be identified (unlike for <code class="literal">Map</code> and <code class="literal">List</code>, there is no key nor index in this case).</p></section><section class="section" id="section-dynamic-payload"><div class="titlepage"><div><div><h2 class="title">11.8. Dynamic payload as part of ConstraintViolation</h2></div></div></div><p>In some cases automatic processing of violations can be aided, if the constraint violation provides additional
data - a so called dynamic payload. This dynamic payload could for example contain hints to the user on how to
resolve the violation.</p><p>Dynamic payloads can be set in <a class="link" href="ch06.html" title="Chapter 6. Creating custom constraints">custom constraints</a> using <code class="literal">HibernateConstraintValidatorContext</code>.
This is shown in example <a class="xref" href="ch11.html#example-constraint-validator-setting-dynamic-payload" title="Example 11.13. ConstraintValidator implementation setting a dynamic payload">Example 11.13, “ConstraintValidator implementation setting a dynamic payload”</a> where the
<code class="literal">javax.validation.ConstraintValidatorContext</code> is unwrapped to <code class="literal">HibernateConstraintValidatorContext</code> in order to call
<code class="literal">withDynamicPayload</code>.</p><div class="example" id="example-constraint-validator-setting-dynamic-payload"><div class="example-title">Example 11.13. ConstraintValidator implementation setting a dynamic payload</div><div class="example-contents"><pre><code class="language-java">public class ValidPassengerCountValidator implements ConstraintValidator&lt;ValidPassengerCount, Car&gt; {

	private static final Map&lt;Integer, String&gt; suggestedCars = newHashMap();

	static {
		suggestedCars.put( 2, "Chevrolet Corvette" );
		suggestedCars.put( 3, "Toyota Volta" );
		suggestedCars.put( 4, "Maserati GranCabrio" );
		suggestedCars.put( 5, " Mercedes-Benz E-Class" );
	}

	@Override
	public void initialize(ValidPassengerCount constraintAnnotation) {
	}

	@Override
	public boolean isValid(Car car, ConstraintValidatorContext context) {
		if ( car == null ) {
			return true;
		}

		int passangerCount = car.getPassengers().size();
		if ( car.getSeatCount() &gt;= passangerCount ) {
			return true;
		}
		else {

			if ( suggestedCars.containsKey( passangerCount ) ) {
				HibernateConstraintValidatorContext hibernateContext = context.unwrap(
						HibernateConstraintValidatorContext.class
				);
				hibernateContext.withDynamicPayload( suggestedCars.get( passangerCount ) );
			}
			return false;
		}
	}
}</code></pre></div></div><br class="example-break"/><p>On the constraint violation processing side, a <code class="literal">javax.validation.ConstraintViolation</code> can then in turn be
unwrapped to <code class="literal">HibernateConstraintViolation</code> in order to retrieve the dynamic payload for further processing.</p><div class="example" id="example-retrieving-dynamic-payload"><div class="example-title">Example 11.14. Retrieval of a ConstraintViolations’s dynamic payload</div><div class="example-contents"><pre><code class="language-java">@Test
public void testDynamicPayloadAddedToConstraintViolation() throws Exception {
	Car car = new Car( 2 );
	car.addPassenger( new Person() );
	car.addPassenger( new Person() );
	car.addPassenger( new Person() );
	Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

	assertEquals( 1, constraintViolations.size() );

	ConstraintViolation&lt;Car&gt; constraintViolation = constraintViolations.iterator().next();
	@SuppressWarnings("unchecked")
	HibernateConstraintViolation&lt;Car&gt; hibernateConstraintViolation = constraintViolation.unwrap(
			HibernateConstraintViolation.class
	);
	String suggestedCar = hibernateConstraintViolation.getDynamicPayload( String.class );
	assertEquals( "Toyota Volta", suggestedCar );
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="non-el-message-interpolator"><div class="titlepage"><div><div><h2 class="title">11.9. <code class="literal">ParameterMessageInterpolator</code></h2></div></div></div><p>Hibernate Validator requires per default an implementation of the Unified EL (see
<a class="xref" href="ch01.html#validator-gettingstarted-uel" title="1.1.1. Unified EL">Section 1.1.1, “Unified EL”</a>) to be available. This is needed to allow the interpolation
of constraint error messages using EL expressions as defined by Bean Validation 1.1.</p><p>For environments where you cannot or do not want to provide an EL implementation, Hibernate Validators
offers a non EL based message interpolator - <code class="literal">org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator</code>.</p><p>Refer to <a class="xref" href="ch04.html#section-custom-message-interpolation" title="4.2. Custom message interpolation">Section 4.2, “Custom message interpolation”</a> to see how to plug in custom message interpolator
implementations.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>Constraint messages containing EL expressions will be returned un-interpolated by
<code class="literal">org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator</code>. This also affects
built-in default constraint messages which use EL expressions. At the moment <code class="literal">DecimalMin</code> and <code class="literal">DecimalMax</code> are affected.</p></div></section><section class="section" id="__literal_resourcebundlelocator_literal"><div class="titlepage"><div><div><h2 class="title">11.10. <code class="literal">ResourceBundleLocator</code></h2></div></div></div><p>With <code class="literal">ResourceBundleLocator</code>, Hibernate Validator provides an additional SPI which allows to retrieve
error messages from other resource bundles than <span class="emphasis"><em>ValidationMessages</em></span> while still using the actual
interpolation algorithm as defined by the specification. Refer to
<a class="xref" href="ch04.html#section-resource-bundle-locator" title="4.2.1. ResourceBundleLocator">Section 4.2.1, “<code class="literal">ResourceBundleLocator</code>”</a> to learn how to make use of that SPI.</p></section><section class="section" id="_custom_contexts"><div class="titlepage"><div><div><h2 class="title">11.11. Custom contexts</h2></div></div></div><p>The Bean Validation specification offers at several points in its API the possibility to unwrap a
given interface to a implementor specific subtype. In the case of constraint violation creation in
<code class="literal">ConstraintValidator</code> implementations as well as message interpolation in <code class="literal">MessageInterpolator</code>
instances, there exist <code class="literal">unwrap()</code> methods for the provided context instances -
<code class="literal">ConstraintValidatorContext</code> respectively <code class="literal">MessageInterpolatorContext</code>. Hibernate Validator provides
custom extensions for both of these interfaces.</p><section class="section" id="section-hibernateconstraintvalidatorcontext"><div class="titlepage"><div><div><h3 class="title">11.11.1. <code class="literal">HibernateConstraintValidatorContext</code></h3></div></div></div><p id="section-custom-constraint-validator-context"><code class="literal">HibernateConstraintValidatorContext</code> is a subtype of <code class="literal">ConstraintValidatorContext</code> which allows you to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">set arbitrary parameters for interpolation via the Expression Language message interpolation
facility using <code class="literal">HibernateConstraintValidatorContext#addExpressionVariable(String, Object)</code>.
For an example refer to <a class="xref" href="ch11.html#example-custom-message-parameter" title="Example 11.15. Custom @Future validator with message parameters">Example 11.15, “Custom @Future validator with message parameters”</a>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Note that the parameters specified via <code class="literal">addExpressionVariable(String, Object)</code> are global and apply
for all constraint violations created by this <code class="literal">isValid()</code> invocation. This includes the default
constraint violation, but also all violations created by the <code class="literal">ConstraintViolationBuilder</code>. You can,
however, update the parameters between invocations of
<code class="literal">ConstraintViolationBuilder#addConstraintViolation()</code>.</p></div></li><li class="listitem"><p class="simpara">obtain the <code class="literal">TimeProvider</code> for getting the current time when validating <code class="literal">@Future</code> and <code class="literal">@Past</code> constraints
(see also <a class="xref" href="ch11.html#section-time-provider" title="11.16. Time providers for @Future and @Past">Section 11.16, “Time providers for @Future and @Past”</a>).</p><p class="simpara">This is useful if you want to customize the message of the <code class="literal">@Future</code> constraint.
By default the message is just "must be in the future". <a class="xref" href="ch11.html#example-custom-message-parameter" title="Example 11.15. Custom @Future validator with message parameters">Example 11.15, “Custom @Future validator with message parameters”</a> shows
how to include the current date in order to make the message more explicit.</p><div class="example" id="example-custom-message-parameter"><div class="example-title">Example 11.15. Custom @Future validator with message parameters</div><div class="example-contents"><pre><code class="language-java">public class MyFutureValidator implements ConstraintValidator&lt;Future, Date&gt; {

	@Override
	public void initialize(Future constraintAnnotation) {
	}

	@Override
	public boolean isValid(Date value, ConstraintValidatorContext context) {
		if ( value == null ) {
			return true;
		}

		HibernateConstraintValidatorContext hibernateContext = context.unwrap(
				HibernateConstraintValidatorContext.class
		);

		Date now = new Date( hibernateContext.getTimeProvider().getCurrentTime() );

		if ( !value.after( now ) ) {
			hibernateContext.disableDefaultConstraintViolation();
			hibernateContext.addExpressionVariable( "now", now )
					.buildConstraintViolationWithTemplate( "Must be after ${now}" )
					.addConstraintViolation();

			return false;
		}

		return true;
	}
}</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>This functionality is currently experimental and might change in future versions.</p></div></li><li class="listitem">set an arbitrary dynamic payload - see <a class="xref" href="ch11.html#section-dynamic-payload" title="11.8. Dynamic payload as part of ConstraintViolation">Section 11.8, “Dynamic payload as part of ConstraintViolation”</a></li></ul></div></section><section class="section" id="__literal_hibernatemessageinterpolatorcontext_literal"><div class="titlepage"><div><div><h3 class="title">11.11.2. <code class="literal">HibernateMessageInterpolatorContext</code></h3></div></div></div><p>Hibernate Validator also offers a custom extension of <code class="literal">MessageInterpolatorContext</code>, namely
<code class="literal">HibernateMessageInterpolatorContext</code> (see <a class="xref" href="ch11.html#example-custom-message-interpolator-context" title="Example 11.16. HibernateMessageInterpolatorContext">Example 11.16, “<code class="literal">HibernateMessageInterpolatorContext</code>”</a>). This
subtype was introduced to allow a better integration of Hibernate Validator into the Glassfish. The
root bean type was in this case needed to determine the right classloader for the message resource
bundle. If you have any other usecases, let us know.</p><div class="example" id="example-custom-message-interpolator-context"><div class="example-title">Example 11.16. <code class="literal">HibernateMessageInterpolatorContext</code></div><div class="example-contents"><pre><code class="language-java">public interface HibernateMessageInterpolatorContext extends MessageInterpolator.Context {

	/**
	 * Returns the currently validated root bean type.
	 *
	 * @return The currently validated root bean type.
	 */
	Class&lt;?&gt; getRootBeanType();
}</code></pre></div></div><br class="example-break"/></section></section><section class="section" id="section-paranamer-parameternameprovider"><div class="titlepage"><div><div><h2 class="title">11.12. ParaNamer based <code class="literal">ParameterNameProvider</code></h2></div></div></div><p>Hibernate Validator comes with a <code class="literal">ParameterNameProvider</code> implementation which leverages the
<a class="link" href="http://paranamer.codehaus.org/">ParaNamer</a> library.</p><p>This library provides several ways for obtaining parameter names at runtime, e.g. based on debug
symbols created by the Java compiler, constants with the parameter names woven into the bytecode in
a post-compile step or annotations such as the <code class="literal">@Named</code> annotation from JSR 330.</p><p>In order to use <code class="literal">ParanamerParameterNameProvider</code>, either pass an instance when bootstrapping a
validator as shown in <a class="xref" href="ch08.html#example-using-custom-parameter-name-provider" title="Example 8.8. Using a custom ParameterNameProvider">Example 8.8, “Using a custom <code class="literal">ParameterNameProvider</code>”</a> or specify
<code class="literal">org.hibernate.validator.parameternameprovider.ParanamerParameterNameProvider</code> as value for the
<code class="literal">&lt;parameter-name-provider&gt;</code> element in the <span class="emphasis"><em>META-INF/validation.xml</em></span> file.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>When using this parameter name provider, you need to add the ParaNamer library to your classpath. It
is available in the Maven Central repository with the group id <code class="literal">com.thoughtworks.paranamer</code> and the
artifact id <code class="literal">paranamer</code>.</p></div><p>By default <code class="literal">ParanamerParameterNameProvider</code> retrieves parameter names from constants added to the byte
code at build time (via <code class="literal">DefaultParanamer</code>) and debug symbols (via <code class="literal">BytecodeReadingParanamer</code>).
Alternatively you can specify a <code class="literal">Paranamer</code> implementation of your choice when creating a
<code class="literal">ParanamerParameterNameProvider</code> instance.</p></section><section class="section" id="section-value-handling"><div class="titlepage"><div><div><h2 class="title">11.13. Unwrapping values</h2></div></div></div><p>Sometimes it is required to unwrap values prior to validating them. For example, in
<a class="xref" href="ch11.html#example-using-unwrapvalidatedvalue" title="Example 11.17. Applying a constraint to wrapped value of a JavaFX property">Example 11.17, “Applying a constraint to wrapped value of a JavaFX property”</a> a <a class="link" href="http://docs.oracle.com/javafx/">JavaFX</a> property type
is used to define an element of a domain model. The <code class="literal">@Size</code> constraint is meant to be applied to the
string value not the wrapping <code class="literal">Property</code> instance.</p><div class="example" id="example-using-unwrapvalidatedvalue"><div class="example-title">Example 11.17. Applying a constraint to wrapped value of a JavaFX property</div><div class="example-contents"><pre><code class="language-java">@Size(min = 3)
private Property&lt;String&gt; name = new SimpleStringProperty( "Bob" );</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The concept of value unwrapping is considered experimental at this time and may evolve into more
general means of value handling in future releases. Please let us know about your use cases for such
functionality.</p></div><p>Bean properties in JavaFX are typically not of simple data types like <code class="literal">String</code> or <code class="literal">int</code>, but are
wrapped in <code class="literal">Property</code> types which allows to make them observable, use them for data binding etc. When
applying a constraint such as <code class="literal">@Size</code> to an element of type <code class="literal">Property&lt;String&gt;</code> without further
preparation, an exception would be raised, indicating that no suitable validator for that constraint
and data type can be found. Thus the validated value must be unwrapped from the containing property
object before looking up a validator and invoking it.</p><p>For unwrapping to occur a <code class="literal">ValidatedValueUnwrapper</code> needs to be registered for the type
requiring unwrapping. Example <a class="xref" href="ch11.html#example-implementation-of-validatedvalueunwrapper" title="Example 11.18. Implementing the ValidatedValueUnwrapper interface">Example 11.18, “Implementing the ValidatedValueUnwrapper interface”</a> shows how this
schematically looks for a JavaFX <code class="literal">PropertyValueUnwrapper</code>. You just need to extend the SPI class
<code class="literal">ValidatedValueUnwrapper</code> and implement its abstract methods.</p><div class="example" id="example-implementation-of-validatedvalueunwrapper"><div class="example-title">Example 11.18. Implementing the ValidatedValueUnwrapper interface</div><div class="example-contents"><pre><code class="language-java">public class PropertyValueUnwrapper extends ValidatedValueUnwrapper&lt;Property&lt;?&gt;&gt; {

	@Override
	public Object handleValidatedValue(Property&lt;?&gt; value) {
		//...
	}

	@Override
	public Type getValidatedValueType(Type valueType) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The <code class="literal">ValidatedValueUnwrapper</code> needs also to be registered with the <code class="literal">ValidatorFactory</code>:</p><div class="example" id="example-registering-validatedvalueunwrapper"><div class="example-title">Example 11.19. Registering a ValidatedValueUnwrapper</div><div class="example-contents"><pre><code class="language-java">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.addValidatedValueHandler( new PropertyValueUnwrapper() )
		.buildValidatorFactory()
		.getValidator();</code></pre></div></div><br class="example-break"/><p>Several unwrapper implementations can be registered. During constraint validator resolution
Hibernate Validator automatically checks whether a <code class="literal">ValidatedValueUnwrapper</code> exists for the validated
value. If so, unwrapping occurs automatically. In some cases, however, constraint validator instances
for a given constraint might exist for the wrapper as well as the wrapped value (<code class="literal">@NotNull</code> for example
applies to all objects). In this case Hibernate Validator needs to be explicitly told which value
to validate. This can be done via <code class="literal">@UnwrapValidatedValue(true)</code> respectively
<code class="literal">@UnwrapValidatedValue(false)</code>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Note that it is not specified which of the unwrapper implementations is
chosen when more than one implementation is suitable to unwrap a given element.</p></div><p>Instead of programmatically registering <code class="literal">ValidatedValueUnwrapper</code> types, the fully-qualified names
of one ore more unwrapper implementations can be specified
via the configuration property <code class="literal">hibernate.validator.validated_value_handlers</code> which can be useful when
configuring the default validator factory using the descriptor <span class="emphasis"><em>META-INF/validation.xml</em></span> (see
<a class="xref" href="ch07.html" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>).</p><section class="section" id="section-optional-unwrapper"><div class="titlepage"><div><div><h3 class="title">11.13.1. Optional unwrapper</h3></div></div></div><p>Hibernate Validator provides built-in unwrapping for <code class="literal">Optional</code> introduced in Java 8.
The unwrapper is registered automatically in Java 8 environments, and no further configuration is
required. An example of unwrapping an <code class="literal">Optional</code> instance is shown in
<a class="xref" href="ch11.html#example-using-unwrapvalidatedvalue-and-optional" title="Example 11.20. Unwrapping Optional instances">Example 11.20, “Unwrapping <code class="literal">Optional</code> instances”</a>.</p><div class="example" id="example-using-unwrapvalidatedvalue-and-optional"><div class="example-title">Example 11.20. Unwrapping <code class="literal">Optional</code> instances</div><div class="example-contents"><pre><code class="language-java">@Size(min = 3)
private Optional&lt;String&gt; firstName = Optional.of( "John" );

@NotNull
@UnwrapValidatedValue // UnwrapValidatedValue required since otherwise unclear which value to validate
private Optional&lt;String&gt; lastName = Optional.of( "Doe" );</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p><code class="literal">Optional.empty()</code> is treated as <code class="literal">null</code> during validation. This means that for constraints where
<code class="literal">null</code> is considered valid, <code class="literal">Optional.empty()</code> is similarly valid.</p></div></section><section class="section" id="section-javafx-unwrapper"><div class="titlepage"><div><div><h3 class="title">11.13.2. JavaFX unwrapper</h3></div></div></div><p>Hibernate Validator also provides built-in unwrapping for JavaFX property values. The unwrapper is
registered automatically for environments where JavaFX is present, and no further configuration is
required. <code class="literal">ObservableValue</code> and its sub-types are supported.
An example of some of the different ways in which <code class="literal">JavaFX</code> property values can be unwrapped is
shown in <a class="xref" href="ch11.html#example-using-unwrapvalidatedvalue-and-javafx" title="Example 11.21. Unwrapping JavaFX properties">Example 11.21, “Unwrapping <code class="literal">JavaFX</code> properties”</a>.</p><div class="example" id="example-using-unwrapvalidatedvalue-and-javafx"><div class="example-title">Example 11.21. Unwrapping <code class="literal">JavaFX</code> properties</div><div class="example-contents"><pre><code class="language-java">@Min(value = 3)
IntegerProperty integerProperty1 = new SimpleIntegerProperty( 4 );

@Min(value = 3)
Property&lt;Number&gt; integerProperty2 = new SimpleIntegerProperty( 4 );

@Min(value = 3)
ObservableValue&lt;Number&gt; integerProperty3 = new SimpleIntegerProperty( 4 );</code></pre></div></div><br class="example-break"/></section><section class="section" id="_unwrapping_object_graphs"><div class="titlepage"><div><div><h3 class="title">11.13.3. Unwrapping object graphs</h3></div></div></div><p>Unwrapping can also be used with object graphs (cascaded validation) as shown in
<a class="xref" href="ch11.html#example-using-unwrapvalidatedvalue-and-optional-with-valid" title="Example 11.22. Unwrapping Optional prior to cascaded validation via @Valid">Example 11.22, “Unwrapping <code class="literal">Optional</code> prior to cascaded validation via <code class="literal">@Valid</code>”</a>.
When validating the object holding the <code class="literal">Optional&lt;Person&gt;</code>, a cascaded validation of the <code class="literal">Person</code>
object would be performed.</p><div class="example" id="example-using-unwrapvalidatedvalue-and-optional-with-valid"><div class="example-title">Example 11.22. Unwrapping <code class="literal">Optional</code> prior to cascaded validation via <code class="literal">@Valid</code></div><div class="example-contents"><pre><code class="language-java">@Valid
private Optional&lt;Person&gt; person = Optional.of( new Person() );</code></pre><pre><code class="language-java">public class Person {
	@Size(min =3)
	private String name = "Bob";
}</code></pre></div></div><br class="example-break"/></section></section><section class="section" id="section-constraint-definition-contribution"><div class="titlepage"><div><div><h2 class="title">11.14. Providing constraint definitions</h2></div></div></div><p>Bean Validation allows to (re-)define constraint definitions via XML in its constraint mapping
files. See <a class="xref" href="ch07.html#section-mapping-xml-constraints" title="7.2. Mapping constraints via constraint-mappings">Section 7.2, “Mapping constraints via <code class="literal">constraint-mappings</code>”</a> for more information and <a class="xref" href="ch07.html#example-constraints-car" title="Example 7.2. Bean constraints configured via XML">Example 7.2, “Bean constraints configured via XML”</a>
for an example. While this approach is sufficient for many use cases,  it has it shortcomings
in others. Imagine for example a constraint library wanting to contribute constraint
definitions for custom types. This library could provide a mapping file with their library, but this
file still would need to be referenced by the user of the library. Luckily there are better ways.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The following concepts are considered experimental at this time. Let us know whether you find them
useful and whether they meet your needs.</p></div><section class="section" id="_constraint_definitions_via_literal_serviceloader_literal"><div class="titlepage"><div><div><h3 class="title">11.14.1. Constraint definitions via <code class="literal">ServiceLoader</code></h3></div></div></div><p>Hibernate Validator allows to utilize Java’s
<a class="link" href="http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html/">ServiceLoader</a>
mechanism to register additional constraint definitions. All you have to do is to add the file
<span class="emphasis"><em>javax.validation.ConstraintValidator</em></span> to <span class="emphasis"><em>META-INF/services</em></span>. In this service file you list the
fully qualified classnames of your constraint validator classes (one per line). Hibernate Validator
will automatically infer the constraint types they apply to.
See <a class="link" href="ch11.html#example-using-service-file-for-constraint-definitions" title="Example 11.23. META-INF/services/javax.validation.ConstraintValidator">Constraint definition via service file</a>
for an example.</p><div class="example" id="example-using-service-file-for-constraint-definitions"><div class="example-title">Example 11.23. <span class="emphasis"><em>META-INF/services/javax.validation.ConstraintValidator</em></span></div><div class="example-contents"><pre class="screen"># Assuming a custom constraint annotation @org.mycompany.CheckCase
org.mycompany.CheckCaseValidator</pre></div></div><br class="example-break"/><p>To contribute default messages for your custom constraints, place a file <span class="emphasis"><em>ContributorValidationMessages.properties</em></span>
and/or its locale-specific specializations at the root your JAR. Hibernate Validator will consider the
entries from all the bundles with this name found on the classpath in addition to those given in <span class="emphasis"><em>ValidationMessages.properties</em></span>.</p><p>This mechanism is also helpful when creating large multi-module applications: Instead of putting all the constraint
messages into one single bundle, you can have one resource bundle per module containing only those messages of that module.</p></section><section class="section" id="section-programmatic-constraint-definition"><div class="titlepage"><div><div><h3 class="title">11.14.2. Adding constraint definitions programmatically</h3></div></div></div><p>While the service loader approach works in many scenarios, but not in all (think for example
OSGi where service files are not visible), there is yet another way of contributing constraint
definitions. You can use the programmatic constraint declaration API - see
<a class="xref" href="ch11.html#example-using-constraint-definition-api" title="Example 11.24. Adding constraint definitions through the programmatic API">Example 11.24, “Adding constraint definitions through the programmatic API”</a>.</p><div class="example" id="example-using-constraint-definition-api"><div class="example-title">Example 11.24. Adding constraint definitions through the programmatic API</div><div class="example-contents"><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
		.constraintDefinition( ValidPassengerCount.class )
		.validatedBy( ValidPassengerCountValidator.class );</code></pre></div></div><br class="example-break"/><p>Instead of directly adding a constraint mapping to the configuration object, you may use a <code class="literal">ConstraintMappingContributor</code>
as detailed in <a class="xref" href="ch11.html#section-programmatic-api-contributor" title="11.5. Applying programmatic constraint declarations to the default validator factory">Section 11.5, “Applying programmatic constraint declarations to the default validator factory”</a>. This can be useful when
configuring the default validator factory using <span class="emphasis"><em>META-INF/validation.xml</em></span> (see
<a class="xref" href="ch07.html" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>).</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>One use case for registering constraint definitions through the programmatic API is the ability to specify an alternative
constraint validator for the <code class="literal">@URL</code> constraint. Historically, Hibernate Validator’s default constraint
validator for this constraint uses the <code class="literal">java.net.URL</code> constructor to validate an URL.
However, there is also a purely regular expression based version available which can be configured using
a <code class="literal">ConstraintDefinitionContributor</code>:</p><p><span class="formalpara-title">Using the programmatic constraint declaration API to register a regular expression based constraint definition for <code class="literal">@URL</code>. </span>
</p><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
		.constraintDefinition( URL.class )
		.includeExistingValidators( false )
		.validatedBy( RegexpURLValidator.class );</code></pre><p>
</p></div></section></section><section class="section" id="section-constraint-customizing-class-loading"><div class="titlepage"><div><div><h2 class="title">11.15. Customizing class-loading</h2></div></div></div><p>There are several cases in which Hibernate Validator needs to load resources or classes given by name:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">XML descriptors (<span class="emphasis"><em>META-INF/validation.xml</em></span> as well as XML constraint mappings)</li><li class="listitem">classes specified by name in XML descriptors (e.g. custom message interpolators etc.)</li><li class="listitem">the <span class="emphasis"><em>ValidationMessages</em></span> resource bundle</li><li class="listitem">the <code class="literal">ExpressionFactory</code> implementation used for expression based message interpolation</li></ul></div><p>By default Hibernate Validator tries to load these resources via the current thread context classloader.
If that’s not successful, Hibernate Validator’s own classloader will be tried as a fallback.</p><p>For cases where this strategy is not appropriate (e.g. modularized environments such as OSGi),
you may provide a specific classloader for loading these resources when bootstrapping the validator factory:</p><div class="example" id="example-using-external-class-loader"><div class="example-title">Example 11.25. Providing a classloader for loading external resources and classes</div><div class="example-contents"><pre><code class="language-java">ClassLoader classLoader = ...;

Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.externalClassLoader( classLoader )
		.buildValidatorFactory()
		.getValidator();</code></pre></div></div><br class="example-break"/><p>In the case of OSGi, you could e.g. pass the loader of a class from the bundle bootstrapping Hibernate Validator
or a custom classloader implementation which delegates to <code class="literal">Bundle#loadClass()</code> etc.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Call <code class="literal">ValidatorFactory#close()</code> if a given validator factory instance is not needed any longer.
Failure to do so may result in a classloader leak in cases where applications/bundles are re-deployed and a non-closed
validator factory still is referenced by application code.</p></div></section><section class="section" id="section-time-provider"><div class="titlepage"><div><div><h2 class="title">11.16. Time providers for @Future and @Past</h2></div></div></div><p>By default the current system time is used when validating the <code class="literal">@Future</code> and <code class="literal">@Past</code> constraints.
In some cases it can be necessary though to work with another "logical" date rather than the system time,
e.g. for testing purposes or in the context of batch applications which may require to run with
yesterday’s date when re-running a failed job execution.</p><p>To address such scenarios, Hibernate Validator provides a custom contract for obtaining the current time, <code class="literal">TimeProvider</code>.
<a class="xref" href="ch11.html#example-using-time-provider" title="Example 11.26. Using a custom TimeProvider">Example 11.26, “Using a custom <code class="literal">TimeProvider</code>”</a> shows an implementation of this contract and its registration when bootstrapping a validator factory.</p><div class="example" id="example-using-time-provider"><div class="example-title">Example 11.26. Using a custom <code class="literal">TimeProvider</code></div><div class="example-contents"><pre><code class="language-java">public class CustomTimeProvider implements TimeProvider {

	@Override
	public long getCurrentTime() {
		Calendar now = ...;
		return now.getTimeInMillis();
	}
}</code></pre><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.timeProvider( timeProvider )
		.buildValidatorFactory();</code></pre></div></div><br class="example-break"/><p>Alternatively, you can specify the fully-qualified classname of a <code class="literal">TimeProvider</code> implementation using the property
<code class="literal">hibernate.validator.time_provider</code> when configuring the default validator factory via <span class="emphasis"><em>META-INF/validation.xml</em></span>
(see <a class="xref" href="ch07.html" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>).</p></section></section><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><hr/><footer><ul class="docnav"><li class="previous"><a accesskey="p" href="ch10.html"><strong>Prev</strong>Chapter 10. Integrating with other frameworks</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch12.html"><strong>Next</strong>Chapter 12. Annotation Processor</a></li></ul></footer><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("validator"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>