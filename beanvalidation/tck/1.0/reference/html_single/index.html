<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Technology Compatibility Kit Reference Guide for JSR-303: Bean Validation</title><link rel="stylesheet" href="css/hibernate-single.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e1"/>Technology Compatibility Kit Reference Guide for JSR-303: Bean
  Validation</h1></div><div><h2 class="subtitle">Specification Lead: Red Hat Inc.</h2></div><div><div xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="authorgroup"><div class="authors">by <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Emmanuel Bernard</span> <span xmlns="http://www.w3.org/1999/xhtml" class="orgname">Red Hat Inc.</span> and <span xmlns="http://www.w3.org/1999/xhtml" class="firstname">Hardy Ferentschik</span> <span xmlns="http://www.w3.org/1999/xhtml" class="orgname">Red Hat Inc.</span></div><div class="editors"/><div class="others"/></div></div><div><div class="literallayout"><p>Licensed under the Apache License, Version 2.0 (the "License");<br/>
you may not use this file except in compliance with the License.<br/>
You may obtain a copy of the License at<br/>
http://www.apache.org/licenses/LICENSE-2.0<br/>
Unless required by applicable law or agreed to in writing, software<br/>
distributed under the License is distributed on an "AS IS" BASIS,  <br/>
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br/>
See the License for the specific language governing permissions and<br/>
limitations under the License.</p></div></div><div><p class="copyright">Copyright © 2009 - 2011 Red Hat, Inc.</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#book-preface">Preface</a></span></dt><dd><dl><dt><span class="section"><a href="#target-audience">1. Who Should Use This Guide</a></span></dt><dt><span class="section"><a href="#before-reading">2. Before You Read This Guide</a></span></dt><dt><span class="section"><a href="#book-organization">3. How This Guide Is Organized</a></span></dt></dl></dd><dt><span class="part"><a href="#d0e100">I. Getting Acquainted with the TCK</a></span></dt><dd><dl><dt><span class="chapter"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e115">1.1. TCK Primer</a></span></dt><dt><span class="section"><a href="#d0e124">1.2. Compatibility Testing</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e133">1.2.1. Why Compatibility Is Important</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e153">1.3. About the Bean Validation TCK</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e165">1.3.1. Bean Validation TCK Specifications and Requirements</a></span></dt><dt><span class="section"><a href="#d0e198">1.3.2. Bean Validation TCK Components</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#appeals-process">2. Appeals Process</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e247">2.1. Who can make challenges to the TCK?</a></span></dt><dt><span class="section"><a href="#d0e252">2.2. What challenges to the TCK may be submitted?</a></span></dt><dt><span class="section"><a href="#d0e268">2.3. How these challenges are submitted?</a></span></dt><dt><span class="section"><a href="#d0e283">2.4. How and by whom challenges are addressed?</a></span></dt><dt><span class="section"><a href="#d0e296">2.5. How accepted challenges to the TCK are managed?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#installation">3. Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e308">3.1. Obtaining the Software</a></span></dt><dt><span class="section"><a href="#tck-environment">3.2. The TCK Environment</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">4. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#tck-harness-properties">4.1. TCK Harness Properties</a></span></dt><dt><span class="section"><a href="#d0e515">4.2. Configuring TestNG to execute the TCK</a></span></dt><dt><span class="section"><a href="#d0e535">4.3. Configuring your build environment to execute the TCK</a></span></dt></dl></dd><dt><span class="chapter"><a href="#reporting">5. Reporting</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e548">5.1. Bean Validation TCK Coverage Metrics</a></span></dt><dt><span class="section"><a href="#d0e578">5.2. Bean Validation TCK Coverage Report</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e585">5.2.1. Bean Validation TCK Assertions</a></span></dt><dt><span class="section"><a href="#d0e614">5.2.2. Producing the Coverage Report</a></span></dt><dt><span class="section"><a href="#d0e688">5.2.3. TestNG Reports</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="#d0e734">II. Executing and Debugging Tests</a></span></dt><dd><dl><dt><span class="chapter"><a href="#sigtest">6. Running the Signature Test</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e745">6.1. Obtaining the sigtest tool</a></span></dt><dt><span class="section"><a href="#d0e759">6.2. Creating the signature file</a></span></dt><dt><span class="section"><a href="#d0e785">6.3. Running the signature test</a></span></dt><dt><span class="section"><a href="#d0e797">6.4. Forcing a signature test failure</a></span></dt></dl></dd><dt><span class="chapter"><a href="#executing">7. Executing the Test Suite</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e827">7.1. The Test Suite Runner</a></span></dt><dt><span class="section"><a href="#d0e846">7.2. Running the Tests In Standalone Mode</a></span></dt><dt><span class="section"><a href="#d0e873">7.3. Running the Tests In the Container</a></span></dt><dt><span class="section"><a href="#d0e918">7.4. Dumping the Test Artifacts</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#test-harness">III. JBoss Test Harness</a></span></dt><dd><dl><dt><span class="chapter"><a href="#test-harness-introduction">8. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#in-container-communication">8.1. Negotiating the execution of an
    in-container test</a></span></dt></dl></dd><dt><span class="chapter"><a href="#test-harness-configuration">9. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#test-harness-properties">9.1. JBoss Test Harness Properties</a></span></dt></dl></dd><dt><span class="chapter"><a href="#executing-test-harness">10. Executing a Test Suite</a></span></dt><dd><dl><dt><span class="section"><a href="#test-suite-runner">10.1. Building a test suite runner using Maven 2</a></span></dt><dt><span class="section"><a href="#dumping-test-artifacts">10.2. Dumping the Test Artifacts to Disk</a></span></dt></dl></dd></dl></dd></dl></div><div class="preface" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="book-preface"/>Preface</h2></div></div></div><p>This guide describes how to download, install, configure, and run the
  Technology Compatibility Kit (TCK) used to verify the compatibility of an
  implementation of JSR-303: Bean Validation specification.</p><p>The Bean Validation TCK is built atop the JBoss Test Harness, a
  portable and configurable automated test suite for authoring unit and
  integration tests in a Java EE environment. The TCK uses the JBoss Test
  Harness version 1.x to execute the test suite.</p><p>The Bean Validation TCK is provided under the <a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0">Apache Public License
  2.0</a>.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="target-audience"/>1. Who Should Use This Guide</h2></div></div></div><p>This guide is for implementors of the Bean Validation specification
    to assist in running the test suite that verifies the compatibility of
    their implementation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="before-reading"/>2. Before You Read This Guide</h2></div></div></div><p>The Bean Validation TCK is based on the Bean Validation
    specification 1.0 (JSR-303). Information about the specification,
    including links to the specification documents, can be found on the <a class="ulink" href="http://jcp.org/en/jsr/detail?id=303">JSR-303 JCP page</a>.</p><p>Before running the tests in the Bean Validation TCK, read and become
    familiar with the JBoss Test Harness Reference Guide (pending), which
    describes how the test harness functions.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="book-organization"/>3. How This Guide Is Organized</h2></div></div></div><p>If you are running the Bean Validation TCK for the first time, read
    <a class="xref" href="#introduction" title="Chapter 1. Introduction">Chapter 1, <i>Introduction</i></a> and <a class="xref" href="#test-harness-introduction" title="Chapter 8. Introduction">Chapter 8, <i>Introduction</i></a> completely for the necessary
    background information about the TCK and the JBoss Test Harness,
    respectively. Once you have reviewed that material, perform the steps
    outlined in the remaining chapters.</p><div class="itemizedlist"><ul><li><p><a class="xref" href="#introduction" title="Chapter 1. Introduction">Chapter 1, <i>Introduction</i></a> gives an overview of the
        principles that apply generally to all Technology Compatibility Kits
        (TCKs), outlines the appeals process and describes the Bean Validation
        TCK architecture and components. It also includes a broad overview of
        how the TCK is executed and lists the platforms on which the TCK has
        been tested and verified.</p></li><li><p><a class="xref" href="#appeals-process" title="Chapter 2. Appeals Process">Chapter 2, <i>Appeals Process</i></a> explains the process to be
        followed by an implementor should they wish to challenge any test in
        the TCK.</p></li><li><p><a class="xref" href="#installation" title="Chapter 3. Installation">Chapter 3, <i>Installation</i></a> explains where to obtain the
        required software for the Bean Validation TCK and how to install it.
        It covers both the primary TCK components as well as tools useful for
        troubleshooting tests.</p></li><li><p><a class="xref" href="#configuration" title="Chapter 4. Configuration">Chapter 4, <i>Configuration</i></a> details the configuration of
        the JBoss Test Harness, how to create a TCK runner for the TCK test
        suite and the mechanics of how an in-container test is
        conducted.</p></li><li><p><a class="xref" href="#reporting" title="Chapter 5. Reporting">Chapter 5, <i>Reporting</i></a> explains the test reports that are
        generated by the TCK test suite and introduces the TCK audit report as
        a tool for measuring the completeness of the TCK in testing the
        JSR-303 specification and in understanding how testcases relate to the
        specification.</p></li><li><p><a class="xref" href="#executing" title="Chapter 7. Executing the Test Suite">Chapter 7, <i>Executing the Test Suite</i></a> documents how the TCK test suite is
        executed. It covers both modes supported by the TCK, standalone and
        in-container, and shows how to dump the generated test artifacts to
        disk.</p></li><li><p><a class="xref" href="#test-harness" title="Part III. JBoss Test Harness">Part III, “JBoss Test Harness”</a> includes excerpts from the JBoss
        Test Harness Reference Guide. How to configure the JBoss Test Harness
        as it relates to the Bean Validation TCK is presented in <a class="xref" href="#configuration" title="Chapter 4. Configuration">Chapter 4, <i>Configuration</i></a>. However, to aid in debugging or
        configuring the TCK in your environment, you may want to read in more
        detail how to use the JBoss Test Harness.</p></li></ul></div></div></div><div class="part" lang="en-US"><div class="titlepage"><div><div><h1 class="title"><a id="d0e100"/>Part I. Getting Acquainted with the TCK</h1></div></div></div><div class="partintro" lang="en-US"><div/><p>The Bean Validation TCK must be used to ensure that your
    implementation conforms to the Bean Validation specification. This part
    introduces the TCK, gives some background about its purpose, states the
    requirements for passing the TCK and outlines the appeals process.</p><p>In this part you will learn where to obtain the Bean Validation TCK
    and supporting software. You are then presented with recommendations of
    how to organize and configure the software so that you are ready to
    execute the TCK.</p><p>Finally, it discusses the reporting provided by the TCK.</p><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e115">1.1. TCK Primer</a></span></dt><dt><span class="section"><a href="#d0e124">1.2. Compatibility Testing</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e133">1.2.1. Why Compatibility Is Important</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e153">1.3. About the Bean Validation TCK</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e165">1.3.1. Bean Validation TCK Specifications and Requirements</a></span></dt><dt><span class="section"><a href="#d0e198">1.3.2. Bean Validation TCK Components</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#appeals-process">2. Appeals Process</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e247">2.1. Who can make challenges to the TCK?</a></span></dt><dt><span class="section"><a href="#d0e252">2.2. What challenges to the TCK may be submitted?</a></span></dt><dt><span class="section"><a href="#d0e268">2.3. How these challenges are submitted?</a></span></dt><dt><span class="section"><a href="#d0e283">2.4. How and by whom challenges are addressed?</a></span></dt><dt><span class="section"><a href="#d0e296">2.5. How accepted challenges to the TCK are managed?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#installation">3. Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e308">3.1. Obtaining the Software</a></span></dt><dt><span class="section"><a href="#tck-environment">3.2. The TCK Environment</a></span></dt></dl></dd><dt><span class="chapter"><a href="#configuration">4. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#tck-harness-properties">4.1. TCK Harness Properties</a></span></dt><dt><span class="section"><a href="#d0e515">4.2. Configuring TestNG to execute the TCK</a></span></dt><dt><span class="section"><a href="#d0e535">4.3. Configuring your build environment to execute the TCK</a></span></dt></dl></dd><dt><span class="chapter"><a href="#reporting">5. Reporting</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e548">5.1. Bean Validation TCK Coverage Metrics</a></span></dt><dt><span class="section"><a href="#d0e578">5.2. Bean Validation TCK Coverage Report</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e585">5.2.1. Bean Validation TCK Assertions</a></span></dt><dt><span class="section"><a href="#d0e614">5.2.2. Producing the Coverage Report</a></span></dt><dt><span class="section"><a href="#d0e688">5.2.3. TestNG Reports</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="introduction"/>Chapter 1. Introduction</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e115">1.1. TCK Primer</a></span></dt><dt><span class="section"><a href="#d0e124">1.2. Compatibility Testing</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e133">1.2.1. Why Compatibility Is Important</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e153">1.3. About the Bean Validation TCK</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e165">1.3.1. Bean Validation TCK Specifications and Requirements</a></span></dt><dt><span class="section"><a href="#d0e198">1.3.2. Bean Validation TCK Components</a></span></dt></dl></dd></dl></div><p>This chapter explains the purpose of a TCK and identifies the
  foundation elements of the Bean Validation TCK.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e115"/>1.1. TCK Primer</h2></div></div></div><p>A TCK, or Technology Compatibility Kit, is one of the three required
    pieces for any JSR (the other two being the specification document and the
    reference implementation). The TCK is a set of tools and tests to verify
    that an implementation of the technology conforms to the specification.
    The tests are the primary component, but the tools serve an equally
    critical role of providing a framework and/or set of SPIs for executing
    the tests.</p><p>The tests in the TCK are derived from assertions in the written
    specification document. The assertions are itemized in an XML document,
    where they each get assigned a unique identifier, and materialize as a
    suite of automated tests that collectively validate whether an
    implementation complies with the aforementioned assertions, and in turn
    the specification. For a particular implementation to be certified, all of
    the required tests must pass (i.e., the provided test suite must be run
    unmodified).</p><p>A TCK is entirely implementation agnostic. It should validate
    assertions by consulting the specficiation's public API.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e124"/>1.2. Compatibility Testing</h2></div></div></div><p>The goal of any specification is to eliminate portability problems
    so long as the program which uses the implementation also conforms to the
    rules laid out in the specification.</p><p>Executing the TCK is a form of compatibility testing. It's important
    to understand that compatibility testing is distinctly different from
    product testing. The TCK is not concerned with robustness, performance or
    ease of use, and therefore cannot vouch for how well an implementation
    meets these criteria. What a TCK can do is to ensure the exactness of an
    implementation as it relates to the specification.</p><p>Compatibility testing of any feature relies on both a complete
    specification and a complete reference implementation. The reference
    implementation demonstrates how each test can be passed and provides
    additional context to the implementor during development for the
    corresponding assertion.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e133"/>1.2.1. Why Compatibility Is Important</h3></div></div></div><p>Java platform compatibility is important to different groups
      involved with Java technologies for different reasons:</p><div class="itemizedlist"><ul><li><p>Compatibility testing is the means by which the JCP ensures
          that the Java platform does not become fragmented as it's ported to
          different operating systems and hardware.</p></li><li><p>Compatibility testing benefits developers working in the Java
          programming language, enabling them to write applications once and
          deploy them across heterogeneous computing environments without
          porting.</p></li><li><p>Compatibility testing enables application users to obtain
          applications from disparate sources and deploy them with
          confidence.</p></li><li><p>Conformance testing benefits Java platform implementors by
          ensuring the same extent of reliability for all Java platform
          ports.</p></li></ul></div><p>The Bean Validation specification goes to great lengths to ensure
      that programs written for Java EE are compatible and the TCK is rigorous
      about enforcing the rules the specification lays down.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e153"/>1.3. About the Bean Validation TCK</h2></div></div></div><p>The Bean Validation TCK is designed as a portable, configurable and
    automated test suite for verifying the compatibility of an implementation
    of JSR-303: Bean Validation specification. The test suite is built atop
    TestNG and provides a series of extensions that allow runtime packaging
    and deployment of JEE artifacts for in-container testing (JBoss Test
    Harness).</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The Bean Validation TCK harness is based on the JBoss Test
      harness, which provides most of the aforementioned functionality.</p></div><p>Each test class in the suite acts as a deployable unit. The
    deployable units, or artifacts, are defined declaratively using
    annotations.</p><p>The declarative approach allows many of the tests to be executed in
    a standalone implementation of Bean Validation, accounting for a boast in
    developer productivity. However, an implementation is only valid if all
    tests pass using the in-container execution mode. The standalone mode is
    merely a developer convenience.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e165"/>1.3.1. Bean Validation TCK Specifications and Requirements</h3></div></div></div><p>This section lists the applicable requirements and specifications
      for the Bean Validation TCK.</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>Bean Validation API</strong></span> - The
          Java API defined in the Bean Validation specification and provided
          by the reference implementation.</p></li><li><p><span class="bold"><strong>JBoss Test Harness</strong></span> - The Bean
          Validation TCK requires version 1.x of the JBoss Test Harness. The
          Harness is based on <a class="ulink" href="http://testng.org">TestNG
          5.x</a>. You can read more about the harness in <a class="xref" href="#test-harness" title="Part III. JBoss Test Harness">Part III, “JBoss Test Harness”</a>.</p></li><li><p><span class="bold"><strong>TCK Audit Tool</strong></span> - An
          itemization of the assertions in the specification documents which
          are cross referenced by the individual tests. Describes how well the
          TCK covers the specification.</p></li><li><p><span class="bold"><strong>Reference runtime</strong></span> - The
          designated reference runtimes for compatibility testing of the Bean
          Validation specification is the Sun Java Platform, Enterprise
          Edition (Java EE) 6 reference implementation (RI). See details at
          <a class="ulink" href="http://java.sun.com/javaee/6/docs/api/">Java EE
          6</a></p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e198"/>1.3.2. Bean Validation TCK Components</h3></div></div></div><p>The Bean Validation TCK includes the following components:</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>JBoss Test Harness 1.x</strong></span> and
          related documentation.</p></li><li><p><span class="bold"><strong>TestNG 5.9</strong></span>, the testing
          framework on which the JBoss Test Harness is based and which
          provides the extension points for selecting an executing the tests
          in the test suite.</p></li><li><p><span class="bold"><strong>The test suite</strong></span>, which is a
          collection of TestNG tests, the TestNG test suite descriptor and
          supplemental resources that configure Bean Validation and other
          software components.</p></li><li><p><span class="bold"><strong>The TCK audit</strong></span> is used to list
          out the assertions identified in the Bean Validation specification.
          It matches the assertions to testcases in the test suite by unique
          identifier and produces a coverage report.</p><p>The audit document is provided along with the TCK. Each
          assertion is defined with a reference to a chapter, section and
          paragraph from the specification document, making it easy for the
          implementor to locate the language in the specification document
          that supports the feature being tested.</p></li><li><p><span class="bold"><strong>TCK documentation</strong></span> accompanied
          by release notes identifying updates between versions.</p></li></ul></div><p>The Bean Validation TCK has been tested run on following
      platforms:</p><div class="itemizedlist"><ul><li><p>JBoss AS 5.1.0.GA using Sun Java SE 6 on Red Hat Enterprise
          Linux 5.2</p></li></ul></div></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="appeals-process"/>Chapter 2. Appeals Process</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e247">2.1. Who can make challenges to the TCK?</a></span></dt><dt><span class="section"><a href="#d0e252">2.2. What challenges to the TCK may be submitted?</a></span></dt><dt><span class="section"><a href="#d0e268">2.3. How these challenges are submitted?</a></span></dt><dt><span class="section"><a href="#d0e283">2.4. How and by whom challenges are addressed?</a></span></dt><dt><span class="section"><a href="#d0e296">2.5. How accepted challenges to the TCK are managed?</a></span></dt></dl></div><p>While the Bean Validation TCK is rigourous about enforcing an
  implementation's conformance to the JSR-303 specification, it's reasonable
  to assume that an implementor may discover new and/or better ways to
  validate the assertions. This chapter covers the appeals process, defined by
  the Specification Lead, Red Hat Middleware LLC., which allows implementors
  of the JSR-303 specification to challenge one or more tests defined by the
  Bean Validation TCK.</p><p>The appeals process identifies who can make challenges to the TCK,
  what challenges to the TCK may be submitted, how these challenges are
  submitted, how and by whom challenges are addressed and how accepted
  challenges to the TCK are managed.</p><p>Following the recent adoption of transparency in the JCP, implementors
  are encouraged to make their appeals public, which this process facilitates.
  The JCP community should recognize that issue reports are a central aspect
  of any good software and it's only natural to point out shortcomings and
  strive to make improvements. Despite this good faith, not all implementors
  will be comfortable with a public appeals process. Instructions about how to
  make a private appeal are therefore provided.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e247"/>2.1. Who can make challenges to the TCK?</h2></div></div></div><p>Any implementor may submit an appeal to challenge one or more tests
    in the Bean Validation TCK. In fact, members of the JSR-303 Expert Group
    (EG) encourage this level of participation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e252"/>2.2. What challenges to the TCK may be submitted?</h2></div></div></div><p>Any test case (e.g., <code class="literal">@Artifact</code> class,
    <code class="literal">@Test</code> method), test case configuration (e.g.,
    validation.xml), test entities, annotations and other resources may be
    challenged by an appeal.</p><p>What is generally not challengable are the assertions made by the
    specification. The specification document is controlled by a separate
    process and challenges to it should be handled through the JSR-303 EG by
    sending an e-mail to <a class="ulink" href="mailto:jsr299-comments@jcp.org">jsr303-comments@jcp.org</a>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e268"/>2.3. How these challenges are submitted?</h2></div></div></div><p>To submit a challenge, a new issue should be created in the <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/BVTCK">BVTCK
    project</a> of the Hibernate JIRA using the Issue Type: Bug. The
    appellant should complete the Summary, Component (TCK Appeal), Environment
    and Description Field only. Any communication regarding the issue should
    be pursed in the comments of the filed issue for accurate record.</p><p>To submit an issue in the Hibernate JIRA, you must have a (free)
    Jira member account. You can create a member account using the <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/secure/Signup!default.jspa">on-line
    registration</a>.</p><p>If you wish to make a private challenge, you should follow the above
    procedure, setting the Security Level to Private. Only the issue reporter,
    TCK Project Lead and designates will be able to view the issue.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e283"/>2.4. How and by whom challenges are addressed?</h2></div></div></div><p>The challenges will be addressed in a timely fashion by the Bean
    Validation TCK Project Lead, as designated by Specification Lead, Red Hat
    Middleware LLC. or his/her designate. The appellant can also monitor the
    process by following the issue report filed in the <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/BVTCK">BVTCK
    project</a> of the Hibernate JIRA.</p><p>The current TCK Project Lead is listed on the <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/BVTCK">BVTCK Project Summary Page</a>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e296"/>2.5. How accepted challenges to the TCK are managed?</h2></div></div></div><p>Accepted challenges will be acknowledged via the filed issue's
    comment section. Communication between the Bean Validation TCK Project
    Lead and the appellant will take place via the issue comments. The issue's
    status will be set to "Resolved" when the TCK project lead believes the
    issue to be resolved. The appellant should, within 30 days, either close
    the issue if they agree, or reopen the issue if they do not believe the
    issue to be resolved.</p><p>Resolved issue not addressed for 30 days will be closed by the TCK
    Project Lead. If the TCK Project Lead and appellant are unable to agree on
    the issue resolution, it will be referred to the JSR-303 specification
    lead or his/her designate.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="installation"/>Chapter 3. Installation</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e308">3.1. Obtaining the Software</a></span></dt><dt><span class="section"><a href="#tck-environment">3.2. The TCK Environment</a></span></dt></dl></div><p>This chapter explains how to obtain the TCK and supporting software
  and provides recommendations for how to install/extract it on your
  system.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e308"/>3.1. Obtaining the Software</h2></div></div></div><p>You can obtain a release of the Bean Validation TCK project via the
    official <a class="ulink" href="http://beanvalidation.org/1.0/">Bean Validation home
    page</a>. The Bean Validation TCK is distributed as a ZIP file, which
    contains the TCK artifacts (the test suite binary and source, the test
    suite descriptor, the audit source and report), the TCK library
    dependencies in <code class="code">/lib</code> and documentation in
    <code class="code">/doc</code>.</p><p>You can also download the current source code from Github - <a class="ulink" href="https://github.com/beanvalidation/beanvalidation-tck">https://github.com/beanvalidation/beanvalidation-tck</a>.</p><p>The TCK project is available in the JBoss Maven 2 repository as
    org.hibernate.jsr303.tck<code class="code">:</code>org.hibernate.jsr303.tck; the POM
    defines all dependencies required to run the TCK.</p><p>Executing the TCK requires a Java EE 5 or better runtime environment
    (i.e., application server), to which the test artifacts are deployed and
    the individual tests are invoked. The TCK does not depend on any
    particular Java EE implementation.</p><p>The JSR-303: Bean Validation reference implementation (RI) project
    is named Hibernate Validator. You can obtain the latest Hibernate
    Validator release from the <a class="ulink" href="http://www.hibernate.org/subprojects/validator/download">download
    page</a> on Hibernate website.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Hibernate Validator is not required for running the Bean
      Validation TCK, but it can be used as a reference for familiarizing
      yourself with the TCK before testing your own Bean Validation
      implementation.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="tck-environment"/>3.2. The TCK Environment</h2></div></div></div><p>The TCK requires the following two Java runtime environments:</p><div class="itemizedlist"><ul><li><p>Java 5 or better</p></li><li><p>Java EE 5 or better (e.g., JBoss AS 5.x or GlassFish V3)</p></li></ul></div><p>You should refer to vendor instructions for how to install the
    runtime.</p><p>The rest of the TCK software can simply be extracted. It's
    recommended that you create a folder named jsr303 to hold all of the
    jsr303-related projects. Then, extract the TCK distribution into a
    subfolder named tck. You can also check out the full Hibernate Validator
    source into a subfolder ri. This will allow you to run the TCK against
    Hibernate Validator.</p><pre class="programlisting">git clone git://github.com/hibernate/hibernate-validator.git ri
git checkout 4.2.0.Final</pre><p>If you have downloaded the Hibernate Validator distribution, extract
    it into a sibling folder named hibernate-validator. The resulting folder
    structure is shown here:</p><pre class="programlisting">jsr303/
   ri/
   tck/</pre><p>Each test class is treated as an individual artifact (hence the
    <code class="literal">@Artifact(artifactType = ArtifactType.JSR303)</code>
    annotation on the class). All test methods (i.e., methods annotated with
    <code class="literal">@Test</code>) in the test class are run.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Using <code class="literal">ArtifactType.JSR303</code> is an additional
      artifact type to the standard WAR and EAR types offered by the JBoss
      Test Harness. It is basically a normal WAR file with a
      <code class="filename">validation.xml</code> file at the root of the classpath.
      The <code class="filename">validation.xml</code> file can be specified with the
      <code class="classname">@ValidationXml </code>annotation. Using
      <code class="literal">ArtifactType.JSR303</code> together with
      <code class="classname">@ValidationXml</code> also allows to have test with
      custom validation.xml files running in standalone mode. This is possible
      by modifying the classloader in standalone mode as shown in
      <code class="classname">org.hibernate.jsr303.tck.util.StandaloneContainersImpl</code>.
      This container implementation is also the default for sandalone
      mode.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><a id="tck-in-jboss-as"/><h2>Running the TCK against the Bean Validation RI (Hibernate
      Validator) and JBoss AS 7</h2><div class="itemizedlist"><ul><li><p>First, you should download the latest JBoss AS 7 release from
          the JBoss AS <a class="ulink" href="http://jboss.org/jbossas/downloads">project
          page</a>.</p></li><li><p>Set the <code class="literal">JBOSS_HOME</code> environment variable to
          the location of the JBoss AS software.</p></li><li><p>Change to the
          <code class="filename">ri/hibernate-validator-tck-runner</code>
          directory.</p></li><li><p>You need to install Maven. You can find documention on how to
          install Maven 2 in the <a class="ulink" href="http://www.sonatype.com/books/maven-book/reference/installation-sect-maven-install.html">Maven:
          The Definitive Guide</a> book published by Sonatype. Web Beans
          bundles a copy of Maven in the <code class="code">lib/maven</code>
          directory.</p></li><li><p>Next, instruct Maven to run the TCK:</p><pre class="programlisting">mvn test -Dincontainer</pre></li><li><p>TestNG will report, via Maven, the outcome of the run, and
          report any failures on the console. Details can be found in
          <code class="code">target/surefire-reports/TestSuite.txt</code>.</p></li></ul></div></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="configuration"/>Chapter 4. Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#tck-harness-properties">4.1. TCK Harness Properties</a></span></dt><dt><span class="section"><a href="#d0e515">4.2. Configuring TestNG to execute the TCK</a></span></dt><dt><span class="section"><a href="#d0e535">4.3. Configuring your build environment to execute the TCK</a></span></dt></dl></div><p>This chapter lays out how to configure the TCK Harness by specifying
  the SPI implementation classes, defining the target container connection
  information, and various other switches. You then learn how to setup a TCK
  runner project that executes the the TCK test suite, putting these settings
  into practice. Finally, a detailed account of how the JBoss Test Harness
  negotiates the execution of the tests in the container is given.</p><p>This chapter does not discuss in detail how to use the TCK in
  standalone mode. The JBoss Test Harness guide provides more on running in
  standalone mode.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="tck-harness-properties"/>4.1. TCK Harness Properties</h2></div></div></div><p>The JBoss Test Harness allows the test suite to be launched in a
    pluggable fashion. In order to execute the TCK, the JBoss Test Harness
    must be configured by specifying implementations of the test launcher and
    container APIs.</p><p>System properties and/or the resource
    <code class="code">META-INF/jboss-test-harness.properties</code>, a Java properties
    file, are used to configure the JBoss Test Harness. You can read more
    about configuring the JBoss Test Harness in <a class="xref" href="#test-harness-properties" title="9.1. JBoss Test Harness Properties">Section 9.1, “JBoss Test Harness Properties”</a>.</p><p>You should set the following properties:</p><div class="table"><a id="d0e460"/><p class="title"><b>Table 4.1. Required JBoss Test Harness Configuration Properties</b></p><div class="table-contents"><table summary="Required JBoss Test Harness Configuration Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property = Required/Example Value</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">org.jboss.testharness.libraryDirectory=/path/to/extra/libraries
            </code></td><td>Directory containing extra JARs you want placed in artifact
            library directory.</td></tr><tr><td><code class="literal">org.jboss.testharness.standalone=false</code></td><td>You must run the tests in-container to pass the TCK</td></tr><tr><td><code class="literal">org.jboss.testharness.runIntegrationTests=true
            </code></td><td>You must run the integration tests to pass the TCK</td></tr><tr><td><code class="literal">org.jboss.testharness.spi.Containers=com.acme.AcmeContainer
            </code></td><td>The container implementation for deploying and executing
            in-container tests. See <a class="xref" href="#deployment-api-contributions" title="Note">Note</a></td></tr><tr><td><code class="literal">org.jboss.testharness.api.TestLauncher=org.jboss.testharness.impl.runner.servlet.ServletTestLauncher
            </code></td><td>You should use the <code class="literal">ServletTestLauncher</code>
            for Java EE 6 and Java EE 6 Web Profile.</td></tr></tbody></table></div></div><br class="table-break"/><p>To run the full TCK you must additionally implement
    <code class="literal">org.jboss.testharness.spi.Containers</code>, which handles
    deploying the test artifact to the container. An implementations of this
    API is already available for JBoss AS 5.1. Therefore, you only need to
    implement this if you wish to use another container.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><a id="deployment-api-contributions"/><h2>Note</h2><p>Red Hat Middleware LLC encourages Bean Validation implementators
      to contribute JBoss Test Harness Deployment API implementations for
      other containers under the ASL license. Please contact the Bean
      Validation TCK lead.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e515"/>4.2. Configuring TestNG to execute the TCK</h2></div></div></div><p>The JBoss Test Harness is built atop TestNG, and it's TestNG that is
    responsible for selecting the tests to execute, the order of execution,
    and reporting the results. Detailed TestNG documentation can be found at
    <a class="ulink" href="http://testng.org/doc/documentation-main.html">testng.org</a>.</p><p>The <code class="literal">tck-tests.xml</code> artifact provided in the TCK
    distribution must be run by TestNG 5.9 (described by the TestNG
    documenation as "with a <code class="literal">testng.xml</code> file") unmodified
    for an implementation to pass the TCK. This file also allows tests to be
    excluded from a run:</p><pre class="programlisting">&lt;suite name="JSR-303 TCK" verbose="2"&gt;
   &lt;test name="JSR-303 TCK"&gt;
      ...
      &lt;classes&gt;
         &lt;class name="org.hibernate.jsr303.tck.tests.bootstrap.ValidationProviderTest"&gt;
            &lt;methods&gt;
               &lt;exclude name="testFirstMatchingValidationProviderResolverIsReturned"/&gt;
            &lt;/methods&gt;
         &lt;/class&gt;
      &lt;/classes&gt;
      ...
   &lt;/test&gt;
&lt;/suite&gt;</pre><p>TestNG provides extensive reporting information. Depending on the
    build tool or IDE you use, the reporting will take a different format.
    Please consult the TestNG documentation and the tool documentation for
    more information.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e535"/>4.3. Configuring your build environment to execute the TCK</h2></div></div></div><p>It's beyond the scope of this guide to describe in how to set up
    your build environment to run the TCK. The JBoss Test Harness guide
    describes how Bean Validation uses Maven 2 to execute the Bean Validation
    TCK. See <a class="xref" href="#test-suite-runner" title="10.1. Building a test suite runner using Maven 2">Section 10.1, “Building a test suite runner using Maven 2”</a>. The TestNG documentation
    provides extensive information on launching TestNG using the Java, Ant,
    Eclipse or IntellJ IDEA.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="reporting"/>Chapter 5. Reporting</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e548">5.1. Bean Validation TCK Coverage Metrics</a></span></dt><dt><span class="section"><a href="#d0e578">5.2. Bean Validation TCK Coverage Report</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e585">5.2.1. Bean Validation TCK Assertions</a></span></dt><dt><span class="section"><a href="#d0e614">5.2.2. Producing the Coverage Report</a></span></dt><dt><span class="section"><a href="#d0e688">5.2.3. TestNG Reports</a></span></dt></dl></dd></dl></div><p>This chapter covers the two types of reports that can be generated
  from the TCK, an assertion coverage report and the test execution results.
  The chapter also justifies why the TCK is good indicator of how accurately
  an implementation conforms to the JSR-303 specification.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e548"/>5.1. Bean Validation TCK Coverage Metrics</h2></div></div></div><p>The Bean Validation TCK coverage has been measured as
    follows:</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>Assertion Breadth
        Coverage</strong></span></p><p>The Bean Validation TCK provides at least 100% coverage of
        identified assertions with test cases.</p></li><li><p><span class="bold"><strong>Assertion Breadth Coverage
        Variance</strong></span></p><p>The coverage of specification sub-sections shows at least a
        normal distribution (centered around 75%).</p></li><li><p><span class="bold"><strong>Assertion Depth Coverage</strong></span></p><p>The assertion depth coverage has not been measured, as, when an
        assertion requires more than one testcase, these have been enumerated
        in an assertion group and so are adequately described by the assertion
        breadth coverage.</p></li><li><p><span class="bold"><strong>API Signature Coverage</strong></span></p><p>The Bean Validation TCK covers 100% of all API public methods
        using the Java CTT Sig Test tool.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e578"/>5.2. Bean Validation TCK Coverage Report</h2></div></div></div><p>A specification can be distilled into a collection of assertions
    that define the behavior of the software. This section introduces the Bean
    Validation TCK coverage report, which documents the relationship between
    the assertions that have been identified in the JSR-303 specification
    document and the tests in the TCK test suite.</p><p>The structure of this report is controlled by the assertion
    document, so we'll start there.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e585"/>5.2.1. Bean Validation TCK Assertions</h3></div></div></div><p>The Bean Validation TCK developers have analyzed the JSR-303
      specification document and identified the assertions that are present in
      each chapter. Here's an example of one such assertion found in section
      2.1:</p><div class="blockquote"><blockquote class="blockquote">
         Every constraint annotation must define a message element of type String 
      </blockquote></div><p>The assertions are listed in the XML file
      <code class="filename">tck-audit.xml</code> in the Bean Validation TCK
      distribution. Each assertion is identified by the section of the
      specification document in which it resides and assigned a unique
      paragraph identifier to narrow down the location of the assertion
      further. To continue with the example, the assertion shown above is
      listed in the tck-audit.xml file using this XML fragment:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">section</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">id</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;2.1.1&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">title</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Constraint&nbsp;definition&nbsp;properties&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">assertion</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">id</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;c&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">text</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">Every&nbsp;constraint&nbsp;annotation&nbsp;must&nbsp;define&nbsp;a&nbsp;message&nbsp;element&nbsp;of&nbsp;type&nbsp;String</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">text</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">assertion</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;...</span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">section</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>The strategy of the Bean Validation TCK is to write a test which
      validates this assertion when run against an implementation. A test case
      (a method annotated with <code class="literal">@Test</code> in an
      <code class="literal">@Artifact</code> class) is correlated with an assertion
      using the
      <code class="literal">@org.jboss.test.audit.annotations.SpecAssertion</code>
      annotation as follows:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Test</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">SpecAssertion</span><span class="java_separator">(</span><span class="java_plain">section&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;2.1.1&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;id&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;c&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;testConstraintDefinitionWithoutMessageParameter</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Validator</span><span class="java_plain">&nbsp;validator&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_type">TestUtil</span><span class="java_separator">.</span><span class="java_plain">getValidatorUnderTest</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;validator</span><span class="java_separator">.</span><span class="java_plain">validate</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">DummyEntityNoMessage</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fail</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;The&nbsp;used&nbsp;constraint&nbsp;does&nbsp;not&nbsp;define&nbsp;a&nbsp;message&nbsp;parameter.&nbsp;The&nbsp;validation&nbsp;should&nbsp;have&nbsp;failed.&quot;</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;</span><span class="java_type">ConstraintDefinitionException</span><span class="java_plain">&nbsp;e&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;success</span>
<!--  --><br/><span class="java_separator">}</span>
</pre><p>To help evaluate the distribution of coverage for these
      assertions, the TCK provides a detailed coverage report. This report is
      also useful to help implementors match tests with the language in the
      specification that supports the behavior being tested.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e614"/>5.2.2. Producing the Coverage Report</h3></div></div></div><p>The coverage report is an HTML report generated as part of the TCK
      project build. Specifically, it is generated by an annotation processor
      that attaches to the compilation of the classes in the TCK test suite,
      another tool from the JBoss Test Utils project. You can enable this
      report by setting the commandline property
      <span class="property">tck-audit</span> to true when running the Maven 2 build in
      the tck directory.</p><pre class="programlisting">mvn clean install -Dtck-audit=true</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>You must run clean first because the annotation processor
        performs it's work when the test class is being compiled. If
        compilation is unnecessary, then the assertions referenced in that
        class will not be discovered.</p></div><p>The report is written to the file target/coverage.html in the same
      project. The report has five sections:</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p><span class="bold"><strong>Chapter Summary</strong></span> - List the
          chapters (that contain assertions) in the specification document
          along with total assertions, tests and coverage percentage.</p></li><li><p><span class="bold"><strong>Section Summary</strong></span> - Lists the
          sections (that contain assertions) in the specification document
          along with total assertions, tests and coverage percentage.</p></li><li><p><span class="bold"><strong>Coverage Detail</strong></span> - Each
          assertion and the test that covers it, if any.</p></li><li><p><span class="bold"><strong>Unmatched Tests</strong></span> - A list of
          tests for which there is no matching assertion (useful during TCK
          development).</p></li><li><p><span class="bold"><strong>Unversioned Tests</strong></span> - A list of
          tests for which there is no <code class="literal">@SpecVersion</code>
          annotation on the test class (useful during TCK development).</p></li></ol></div><p>The coverage report is color coded to indicate the status of an
      assertion, or group of assertions. The status codes are as
      follows:</p><div class="itemizedlist"><ul><li><p><span class="bold"><strong>Covered</strong></span> - a test exists for
          this assertion</p></li><li><p><span class="bold"><strong>Not covered</strong></span> - no test exists
          for this assertion</p></li><li><p><span class="bold"><strong>Problematic</strong></span> - a test exists,
          but is currently disabled. For example, this may be because the test
          is under development</p></li><li><p><span class="bold"><strong>Untestable</strong></span> - the assertion
          has been deemed untestable, a note, explaining why, is normally
          provided</p></li></ul></div><p>For reasons provided in the <code class="literal">tck-audit.xml</code>
      document and presented in the coverage report, some assertions are not
      testable.</p><p>The coverage report does not give any indication as to whether the
      tests are passing. That's where the TestNG reports come in.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e688"/>5.2.3. TestNG Reports</h3></div></div></div><p>As you by now, the Bean Validation TCK test suite is really just a
      TestNG test suite. That means an execution of the Bean Validation TCK
      test suite produces all the same reports that TestNG produces. This
      section will go over those reports and show you were to go to find each
      of them.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e693"/>5.2.3.1. Maven 2, Surefire and TestNG</h4></div></div></div><p>When the Bean Validation TCK test suite is executed during the
        Maven 2 test phase of the TCK runner project, TestNG is invoked
        indirectly through the Maven Surefire plugin. Surefire is a test
        execution abstraction layer capable of executing a mix of tests
        written for JUnit, TestNG, and other supported test frameworks.</p><p>Why is this relevant? It means two things. First, it means that
        you are going to get a summary of the test run on the commandline.
        Here's the output generated when the tests are run using standalone
        mode.</p><pre class="programlisting">-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running TestSuite
Tests run: 237, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 11.062 sec

Results :

Tests run: 237, Failures: 0, Errors: 0, Skipped: 0
</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The number of tests executed, the execution time, and the
          output will differ when you run the tests using in-container mode as
          the Bean Validation TCK requires.</p></div><p>If the Maven reporting plugin that compliments Surefire is
        configured properly, Maven will also generate a generic HTML test
        result report. That report is written to the file test-report.html in
        the target/surefire-reports directory of the TCK runner project. It
        shows how many tests were run, how many failed and the success rate of
        the test run.</p><p>The one drawback of the Maven Surefire report plugin is that it
        buffers the test failures and puts them in the HTML report rather than
        outputting them to the commandline. If you are running the test suite
        to determine if there are any failures, it may be more useful to get
        this information in the foreground. You can prevent the failures from
        being redirected to the report using the following commandline
        switch:</p><pre class="programlisting">mvn test -Dsurefire.useFile=false</pre><p>The information that the Surefire provides is fairly basic and
        the detail pales in comparison to what the native TestNG reports
        provide.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e713"/>5.2.3.2. TestNG HTML Reports</h4></div></div></div><p>TestNG produces several HTML reports for a given test run. All
        the reports can be found in the target/surefire-reports directory in
        the TCK runner project. Below is a list of the three types of
        reports:</p><div class="itemizedlist"><ul><li><p>Test Summary Report</p></li><li><p>Test Suite Detail Report</p></li><li><p>Emailable Report</p></li></ul></div><p>The first report, the test summary report is written to the file
        index.html. It produces the same information as the generic Surefire
        report.The summary report links to the test suite detail report, which
        has a wealth of information. It shows a complete list of test groups
        along with the classes in each group, which groups were included and
        excluded, and any exceptions that were raised, whether from a passed
        or failed test. A partial view of the test suite detail report is
        shown below.</p><p>The test suite detail report is very useful, but it borderlines
        on complex. As an alternative, you can have a look at the emailable
        report, which is a single HTML document that shows much of the same
        information as the test suite detail report in a more compact
        layout.</p></div></div></div></div></div><div class="part" lang="en-US"><div class="titlepage"><div><div><h1 class="title"><a id="d0e734"/>Part II. Executing and Debugging Tests</h1></div></div></div><div class="partintro" lang="en-US"><div/><p>In this part you learn how to execute the Bean Validation TCK on the
    Bean validation reference implementation (Hibernate Validator). You are
    walked through the steps necessary to execute the test suite against
    Hibernate Validator and you discover how to modify the TCK runner to
    execute the test suite against your own implementation. First, however,
    you learn how to pass the Signature Test.</p><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#sigtest">6. Running the Signature Test</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e745">6.1. Obtaining the sigtest tool</a></span></dt><dt><span class="section"><a href="#d0e759">6.2. Creating the signature file</a></span></dt><dt><span class="section"><a href="#d0e785">6.3. Running the signature test</a></span></dt><dt><span class="section"><a href="#d0e797">6.4. Forcing a signature test failure</a></span></dt></dl></dd><dt><span class="chapter"><a href="#executing">7. Executing the Test Suite</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e827">7.1. The Test Suite Runner</a></span></dt><dt><span class="section"><a href="#d0e846">7.2. Running the Tests In Standalone Mode</a></span></dt><dt><span class="section"><a href="#d0e873">7.3. Running the Tests In the Container</a></span></dt><dt><span class="section"><a href="#d0e918">7.4. Dumping the Test Artifacts</a></span></dt></dl></dd></dl></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="sigtest"/>Chapter 6. Running the Signature Test</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e745">6.1. Obtaining the sigtest tool</a></span></dt><dt><span class="section"><a href="#d0e759">6.2. Creating the signature file</a></span></dt><dt><span class="section"><a href="#d0e785">6.3. Running the signature test</a></span></dt><dt><span class="section"><a href="#d0e797">6.4. Forcing a signature test failure</a></span></dt></dl></div><p>One of the requirements of an implementation passing the TCK is for it
  to pass the Bean Validation signature test. This section describes how the
  signature file is generated and how to run it against your
  implementation.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e745"/>6.1. Obtaining the sigtest tool</h2></div></div></div><p>You can obtain the Sigtest tool from the <a class="ulink" href="https://wiki.openjdk.java.net/display/CodeTools/SigTest">Sigtest home
    page</a>. The TCK uses version 3_0-dev-bin-b09-24_apr_2013 which can
    be obtained from the SigTest <a class="ulink" href="http://download.java.net/sigtest/download.html">download page</a>. The
    user guide can be found <a class="ulink" href="http://download.oracle.com/javame/test-tools/sigtest/2_2/sigtest2_2_usersguide.pdf">here</a>
    (the latest published documentation version is 2.2 but this documentation
    still applies to SigTest 3.0 in general). The downloadable package
    contains the jar files used in the commands below.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e759"/>6.2. Creating the signature file</h2></div></div></div><p>The TCK package contains the files
    <code class="filename">validation-api-java5.sig</code>,<code class="filename">
    validation-api-java6.sig</code>,
    <code class="filename">validation-api-java7.sig</code> and
    <code class="filename">validation-api-java8.sig</code> (in the
    <code class="filename">artifacts</code> directory) which were created using the
    following command (using the corresponding Java version):</p><pre class="programlisting">java -jar sigtestdev.jar Setup -classpath $JAVA_HOME/jre/lib/rt.jar:lib/validation-api-1.0.0.GA.jar -package javax.validation -filename validation-api-java6.sig</pre><p>In order to pass the Bean Validation TCK you have to make sure that
    your API passes the signature tests against
    <code class="filename">validation-api.sig.</code></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e785"/>6.3. Running the signature test</h2></div></div></div><p>To run the signature test use:</p><pre class="programlisting">java -jar sigtest.jar Test -classpath $JAVA_HOME/jre/lib/rt.jar:lib/validation-api-1.0.0.GA.jar -static -package javax.validation -filename validation-api-java6.sig</pre><p>You have to chose the right version of the signature file depending
    on your Java version. In order to run against your own Bean Validation API
    replace validation-api-1.0.0.GA.jar with your own API jar. You
    should get the message <code class="literal">"STATUS:Passed."</code>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e797"/>6.4. Forcing a signature test failure</h2></div></div></div><p>Just for fun (and to confirm that the signature test is working
    correctly), you can try the following:</p><p>1) Edit validation-api.sig</p><p>2) Modify one of the class signatures - in the following example we
    change one of the constructors for <code class="literal">ValidationException</code>
    - here's the original:</p><pre class="programlisting">CLSS public javax.validation.ValidationException
cons public ValidationException()
cons public ValidationException(java.lang.String)
cons public ValidationException(java.lang.String,java.lang.Throwable)
cons public ValidationException(java.lang.Throwable)
supr java.lang.RuntimeException</pre><p>Let's change the default (empty) constructor parameter to one with a
    <code class="literal">java.lang.Integer</code> parameter instead:</p><pre class="programlisting">CLSS public javax.validation.ValidationException
cons public ValidationException(java.lang.Integer)
cons public ValidationException(java.lang.String)
cons public ValidationException(java.lang.String,java.lang.Throwable)
cons public ValidationException(java.lang.Throwable)
supr java.lang.RuntimeException</pre><p>3) Now when we run the signature test using the above command, we
    should get the following errors:</p><pre class="programlisting">Missing Constructors
--------------------

javax.validation.ValidationException:   constructor public javax.validation.ValidationException.ValidationException(java.lang.Integer)

Added Constructors
------------------

javax.validation.ValidationException:   constructor public javax.validation.ValidationException.ValidationException()


STATUS:Failed.2 errors
</pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="executing"/>Chapter 7. Executing the Test Suite</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e827">7.1. The Test Suite Runner</a></span></dt><dt><span class="section"><a href="#d0e846">7.2. Running the Tests In Standalone Mode</a></span></dt><dt><span class="section"><a href="#d0e873">7.3. Running the Tests In the Container</a></span></dt><dt><span class="section"><a href="#d0e918">7.4. Dumping the Test Artifacts</a></span></dt></dl></div><p>This chapter explains how to run the TCK on Hibernate Validator as
  well as your own implementation. The Bean Validation TCK uses the Maven 2
  TestNG plugin and the JBoss Test Harness to execute the test suite. Learning
  to execute the test suite from Maven 2 is prerequisite knowlege for running
  the tests in an IDE, such as Eclipse.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e827"/>7.1. The Test Suite Runner</h2></div></div></div><p>The test suite is executed by the Maven 2 TestNG plugin during the
    test phase of the Maven 2 life cycle. The execution happens within a TCK
    runner project (as opposed to the TCK project itself). Hibernate Validator
    includes a TCK runner project (hibernate-validator-tck-runner) that
    executes the Bean Validation TCK on Hibernate Validator running inside
    JBoss AS 5.1. To execute the Bean Validation TCK on your own Bean
    Validation implementation, you could modify the TCK runner project
    included with Hibernate Validator to use your Bean Validation
    implementation as described in <a class="xref" href="#configuration" title="Chapter 4. Configuration">Chapter 4, <i>Configuration</i></a>. </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>For the Bean Validation TCK to run the system property
      <span class="property">validation.provider</span> has to be specified as system
      property. The value has to be the fully specified class name of the
      <code class="classname">ValidationProvider</code> of your Bean Validation
      Implementation. In the case of Hibernate Validator this is
      <code class="classname">org.hibernate.validator.HibernateValidator</code>. This
      applies for standalone as well as in-container mode.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e846"/>7.2. Running the Tests In Standalone Mode</h2></div></div></div><p>To execute the TCK test suite against Bean Validation, first switch
    to the <code class="filename">hibernate-validator-tck-runner </code>directory in
    the checked out Hibernate Validator distribution:</p><pre class="programlisting">cd ri/hibernate-validator-tck-runner</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>These instructions assume you have extracted the Bean Validation
      related software according to the recommendation given in <a class="xref" href="#tck-environment" title="3.2. The TCK Environment">Section 3.2, “The TCK Environment”</a>.</p></div><p>Then execute the Maven 2 life cycle through the test phase:</p><pre class="programlisting">mvn test</pre><p>Without any command-line flags, the test suite is run in standalone
    mode, which means that any test class with the
    <code class="literal">@org.jboss.testharness.impl.packaging.IntegrationTest </code>
    annotation is skipped. This mode uses the
    <code class="literal">StandaloneContainers</code> SPI to invoke the test artifact
    within a mock Java EE life cycle and capture the results of the test.
    However, passing the suite in this mode is not sufficient to pass the TCK
    as a whole. The suite must be passed while executing using the
    in-container mode.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e873"/>7.3. Running the Tests In the Container</h2></div></div></div><p>To execute the test suite using in-container mode with the JBoss TCK
    runner, you first have to setup JBoss AS as described in the <a class="xref" href="#tck-in-jboss-as" title="Running the TCK against the Bean Validation RI (Hibernate Validator) and JBoss AS 7">Running the TCK against the Bean Validation RI (Hibernate
      Validator) and JBoss AS 7</a> callout.</p><p>Then, execute the TCK runner with Maven 2 as follows:</p><pre class="programlisting">mvn test -Dincontainer</pre><p>The presence of the <code class="literal">incontainer</code> property
    activates a Maven 2 profile that assigns the
    <code class="literal">org.jboss.testharness.standalone</code> system property to
    <code class="literal">false</code> and the
    <code class="literal">org.jboss.testharness.runIntegrationTests</code> system
    property to <code class="literal">true</code>, hence activating the in-container
    test mode. This time, all the test artifacts in the test suite are
    executed.</p><p>The in-container profile will also start and stop the application
    server automatically, a feature which the profile activates by setting the
    <code class="literal">org.jboss.testharness.container.forceRestart</code> to
    <code class="literal">true</code>.</p><p>The in-container mode uses the <code class="literal">Containers</code> SPI to
    deploy the test artifact to the container and execute the test in a true
    Java EE life cycle. The JBoss TCK runner has a dependency on the library
    that provides an implementation of this interface for JBoss AS 5.1.</p><p>Since in-container tests are executed in a remote JVM, the results
    of the test must be communicated back to the runner over a
    container-supported protocol. The JBoss Test Harness provides
    servlet-based communication over HTTP as described in <a class="xref" href="#incontainer-communication">Section 8.1, “Negotiating the execution of an
    in-container test”</a>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e918"/>7.4. Dumping the Test Artifacts</h2></div></div></div><p>As you have learned, when the test suite is executing using
    in-container mode, each test class is packaged as a deployable artifact
    and deployed to the container. The test is then executed within the
    context of the deployed application. This leaves room for errors in
    packaging. When investigating a test failure, you may find it helpful to
    inspect the artifact after it's generated. The TCK can accommodate this
    type of inspection by "dumping" the generated artifact to disk.</p><p>The feature just described is activated in the jboss-tck-runner
    project by appending the <code class="literal">dumpArtifacts</code> command line
    property to the end of the command that invokes the Maven 2 test
    phase.</p><pre class="programlisting">mvn test-compile -DdumpArtifacts</pre><p>The directory where the artifacts get written is configured using
    the <code class="literal">org.jboss.testharness.outputDirectory</code> property. The
    <code class="literal">dumpArtifacts</code> profile in the jboss-tck-runner project
    sets this value to the relative directory path
    <code class="literal">target/jsr303-artifacts</code>.</p><p>You can read more about this feature in <a class="xref" href="#dumping-test-artifacts" title="10.2. Dumping the Test Artifacts to Disk">Section 10.2, “Dumping the Test Artifacts to Disk”</a>.</p></div></div></div><div class="part" lang="en-US"><div class="titlepage"><div><div><h1 class="title"><a id="test-harness"/>Part III. JBoss Test Harness</h1></div></div></div><div class="partintro" lang="en-US"><div/><p>In this part you learn about the JBoss Test Harness through selected
    chapters from the JBoss Test Harness Reference Guide. </p><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#test-harness-introduction">8. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#in-container-communication">8.1. Negotiating the execution of an
    in-container test</a></span></dt></dl></dd><dt><span class="chapter"><a href="#test-harness-configuration">9. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#test-harness-properties">9.1. JBoss Test Harness Properties</a></span></dt></dl></dd><dt><span class="chapter"><a href="#executing-test-harness">10. Executing a Test Suite</a></span></dt><dd><dl><dt><span class="section"><a href="#test-suite-runner">10.1. Building a test suite runner using Maven 2</a></span></dt><dt><span class="section"><a href="#dumping-test-artifacts">10.2. Dumping the Test Artifacts to Disk</a></span></dt></dl></dd></dl></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="test-harness-introduction"/>Chapter 8. Introduction</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#in-container-communication">8.1. Negotiating the execution of an
    in-container test</a></span></dt></dl></div><p>This chapter explains the purpose of the test harness and describes
  its key features.</p><p>The JBoss Test Harness is a testing framework based on TestNG that
  provides a series of extensions that allow runtime packaging and deployment
  of Java EE artifacts (EAR or WAR) for in-container testing. It's important
  to note that the JBoss Test Harness has no relation with, or dependency on,
  the JBoss Application Server (JBoss AS).</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>You'll often see the term <span class="italic">in-container</span> used in this reference guide. This
    term refers to running the test suite in any of the aforementioned
    environments, whilst <span class="italic">standalone</span> refers
    to running the tests outside the container via an implementation-specific
    standalone bootstrap. The standalone mode only runs those tests which the
    Bean Validation RI can run without deployment in a Java EE
    container.</p></div><p>The last thing Java developers want is yet another testing framework
  to make their life more complicated. That's why the JBoss Test Harness is
  built entirely upon TestNG. TestNG is one of two prominent test frameworks
  for Java (the other being JUnit). Furthermore, what developers want is a
  good integration with their Integrated Development Environment (IDE). These
  days, if a tool doesn't have an IDE plugin, then it won't get the attention
  it deserves. TestNG plugins are available for all major IDEs and build tools
  (Ant and Maven 2). Again, a motivating factor for extending TestNG.</p><p>Because it leverages the existing TestNG ecosystem, there is no need
  for a special test launcher for the JBoss Test Harness. You simply use the
  IDE or build tool of your choice (so long as it has TestNG support). You
  also get reporting and debugging for free (various reporting plugins are
  provided for TestNG).</p><p>You can read more about TestNG at <a class="ulink" href="http://testng.org/doc/documentation-main.html">testng.org</a>.</p><p>The JBoss Test Harness supports the following features:</p><div class="itemizedlist"><ul><li><p>Test activation via any method supported by the TestNG
      configuration descriptor (package, group, class)</p></li><li><p>Exclusion of in-container tests in standalone mode</p></li><li><p>Exclusion of individual tests labeled as under
      investigation</p></li><li><p>Integration with any TestNG plugin (Eclipse, IntelliJ, Ant,
      Maven)</p></li><li><p>Automated reporting capability as provided by TestNG</p></li><li><p>Standalone and in-container test mode</p></li><li><p>Container pluggability</p></li><li><p>Declarative packaging of additional resources and classes in
      artifact</p></li><li><p>Declarative deployment exception trapping</p></li><li><p>Artifact dumping for failure and packaging analysis</p></li></ul></div><p>A test is designated by a method annotated with
  <code class="literal">@org.testng.annotations.Test</code> in a class which extends
  <code class="literal">org.jboss.testharness.AbstractTest</code> and is annotated with
  <code class="literal">@org.jboss.testharness.impl.packaging.Artifact</code>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Test suites may often choose to extend
    <code class="literal">AbstractTest</code> and require tests to extend that base
    class. In fact, both the CDI TCK and the Bean Validation TCK provide base
    classes that extend <code class="literal">AbstractTest</code> to provide
    functionality specific to the needs of the TCK.</p></div><p>The <code class="literal">@Test</code> annotation is provided by TestNG, the
  <code class="literal">@Artifact</code> annotation is provided by the JBoss Test
  Harness and the <code class="literal">AbstractTest</code> is part of the JBoss Test
  Harness. There is a one-to-one mapping between a TestNG test class and an
  artifact. The packaging type is defined by the
  <code class="literal">@org.jboss.testharness.impl.packaging.Packaging</code>
  annotation on the test class, defaulting to a WAR if not specified.</p><p>Prior to executing the tests for a given class, the JBoss Test Harness
  packages the class as a deployable artifact (EAR or WAR), along with any
  extra resources specified, and deploys the artifact to the container. The
  harness provides test execution and result reporting via HTTP communication
  to a simple Servlet using a thin layer over the TestNG test launcher. The
  test harness can also catch and enforce expected deployment exceptions. This
  setup and tear down activity is provided by the super class
  <code class="literal">org.jboss.testharness.AbstractTest</code>, which all test
  classes must extend (directly or indirectly).</p><p>If the annotation
  <code class="literal">@org.jboss.testharness.impl.packaging.IntegrationTest </code> is
  not present on the test class, then it means the test class can be executed
  in standalone mode. In standalone mode, the deployable artifact is assembled
  on the local classpath and the tests execute in the same JVM as the
  launcher, just as though it were a regular TestNG test case. The standalone
  mode is provided for convenience and efficiency, allowing you the speed of
  mock-based testing and the confidence of an in-container test, using the
  same test objects and tests.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="in-container-communication"/>8.1. Negotiating the execution of an
    in-container test</h2></div></div></div><p>The basic procedure of an in-container test is as follows. The JBoss
    Test Harness produces a deployable artifact from an
    <code class="literal">@Artifact</code> test class and any declared dependent
    classes, descriptors or other resources. Then it deploys the artifact to
    the container using the <code class="literal">Containers</code> SPI, negotiates with
    the container to execute the test and return the result and, finally,
    undeploys the artifact. TestNG collects the results of all the tests run
    in the typical way and produces a report.</p><div align="center"><img src="images/in-container-execution.png" align="middle"/></div><p>The question is, how does the JBoss Test Harness negotiate with the
    container to execute the test when TestNG is being invoked locally?
    Technially the mechanism is pluggable, but JBoss Test Harness provides a
    default implementation that uses HTTP communication that you will likely
    use. Here's how the default implementation works.</p><p>The artifact generator bundles and registers (in the web.xml
    descriptor) an <code class="literal">HttpServlet</code>,
    <code class="literal">org.jboss.testharness.impl.runner.servlet.ServletTestRunner</code>,
    that responds to test execution GET requests. TestNG running on the client
    side delegates to a test launcher (more on that in a moment) which
    originates these text execution requests to transfer control to the
    container JVM. The name of the test method to be executed is specified in
    a request query parameter named <code class="literal">methodName</code>.</p><p>When the test execution request is received, the servlet delegates
    to an instance of
    <code class="literal">org.jboss.testharness.impl.runner.TestRunner</code>, passing
    it the name of the test method. <code class="literal">TestRunner</code> reads the
    name of the test class from the resource
    META-INF/jboss-test-harness.properties, which is bundled in the artifact
    by the artifact generator. It then combines the class name and the method
    name to produce a TestNG test suite and runs the suite (within the context
    of the container).</p><p>TestNG returns the results of the run as an
    <code class="literal">ITestResult</code> object.
    <code class="literal">ServletTestRunner</code> translates this object into a
    <code class="literal">org.jboss.testharness.api.TestResult</code> and passes it back
    to the test launcher on the client side by encoding the translated object
    into the response. The object gets encoded as either html or a serialized
    object, depending on the value of the <code class="literal">outputMode</code>
    request parameter that was passed to the servlet. Once the result has been
    transfered to the client-side TestNG, TestNG wraps up the run of the test
    as though it had been executed in the same JVM.</p><p>There's one piece missing. How does TestNG on the client side know
    to submit a request to the <code class="literal">ServletTestRunner</code> servlet to
    get TestNG to execute the test in the container JVM? That's the role of
    the test launcher.</p><p>The test launcher is the API that allows test suite to launch the
    test in a pluggable fashion. <code class="literal">AbstractTest</code> implements
    <code class="literal">IHookable</code>, a TestNG interface which allows the
    execution of the test method to be intercepted. Using that mechanism,
    <code class="literal">AbstractTest</code> delegates execution of the test method (a
    method annotated with <code class="literal">@Test</code> in an
    <code class="literal">@Artifact</code> class) to an implementation of
    <code class="literal">org.jboss.testharness.api.TestLauncher</code> if the tests are
    being executed in-container. As you might anticipate, the implementation
    is specified using a property with the same name as the interface in a
    META-INF/jboss-test-launcher.properties resource. The JBoss Test Harness
    provides a default implementation,
    <code class="literal">org.jboss.testharness.impl.runner.servlet.ServletTestLauncher</code>,
    that hooks into the HTTP communication infrastructure described above. It
    invokes the <code class="literal">ServletTestRunner</code> servlet for each method
    annotated with <code class="literal">@Test</code> in the
    <code class="literal">@Artifact</code> that is not otherwise disabled.</p><p>If you wish to implement the runner yourself, you must return a
    <code class="literal">TestResult</code> as a result of executing the method in the
    container. You must also ensure that any exception which occurs during
    deployment is wrapped as a
    <code class="literal">org.jboss.testharness.api.DeploymentException</code>, and that
    any communication problem is rethrown as an
    <code class="literal">IOException</code>. The deployment exception may be
    transformed by an implementation of the
    <code class="literal">org.jboss.testharness.api.DeploymentExceptionTransformer
    </code> interface, which is specified using the
    <code class="literal">org.jboss.testharness.container.deploymentExceptionTransformer
    </code> property. The default implementation passes on the original
    exception unchanged. </p><p>So in short, JBoss Test Harness takes care of all the interfaces you
    need to execute tests in-container except for the implementation of the
    <code class="literal">Containers</code> SPI. That is, unless you are deploying to
    one of the containers supported by the JBoss Test Harness.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="test-harness-configuration"/>Chapter 9. Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#test-harness-properties">9.1. JBoss Test Harness Properties</a></span></dt></dl></div><p>
      This chapter lays out how to configure the JBoss Test Harness by
      specifying the API implementation classes, defining the target container
      connection information, and various other switches. Finally, a detailed
      account of how the JBoss Test Harness negotiates the execution of the
      tests in the container is given.
   </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="test-harness-properties"/>9.1. JBoss Test Harness Properties</h2></div></div></div><p>
         The JBoss Test Harness allows the test suite to be launched in a
         pluggable fashion. In order to execute a test suite, the JBoss Test
         Harness must be configured by specifying implementations of the test
         launcher and container APIs.
      </p><p>
         System properties and/or the resource
         <code class="code">META-INF/jboss-test-harness.properties</code>,
         a Java properties file, are used to configure the JBoss Test Harness.
         The bootstrap configuration builder looks to the property
         <code class="literal">org.jboss.testharness.api.ConfigurationBuilder</code>,
         the first property listed in table 3.1, for the fully qualified class
         name (FQCN) of a concrete configuration builder implementation to get
         started. This implementation loads the remaining configuration settings
         and produces a JBoss Test Harness configuration.
      </p><p>
         For you convenience, the default configuration builder implementation
         <code class="literal">org.jboss.testharness.impl.PropertiesBasedConfigurationBuilder
         </code> is provided, which collates all the JBoss Test Harness
         configuration settings from system and Java properties. It does so by
         aggregating the system properties with the properties defined in the
         META-INF/jboss-test-harness.properties resource in any classpath entry
         under a single properties map, allowing you to partition the
         configuration settings as needed.
      </p><p>
         A complete list of configuration properties for the JBoss Test
         Harness
         has been itemized in
         <a class="xref" href="#test-harness-properties-list" title="Table 9.1. JBoss Test Harness Configuration Properties">Table 9.1, “JBoss Test Harness Configuration Properties”</a>,
         accompanied by the default value (if any) and a description for each
         property.
      </p><div class="table"><a id="test-harness-properties-list"/><p class="title"><b>Table 9.1. JBoss Test Harness Configuration Properties</b></p><div class="table-contents"><table summary="JBoss Test Harness Configuration Properties" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Property = Default Value</th><th>Description</th></tr></thead><tbody><tr><td>
                     <code class="literal">org.jboss.testharness.api.ConfigurationBuilder=
                     </code>
                     <code class="literal">org.jboss.testharness.impl.PropertiesBasedConfigurationBuilder
                     </code>
                  </td><td>
                     The configuration bootstrap class for the JBoss Test
                     Harness.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.testPackage=</code>
                  </td><td>
                     The top-level Java package containing classes to be
                     tested. Used to determine which artifacts to dump to disk
                     only; not used during running of a suite.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.libraryDirectory=</code>
                  </td><td>
                     Directory containing extra JARs which should be deployed
                     in
                     the artifact (for example in
                     <code class="literal">WEB-INF/lib</code>.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.standalone=true</code>
                  </td><td>
                     Tests are run using standalone mode if true or using
                     in-container mode if false.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.runIntegrationTests=false
                     </code>
                  </td><td>
                     If true, integration tests are run. In-container mode
                     must be activated.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.spi.Containers=</code>
                  </td><td>
                     The deployment implementation for setting up and
                     tearing down the container and deploying and undeploying
                     in-container tests.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.host=localhost:8080
                     </code>
                  </td><td>
                     The host and port on which the container is running.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.connectDelay=5000</code>
                  </td><td>
                     The timeout (ms) when attempting to connect to the
                     container (e.g. via http).
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.api.TestLauncher=</code>
                  </td><td>
                     The in-container test launcher, the built in
                     <code class="literal">org.jboss.testharness.impl.runner.servlet.ServletTestLauncher
                     </code>
                     is provided and suitable for any Servlet environment.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.container.\</code>
                     <code class="literal">deploymentExceptionTransformer=</code>
                  </td><td>
                     Provides an interception feature for deployment
                     exceptions,
                     allowing them to be inspected and altered before
                     reporting
                     to the test harness for validation by the test
                     case.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.container.forceRestart=false
                     </code>
                  </td><td>
                     Whether the container should be restarted before the
                     tests are executed.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.container.extraConfigurationDir=
                     </code>
                  </td><td>
                     A directory containing a
                     <code class="literal">build.properties</code>
                     or
                     <code class="literal">local.build.properties</code>
                     files that define additional properties. Can be used to
                     provide runtime specific properties.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.spi.StandaloneContainers=
                     </code>
                  </td><td>
                     The container implementation for executing standalone
                     tests.
                  </td></tr><tr><td>
                     <code class="literal">dumpArtifacts=false</code>
                  </td><td>
                     Whether the test artifacts should be written to disk
                     for inspection.
                  </td></tr><tr><td>
                     <code class="literal">org.jboss.testharness.outputDirectory=</code>
                     <code class="literal">%java.io.tmpdir%/jsr-299-tck/</code>
                  </td><td>
                     Directory where test artifacts will be written to disk, if
                     <code class="literal">dumpArtifacts</code>
                     is true.
                  </td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="executing-test-harness"/>Chapter 10. Executing a Test Suite</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#test-suite-runner">10.1. Building a test suite runner using Maven 2</a></span></dt><dt><span class="section"><a href="#dumping-test-artifacts">10.2. Dumping the Test Artifacts to Disk</a></span></dt></dl></div><p>This chapter explains how to execute and debug a test suite built
  using the JBoss Test Harness.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="test-suite-runner"/>10.1. Building a test suite runner using Maven 2</h2></div></div></div><p>The test suite runner project is the magic that makes everything
    come together and allows you to execute the test suite. If you fully
    understand how the JBoss Test Harness functions, and have a good grasp on
    Maven 2, then it's not to difficult to understand how the test suite
    runner project works. Regardless of your background, this guide covers
    what you need to know to get up and running by studying the test suite
    runner used to run the Bean Validation TCK against the Bean Validation RI,
    Hibernate Validator.</p><p>The TCK runner for the Hibernate Validator can be found in the
    <code class="filename">hibernate-validator-tck-runner</code> directory in the
    Hibernate Validator checkout. The dependencies of the TCK runner project
    for Hibernate Validator are listed in <a class="xref" href="#tck-runner-dependencies" title="Table 10.1. Bean Validation TCK Runner Dependencies">Table 10.1, “Bean Validation TCK Runner Dependencies”</a>.</p><div class="table"><a id="tck-runner-dependencies"/><p class="title"><b>Table 10.1. Bean Validation TCK Runner Dependencies</b></p><div class="table-contents"><table summary="Bean Validation TCK Runner Dependencies" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th>Group ID</th><th>Artifact ID</th><th>Version</th></tr></thead><tbody><tr><td>javax.validation</td><td>validation-api</td><td>1.0.0.GA</td></tr><tr><td>org.hibernate</td><td>hibernate-validator</td><td>4.2.0.Final</td></tr><tr><td>org.hibernate.jsr303.tck</td><td>jsr303-tck</td><td>1.0.8.GA</td></tr><tr><td>org.hibernate.javax.persistence</td><td>hibernate-jpa-2.0-api</td><td>1.0.1.Final</td></tr><tr><td>org.sl4j</td><td>slf4j-api, slf4j-simple</td><td>1.6.1</td></tr><tr><td>org.testng</td><td>testng (classifier: jdk15)</td><td>5.8</td></tr><tr><td>org.jboss.jbossas.as7-cdi-tck</td><td>jbossas-container</td><td>1.0.0.Alpha1</td></tr></tbody></table></div></div><br class="table-break"/><p>You can find all of these artifacts in the <a class="ulink" href="http://repository.jboss.org/maven2">JBoss Maven
    repository</a>.</p><p>You should substituate the hibernate-validator artifact from <a class="xref" href="#tck-runner-dependencies" title="Table 10.1. Bean Validation TCK Runner Dependencies">Table 10.1, “Bean Validation TCK Runner Dependencies”</a> with your own artifact. You'll also
    need to replace the jbossas-container artifact if you are not testing your
    implementation on JBoss AS. The jbossas-container artifact contains
    implementations of the <code class="literal">Containers</code> SPI for the JBoss
    Test Harness for JBoss AS 7.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>When running the test suite in the in-container mode, the tests
      will run against libraries installed into the container.</p></div><p>The TCK is executed using the Maven TestNG plugin. Maven 2 profiles
    are used to control the properties that are set at the time of the
    execution. For instance, the <code class="literal">incontainer</code> profile
    enables integration tests and disables standalone mode, changing the
    default settings.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="dumping-test-artifacts"/>10.2. Dumping the Test Artifacts to Disk</h2></div></div></div><p>As you have learned, when the test suite is executing using
    in-container mode, each test class is packaged as a deployable artifact
    and deployed to the container. The test is then executed within the
    context of the deployed application. This leaves room for errors in
    packaging. When investigating a test failure, it's helpful to be able to
    inspect the artifact after it is generated. The JBoss Test Harness can
    accommodate this type of inspection by "dumping" the generated artifact to
    disk.</p><p>If you want to write the artifacts to disk, and avoid executing the
    test suite, you can simply execute the main method of the class
    <code class="literal">org.jboss.testharness.api.TCK</code>. For example you could
    use a Maven profile that is activated when the
    <code class="literal">dumpArtifacts</code> command line property is defined:</p><pre class="programlisting">mvn test-compile -DdumpArtifacts</pre><p>The output directory where the artifacts are written is defined by
    the property
    <code class="literal">org.jboss.testharness.outputDirectory</code>.</p><p>Once the artifact is written to disk, you have an option of manually
    deploying it to the container. You can execute the tests in the artfact by
    requesting the context path of the application in the browser. If you want
    to execute an individual test method, specify the method name in the
    <code class="literal">methodName</code> request parameter (e.g.,
    ?methodName=testMethodName).</p></div></div></div></div><HR xmlns=""/><a xmlns="" href=""><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2009 - 2011 Red Hat, Inc.</p></a></body></html>