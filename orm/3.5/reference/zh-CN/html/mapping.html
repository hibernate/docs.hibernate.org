<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 5 章 对象/关系数据库映射基础（Basic O/R Mapping）</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="persistent-classes.html" title="第 4 章 持久化类（Persistent Classes）"/><link rel="next" href="collections.html" title="第 6 章 集合映射（Collection mappings）"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="persistent-classes.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="collections.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="mapping"/>第 5 章 对象/关系数据库映射基础（Basic O/R Mapping）</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="mapping.html#mapping-declaration">5.1. 映射定义（Mapping declaration）</a></span></dt><dd><dl><dt><span class="section"><a href="mapping.html#mapping-declaration-doctype">5.1.1. Doctype</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-mapping">5.1.2. Hibernate-mapping</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-class">5.1.3. 类</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-id">5.1.4. id</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-id-enhanced">5.1.5. 增强的标识符生成器</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-id-enhanced-optimizers">5.1.6. 标识符生成器的优化</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-compositeid">5.1.7. composite-id</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-discriminator">5.1.8. 鉴别器（discriminator） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-version">5.1.9. 版本（version）（可选） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-timestamp">5.1.10. timestamp（可选) </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-property">5.1.11. Property</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-manytoone">5.1.12. 多对一（many-to-one） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-onetoone">5.1.13. 一对一 </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-naturalid">5.1.14. 自然 ID（natural-id） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-component">5.1.15. 组件（component）和动态组件（dynamic-component） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-properties">5.1.16. 属性（Properties）</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-subclass">5.1.17. 子类（subclass） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-joinedsubclass">5.1.18. 连接的子类（joined-subclass） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-unionsubclass">5.1.19. 联合子类（union-subclass） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-join">5.1.20. 连接（join） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-key">5.1.21. Key</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-column">5.1.22. 字段和规则元素（column and formula elements） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-declaration-import">5.1.23. 引用（import） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-types-anymapping">5.1.24. Any</a></span></dt></dl></dd><dt><span class="section"><a href="mapping.html#mapping-types">5.2. Hibernate 的类型 </a></span></dt><dd><dl><dt><span class="section"><a href="mapping.html#mapping-types-entitiesvalues">5.2.1. 实体（Entities）和值（values）</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-types-basictypes">5.2.2. 基本值类型</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-types-custom">5.2.3. 自定义值类型</a></span></dt></dl></dd><dt><span class="section"><a href="mapping.html#mapping-entityname">5.3. 多次映射同一个类</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-quotedidentifiers">5.4. SQL 中引号包围的标识符</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-alternatives">5.5. 其他元数据（Metadata）</a></span></dt><dd><dl><dt><span class="section"><a href="mapping.html#mapping-xdoclet">5.5.1. 使用 XDoclet 标记</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-annotations">5.5.2. 使用 JDK 5.0 的注解（Annotation）</a></span></dt></dl></dd><dt><span class="section"><a href="mapping.html#mapping-generated">5.6. 数据库生成属性（Generated Properties） </a></span></dt><dt><span class="section"><a href="mapping.html#mapping-column-read-and-write">5.7. 字段的读写表达式</a></span></dt><dt><span class="section"><a href="mapping.html#mapping-database-object">5.8. 辅助数据库对象（Auxiliary Database Objects） </a></span></dt></dl></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-declaration"/>5.1. 映射定义（Mapping declaration）</h2></div></div></div><p>对象和关系数据库之间的映射通常是用一个 XML 文档来定义的。这个映射文档被设计为易读的，并且可以手工修改。映射语言是以 Java 为中心，这意味着映射文档是按照持久化类的定义来创建的，而非表的定义。  </p><p>请注意，虽然很多 Hibernate 用户选择手写 XML 映射文档，但也有一些工具可以用来生成映射文档，包括 XDoclet、Middlegen 和 AndroMDA。 </p><p>下面是一个映射的例子： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">DOCTYPE</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">hibernate-mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">PUBLIC</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_value">&quot;-//Hibernate/Hibernate&nbsp;Mapping&nbsp;DTD&nbsp;3.0//EN&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_value">&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">package</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;eg&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">table</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cats&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">discriminator-value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;C&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;native&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">discriminator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;subclass&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;character&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;weight&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;birthdate&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;date&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">update</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;false&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;color&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;eg.types.ColorUserType&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">update</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;false&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;sex&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">update</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;false&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;litterId&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;litterId&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">update</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;false&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;mother&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;mother_id&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">update</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;false&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;kittens&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">inverse</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">order-by</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;litter_id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;mother_id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">discriminator-value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;D&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;name&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;string&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Dog&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;mapping&nbsp;for&nbsp;Dog&nbsp;could&nbsp;go&nbsp;here&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>我们现在开始讨论映射文档的内容。我们只描述 Hibernate 在运行时用到的文档元素和属性。映射文档还包括一些额外的可选属性和元素，它们在使用 schema 导出工具的时候会影响导出的数据库 schema 结果（比如，<code class="literal">not-null</code> 属性）。 </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-doctype"/>5.1.1. Doctype</h3></div></div></div><p>所有的 XML 映射都需要定义如上所示的 doctype。DTD 可以从上述 URL 中获取，也可以从 <code class="literal">hibernate-x.x.x/src/org/hibernate </code> 目录中、或 <code class="literal">hibernate.jar</code> 文件中找到。Hibernate 总是会首先在它的 classptah 中搜索 DTD 文件。如果你发现它是通过连接 Internet 查找 DTD 文件，就对照你的 classpath 目录检查 XML 文件里的 DTD 声明。 </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-entity-resolution"/>5.1.1.1. EntityResolver</h4></div></div></div><p>Hibernate 首先试图在其 classpath 中解析 DTD。这是依靠在系统中注册的 <code class="literal">org.xml.sax.EntityResolver</code> 的一个具体实现，SAXReader 依靠它来读取 xml 文件。这个自定义的 <code class="literal">EntityResolver</code> 能辨认两种不同的 systenId 命名空间： </p><div class="itemizedlist"><ul><li><p>若 resolver 遇到了一个以 <code class="literal">http://hibernate.sourceforge.net/</code> 为开头的 systemId，它会辨认出是 <code class="literal">hibernate namespace</code>，resolver 就试图通过加载 Hibernate 类的 classloader 来查找这些实体。  </p></li><li><p>若 resolver 遇到了一个使用 <code class="literal">classpath://</code> URL 协议的 systemId，它会辨认出这是 <code class="literal">user namespace</code>，resolver 试图通过（1) 当前线程上下文的 classloader 和（2) 加载 Hibernate class 的 classloader 来查找这些实体。 </p></li></ul></div><p>下面是一个使用用户命名空间（user namespace）的例子： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">DOCTYPE</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">hibernate-mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">PUBLIC</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_value">'-//Hibernate/Hibernate&nbsp;Mapping&nbsp;DTD&nbsp;3.0//EN'</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_value">'http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd'</span><span class="xml_plain">&nbsp;[</span><br />
<span class="xml_plain">&lt;!</span><span class="xml_attribute_name">ENTITY</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">version</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_value">&quot;3.5.6-Final&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">ENTITY</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">today</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_value">&quot;September&nbsp;15,&nbsp;2010&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">ENTITY</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">types</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">SYSTEM</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_value">&quot;classpath://your/domain/types.xml&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">]&gt;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">package</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;your.domain&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;MyEntity&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;my-custom-id-type&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&amp;types;</span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
</pre><p>这里的 <code class="literal">types.xml</code> 是 <code class="literal">your.domain</code> 包中的一个资源，它包含了一个自定义的 <a class="link" href="mapping.html#mapping-types-custom" title="5.2.3. 自定义值类型">typedef</a>。  </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-mapping"/>5.1.2. Hibernate-mapping</h3></div></div></div><p>这个元素包括一些可选的属性。<code class="literal">schema</code> 和 <code class="literal">catalog</code> 属性， 指明了这个映射所连接（refer）的表所在的 schema 和/或 catalog 名称。假若指定了这个属性，表名会加上所指定的 schema 和 catalog 的名字扩展为全限定名。假若没有指定，表名就不会使用全限定名。<code class="literal">default-cascade</code> 指定了未明确注明 <code class="literal">cascade</code> 属性的 Java 属性和 集合类 Hibernate 会采取什么样的默认级联风格。<code class="literal">auto-import</code> 属性默认让我们在查询语言中可以使用非全限定名的类名。 </p><div class="programlistingco"><pre class="programlisting">&lt;hibernate-mapping
         schem<span xmlns="" class="co" id="hm1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>a="schemaName"
         catal<span xmlns="" class="co" id="hm2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>og="catalogName"
         defau<span xmlns="" class="co" id="hm3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>lt-cascade="cascade_style"
         defau<span xmlns="" class="co" id="hm4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>lt-access="field|property|ClassName"
         defau<span xmlns="" class="co" id="hm5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>lt-lazy="true|false"
         auto-<span xmlns="" class="co" id="hm6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>import="true|false"
         packa<span xmlns="" class="co" id="hm7"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>ge="package.name"
 /&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">schema</code>（可选）：数据库 schema 的名称。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">catalog</code>（可选）：数据库 catalog 的名称。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">default-cascade</code>（可选 — 默认为 <code class="literal">none</code>）：默认的级联风格。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">default-access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问所有属性的策略。可以通过实现 <code class="literal">PropertyAccessor</code> 接口自定义。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">default-lazy</code>（可选 — 默认为 <code class="literal">true</code>）：指定了未明确注明 <code class="literal">lazy</code> 属性的 Java 属性和集合类，Hibernate 会采取什么样的默认加载风格。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">auto-import</code>（可选 — 默认为 <code class="literal">true</code>）：指定我们是否可以在查询语言中使用非全限定的类名（仅限于本映射文件中的类）。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">package</code>（可选）：指定一个包前缀，如果在映射文档中没有指定全限定的类名，就使用这个作为包名。  </p></td></tr></table></div></div><p>假若你有两个持久化类，它们的非全限定名是一样的（就是两个类的名字一样，所在的包不一样 — 译者注），你应该设置 <code class="literal">auto-import="false"</code>。如果你把一个“导入过”的名字同时对应两个类，Hibernate 会抛出一个异常。 </p><p>注意 <code class="literal">hibernate-mapping</code> 元素允许你嵌套多个如上所示的 <code class="literal">&lt;class&gt;</code> 映射。但是最好的做法（也许一些工具需要的）是一个持久化类（或一个类的继承层次）对应一个映射文件，并以持久化的超类名称命名，例如：<code class="literal">Cat.hbm.xml</code>、<code class="literal">Dog.hbm.xml</code>，或者如果使用继承，<code class="literal">Animal.hbm.xml</code>。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-class"/>5.1.3. 类</h3></div></div></div><p>你可以使用 <code class="literal">class</code> 元素来定义一个持久化类。例如： </p><div class="programlistingco"><pre class="programlisting">&lt;class
        name="<span xmlns="" class="co" id="class1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>ClassName"
        table=<span xmlns="" class="co" id="class2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>"tableName"
        discri<span xmlns="" class="co" id="class3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>minator-value="discriminator_value"
        mutabl<span xmlns="" class="co" id="class4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>e="true|false"
        schema<span xmlns="" class="co" id="class5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>="owner"
        catalo<span xmlns="" class="co" id="class6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>g="catalog"
        proxy=<span xmlns="" class="co" id="class7"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>"ProxyInterface"
        dynami<span xmlns="" class="co" id="class8"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>c-update="true|false"
        dynami<span xmlns="" class="co" id="class9"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>c-insert="true|false"
        select<span xmlns="" class="co" id="class10"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>-before-update="true|false"
        polymo<span xmlns="" class="co" id="class11"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>rphism="implicit|explicit"
        where=<span xmlns="" class="co" id="class12"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>"arbitrary sql where condition"
        persis<span xmlns="" class="co" id="class13"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>ter="PersisterClass"
        batch-<span xmlns="" class="co" id="class14"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>size="N"
        optimi<span xmlns="" class="co" id="class15"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>stic-lock="none|version|dirty|all"
        lazy="<span xmlns="" class="co" id="class16">(16)</span>true|false"
        entity<span xmlns="" class="co" id="class17">(17)</span>-name="EntityName"
        check=<span xmlns="" class="co" id="class18">(18)</span>"arbitrary sql check condition"
        rowid=<span xmlns="" class="co" id="class19">(19)</span>"rowid"
        subsel<span xmlns="" class="co" id="class20">(20)</span>ect="SQL expression"
        abstra<span xmlns="" class="co" id="class21">(21)</span>ct="true|false"
        node="element-name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>（可选）：持久化类（或者接口）的 Java 全限定名。 如果这个属性不存在，Hibernate 将假定这是一个非 POJO 的实体映射。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">table</code>（可选 — 默认是类的非全限定名）：对应的数据库表名。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">discriminator-value</code>（可选 — 默认和类名一样）：一个用于区分不同的子类的值，在多态行为时使用。它可以接受的值包括 <code class="literal">null</code> 和 <code class="literal">not null</code>。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">mutable</code>（可选，默认值为 <code class="literal">true</code>）：表明该类的实例是可变的或者不可变的。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">schema</code>（可选）：覆盖在根 <code class="literal">&lt;hibernate-mapping&gt;</code> 元素中指定的 schema 名字。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">catalog</code>（可选）：覆盖在根 <code class="literal">&lt;hibernate-mapping&gt;</code> 元素中指定的 catalog 名字。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">proxy</code>（可选）：指定一个接口，在延迟装载时作为代理使用。你可以在这里使用该类自己的名字。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">dynamic-update</code>（可选，默认为 <code class="literal">false</code>）：指定用于 <code class="literal">UPDATE</code> 的 SQL 将会在运行时动态生成，并且只更新那些改变过的字段。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">dynamic-insert</code>（可选，默认为 <code class="literal">false</code>）：指定用于 <code class="literal">INSERT</code> 的 SQL 将会在运行时动态生成，并且只包含那些非空值字段。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">select-before-update</code>（可选，默认为 <code class="literal">false</code>）：指定 Hibernate 除非确定对象真正被修改了（如果该值为 true — 译注），否则<span class="emphasis"><em>不会</em></span>执行 SQL <code class="literal">UPDATE</code> 操作。在特定场合（实际上，它只在一个瞬时对象（transient object）关联到一个新的 session 中时执行的 update() 中生效），这说明 Hibernate 会在 <code class="literal">UPDATE</code> 之前执行一次额外的 SQL <code class="literal">SELECT</code> 操作来决定是否确实需要执行 <code class="literal">UPDATE</code>。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">polymorphism（多态）</code>（可选，默认值为 <code class="literal">implicit （隐式）</code>）：界定是隐式还是显式的使用多态查询（这只在 Hibernate 的具体表继承策略中用到 — 译注）。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">where</code>（可选）指定一个附加的 SQL <code class="literal">WHERE</code> 条件，在抓取这个类的对象时会一直增加这个条件。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">persister</code>（可选）：指定一个定制的 <code class="literal">ClassPersister</code>。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">batch-size</code>（可选,默认是 <code class="literal">1</code>）指定一个用于 根据标识符（identifier）抓取实例时使用的 "batch size"（批次抓取数量）。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">optimistic-lock（乐观锁定）</code>（可选，默认是 <code class="literal">version</code>）：决定乐观锁定的策略。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p>(16)</p></td><td valign="top" align="left"><p><code class="literal">lazy</code>（可选）：通过设置 <code class="literal">lazy="false"</code>，所有的延迟加载（Lazy fetching）功能将被全部禁用（disabled）。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p>(17)</p></td><td valign="top" align="left"><p><code class="literal">entity-name</code> (optional - defaults to the class name): Hibernate3 allows a class to be mapped multiple times, potentially to different tables. It also allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <a class="xref" href="persistent-classes.html#persistent-classes-dynamicmodels" title="4.4. 动态模型（Dynamic models）">第 4.4 节 “动态模型（Dynamic models）”</a> and <a class="xref" href="xml.html" title="第 19 章 XML 映射">第 19 章 <i>XML 映射</i></a> for more information. </p></td></tr><tr><td width="5%" valign="top" align="left"><p>(18)</p></td><td valign="top" align="left"><p><code class="literal">check</code>（可选）：这是一个 SQL 表达式， 用于为自动生成的 schema 添加多行（multi-row）约束<span class="emphasis"><em>检查</em></span>。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p>(19)</p></td><td valign="top" align="left"><p><code class="literal">rowid</code>（可选）：Hibernate 可以使用数据库支持的所谓的 ROWIDs，例如：Oracle 数据库，如果你设置这个可选的 <code class="literal">rowid</code>，Hibernate 可以使用额外的字段 <code class="literal">rowid</code> 实现快速更新。ROWID 是这个功能实现的重点，它代表了一个存储元组（tuple）的物理位置。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p>(20)</p></td><td valign="top" align="left"><p><code class="literal">subselect</code>（可选）：它将一个不可变（immutable）并且只读的实体映射到一个数据库的子查询中。当你想用视图代替一张基本表的时候，这是有用的，但最好不要这样做。更多的介绍请看下面内容。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p>(21)</p></td><td valign="top" align="left"><p><code class="literal">abstract</code>（可选）：用于在 <code class="literal">&lt;union-subclass&gt;</code> 的层次结构（hierarchies）中标识抽象超类。 </p></td></tr></table></div></div><p>若指明的持久化类实际上是一个接口，这也是完全可以接受的。之后你可以用元素 <code class="literal">&lt;subclass&gt;</code> 来指定该接口的实际实现类。你可以持久化任何 <span class="emphasis"><em>static</em></span>（静态的）内部类。你应该使用标准的类名格式来指定类名，比如：<code class="literal">Foo$Bar</code>。 </p><p>不可变类，<code class="literal">mutable="false"</code> 不可以被应用程序更新或者删除。这允许 Hibernate 实现一些小小的性能优化。 </p><p>可选的 <code class="literal">proxy</code> 属性允许延迟加载类的持久化实例。Hibernate 开始会返回实现了这个命名接口的 CGLIB 代理。当代理的某个方法被实际调用的时候，真实的持久化对象才会被装载。参见下面的“用于延迟装载的代理”。  </p><p><span class="emphasis"><em>Implicit</em></span>（隐式）的多态是指，如果查询时给出的是任何超类、该类实现的接口或者该类的名字，都会返回这个类的实例；如果查询中给出的是子类的名字，则会返回子类的实例。<span class="emphasis"><em>Explicit</em></span>（显式）的多态是指，只有在查询时给出明确的该类名字时才会返回这个类的实例； 同时只有在这个 <code class="literal">&lt;class&gt;</code> 的定义中作为 <code class="literal">&lt;subclass&gt;</code> 或者 <code class="literal">&lt;joined-subclass&gt;</code> 出现的子类，才会可能返回。在大多数情况下，默认的 <code class="literal">polymorphism="implicit"</code> 都是合适的。显式的多态在有两个不同的类映射到同一个表的时候很有用。（允许一个“轻量级”的类，只包含部分表字段）。  </p><p><code class="literal">persister</code> 属性可以让你定制这个类使用的持久化策略。你可以指定你自己实现 <code class="literal">org.hibernate.persister.EntityPersister</code> 的子类，你甚至可以完全从头开始编写一个 <code class="literal">org.hibernate.persister.ClassPersister</code> 接口的实现，比如是用储存过程调用、序列化到文件或者 LDAP 数据库来实现。参阅 <code class="literal">org.hibernate.test.CustomPersister</code>，这是持久化到 <code class="literal">Hashtable</code> 的一个简单例子。  </p><p>请注意 <code class="literal">dynamic-update</code> 和 <code class="literal">dynamic-insert</code> 的设置并不会继承到子类，所以在 <code class="literal">&lt;subclass&gt;</code> 或者 <code class="literal">&lt;joined-subclass&gt;</code> 元素中可能需要再次设置。这些设置在某些情况下能够提高效率，而其他情况下则反而可能降低性能。 </p><p>使用 <code class="literal">select-before-update</code> 通常会降低性能。如果你重新连接一个脱管（detached）对象实例 到一个 <code class="literal">Session</code> 中时，它可以防止数据库不必要的触发 update。这就很有用了。 </p><p>如果你打开了<code class="literal">dynamic-update</code>，你可以选择几种乐观锁定的策略： </p><div class="itemizedlist"><ul><li><p><code class="literal">version（版本检查）</code>：检查 version/timestamp 字段 </p></li><li><p><code class="literal">all（全部）</code>：检查全部字段 </p></li><li><p><code class="literal">dirty（脏检查）</code>：只检察修改过的字段，允许某些并行更新 </p></li><li><p><code class="literal">none（不检查）</code>：不使用乐观锁定 </p></li></ul></div><p>我们<span class="emphasis"><em>强烈</em></span>建议你在 Hibernate 中使用 version/timestamp 字段来进行乐观锁定。这个选择可以优化性能，且能够处理对脱管实例的修改（例如：在使用 <code class="literal">Session.merge()</code> 的时候）。 </p><p>对 Hibernate 映射来说视图和表是没有区别的，这是因为它们在数据层都是透明的（ 注意：一些数据库不支持视图属性，特别是更新的时候）。有时你想使用视图，但却不能在数据库中创建它（例如：在遗留的 schema 中）。这样的话，你可以映射一个不可变的（immutable）并且是 只读的实体到一个给定的 SQL 子查询表达式：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Summary&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">subselect</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select&nbsp;item.name,&nbsp;max(bid.amount),&nbsp;count(*)</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;item</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;join&nbsp;bid&nbsp;on&nbsp;bid.item_id&nbsp;=&nbsp;item.id</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;group&nbsp;by&nbsp;item.name</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">subselect</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">synchronize</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">table</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;item&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">synchronize</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">table</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;bid&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;name&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>定义这个实体用到的表为同步（synchronize），确保自动刷新（auto-flush）正确执行，并且依赖原实体的查询不会返回过期数据。在属性元素和嵌套映射元素中都可使用 <code class="literal">&lt;subselect&gt;</code>。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id"/>5.1.4. id</h3></div></div></div><p>被映射的类<span class="emphasis"><em>必须</em></span>定义对应数据库表主键字段。大多数类有一个 JavaBeans 风格的属性， 为每一个实例包含唯一的标识。<code class="literal">&lt;id&gt;</code> 元素定义了该属性到数据库表主键字段的映射。 </p><div class="programlistingco"><pre class="programlisting">&lt;id
        name="<span xmlns="" class="co" id="id1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>propertyName"
        type="<span xmlns="" class="co" id="id2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>typename"
        column<span xmlns="" class="co" id="id3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>="column_name"
        unsave<span xmlns="" class="co" id="id4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>d-value="null|any|none|undefined|id_value"
        access<span xmlns="" class="co" id="id5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>="field|property|ClassName"&gt;
        node="element-name|@attribute-name|element/@attribute|."

        &lt;generator class="generatorClass"/&gt;
&lt;/id
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>（可选）：标识属性的名字。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">type</code>（可选）：一个 Hibernate 类型的名字。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">column</code>（可选 — 默认为属性名）：主键字段的名字。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code>（可选 — 默认为一个切合实际（sensible）的值）：一个特定的标识属性值，用来标志该实例是刚刚创建的，尚未保存。这可以把这种实例和从以前的 session 中装载过（可能又做过修改--译者注）但未再次持久化的实例区分开来。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问属性值的策略。  </p></td></tr></table></div></div><p>如果 <code class="literal">name</code> 属性不存在，会认为这个类没有标识属性。 </p><p><code class="literal">unsaved-value</code> 属性在 Hibernate3 中几乎不再需要。 </p><p>还有一个另外的 <code class="literal">&lt;composite-id&gt;</code> 定义可以访问旧式的多主键数据。我们非常不鼓励使用这种方式。 </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-generator"/>5.1.4.1. Generator</h4></div></div></div><p>可选的 <code class="literal">&lt;generator&gt;</code> 子元素是一个 Java 类的名字，用来为该持久化类的实例生成唯一的标识。如果这个生成器实例需要某些配置值或者初始化参数，用 <code class="literal">&lt;param&gt;</code> 元素来传递。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;long&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cat_id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.id.TableHiLoGenerator&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;table&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">uid_table</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;column&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">next_hi_value_column</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">generator</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>所有的生成器都实现 <code class="literal">org.hibernate.id.IdentifierGenerator</code> 接口。这是一个非常简单的接口；某些应用程序可以选择提供他们自己特定的实现。当然，Hibernate 提供了很多内置的实现。下面是一些内置生成器的快捷名字：   </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">increment</code></span></dt><dd><p>用于为 <code class="literal">long</code>, <code class="literal">short</code> 或者 <code class="literal">int</code> 类型生成 唯一标识。只有在没有其他进程往同一张表中插入数据时才能使用。<span class="emphasis"><em>在集群下不要使用。</em></span> </p></dd><dt><span class="term"><code class="literal">identity</code></span></dt><dd><p>对 DB2，MySQL，MS SQL Server，Sybase 和 HypersonicSQL 的内置标识字段提供支持。返回的标识符是 <code class="literal">long</code>，<code class="literal">short</code> 或者 <code class="literal">int</code> 类型的。 </p></dd><dt><span class="term"><code class="literal">sequence</code></span></dt><dd><p>在 DB2，PostgreSQL，Oracle，SAP DB，McKoi 中使用序列（sequence）， 而在 Interbase 中使用生成器（generator）。返回的标识符是 <code class="literal">long</code>，<code class="literal">short</code> 或者 <code class="literal">int</code> 类型的。 </p></dd><dt><span class="term"><code class="literal">hilo</code></span></dt><dd><p><a id="mapping-declaration-id-hilodescription"/>使用一个高/低位算法高效的生成 <code class="literal">long</code>，<code class="literal">short</code> 或者 <code class="literal">int</code> 类型的标识符。给定一个表和字段（默认分别是 <code class="literal">hibernate_unique_key</code> 和 <code class="literal">next_hi</code>）作为高位值的来源。高/低位算法生成的标识符只在一个特定的数据库中是唯一的。 </p></dd><dt><span class="term"><code class="literal">seqhilo</code></span></dt><dd><p>使用一个高/低位算法来高效的生成 <code class="literal">long</code>，<code class="literal">short</code> 或者 <code class="literal">int</code> 类型的标识符，给定一个数据库序列（sequence)的名字。 </p></dd><dt><span class="term"><code class="literal">uuid</code></span></dt><dd><p>用一个 128-bit 的 UUID 算法生成字符串类型的标识符，这在一个网络中是唯一的（使用了 IP 地址）。UUID 被编码为一个 32 位 16 进制数字的字符串。  </p></dd><dt><span class="term"><code class="literal">guid</code></span></dt><dd><p>在 MS SQL Server 和 MySQL 中使用数据库生成的 GUID 字符串。 </p></dd><dt><span class="term"><code class="literal">native</code></span></dt><dd><p>根据底层数据库的能力选择 <code class="literal">identity</code>、<code class="literal">sequence</code> 或者 <code class="literal">hilo</code> 中的一个。 </p></dd><dt><span class="term"><code class="literal">assigned</code></span></dt><dd><p>让应用程序在调用 <code class="literal">save()</code> 之前为对象分配一个标识符。这是 <code class="literal">&lt;generator&gt;</code> 元素没有指定时的默认生成策略。 </p></dd><dt><span class="term"><code class="literal">select</code></span></dt><dd><p>通过数据库触发器选择一些唯一主键的行并返回主键值来分配一个主键。  </p></dd><dt><span class="term"><code class="literal">foreign</code></span></dt><dd><p>使用另外一个相关联的对象的标识符。它通常和 <code class="literal">&lt;one-to-one&gt;</code> 联合起来使用。 </p></dd><dt><span class="term"><code class="literal">sequence-identity</code></span></dt><dd><p>一种特别的序列生成策略，它使用数据库序列来生成实际值，但将它和 JDBC3 的 getGeneratedKeys 结合在一起，使得在插入语句执行的时候就返回生成的值。目前为止只有面向 JDK 1.4 的 Oracle 10g 驱动支持这一策略。由于 Oracle 驱动程序的一个 bug，这些插入语句的注释被关闭了。 </p></dd></dl></div><p>

                </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-hilo"/>5.1.4.2. 高/低位算法（Hi/Lo Algorithm）</h4></div></div></div><p><code class="literal">hilo</code> 和 <code class="literal">seqhilo</code> 生成器给出了两种 hi/lo 算法的实现， 这是一种很令人满意的标识符生成算法。第一种实现需要一个“特殊”的数据库表来保存下一个可用的“hi”值。 第二种实现使用一个 Oracle 风格的序列（在被支持的情况下）。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;long&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cat_id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;hilo&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;table&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">hi_value</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;column&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">next_value</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;max_lo&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">100</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">generator</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;long&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;cat_id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;seqhilo&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;sequence&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">hi_value</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;max_lo&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">100</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">generator</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>可惜的是，你在为 Hibernate 自行提供 <code class="literal">Connection</code> 时无法使用 <code class="literal">hilo</code>。 当 Hibernate 使用 JTA 获取应用服务器的数据源连接时，你必须正确地配置 <code class="literal">hibernate.transaction.manager_lookup_class</code>。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-uuid"/>5.1.4.3. UUID 算法（UUID Algorithm ）</h4></div></div></div><p>UUID 包含：IP 地址、JVM 的启动时间（精确到 1/4 秒）、系统时间和一个计数器值（在 JVM 中唯一）。 在 Java 代码中不可能获得 MAC 地址或者内存地址，所以这已经是我们在不使用 JNI 的前提下的能做的最好实现了。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-sequences"/>5.1.4.4. 标识字段和序列（Identity columns and Sequences）</h4></div></div></div><p>对于内部支持标识字段的数据库（DB2、MySQL、Sybase 和 MS SQL），你可以使用 <code class="literal">identity</code> 关键字生成。对于内部支持序列的数据库（DB2、Oracle、PostgreSQL、Interbase、McKoi 和 SAP DB），你可以使用 <code class="literal">sequence</code> 风格的关键字生成。这两种方式对于插入一个新的对象都需要两次 SQL 查询。例如： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;long&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;person_id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;sequence&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;sequence&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">person_id_sequence</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">generator</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;long&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;person_id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">unsaved-value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;0&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;identity&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>对于跨平台开发，<code class="literal">native</code> 策略会从 <code class="literal">identity</code>、<code class="literal">sequence</code> 和 <code class="literal">hilo</code> 中进行选择，选择哪一个，这取决于底层数据库的支持能力。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-assigned"/>5.1.4.5. 程序分配的标识符（Assigned Identifiers）</h4></div></div></div><p>如果你需要应用程序分配一个标示符（而非 Hibernate 来生成），你可以使用 <code class="literal">assigned</code> 生成器。这种特殊的生成器会使用已经分配给对象的标识符属性的标识符值。 这个生成器使用一个自然键（natural key，有商业意义的列－译注）作为主键，而不是使用一个代理键（ surrogate key，没有商业意义的列－译注）。这是没有指定 <code class="literal">&lt;generator&gt;</code> 元素时的默认行为。 </p><p>当选择 <code class="literal">assigned</code> 生成器时，除非有一个 version 或 timestamp 属性，或者你定义了 <code class="literal">Interceptor.isUnsaved()</code>，否则需要让 Hiberante 使用 <code class="literal">unsaved-value="undefined"</code>，强制 Hibernatet 查询数据库来确定一个实例是瞬时的（transient） 还是脱管的（detached）。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="mapping-declaration-id-select"/>5.1.4.6. 触发器实现的主键生成器（Primary keys assigned by triggers）</h4></div></div></div><p>仅仅用于遗留的 schema 中（Hibernate 不能用触发器生成 DDL）。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;long&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;person_id&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;select&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;key&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">socialSecurityNumber</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">generator</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>在上面的例子中，类定义了一个命名为 <code class="literal">socialSecurityNumber</code> 的具有唯一值的属性，它是一个自然键（natural key），命名为 <code class="literal">person_id</code> 的代理键（surrogate key）的值由触发器生成。 </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced"/>5.1.5. 增强的标识符生成器</h3></div></div></div><p>从 3.2.3 版本开始，有两个代表不同标识符生成概念的新的生成器。第一个概念是数据库移植性；第二个是优化。优化表示你不需对每个新标识符的请求都查询数据库。从 3.3.x 开始，这两个新的生成器都是用来取代上面所述的生成器的。然而，它们也包括在当前版本里且可以由 FQN 进行引用。 </p><p>这些生成器的第一个是 <code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code>，首先，它是作为 <code class="literal">sequence</code> 生成器的替代物，其次，它是比 <code class="literal">native</code> 具有更好移植性的生成器。这是因为 <code class="literal">native</code> 通常在 <code class="literal">identity</code> 和 <code class="literal">sequence</code> 之间选择，它有差别很大的 semantic，在移植时会导致潜在的问题。然而，<code class="literal">org.hibernate.id.enhanced.SequenceStyleGenerator</code> 以不同的方式实现移植性。它根据所使用的方言的能力，在数据库表或序列之间选择以存储其增量。这和 <code class="literal">native</code> 的区别是基于表或序列的存储具有恰好相同的 semantic。实际上，序列就是 Hibernate 试图用基于表的生成器来模拟的。这个生成器有如下的配置参数： </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">sequence_name</code>（可选 — 默认为 <code class="literal">hibernate_sequence</code>）：序列或表的名字 </p></li><li><p><code class="literal">initial_value</code>（可选，默认为 <code class="literal">1</code>）：从序列/表里获取的初始值。按照序列创建的术语，这等同于子句 "STARTS WITH"。 </p></li><li><p><code class="literal">increment_size</code>（可选 - 缺省为 <code class="literal">1</code>）：对序列/表的调用应该区分的值。按照序列创建的术语，这等同于子句 "INCREMENT BY"。 </p></li><li><p><code class="literal">force_table_use</code>（可选 - 缺省为 <code class="literal">false</code>）：即使方言可能支持序列，是否也应该强制把表用作后台结构。 </p></li><li><p><code class="literal">value_column</code>（可选 - 缺省为 <code class="literal">next_val</code>）：只和表结构相关，它是用于保存值的字段的名称。 </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal">none</code>): See <a class="xref" href="mapping.html#mapping-declaration-id-enhanced-optimizers" title="5.1.6. 标识符生成器的优化">第 5.1.6 节 “标识符生成器的优化”</a> </p></li></ul></div><p>
            </p><p>新生成器的第二个是 <code class="literal">org.hibernate.id.enhanced.TableGenerator</code>，它的目的首先是替代 <code class="literal">table</code> 生成器，即使它实际上比 <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code> 功能要强得多；其次，作为利用可插拔 optimizer 的 <code class="literal">org.hibernate.id.MultipleHiLoPerTableGenerator</code> 的替代品。基本上这个生成器定义了一个可以利用多个不同的键值记录存储大量不同增量值的表。这个生成器有如下的配置参数： </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">table_name</code>（可选 — 默认是 <code class="literal">hibernate_sequences</code>）：所用的表的名称。 </p></li><li><p><code class="literal">value_column_name</code>（可选 — 默认为 <code class="literal">next_val</code>）：用于存储这些值的表的字段的名字。 </p></li><li><p><code class="literal">segment_column_name</code>（可选，默认为 <code class="literal">sequence_name</code>）：用于保存 "segment key" 的字段的名称。这是标识使用哪个增量值的值。 </p></li><li><p><code class="literal">segment_value</code>（可选，默认为 <code class="literal">default</code>）：我们为这个生成器获取增量值的 segment 的 "segment key"。 </p></li><li><p><code class="literal">segment_value_length</code>（可选 — 默认为 <code class="literal">255</code>）：用于 schema 生成；创建 Segment Key 字段的字段大小。 </p></li><li><p><code class="literal">initial_value</code>（可选 — 默认是 <code class="literal">1</code>）：从表里获取的初始值。 </p></li><li><p><code class="literal">increment_size</code>（可选 — 默认是 <code class="literal">1</code>）：对表随后的调用应该区分的值。 </p></li><li><p><code class="literal">optimizer</code> (optional - defaults to <code class="literal"/>): See <a class="xref" href="mapping.html#mapping-declaration-id-enhanced-optimizers" title="5.1.6. 标识符生成器的优化">第 5.1.6 节 “标识符生成器的优化”</a> </p></li></ul></div><p>
            </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-id-enhanced-optimizers"/>5.1.6. 标识符生成器的优化</h3></div></div></div><p>For identifier generators that store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you can group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<a class="xref" href="mapping.html#mapping-declaration-id-enhanced" title="5.1.5. 增强的标识符生成器">第 5.1.5 节 “增强的标识符生成器”</a> support this operation. </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">none</code>（如果没有指定 optimizer，通常这是缺省配置）：这不会执行任何优化，在每次请求时都访问数据库。 </p></li><li><p><code class="literal">hilo</code>：对从数据库获取的值应用 hi/lo 算法。用于这个 optimizer 的从数据库获取的值应该是有序的。它们表明“组编号”。<code class="literal">increment_size</code> 将乘以内存里的值来定义组的“hi 值”。 </p></li><li><p><code class="literal">pooled</code>：和 <code class="literal">hilo</code> 一样，这个 optimizer 试图最小化对数据库的访问。然而，我们只是简单地把“下一组”的起始值而不是把序列值和分组算法的组合存入到数据库结构里。在这里，<code class="literal">increment_size</code> 表示数据库里的值。 </p></li></ul></div><p>
            </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-compositeid"/>5.1.7. composite-id</h3></div></div></div><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">composite-id</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;propertyName&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ClassName&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">mapped</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true|false&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">access</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;field|property|ClassName&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node=&quot;element-name|.&quot;</span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key-property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;propertyName&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;typename&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;column_name&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key-many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;propertyName&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ClassName&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;column_name&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">composite-id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>如果表使用联合主键，你可以映射类的多个属性为标识符属性。<code class="literal">&lt;composite-id&gt;</code> 元素接受 <code class="literal">&lt;key-property&gt;</code> 属性映射和 <code class="literal">&lt;key-many-to-one&gt;</code> 属性映射作为子元素。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">composite-id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key-property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;medicareNumber&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key-property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;dependent&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">composite-id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>你的持久化类<span class="emphasis"><em>必须</em></span>覆盖 <code class="literal">equals()</code> 和 <code class="literal">hashCode()</code> 方法，来实现组合的标识符的相等判断。实现 <code class="literal">Serializable</code> 接口也是必须的。 </p><p>不幸的是，这种组合关键字的方法意味着一个持久化类是它自己的标识。除了对象自己之外，没有什么方便的“把手”可用。你必须初始化持久化类的实例，填充它的标识符属性，再 <code class="literal">load()</code> 组合关键字关联的持久状态。我们把这种方法称为 <span class="emphasis"><em>embedded（嵌入式）</em></span>的组合标识符，在重要的应用中不鼓励使用这种用法。  </p><p>第二种方法我们称为 <span class="emphasis"><em>mapped（映射式）</em></span>组合标识符（mapped composite identifier），<code class="literal">&lt;composite-id&gt;</code> 元素中列出的标识属性不但在持久化类出现，还形成一个独立的标识符类。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">composite-id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;MedicareId&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">mapped</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key-property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;medicareNumber&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key-property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;dependent&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">composite-id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>在这个例子中，组合标识符类 <code class="literal">MedicareId</code> 和实体类都含有 <code class="literal">medicareNumber</code> 和 <code class="literal">dependent</code> 属性。标识符类必须重载 <code class="literal">equals()</code> 和 <code class="literal">hashCode()</code> 并且实现 <code class="literal">Serializable</code> 接口。这种方法的缺点是出现了明显的代码重复。 </p><p>下面列出的属性是用来指定一个映射式组合标识符的： </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mapped</code>（可选，默认为 <code class="literal">false</code>）：指明使用一个映射式组合标识符，其包含的属性映射同时在实体类和组合标识符类中出现。  </p></li><li><p><code class="literal">class</code>（可选,但对映射式组合标识符必须指定）：作为组合标识符类使用的类名。 </p></li></ul></div><p>We will describe a third, even more convenient approach, where the composite identifier is implemented as a component class in <a class="xref" href="components.html#components-compositeid" title="8.4. 组件作为联合标识符（Components as composite identifiers）">第 8.4 节 “组件作为联合标识符（Components as composite identifiers）”</a>. The attributes described below apply only to this alternative approach: </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">name</code>（可选,但对这种方法而言必须）：包含此组件标识符的组件类型的名字（参阅第 9 章）。 </p></li><li><p><code class="literal">access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问属性值的策略。  </p></li><li><p><code class="literal">class</code>（可选 — 默认会用反射来自动判定属性类型 ）：用来作为组合标识符的组件类的类名（参阅下一节）。  </p></li></ul></div><p>第三种方式，被称为 <span class="emphasis"><em>identifier component（标识符组件）</em></span>是我们对几乎所有应用都推荐使用的方式。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-discriminator"/>5.1.8. 鉴别器（discriminator） </h3></div></div></div><p>在"一棵对象继承树对应一个表"的策略中，<code class="literal">&lt;discriminator&gt;</code> 元素是必需的，它定义了表的鉴别器字段。鉴别器字段包含标志值，用于告知持久化层应该为某个特定的行创建哪一个子类的实例。如下这些受到限制的类型可以使用：<code class="literal">string</code>、<code class="literal">character</code>、<code class="literal">integer</code>、<code class="literal">byte</code>、<code class="literal">short</code>、<code class="literal">boolean</code>、<code class="literal">yes_no</code>、<code class="literal">true_false</code>。 </p><div class="programlistingco"><pre class="programlisting">&lt;discriminator
        column<span xmlns="" class="co" id="discriminator1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>="discriminator_column"
        type="<span xmlns="" class="co" id="discriminator2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>discriminator_type"
        force=<span xmlns="" class="co" id="discriminator3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>"true|false"
        insert<span xmlns="" class="co" id="discriminator4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>="true|false"
        formul<span xmlns="" class="co" id="discriminator5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>a="arbitrary sql expression"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">column</code>（可选 — 默认为 <code class="literal">class</code>）discriminator 器字段的名字。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">type</code>（可选 — 默认为 <code class="literal">string</code>）一个 Hibernate 字段类型的名字  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">force(强制)</code>（可选 — 默认为 <code class="literal">false</code>）"强制" Hibernate 指定允许的鉴别器值,即使当取得的所有实例都是根类的。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">insert</code>（可选 - 默认为<code class="literal">true</code>）如果你的鉴别器字段也是映射为复合标识（composite identifier）的一部分，则需将这个值设为 <code class="literal">false</code>。（告诉 Hibernate 在做 SQL <code class="literal">INSERT</code> 时不包含该列）  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">formula</code>（可选）一个 SQL 表达式，在类型判断（判断是父类还是具体子类 — 译注）时执行。可用于基于内容的鉴别器。  </p></td></tr></table></div></div><p>鉴别器字段的实际值是根据 <code class="literal">&lt;class&gt;</code> 和 <code class="literal">&lt;subclass&gt;</code> 元素中的 <code class="literal">discriminator-value</code> 属性得来的。 </p><p><code class="literal">force</code> 属性仅仅在这种情况下有用的：表中包含没有被映射到持久化类的附加辨别器值。这种情况不会经常遇到。  </p><p>使用 <code class="literal">formula</code> 属性你可以定义一个 SQL 表达式，用来判断一行数据的类型。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">discriminator</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">formula</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;case&nbsp;when&nbsp;CLASS_TYPE&nbsp;in&nbsp;('a',&nbsp;'b',&nbsp;'c')&nbsp;then&nbsp;0&nbsp;else&nbsp;1&nbsp;end&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;integer&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-version"/>5.1.9. 版本（version）（可选） </h3></div></div></div><p><code class="literal">&lt;version&gt;</code> 元素是可选的，表明表中包含附带版本信息的数据。这在你准备使用<span class="emphasis"><em> 长事务（long transactions）</em></span>的时候特别有用。下面是更多信息： </p><div class="programlistingco"><pre class="programlisting">&lt;version
        column<span xmlns="" class="co" id="version1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>="version_column"
        name="<span xmlns="" class="co" id="version2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>propertyName"
        type="<span xmlns="" class="co" id="version3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>typename"
        access<span xmlns="" class="co" id="version4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>="field|property|ClassName"
        unsave<span xmlns="" class="co" id="version5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>d-value="null|negative|undefined"
        genera<span xmlns="" class="co" id="version6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>ted="never|always"
        insert<span xmlns="" class="co" id="version7"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>="true|false"
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">column</code>（可选 — 默认为属性名）：指定持有版本号的字段名。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：持久化类的属性名。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">type</code>（可选 — 默认是 <code class="literal">integer</code>）：版本号的类型。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问属性值的策略。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code>（可选 — 默认是 <code class="literal">undefined</code>）：用于标明某个实例时刚刚被实例化的（尚未保存）版本属性值，依靠这个值就可以把这种情况 和已经在先前的 session 中保存或装载的脱管（detached）实例区分开来。（<code class="literal">undefined</code> 指明应被使用的标识属性值。）  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">generated</code>（可选 — 默认是 <code class="literal">never</code>）：表明此版本属性值是否实际上是由数据库生成的。请参阅  <a class="link" href="mapping.html#mapping-generated" title="5.6. 数据库生成属性（Generated Properties）">generated properties</a> 部分的讨论。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">insert</code>（可选 — 默认是 <code class="literal">true</code>）：表明此版本列应该包含在 SQL 插入语句中。只有当数据库字段有默认值 <code class="literal">0</code> 的时候，才可以设置为 <code class="literal">false</code>。  </p></td></tr></table></div></div><p>版本号必须是以下类型：<code class="literal">long</code>、<code class="literal">integer</code>、<code class="literal">short</code>、<code class="literal">timestamp</code> 或者 <code class="literal">calendar</code>。 </p><p>一个脱管（detached）实例的 version 或 timestamp 属性不能为空（null），因为 Hibernate 不管  <code class="literal">unsaved-value</code> 被指定为何种策略，它将任何属性为空的 version 或 timestamp 实例看作为瞬时（transient）实例。 <span class="emphasis"><em>避免 Hibernate 中的传递重附（transitive reattachment）问题的一个简单方法是 定义一个不能为空的 version 或 timestamp 属性，特别是在人们使用程序分配的标识符（assigned identifiers） 或复合主键时非常有用</em></span>。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-timestamp"/>5.1.10. timestamp（可选) </h3></div></div></div><p>可选的 <code class="literal">&lt;timestamp&gt;</code> 元素指明了表中包含时间戳数据。这用来作为版本的替代。时间戳本质上是一种对乐观锁定的一种不是特别安全的实现。当然，有时候应用程序可能在其他方面使用时间戳。  </p><div class="programlistingco"><pre class="programlisting">&lt;timestamp
        column<span xmlns="" class="co" id="timestamp1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>="timestamp_column"
        name="<span xmlns="" class="co" id="timestamp2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>propertyName"
        access<span xmlns="" class="co" id="timestamp3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>="field|property|ClassName"
        unsave<span xmlns="" class="co" id="timestamp4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>d-value="null|undefined"
        source<span xmlns="" class="co" id="timestamp5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>="vm|db"
        genera<span xmlns="" class="co" id="timestamp6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>ted="never|always"
        node="element-name|@attribute-name|element/@attribute|."
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">column</code>（可选 — 默认为属性名）：存有时间戳的字段名。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：在持久化类中的 JavaBeans 风格的属性名，其 Java 类型是 <code class="literal">Date</code> 或者 <code class="literal">Timestamp</code> 的。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问属性值的策略。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">unsaved-value</code>（可选 — 默认是 <code class="literal">null</code>）：用于标明某个实例时刚刚被实例化的（尚未保存）版本属性值，依靠这个值就可以把这种情况和已经在先前的 session 中保存或装载的脱管（detached）实例区分开来。（<code class="literal">undefined</code> 指明使用标识属性值进行这种判断。）  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">source</code>（可选 — 默认是 <code class="literal">vm</code>）：Hibernate 如何才能获取到时间戳的值呢？从数据库，还是当前 JVM？从数据库获取会带来一些负担，因为 Hibernate 必须访问数据库来获得“下一个值”，但是在集群环境中会更安全些。还要注意，并不是所有的 <code class="literal">Dialect（方言）</code>都支持获得数据库的当前时间戳的，而支持的数据库中又有一部分因为精度不足，用于锁定是不安全的（例如 Oracle 8）。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">generated</code>（可选 - 默认是 <code class="literal">never</code>）：指出时间戳值是否实际上是由数据库生成的。请参阅 <a class="link" href="mapping.html#mapping-generated" title="5.6. 数据库生成属性（Generated Properties）">generated properties</a> 的讨论。  </p></td></tr></table></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>注意，<code class="literal">&lt;timestamp&gt;</code> 和 <code class="literal">&lt;version type="timestamp"&gt;</code> 是等价的。并且 <code class="literal">&lt;timestamp source="db"&gt;</code> 和 <code class="literal">&lt;version type="dbtimestamp"&gt;</code> 是等价的。  </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-property"/>5.1.11. Property</h3></div></div></div><p><code class="literal">&lt;property&gt;</code> 元素为类定义了一个持久化的、JavaBean 风格的属性。  </p><div class="programlistingco"><pre class="programlisting">&lt;property
        name="<span xmlns="" class="co" id="property1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>propertyName"
        column<span xmlns="" class="co" id="property2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>="column_name"
        type="<span xmlns="" class="co" id="property3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>typename"
        update<span xmlns="" class="co" id="property4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>="true|false"
        insert<span xmlns="" class="co" id="property5"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>="true|false"
        formul<span xmlns="" class="co" id="property6"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>a="arbitrary SQL expression"
        access<span xmlns="" class="co" id="property7"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>="field|property|ClassName"
        lazy="<span xmlns="" class="co" id="property8"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>true|false"
        unique<span xmlns="" class="co" id="property9"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>="true|false"
        not-nu<span xmlns="" class="co" id="property10"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>ll="true|false"
        optimi<span xmlns="" class="co" id="property11"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>stic-lock="true|false"
        genera<span xmlns="" class="co" id="property12"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>ted="never|insert|always"
        node="element-name|@attribute-name|element/@attribute|."
        index="index_name"
        unique_key="unique_key_id"
        length="L"
        precision="P"
        scale="S"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：属性的名字，以小写字母开头。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">column</code>（可选 — 默认为属性名字）：对应的数据库字段名。 也可以通过嵌套的 <code class="literal">&lt;column&gt;</code> 元素指定。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">type</code>（可选）：一个 Hibernate 类型的名字。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">update, insert</code>（可选 — 默认为 <code class="literal">true</code>）： 表明用于　<code class="literal">UPDATE</code> 和/或 <code class="literal">INSERT</code> 的 SQL 语句中是否包含这个被映射了的字段。这二者如果都设置为 <code class="literal">false</code> 则表明这是一个“外源性（derived）”的属性，它的值来源于映射到同一个（或多个） 字段的某些其他属性，或者通过一个 trigger（触发器）或其他程序生成。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">formula</code>（可选）：一个 SQL 表达式，定义了这个<span class="emphasis"><em>计算 （computed）</em></span> 属性的值。计算属性没有和它对应的数据库字段。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问属性值的策略。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">lazy</code>（可选 — 默认为 <code class="literal">false</code>）：指定 指定实例变量第一次被访问时，这个属性是否延迟抓取（fetched lazily）（ 需要运行时字节码增强）。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">unique</code>（可选）：使用 DDL 为该字段添加唯一的约束。同样，允许它作为 <code class="literal">property-ref</code> 引用的目标。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">not-null</code>（可选）：使用 DDL 为该字段添加可否为空（nullability）的约束。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code>（可选 — 默认为 <code class="literal">true</code>）：指定这个属性在做更新时是否需要获得乐观锁定（optimistic lock）。换句话说，它决定这个属性发生脏数据时版本（version）的值是否增长。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">generated</code>（可选 — 默认为 <code class="literal">never</code>）：表明此属性值是否实际上是由数据库生成的。请参阅 <a class="link" href="mapping.html#mapping-generated" title="5.6. 数据库生成属性（Generated Properties）">generated properties</a> 的讨论。  </p></td></tr></table></div></div><p><span class="emphasis"><em>typename</em></span> 可以是如下几种： </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>Hibernate 基本类型名（比如：<code class="literal">integer, string, character,date, timestamp, float, binary, serializable, object, blob</code>）。  </p></li><li><p>一个 Java 类的名字，这个类属于一种默认基础类型（比如：<code class="literal">int, float,char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</code>)。  </p></li><li><p>一个可以序列化的 Java 类的名字。 </p></li><li><p>一个自定义类型的类的名字。（比如：<code class="literal">com.illflow.type.MyCustomType</code>)。  </p></li></ol></div><p>如果你没有指定类型，Hibernarte 会使用反射来得到这个名字的属性，以此来猜测正确的 Hibernate 类型。Hibernate 会按照规则 2，3，4 的顺序对属性读取器（getter方法）的返回类进行解释。然而，这还不够。 在某些情况下你仍然需要 <code class="literal">type</code> 属性。（比如，为了区别<code class="literal">Hibernate.DATE</code> 和<code class="literal">Hibernate.TIMESTAMP</code>,或者为了指定一个自定义类型。）  </p><p><code class="literal">access</code> 属性用来让你控制 Hibernate 如何在运行时访问属性。在默认情况下，Hibernate 会使用属性的 get/set 方法对（pair）。如果你指明 <code class="literal">access="field"</code>，Hibernate 会忽略 get/set 方法对，直接使用反射来访问成员变量。你也可以指定你自己的策略，这就需要你自己实现 <code class="literal">org.hibernate.property.PropertyAccessor</code> 接口，再在 access 中设置你自定义策略类的名字。  </p><p>衍生属性（derive propertie）是一个特别强大的特征。这些属性应该定义为只读，属性值在装载时计算生成。 你用一个 SQL 表达式生成计算的结果，它会在这个实例转载时翻译成一个 SQL 查询的 <code class="literal">SELECT</code> 子查询语句。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;totalPrice&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">formula</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;(&nbsp;SELECT&nbsp;SUM&nbsp;(li.quantity*p.price)&nbsp;FROM&nbsp;LineItem&nbsp;li,&nbsp;Product&nbsp;p</span><br />
<span class="xml_attribute_value">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WHERE&nbsp;li.productId&nbsp;=&nbsp;p.productId</span><br />
<span class="xml_attribute_value">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND&nbsp;li.customerId&nbsp;=&nbsp;customerId</span><br />
<span class="xml_attribute_value">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND&nbsp;li.orderNumber&nbsp;=&nbsp;orderNumber&nbsp;)&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>注意，你可以使用实体自己的表，而不用为这个特别的列定义别名（上面例子中的 <code class="literal">customerId</code>）。同时注意，如果你不喜欢使用属性， 你可以使用嵌套的 <code class="literal">&lt;formula&gt;</code> 映射元素。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-manytoone"/>5.1.12. 多对一（many-to-one） </h3></div></div></div><p>通过 <code class="literal">many-to-one</code> 元素,可以定义一种常见的与另一个持久化类的关联。这种关系模型是多对一关联（实际上是一个对象引用－译注）：这个表的一个外键引用目标表的主键字段。  </p><div class="programlistingco"><pre class="programlisting">&lt;many-to-one
        name="<span xmlns="" class="co" id="manytoone1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>propertyName"
        column<span xmlns="" class="co" id="manytoone2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>="column_name"
        class=<span xmlns="" class="co" id="manytoone3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>"ClassName"
        cascad<span xmlns="" class="co" id="manytoone4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>e="cascade_style"
        fetch=<span xmlns="" class="co" id="manytoone5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>"join|select"
        update<span xmlns="" class="co" id="manytoone6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>="true|false"
        insert<span xmlns="" class="co" id="manytoone7"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>="true|false"
        proper<span xmlns="" class="co" id="manytoone8"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>ty-ref="propertyNameFromAssociatedClass"
        access<span xmlns="" class="co" id="manytoone9"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>="field|property|ClassName"
        unique<span xmlns="" class="co" id="manytoone10"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>="true|false"
        not-nu<span xmlns="" class="co" id="manytoone11"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>ll="true|false"
        optimi<span xmlns="" class="co" id="manytoone12"><img src="images/org/hibernate/docbook/callouts/11.png" alt="(11)"/></span>stic-lock="true|false"
        lazy="<span xmlns="" class="co" id="manytoone13"><img src="images/org/hibernate/docbook/callouts/12.png" alt="(12)"/></span>proxy|no-proxy|false"
        not-fo<span xmlns="" class="co" id="manytoone14"><img src="images/org/hibernate/docbook/callouts/13.png" alt="(13)"/></span>und="ignore|exception"
        entity<span xmlns="" class="co" id="manytoone15"><img src="images/org/hibernate/docbook/callouts/14.png" alt="(14)"/></span>-name="EntityName"
        formul<span xmlns="" class="co" id="manytoone16"><img src="images/org/hibernate/docbook/callouts/15.png" alt="(15)"/></span>a="arbitrary SQL expression"
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        index="index_name"
        unique_key="unique_key_id"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：属性名。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">column</code>（可选）：外键字段的名称。也可以通过嵌套的  <code class="literal">&lt;column&gt;</code> 指定。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">class</code>（可选 — 默认是通过反射得到的属性类型）：被关联的类的名字。   </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">cascade（级联）</code>（可选）表明操作是否从父对象级联到被关联的对象。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">fetch</code>（可选 — 默认为 <code class="literal">select</code>）：在外连接抓取（outer-join fetching）和序列选择抓取（sequential select fetching）两者中选择其一。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">update, insert</code>（可选 — 默认为 <code class="literal">true</code>）指定对应的字段是否包含在用于 <code class="literal">UPDATE</code> 和/或 <code class="literal">INSERT</code> 的 SQL 语句中。如果二者都是<code class="literal">false</code>,则这是一个纯粹的 “外源性（derived）”关联，它的值是通过映射到同一个（或多个）字段的某些其他属性得到 或者通过 trigger（触发器）、或其他程序生成。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">property-ref</code>：（可选）被关联到此外键的类中的对应属性的名字。如果没有指定，被关联类的主键将被使用。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问属性值的策略。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">unique</code>（可选）：使用 DDL 为外键字段生成一个唯一约束。此外， 这也可以用作 <code class="literal">property-ref</code> 的目标属性。这使关联同时具有一对一的效果。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">not-null</code>（可选）：使用 DDL 为外键字段生成一个非空约束。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/11.png" alt="11" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code>（可选 — 默认为 <code class="literal">true</code>）：指定这个属性在做更新时是否需要获得乐观锁定（optimistic lock）。换句话说，它决定这个属性发生脏数据时版本（version）的值是否增长。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/12.png" alt="12" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">lazy</code>（可选 — 默认为 <code class="literal">proxy</code>）：默认情况下，单点关联是经过代理的。<code class="literal">lazy="no-proxy"</code> 指定此属性应该在实例变量第一次被访问时应该延迟抓取（fetche lazily）（需要运行时字节码的增强）。<code class="literal">lazy="false"</code> 指定此关联总是被预先抓取。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/13.png" alt="13" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">not-found</code>（可选 - 默认为<code class="literal">exception</code>）：指定如何处理引用缺失行的外键：<code class="literal">ignore</code> 会把缺失的行作为一个空关联处理。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/14.png" alt="14" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">entity-name</code>（可选）：被关联的类的实体名。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/15.png" alt="15" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">formula</code>（可选）：SQL 表达式，用于定义 <span class="emphasis"><em>computed（计算出的）</em></span>外键值。 </p></td></tr></table></div></div><p>Setting a value of the <code class="literal">cascade</code> attribute to any meaningful value other than <code class="literal">none</code> will propagate certain operations to the associated object. The meaningful values are divided into three categories. First, basic operations, which include: <code class="literal">persist, merge, delete, save-update, evict, replicate, lock and refresh</code>; second, special values: <code class="literal">delete-orphan</code>; and third, <code class="literal">all</code> comma-separated combinations of operation names: <code class="literal">cascade="persist,merge,evict"</code> or <code class="literal">cascade="all,delete-orphan"</code>. See <a class="xref" href="objectstate.html#objectstate-transitive" title="10.11. 传播性持久化（transitive persistence）">第 10.11 节 “传播性持久化（transitive persistence）”</a> for a full explanation. Note that single valued, many-to-one and one-to-one, associations do not support orphan delete. </p><p>一个典型的简单 <code class="literal">many-to-one</code> 定义例子：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;product&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Product&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;PRODUCT_ID&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p><code class="literal">property-ref</code> 属性只应该用来对付遗留下来的数据库系统，可能有外键指向对方关联表的是个非主键字段（但是应该是一个惟一关键字）的情况下。这是一种十分丑陋的关系模型。比如说，假设 <code class="literal">Product</code> 类有一个惟一的序列号，它并不是主键。（<code class="literal">unique</code> 属性控制 Hibernate 通过 SchemaExport 工具进行的 DDL 生成。）  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;serialNumber&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">unique</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;string&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;SERIAL_NUMBER&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>那么关于 <code class="literal">OrderItem</code> 的映射可能是： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;product&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">property-ref</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;serialNumber&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;PRODUCT_SERIAL_NUMBER&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>当然，我们决不鼓励这种用法。  </p><p>如果被引用的唯一主键由关联实体的多个属性组成，你应该在名称为 <code class="literal">&lt;properties&gt;</code> 的元素 里面映射所有关联的属性。 </p><p>假若被引用的唯一主键是组件的属性，你可以指定属性路径：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;owner&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">property-ref</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;identity.ssn&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;OWNER_SSN&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-onetoone"/>5.1.13. 一对一 </h3></div></div></div><p>持久化对象之间一对一的关联关系是通过 <code class="literal">one-to-one</code> 元素定义的。 </p><div class="programlistingco"><pre class="programlisting">&lt;one-to-one
        name="<span xmlns="" class="co" id="onetoone1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>propertyName"
        class=<span xmlns="" class="co" id="onetoone2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>"ClassName"
        cascad<span xmlns="" class="co" id="onetoone3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>e="cascade_style"
        constr<span xmlns="" class="co" id="onetoone4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>ained="true|false"
        fetch=<span xmlns="" class="co" id="onetoone5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>"join|select"
        proper<span xmlns="" class="co" id="onetoone6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>ty-ref="propertyNameFromAssociatedClass"
        access<span xmlns="" class="co" id="onetoone7"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>="field|property|ClassName"
        formul<span xmlns="" class="co" id="onetoone8"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>a="any SQL expression"
        lazy="<span xmlns="" class="co" id="onetoone9"><img src="images/org/hibernate/docbook/callouts/9.png" alt="(9)"/></span>proxy|no-proxy|false"
        entity<span xmlns="" class="co" id="onetoone10"><img src="images/org/hibernate/docbook/callouts/10.png" alt="(10)"/></span>-name="EntityName"
        node="element-name|@attribute-name|element/@attribute|."
        embed-xml="true|false"
        foreign-key="foreign_key_name"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：属性名。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">class</code>（可选 — 默认是通过反射得到的属性类型）：被关联的类的名字。   </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">cascade（级联）</code>（可选）表明操作是否从父对象级联到被关联的对象。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">constrained（约束）</code>（可选）表明该类对应的表对应的数据库表，和被关联的对象所对应的数据库表之间，通过一个外键引用对主键进行约束。这个选项影响 <code class="literal">save()</code> 和 <code class="literal">delete()</code> 在级联执行时的先后顺序以及决定该关联能否被委托（也在 schema export tool 中被使用）。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">fetch</code>（可选 — 默认为 <code class="literal">select</code>）：在外连接抓取（outer-join fetching）和序列选择抓取（sequential select fetching）两者中选择其一。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">property-ref</code>：（可选）指定关联类的属性名，这个属性将会和本类的主键相对应。如果没有指定，会使用对方关联类的主键。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问属性值的策略。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">formula </code>（可选）：绝大多数一对一的关联都指向其实体的主键。在一些少见的情况中，你可能会指向其他的一个或多个字段，或者是一个表达式，这些情况下，你可以用一个 SQL 公式来表示。（可以在 org.hibernate.test.onetooneformula 找到例子）  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/9.png" alt="9" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">lazy</code>（可选 — 默认为 <code class="literal">proxy</code>）：默认情况下，单点关联是经过代理的。<code class="literal">lazy="no-proxy"</code>指定此属性应该在实例变量第一次被访问时应该延迟抓取（fetche lazily）（需要运行时字节码的增强）。 <code class="literal">lazy="false"</code>指定此关联总是被预先抓取。<span class="emphasis"><em>注意，如果<code class="literal">constrained="false"</code>, 不可能使用代理，Hibernate会采取预先抓取</em></span>。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/10.png" alt="10" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">entity-name</code>（可选）：被关联的类的实体名。  </p></td></tr></table></div></div><p>有两种不同的一对一关联：  </p><div class="itemizedlist"><ul><li><p>主键关联 </p></li><li><p>惟一外键关联 </p></li></ul></div><p>主键关联不需要额外的表字段；如果两行是通过这种一对一关系相关联的，那么这两行就共享同样的主关键字值。所以如果你希望两个对象通过主键一对一关联，你必须确认它们被赋予同样的标识值。 </p><p>比如说，对下面的 <code class="literal">Employee</code> 和 <code class="literal">Person</code> 进行主键一对一关联： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;person&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;employee&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Employee&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">constrained</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>现在我们必须确保 PERSON 和 EMPLOYEE 中相关的字段是相等的。我们使用一个被成为 <code class="literal">foreign</code> 的特殊的 hibernate 标识符生成策略：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;person&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">table</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;PERSON&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;PERSON_ID&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;foreign&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;property&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">employee</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">generator</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;employee&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Employee&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">constrained</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>一个刚刚保存的 <code class="literal">Person</code> 实例被赋予和该 <code class="literal">Person</code> 的 <code class="literal">employee</code> 属性所指向的 <code class="literal">Employee</code> 实例同样的关键字值。  </p><p>另一种方式是一个外键和一个惟一关键字对应，上面的 <code class="literal">Employee</code> 和  <code class="literal">Person</code> 的例子，如果使用这种关联方式，可以表达成：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;person&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;PERSON_ID&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">unique</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>如果在 <code class="literal">Person</code> 的映射加入下面几句，这种关联就是双向的：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;employee&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Employee&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">property-ref</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;person&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-naturalid"/>5.1.14. 自然 ID（natural-id） </h3></div></div></div><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">natural-id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">mutable</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true|false&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;...&nbsp;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;...&nbsp;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;......</span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">natural-id</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>我们建议使用代用键（键值不具备实际意义）作为主键，我们仍然应该尝试为所有的实体采用自然的键值作为（附加——译者注）标示。自然键（natural key）是单个或组合属性，他们必须唯一且非空。如果它还是不可变的那就更理想了。在 <code class="literal">&lt;natural-id&gt;</code> 元素中列出自然键的属性。Hibernate 会帮你生成必须的唯一键值和非空约束，你的映射会更加的明显易懂（原文是 self-documenting，自我注解）。  </p><p>我们强烈建议你实现 <code class="literal">equals()</code> 和 <code class="literal">hashCode()</code> 方法,来比较实体的自然键属性。  </p><p>这一映射不是为了把自然键作为主键而准备的。  </p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">mutable</code>（可选，默认为 <code class="literal">false</code>）：默认情况下，自然标识属性被假定为不可变的（常量）。  </p></li></ul></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-component"/>5.1.15. 组件（component）和动态组件（dynamic-component） </h3></div></div></div><p><code class="literal">&lt;component&gt;</code> 元素把子对象的一些元素与父类对应的表的一些字段映射起来。然后组件可以定义它们自己的属性、组件或者集合。参见后面的“Components”一章。  </p><div class="programlistingco"><pre class="programlisting">&lt;component
        name="<span xmlns="" class="co" id="component1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>propertyName"
        class=<span xmlns="" class="co" id="component2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>"className"
        insert<span xmlns="" class="co" id="component3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>="true|false"
        update<span xmlns="" class="co" id="component4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>="true|false"
        access<span xmlns="" class="co" id="component5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>="field|property|ClassName"
        lazy="<span xmlns="" class="co" id="component6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>true|false"
        optimi<span xmlns="" class="co" id="component7"><img src="images/org/hibernate/docbook/callouts/7.png" alt="(7)"/></span>stic-lock="true|false"
        unique<span xmlns="" class="co" id="component8"><img src="images/org/hibernate/docbook/callouts/8.png" alt="(8)"/></span>="true|false"
        node="element-name|."
&gt;

        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/component
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：属性名。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">class</code>（可选 — 默认为通过反射得到的属性类型）：组件（子）类的名字。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">insert</code>：被映射的字段是否出现在 SQL 的 <code class="literal">INSERT</code> 语句中？  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">update</code>：被映射的字段是否出现在 SQL 的 <code class="literal">UPDATE</code> 语句中？  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问属性值的策略。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">lazy</code>（可选 — 默认是 <code class="literal">false</code>）：表明此组件应在实例变量第一次被访问的时候延迟加载（需要编译时字节码装置器）。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/7.png" alt="7" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code>（可选 — 默认是 <code class="literal">true</code>）：表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号（Version）。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/8.png" alt="8" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">unique</code>（可选 — 默认是 <code class="literal">false</code>）：表明组件映射的所有字段上都有唯一性约束。 </p></td></tr></table></div></div><p>其 <code class="literal">&lt;property&gt;</code> 子标签为子类的一些属性与表字段之间建立映射。 </p><p><code class="literal">&lt;component&gt;</code> 元素允许加入一个 <code class="literal">&lt;parent&gt;</code> 子元素，在组件类内部就可以有一个指向其容器的实体的反向引用。 </p><p>The <code class="literal">&lt;dynamic-component&gt;</code> element allows a <code class="literal">Map</code> to be mapped as a component, where the property names refer to keys of the map. See <a class="xref" href="components.html#components-dynamic" title="8.5. 动态组件（Dynamic components）">第 8.5 节 “动态组件（Dynamic components）”</a> for more information. </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-properties"/>5.1.16. 属性（Properties）</h3></div></div></div><p><code class="literal">&lt;properties&gt;</code> 元素允许定义一个命名的逻辑分组（grouping）包含一个类中的多个属性。这个元素最重要的用处是允许多个属性的组合作为 <code class="literal">property-ref</code> 的目标（target）。这也是定义多字段唯一约束的一种方便途径。例如： </p><div class="programlistingco"><pre class="programlisting">&lt;properties
        name="<span xmlns="" class="co" id="properties1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>logicalName"
        insert<span xmlns="" class="co" id="properties2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>="true|false"
        update<span xmlns="" class="co" id="properties3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>="true|false"
        optimi<span xmlns="" class="co" id="properties4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>stic-lock="true|false"
        unique<span xmlns="" class="co" id="properties5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>="true|false"
&gt;

        &lt;property ...../&gt;
        &lt;many-to-one .... /&gt;
        ........
&lt;/properties
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：分组的逻辑名称 — <span class="emphasis"><em>不是</em></span> 实际属性的名称。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">insert</code>：被映射的字段是否出现在 SQL 的 <code class="literal">INSERT</code> 语句中？  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">update</code>：被映射的字段是否出现在 SQL 的 <code class="literal">UPDATE</code> 语句中？  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code>（可选 — 默认是 <code class="literal">true</code>）：表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号（Version）。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">unique</code>（可选 — 默认是 <code class="literal">false</code>）：表明组件映射的所有字段上都有唯一性约束。 </p></td></tr></table></div></div><p>例如，如果我们有如下的 <code class="literal">&lt;properties&gt;</code> 映射： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;personNumber&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">properties</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;name&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">unique</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">update</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;false&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;firstName&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;initial&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;lastName&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">properties</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>然后，我们可能有一些遗留的数据关联，引用 <code class="literal">Person</code> 表的这个唯一键，而不是主键： </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;person&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">property-ref</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;name&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">column</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;firstName&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">column</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;initial&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">column</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;lastName&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>我们并不推荐这样使用，除非在映射遗留数据的情况下。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-subclass"/>5.1.17. 子类（subclass） </h3></div></div></div><p>最后，多态持久化需要为父类的每个子类都进行定义。对于“每一棵类继承树对应一个表”的策略来说，就需要使用 <code class="literal">&lt;subclass&gt;</code> 定义。  </p><div class="programlistingco"><pre class="programlisting">&lt;subclass
        name="<span xmlns="" class="co" id="subclass1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>ClassName"
        discri<span xmlns="" class="co" id="subclass2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>minator-value="discriminator_value"
        proxy=<span xmlns="" class="co" id="subclass3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>"ProxyInterface"
        lazy="<span xmlns="" class="co" id="subclass4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        entity-name="EntityName"
        node="element-name"
        extends="SuperclassName"&gt;

        &lt;property .... /&gt;
        .....
&lt;/subclass
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：子类的全限定名。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">discriminator-value（辨别标志）</code>（可选 — 默认为类名）：一个用于区分每个独立的子类的值。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">proxy</code>（可选）：指定一个类或者接口，在延迟装载时作为代理使用。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">lazy</code>（可选，默认是 <code class="literal">true</code>）：设置为 <code class="literal">lazy="false"</code> 禁止使用延迟装载。  </p></td></tr></table></div></div><p>每个子类都应该定义它自己的持久化属性和子类。<code class="literal">&lt;version&gt;</code> 和 <code class="literal">&lt;id&gt;</code> 属性可以从根父类继承下来。在一棵继承树上的每个子类都必须定义一个唯一的 <code class="literal">discriminator-value</code>。如果没有指定，就会使用 Java 类的全限定名。  </p><p>For information about inheritance mappings see <a class="xref" href="inheritance.html" title="第 9 章 继承映射（Inheritance Mapping）">第 9 章 <i>继承映射（Inheritance Mapping） </i></a>. </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-joinedsubclass"/>5.1.18. 连接的子类（joined-subclass） </h3></div></div></div><p>此外，每个子类可能被映射到他自己的表中（每个子类一个表的策略）。被继承的状态通过和超类的表关联得到。我们使用 <code class="literal">&lt;joined-subclass&gt;</code> 元素。  </p><div class="programlistingco"><pre class="programlisting">&lt;joined-subclass
        name="<span xmlns="" class="co" id="joinedsubclass1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>ClassName"
        table=<span xmlns="" class="co" id="joinedsubclass2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>"tablename"
        proxy=<span xmlns="" class="co" id="joinedsubclass3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>"ProxyInterface"
        lazy="<span xmlns="" class="co" id="joinedsubclass4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;key .... &gt;

        &lt;property .... /&gt;
        .....
&lt;/joined-subclass
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：子类的全限定名。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">table</code>：子类的表名。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">proxy</code>（可选）：指定一个类或者接口，在延迟装载时作为代理使用。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">lazy</code>（可选，默认是 <code class="literal">true</code>）：设置为 <code class="literal">lazy="false"</code> 禁止使用延迟装载。  </p></td></tr></table></div></div><p>这种映射策略不需要指定辨别标志（discriminator）字段。但是，每一个子类都必须使用 <code class="literal">&lt;key&gt;</code> 元素指定一个表字段来持有对象的标识符。本章开始的映射可以被用如下方式重写：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_processing_instruction">&lt;?xml&nbsp;version=&quot;1.0&quot;?&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_plain">!</span><span class="xml_attribute_name">DOCTYPE</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">hibernate-mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">PUBLIC</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_value">&quot;-//Hibernate/Hibernate&nbsp;Mapping&nbsp;DTD//EN&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_value">&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">package</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;eg&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">table</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CATS&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;uid&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;long&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;hilo&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;birthdate&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;date&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;color&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;sex&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;weight&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;mate&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">set</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;kittens&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;MOTHER&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">one-to-many</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Cat&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">set</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">joined-subclass</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DomesticCat&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">table</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;DOMESTIC_CATS&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;CAT&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;name&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;string&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">joined-subclass</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;eg.Dog&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_comment">&lt;!--&nbsp;mapping&nbsp;for&nbsp;Dog&nbsp;could&nbsp;go&nbsp;here&nbsp;--&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>For information about inheritance mappings see <a class="xref" href="inheritance.html" title="第 9 章 继承映射（Inheritance Mapping）">第 9 章 <i>继承映射（Inheritance Mapping） </i></a>. </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-unionsubclass"/>5.1.19. 联合子类（union-subclass） </h3></div></div></div><p>第三种选择是仅仅映射类继承树中具体类部分到表中（每个具体类一张表的策略）。其中，每张表定义了类的所有持久化状态，包括继承的状态。在 Hibernate 中，并不需要完全显式地映射这样的继承树。你可以简单地使用单独的 <code class="literal">&lt;class&gt;</code> 定义映射每个类。然而，如果你想使用多态关联（例如，一个对类继承树中超类的关联），你需要使用 <code class="literal">&lt;union-subclass&gt;</code> 映射。  </p><div class="programlistingco"><pre class="programlisting">&lt;union-subclass
        name="<span xmlns="" class="co" id="unionsubclass1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>ClassName"
        table=<span xmlns="" class="co" id="unionsubclass2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>"tablename"
        proxy=<span xmlns="" class="co" id="unionsubclass3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>"ProxyInterface"
        lazy="<span xmlns="" class="co" id="unionsubclass4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>true|false"
        dynamic-update="true|false"
        dynamic-insert="true|false"
        schema="schema"
        catalog="catalog"
        extends="SuperclassName"
        abstract="true|false"
        persister="ClassName"
        subselect="SQL expression"
        entity-name="EntityName"
        node="element-name"&gt;

        &lt;property .... /&gt;
        .....
&lt;/union-subclass
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：子类的全限定名。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">table</code>：子类的表名。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">proxy</code>（可选）：指定一个类或者接口，在延迟装载时作为代理使用。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">lazy</code>（可选，默认是 <code class="literal">true</code>）：设置为 <code class="literal">lazy="false"</code> 禁止使用延迟装载。  </p></td></tr></table></div></div><p>这种映射策略不需要指定辨别标志（discriminator）字段。 </p><p>For information about inheritance mappings see <a class="xref" href="inheritance.html" title="第 9 章 继承映射（Inheritance Mapping）">第 9 章 <i>继承映射（Inheritance Mapping） </i></a>. </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-join"/>5.1.20. 连接（join） </h3></div></div></div><p>使用 <code class="literal">&lt;join&gt;</code> 元素，假若在表之间存在一对一关联,可以将一个类的属性映射到多张表中。  </p><div class="programlistingco"><pre class="programlisting">&lt;join
        table=<span xmlns="" class="co" id="join1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>"tablename"
        schema<span xmlns="" class="co" id="join2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>="owner"
        catalo<span xmlns="" class="co" id="join3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>g="catalog"
        fetch=<span xmlns="" class="co" id="join4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>"join|select"
        invers<span xmlns="" class="co" id="join5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>e="true|false"
        option<span xmlns="" class="co" id="join6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>al="true|false"&gt;

        &lt;key ... /&gt;

        &lt;property ... /&gt;
        ...
&lt;/join
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">table</code>：被连接表的名称。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">schema</code>（可选）：覆盖在根 <code class="literal">&lt;hibernate-mapping&gt;</code> 元素中指定的 schema 名字。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">catalog</code>（可选）：覆盖在根 <code class="literal">&lt;hibernate-mapping&gt;</code> 元素中指定的 catalog 名字。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">fetch</code>（可选 — 默认是 <code class="literal">join</code>）：如果设置为默认值 <code class="literal">join</code>，Hibernate 将使用一个内连接来得到这个类或其超类定义的 <code class="literal">&lt;join&gt;</code>，而使用一个外连接来得到其子类定义的 <code class="literal">&lt;join&gt;</code>。如果设置为 <code class="literal">select</code>，则 Hibernate 将为子类定义的 <code class="literal">&lt;join&gt;</code> 使用顺序选择。这仅在一行数据表示一个子类的对象的时候才会发生。对这个类和其超类定义的 <code class="literal">&lt;join&gt;</code>，依然会使用内连接得到。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">inverse</code>（可选 — 默认是 <code class="literal">false</code>）：如果打开，Hibernate 不会插入或者更新此连接定义的属性。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">optional</code>（可选 — 默认是 <code class="literal">false</code>）：如果打开，Hibernate 只会在此连接定义的属性非空时插入一行数据，并且总是使用一个外连接来得到这些属性。  </p></td></tr></table></div></div><p>例如，一个人（person）的地址（address）信息可以被映射到单独的表中（并保留所有属性的值类型语义）：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Person&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">table</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;PERSON&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;PERSON_ID&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">...</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">join</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">table</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ADDRESS&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">key</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;ADDRESS_ID&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;address&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;zip&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;country&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">join</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
</pre><p>此特性常常对遗留数据模型有用，我们推荐表个数比类个数少，以及细粒度的领域模型。然而，在单独的继承树上切换继承映射策略是有用的，后面会解释这点。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-key"/>5.1.21. Key</h3></div></div></div><p>我们目前已经见到过 <code class="literal">&lt;key&gt;</code> 元素多次了。这个元素在父映射元素定义了对新表的连接，并且在被连接表中定义了一个外键引用原表的主键的情况下经常使用。  </p><div class="programlistingco"><pre class="programlisting">&lt;key
        column<span xmlns="" class="co" id="key1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>="columnname"
        on-del<span xmlns="" class="co" id="key2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>ete="noaction|cascade"
        proper<span xmlns="" class="co" id="key3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>ty-ref="propertyName"
        not-nu<span xmlns="" class="co" id="key4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>ll="true|false"
        update<span xmlns="" class="co" id="key5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>="true|false"
        unique<span xmlns="" class="co" id="key6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>="true|false"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">column</code>（可选）：外键字段的名称。也可以通过嵌套的  <code class="literal">&lt;column&gt;</code> 指定。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">on-delete</code>（可选，默认是 <code class="literal">noaction</code>）：表明外键关联是否打开数据库级别的级联删除。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">property-ref</code>（可选）：表明外键引用的字段不是原表的主键（提供给遗留数据）。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">not-null</code>（可选）：表明外键的字段不可为空（这意味着无论何时外键都是主键的一部分）。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">update</code>（可选）：表明外键决不应该被更新（这意味着无论何时外键都是主键的一部分）。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">unique</code>（可选）：表明外键应有唯一性约束（这意味着无论何时外键都是主键的一部分）。  </p></td></tr></table></div></div><p>对那些看重删除性能的系统，我们推荐所有的键都应该定义为 <code class="literal">on-delete="cascade"</code>，这样 Hibernate 将使用数据库级的 <code class="literal">ON CASCADE DELETE</code> 约束，而不是多个 <code class="literal">DELETE</code> 语句。注意，这个特性会绕过 Hibernate 通常对版本数据（versioned data）采用的乐观锁策略。  </p><p><code class="literal">not-null</code> 和 <code class="literal">update</code> 属性在映射单向一对多关联的时候有用。如果你映射一个单向一对多关联到非空的（non-nullable）外键，你<span class="emphasis"><em>必须</em></span> 用 <code class="literal">&lt;key not-null="true"&gt;</code> 定义此键字段。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-column"/>5.1.22. 字段和规则元素（column and formula elements） </h3></div></div></div><p>任何接受 <code class="literal">column</code> 属性的映射元素都可以选择接受 <code class="literal">&lt;column&gt;</code> 子元素。同样的，<code class="literal">formula</code> 子元素也可以替换 <code class="literal">&lt;formula&gt;</code> 属性。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">column</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;column_name&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;N&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">precision</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;N&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">scale</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;N&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true|false&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">unique</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true|false&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">unique-key</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;multicolumn_unique_key_name&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">index</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;index_name&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">sql-type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;sql_type_name&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">check</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;SQL&nbsp;expression&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">default</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;SQL&nbsp;expression&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">read</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;SQL&nbsp;expression&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">write</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;SQL&nbsp;expression&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">formula</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">SQL&nbsp;expression</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">formula</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p><code class="literal">column</code> 上的大多数属性都提供了在自动模式生成过程中对 DDL 进行裁剪的方法。<code class="literal">read</code> 和 <code class="literal">write</code> 属性允许你指定 Hibernate 用于访问字段值的自定义的 SQL。关于更多的内容，请参考 <a class="link" href="mapping.html#mapping-column-read-and-write" title="5.7. 字段的读写表达式">column read and write expressions</a>。 </p><p><code class="literal">column</code> 和 <code class="literal">formula</code> 属性甚至可以在同一个属性或关联映射中被合并来表达，例如，一些奇异的连接条件。 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;homeAddress&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Address&quot;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_attribute_name">insert</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;false&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">update</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;false&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">column</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;person_id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">not-null</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;true&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">length</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;10&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">formula</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">'MAILING'</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">formula</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">many-to-one</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-declaration-import"/>5.1.23. 引用（import） </h3></div></div></div><p>假设你的应用程序有两个同样名字的持久化类，但是你不想在 Hibernate 查询中使用他们的全限定名。除了依赖 <code class="literal">auto-import="true"</code> 以外，类也可以被显式地“import（引用）”。你甚至可以引用没有被明确映射的类和接口。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">import</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;java.lang.Object&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">rename</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Universe&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><div class="programlistingco"><pre class="programlisting">&lt;import
        class=<span xmlns="" class="co" id="import1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>"ClassName"
        rename<span xmlns="" class="co" id="import2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>="ShortName"
/&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">class</code>：任何 Java 类的全限定名。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">rename</code>（可选 — 默认为类的全限定名）：在查询语句中可以使用的名字。  </p></td></tr></table></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-anymapping"/>5.1.24. Any</h3></div></div></div><p>这是属性映射的又一种类型。<code class="literal">&lt;any&gt;</code> 映射元素定义了一种从多个表到类的多态关联。这种类型的映射常常需要多于一个字段。第一个字段持有被关联实体的类型，其他的字段持有标识符。对这种类型的关联来说，不可能指定一个外键约束，所以这当然不是映射（多态）关联的通常的方式。你只应该在非常特殊的情况下使用它(比如，审计 log，用户会话数据等等)。  </p><p><code class="literal">meta-type</code> 属性使得应用程序能指定一个将数据库字段的值映射到持久化类的自定义类型。这个持久化类包含有用 <code class="literal">id-type</code> 指定的标识符属性。你必须指定从 meta-type 的值到类名的映射。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">any</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;being&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">id-type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;long&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">meta-type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;string&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">meta-value</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TBL_ANIMAL&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Animal&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">meta-value</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TBL_HUMAN&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Human&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">meta-value</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">value</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;TBL_ALIEN&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;Alien&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">column</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;table_name&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">column</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">any</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><div class="programlistingco"><pre class="programlisting">&lt;any
        name="<span xmlns="" class="co" id="any1"><img src="images/org/hibernate/docbook/callouts/1.png" alt="(1)"/></span>propertyName"
        id-typ<span xmlns="" class="co" id="any2"><img src="images/org/hibernate/docbook/callouts/2.png" alt="(2)"/></span>e="idtypename"
        meta-t<span xmlns="" class="co" id="any3"><img src="images/org/hibernate/docbook/callouts/3.png" alt="(3)"/></span>ype="metatypename"
        cascad<span xmlns="" class="co" id="any4"><img src="images/org/hibernate/docbook/callouts/4.png" alt="(4)"/></span>e="cascade_style"
        access<span xmlns="" class="co" id="any5"><img src="images/org/hibernate/docbook/callouts/5.png" alt="(5)"/></span>="field|property|ClassName"
        optimi<span xmlns="" class="co" id="any6"><img src="images/org/hibernate/docbook/callouts/6.png" alt="(6)"/></span>stic-lock="true|false"
&gt;
        &lt;meta-value ... /&gt;
        &lt;meta-value ... /&gt;
        .....
        &lt;column .... /&gt;
        &lt;column .... /&gt;
        .....
&lt;/any
&gt;</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/1.png" alt="1" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">name</code>：属性名 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/2.png" alt="2" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">id-type</code>：标识符类型 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/3.png" alt="3" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">meta-type</code>（可选 -默认是 <code class="literal">string</code>）：允许辨别标志(discriminator)映射的任何类型。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/4.png" alt="4" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">cascade</code>（可选 — 默认是<code class="literal">none</code>）：级联的类型。 </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/5.png" alt="5" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">access</code>（可选 — 默认为 <code class="literal">property</code>）：Hibernate 用来访问属性值的策略。  </p></td></tr><tr><td width="5%" valign="top" align="left"><p><img xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" src="images/org/hibernate/docbook/callouts/6.png" alt="6" border="0" height="17px" width="17px"/></p></td><td valign="top" align="left"><p><code class="literal">optimistic-lock</code>（可选 — 默认是 <code class="literal">true</code>）：表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号（Version）。 </p></td></tr></table></div></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-types"/>5.2. Hibernate 的类型 </h2></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-entitiesvalues"/>5.2.1. 实体（Entities）和值（values）</h3></div></div></div><p>和持久化服务相比，Java 级别的对象分为两个组别： </p><p><span class="emphasis"><em>实体entity</em></span> 独立于任何持有实体引用的对象。与通常的 Java 模型相比，不再被引用的对象会被当作垃圾收集掉。实体必须被显式的保存和删除（除非保存和删除是从父实体向子实体引发的<span class="emphasis"><em>级联</em></span>）。这和 ODMG 模型中关于对象通过可触及保持持久性有一些不同 — 比较起来更加接近应用程序对象通常在一个大系统中的使用方法。实体支持循环引用和交叉引用，它们也可以加上版本信息。  </p><p>一个实体的持久状态包含指向其他实体和<span class="emphasis"><em>值</em></span>类型实例的引用。值可以是原始类型，集合（不是集合中的对象），组件或者特定的不可变对象。与实体不同，值（特别是集合和组件）是通过可触及性来进行持久化和删除的。因为值对象（和原始类型数据）是随着包含他们的实体而被持久化和删除的，他们不能被独立的加上版本信息。值没有独立的标识，所以他们不能被两个实体或者集合共享。  </p><p>直到现在，我们都一直使用术语“持久类”（persistent class）来代表实体。我们仍然会这么做。然而严格说来，不是所有的用户自定义的，带有持久化状态的类都是实体。<span class="emphasis"><em>组件</em></span>就是用户自定义类，却是值语义的。<code class="literal">java.lang.String</code> 类型的 java 属性也是值语义的。给了这个定义以后，我们可以说所有 JDK 提供的类型（类）都是值类型的语义，而用于自定义类型可能被映射为实体类型或值类型语义。采用哪种类型的语义取决于开发人员。在领域模型中，寻找实体类的一个好线索是共享引用指向这个类的单一实例，而组合或聚合通常被转化为值类型。  </p><p>我们会在本文档中重复碰到这两个概念。  </p><p>挑战在于将 java 类型系统(和开发者定义的实体和值类型)映射到 SQL/数据库类型系统。Hibernate 提供了连接两个系统之间的桥梁：对于实体类型，我们使用 <code class="literal">&lt;class&gt;</code>，<code class="literal">&lt;subclass&gt;</code> 等等。对于值类型，我们使用 <code class="literal">&lt;property&gt;</code>，<code class="literal">&lt;component&gt;</code> 及其他，通常跟随着 <code class="literal">type</code> 属性。这个属性的值是Hibernate 的<span class="emphasis"><em>映射类型</em></span>的名字。Hibernate 提供了许多现成的映射（标准的 JDK 值类型）。你也可以编写自己的映射类型并实现自定义的变换策略，随后我们会看到这点。  </p><p>所有的 Hibernate 内建类型，除了 collections 以外，都支持空（null）语义。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-basictypes"/>5.2.2. 基本值类型</h3></div></div></div><p>内置的 <span class="emphasis"><em>basic mapping types</em></span> 可以大致地分类为： </p><div class="variablelist"><dl><dt><span class="term"><code class="literal">integer, long, short, float, double, character, byte, boolean, yes_no, true_false</code></span></dt><dd><p>这些类型都对应 Java 的原始类型或者其封装类，来符合（特定厂商的）SQL 字段类型。<code class="literal">boolean, yes_no</code> 和 <code class="literal">true_false</code> 都是 Java 中 <code class="literal">boolean</code> 或者 <code class="literal">java.lang.Boolean</code> 的另外说法。 </p></dd><dt><span class="term"><code class="literal">string</code></span></dt><dd><p>从 <code class="literal">java.lang.String</code> 到 <code class="literal">VARCHAR</code>（或者 Oracle 的 <code class="literal">VARCHAR2</code>）的映射。 </p></dd><dt><span class="term"><code class="literal">date, time, timestamp</code></span></dt><dd><p>从 <code class="literal">java.util.Date</code> 和其子类到 SQL 类型 <code class="literal">DATE</code>，<code class="literal">TIME</code> 和 <code class="literal">TIMESTAMP</code>（或等价类型）的映射。 </p></dd><dt><span class="term"><code class="literal">calendar, calendar_date</code></span></dt><dd><p>从 <code class="literal">java.util.Calendar</code> 到 SQL 类型 <code class="literal">TIMESTAMP</code> 和 <code class="literal">DATE</code>（或等价类型）的映射。 </p></dd><dt><span class="term"><code class="literal">big_decimal, big_integer</code></span></dt><dd><p>从 <code class="literal">java.math.BigDecimal</code> 和 <code class="literal">java.math.BigInteger</code> 到 <code class="literal">NUMERIC</code>（或者 Oracle 的 <code class="literal">NUMBER</code>类型）的映射。 </p></dd><dt><span class="term"><code class="literal">locale, timezone, currency</code></span></dt><dd><p>从 <code class="literal">java.util.Locale</code>，<code class="literal">java.util.TimeZone</code>  和 <code class="literal">java.util.Currency</code> 到 <code class="literal">VARCHAR</code>（或者 Oracle 的 <code class="literal">VARCHAR2</code> 类型）的映射。<code class="literal">Locale</code> 和 <code class="literal">Currency</code> 的实例被映射为它们的 ISO 代码。<code class="literal">TimeZone</code> 的实例被影射为它的 <code class="literal">ID</code>。 </p></dd><dt><span class="term"><code class="literal">class</code></span></dt><dd><p>从 <code class="literal">java.lang.Class</code> 到 <code class="literal">VARCHAR</code>（或者 Oracle 的 <code class="literal">VARCHAR2</code> 类型）的映射。<code class="literal">Class</code> 被映射为它的全限定名。 </p></dd><dt><span class="term"><code class="literal">binary</code></span></dt><dd><p>把字节数组（byte arrays）映射为对应的 SQL 二进制类型。 </p></dd><dt><span class="term"><code class="literal">text</code></span></dt><dd><p>把长 Java 字符串映射为 SQL 的 <code class="literal">CLOB</code> 或者 <code class="literal">TEXT</code> 类型。 </p></dd><dt><span class="term"><code class="literal">serializable</code></span></dt><dd><p>把可序列化的 Java 类型映射到对应的 SQL 二进制类型。你也可以为一个并非默认为基本类型的可序列化 Java 类或者接口指定 Hibernate 类型 <code class="literal">serializable</code>。  </p></dd><dt><span class="term"><code class="literal">clob, blob</code></span></dt><dd><p>JDBC 类 <code class="literal">java.sql.Clob</code> 和 <code class="literal">java.sql.Blob</code>的映射。某些程序可能不适合使用这个类型，因为 blob 和 clob 对象可能在一个事务之外是无法重用的。（而且, 驱动程序对这种类型的支持充满着补丁和前后矛盾。）  </p></dd><dt><span class="term">
                            <code class="literal">imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary</code>
                        </span></dt><dd><p>一般来说，映射类型被假定为是可变的 Java 类型，只有对不可变 Java 类型，Hibernate 会采取特定的优化措施，应用程序会把这些对象作为不可变对象处理。比如，你不应该对作为 <code class="literal">imm_timestamp</code> 映射的 Date 执行 <code class="literal">Date.setTime()</code>。要改变属性的值，并且保存这一改变，应用程序必须对这一属性重新设置一个新的（不一样的）对象。  </p></dd></dl></div><p>

            </p><p>实体及其集合的唯一标识可以是除了 <code class="literal">binary</code>、 <code class="literal">blob</code> 和 <code class="literal">clob</code> 之外的任何基础类型。（联合标识也是允许的，后面会说到。） </p><p>在 <code class="literal">org.hibernate.Hibernate</code> 中，定义了基础类型对应的 <code class="literal">Type</code> 常量。比如，<code class="literal">Hibernate.STRING</code> 代表 <code class="literal">string</code> 类型。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-types-custom"/>5.2.3. 自定义值类型</h3></div></div></div><p>开发者创建属于他们自己的值类型也是很容易的。比如说，你可能希望持久化 <code class="literal">java.lang.BigInteger</code> 类型的属性，持久化成为 <code class="literal">VARCHAR</code> 字段。Hibernate没有内置这样一种类型。自定义类型能够映射一个属性(或集合元素)到不止一个数据库表字段。比如说，你可能有这样的 Java 属性：<code class="literal">getName()</code>/<code class="literal">setName()</code>，这是 <code class="literal">java.lang.String</code> 类型的，对应的持久化到三个字段：<code class="literal">FIRST_NAME</code>，<code class="literal">INITIAL</code>，<code class="literal">SURNAME</code>。  </p><p>要实现一个自定义类型，可以实现 <code class="literal">org.hibernate.UserType</code> 或 <code class="literal">org.hibernate.CompositeUserType</code> 中的任一个，并且使用类型的 Java 全限定类名来定义属性。请查看 <code class="literal">org.hibernate.test.DoubleStringType</code> 这个例子，看看它是怎么做的。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;twoStrings&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.test.DoubleStringType&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">column</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;first_string&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">column</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;second_string&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>注意使用 <code class="literal">&lt;column&gt;</code> 标签来把一个属性映射到多个字段的做法。 </p><p><code class="literal">CompositeUserType</code>，<code class="literal">EnhancedUserType</code>，<code class="literal">UserCollectionType</code> 和 <code class="literal">UserVersionType</code> 接口为更特殊的使用方式提供支持。 </p><p>你甚至可以在一个映射文件中提供参数给一个 <code class="literal">UserType</code>。 为了这样做，你的 <code class="literal">UserType</code> 必须实现 <code class="literal">org.hibernate.usertype.ParameterizedType</code> 接口。为了给自定义类型提供参数，你可以在映射文件中使用 <code class="literal">&lt;type&gt;</code> 元素。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;priority&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">type</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;com.mycompany.usertypes.DefaultValueIntegerType&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;default&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">0</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">type</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">property</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>现在，<code class="literal">UserType</code> 可以从传入的 <code class="literal">Properties</code> 对象中得到 <code class="literal">default</code> 参数的值。 </p><p>如果你非常频繁地使用某一 <code class="literal">UserType</code>，可以为他定义一个简称。这可以通过使用 <code class="literal">&lt;typedef&gt;</code> 元素来实现。Typedefs 为一自定义类型赋予一个名称，并且如果此类型是参数化的，还可以包含一系列默认的参数值。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">typedef</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;com.mycompany.usertypes.DefaultValueIntegerType&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;default_zero&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">param</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;default&quot;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">0</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">param</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">typedef</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;priority&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">type</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;default_zero&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
</pre><p>也可以根据具体案例通过属性映射中的类型参数覆盖在 typedef 中提供的参数。 </p><p>尽管 Hibernate 内建的丰富的类型和对组件的支持意味着你可能很少 <span class="emphasis"><em>需要</em></span>使用自定义类型。不过，为那些在你的应用中经常出现的(非实体)类使用自定义类型也是一个好方法。例如，一个 <code class="literal">MonetaryAmount</code> 类使用 <code class="literal">CompositeUserType</code> 来映射是不错的选择，虽然他可以很容易地被映射成组件。这样做的动机之一是抽象。使用自定义类型，以后假若你改变表示金额的方法时，它可以保证映射文件不需要修改。  </p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-entityname"/>5.3. 多次映射同一个类</h2></div></div></div><p>对特定的持久化类，映射多次是允许的。这种情形下，你必须指定 <span class="emphasis"><em>entity name</em></span> 来区别不同映射实体的对象实例。（默认情况下，实体名字和类名是相同的。） Hibernate 在操作持久化对象、编写查询条件，或者把关联映射到指定实体时，允许你指定这个 entity name（实体名字）。  </p><pre class="programlisting">&lt;class name="Contract" table="Contracts"
        entity-name="CurrentContract"&gt;
    ...
    &lt;set name="history" inverse="true"
            order-by="effectiveEndDate desc"&gt;
        &lt;key column="currentContractId"/&gt;
        &lt;one-to-many entity-name="HistoricalContract"/&gt;
    &lt;/set&gt;
&lt;/class&gt;

&lt;class name="Contract" table="ContractHistory"
        entity-name="HistoricalContract"&gt;
    ...
    &lt;many-to-one name="currentContract"
            column="currentContractId"
            entity-name="CurrentContract"/&gt;
&lt;/class
&gt;</pre><p>注意这里关联是如何用 <code class="literal">entity-name</code> 来代替 <code class="literal">class</code> 的。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-quotedidentifiers"/>5.4. SQL 中引号包围的标识符</h2></div></div></div><p>你可通过在映射文档中使用反向引号（`）把表名或者字段名包围起来，以强制 Hibernate 在生成的 SQL 中把标识符用引号包围起来。Hibernate 会使用相应的 SQL<code class="literal">Dialect</code>（方言）来使用正确的引号风格(通常是双引号，但是在 SQL Server 中是括号，MySQL 中是反向引号)。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">class</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;LineItem&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">table</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;`Line&nbsp;Item`&quot;</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">id</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;id&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;`Item&nbsp;Id`&quot;</span><span class="xml_tag_symbols">/&gt;&lt;</span><span class="xml_tag_name">generator</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;assigned&quot;</span><span class="xml_tag_symbols">/&gt;&lt;/</span><span class="xml_tag_name">id</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">property</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;itemNumber&quot;</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">column</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;`Item&nbsp;#`&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">class</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-alternatives"/>5.5. 其他元数据（Metadata）</h2></div></div></div><p>XML 并不适用于所有人, 因此有其他定义 Hibernate O/R 映射元数据（metadata）的方法。  </p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-xdoclet"/>5.5.1. 使用 XDoclet 标记</h3></div></div></div><p>很多 Hibernate 使用者更喜欢使用 XDoclet<code class="literal">@hibernate.tags</code> 将映射信息直接嵌入到源代码中。我们不会在本文档中涉及这个方法，因为严格说来，这属于 XDoclet 的一部分。然而，我们包含了如下使用 XDoclet 映射的 <code class="literal">Cat</code> 类的例子。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_keyword">package</span><!-- <br/> --><span class="java_plain">&nbsp;eg</span><!-- <br/> --><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">import</span><span class="java_plain">&nbsp;java</span><span class="java_separator">.</span><span class="java_plain">util</span><span class="java_separator">.</span><span class="java_type">Set</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">import</span><span class="java_plain">&nbsp;java</span><span class="java_separator">.</span><span class="java_plain">util</span><span class="java_separator">.</span><span class="java_type">Date</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@hibernate</span><span class="java_javadoc_comment">.class</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;*&nbsp;&nbsp;table=&quot;CATS&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;*/</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">Long</span><span class="java_plain">&nbsp;id</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;identifier</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">Date</span><span class="java_plain">&nbsp;birthdate</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;mother</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">Set</span><span class="java_plain">&nbsp;kittens</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">Color</span><span class="java_plain">&nbsp;color</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">char</span><span class="java_plain">&nbsp;sex</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">float</span><span class="java_plain">&nbsp;weight</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_comment">/*</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@hibernate.id</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;generator-class=&quot;native&quot;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;column=&quot;CAT_ID&quot;</span>
<!--  --><br/><span class="java_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Long</span><span class="java_plain">&nbsp;getId</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;id</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;setId</span><span class="java_separator">(</span><span class="java_type">Long</span><span class="java_plain">&nbsp;id</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">this</span><span class="java_separator">.</span><span class="java_plain">id</span><span class="java_operator">=</span><span class="java_plain">id</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@hibernate</span><span class="java_javadoc_comment">.many-to-one</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;column=&quot;PARENT_ID&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;getMother</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;mother</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;setMother</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;mother</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">this</span><span class="java_separator">.</span><span class="java_plain">mother&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;mother</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@hibernate</span><span class="java_javadoc_comment">.property</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;column=&quot;BIRTH_DATE&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Date</span><span class="java_plain">&nbsp;getBirthdate</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;birthdate</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;setBirthdate</span><span class="java_separator">(</span><span class="java_type">Date</span><span class="java_plain">&nbsp;date</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;birthdate&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;date</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@hibernate</span><span class="java_javadoc_comment">.property</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;column=&quot;WEIGHT&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">float</span><span class="java_plain">&nbsp;getWeight</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;weight</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;setWeight</span><span class="java_separator">(</span><span class="java_type">float</span><span class="java_plain">&nbsp;weight</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">this</span><span class="java_separator">.</span><span class="java_plain">weight&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;weight</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@hibernate</span><span class="java_javadoc_comment">.property</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;column=&quot;COLOR&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;not-null=&quot;true&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Color</span><span class="java_plain">&nbsp;getColor</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;color</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;setColor</span><span class="java_separator">(</span><span class="java_type">Color</span><span class="java_plain">&nbsp;color</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">this</span><span class="java_separator">.</span><span class="java_plain">color&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;color</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@hibernate</span><span class="java_javadoc_comment">.set</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;inverse=&quot;true&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;order-by=&quot;BIRTH_DATE&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@hibernate</span><span class="java_javadoc_comment">.collection-key</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;column=&quot;PARENT_ID&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@hibernate</span><span class="java_javadoc_comment">.collection-one-to-many</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">Set</span><span class="java_plain">&nbsp;getKittens</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;kittens</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;setKittens</span><span class="java_separator">(</span><span class="java_type">Set</span><span class="java_plain">&nbsp;kittens</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">this</span><span class="java_separator">.</span><span class="java_plain">kittens&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;kittens</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;addKitten&nbsp;not&nbsp;needed&nbsp;by&nbsp;</span><span class="java_type">Hibernate</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;addKitten</span><span class="java_separator">(</span><span class="java_type">Cat</span><span class="java_plain">&nbsp;kitten</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kittens</span><span class="java_separator">.</span><span class="java_plain">add</span><span class="java_separator">(</span><span class="java_plain">kitten</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_javadoc_comment">/**</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;</span><span class="java_javadoc_tag">@hibernate</span><span class="java_javadoc_comment">.property</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;column=&quot;SEX&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;not-null=&quot;true&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;update=&quot;false&quot;</span>
<!--  --><br/><span class="java_javadoc_comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">char</span><span class="java_plain">&nbsp;getSex</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;sex</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;setSex</span><span class="java_separator">(</span><span class="java_type">char</span><span class="java_plain">&nbsp;sex</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">this</span><span class="java_separator">.</span><span class="java_plain">sex</span><span class="java_operator">=</span><span class="java_plain">sex</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>参考 Hibernate 网站更多的 Xdoclet 和 Hibernate 的例子。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="mapping-annotations"/>5.5.2. 使用 JDK 5.0 的注解（Annotation）</h3></div></div></div><p>JDK 5.0 在语言级别引入了 XDoclet 风格的标注，并且是类型安全的，在编译期进行检查。这一机制比 XDoclet 的注解更为强大，有更好的工具和 IDE 支持。例如，IntelliJ IDEA，支持 JDK 5.0 注解的自动完成和语法高亮 。EJB 规范的新修订版 (JSR-220) 使用 JDK 5.0 的注解作为entity beans的主要元数据（metadata）机制。Hibernate 3 实现了JSR-220(the persistence API) 的 <code class="literal">EntityManager</code>，支持通过 <span class="emphasis"><em>Hibernate Annotations</em></span> 包定义映射元数据。这个包作为单独的部分下载，支持 EJB3(JSR-220) 和 Hibernate3 的元数据。  </p><p>这是一个被注解为 EJB entity bean 的 POJO 类的例子 </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Entity</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">access&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">AccessType</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">FIELD</span><!-- <br/> --><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">Customer</span><span class="java_plain">&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">Serializable</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">Id</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Long</span><span class="java_plain">&nbsp;id</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;firstName</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;lastName</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Date</span><span class="java_plain">&nbsp;birthday</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">Transient</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Integer</span><span class="java_plain">&nbsp;age</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">Embedded</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">private</span><span class="java_plain">&nbsp;</span><span class="java_type">Address</span><span class="java_plain">&nbsp;homeAddress</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">OneToMany</span><span class="java_separator">(</span><span class="java_plain">cascade</span><span class="java_operator">=</span><span class="java_type">CascadeType</span><span class="java_separator">.</span><span class="java_plain">ALL</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">JoinColumn</span><span class="java_separator">(</span><span class="java_plain">name</span><span class="java_operator">=</span><span class="java_literal">&quot;CUSTOMER_ID&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">Set</span><span class="java_operator">&lt;</span><span class="java_type">Order</span>
<!--  --><br/><span class="java_operator">&gt;</span><span class="java_plain">&nbsp;orders</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Getter</span><span class="java_operator">/</span><span class="java_plain">setter&nbsp;and&nbsp;business&nbsp;methods</span>
<!--  --><br/><span class="java_separator">}</span></pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>注意：对 JDK 5.0 注解（和 JSR-220)支持的工作仍然在进行中,并未完成。更多细节请参阅 Hibernate Annotations 模块。  </p></div></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-generated"/>5.6. 数据库生成属性（Generated Properties） </h2></div></div></div><p>Generated properties 指的是其值由数据库生成的属性。一般来说，如果对象有任何属性由数据库生成值，Hibernate 应用程序需要进行<code class="literal">刷新（refresh）</code>。但如果把属性标明为 generated，就可以转由 Hibernate 来负责这个动作。实际上。对定义了 generated properties 的实体,每当 Hibernate 执行一条 SQL INSERT 或者 UPDATE 语句，会立刻执行一条 select 来获得生成的值。  </p><p>被标明为 generated 的属性还必须是 non-insertable 和 non-updateable 的。只有 <a class="link" href="mapping.html#mapping-declaration-version" title="5.1.9. 版本（version）（可选）">versions</a>、<a class="link" href="mapping.html#mapping-declaration-timestamp" title="5.1.10. timestamp（可选)">timestamps</a> 和 <a class="link" href="mapping.html#mapping-declaration-property" title="5.1.11. Property">simple properties</a> 可以被标明为 generated。  </p><p><code class="literal">never</code>（默认）标明此属性值不是从数据库中生成。  </p><p><code class="literal">insert</code> — 标明此属性值在 insert 的时候生成，但是不会在随后的 update 时重新生成。比如说创建日期就归属于这类。注意虽然 <a class="link" href="mapping.html#mapping-declaration-version" title="5.1.9. 版本（version）（可选）">version</a> 和 <a class="link" href="mapping.html#mapping-declaration-timestamp" title="5.1.10. timestamp（可选)">timestamp</a> 属性可以被标注为 generated，但是不适用这个选项。 </p><p><code class="literal">always</code> — 标明此属性值在 insert 和 update 时都会被生成。  </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-column-read-and-write"/>5.7. 字段的读写表达式</h2></div></div></div><p>Hibernate allows you to customize the SQL it uses to read and write the values of columns mapped to <a class="link" href="mapping.html#mapping-declaration-property" title="5.1.11. Property">simple properties</a>. For example, if your database provides a set of data encryption functions, you can invoke them for individual columns like this: </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML">&lt;!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) --&gt;
&lt;span class="xml_tag_symbols"&gt;&amp;lt;&lt;/span&gt;&lt;span class="xml_tag_name"&gt;property&lt;/span&gt;&lt;span class="xml_plain"&gt;&amp;nbsp;&lt;/span&gt;&lt;span class="xml_attribute_name"&gt;name&lt;/span&gt;&lt;span class="xml_tag_symbols"&gt;=&lt;/span&gt;&lt;span class="xml_attribute_value"&gt;&amp;quot;creditCardNumber&amp;quot;&lt;/span&gt;&lt;span class="xml_tag_symbols"&gt;&amp;gt;&lt;/span&gt;&lt;span class="xml_plain"&gt;&lt;/span&gt;&lt;br /&gt;
&lt;span class="xml_plain"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class="xml_tag_symbols"&gt;&amp;lt;&lt;/span&gt;&lt;span class="xml_tag_name"&gt;column&lt;/span&gt;&lt;span class="xml_plain"&gt;&amp;nbsp;&lt;/span&gt;&lt;br /&gt;
&lt;span class="xml_plain"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class="xml_attribute_name"&gt;name&lt;/span&gt;&lt;span class="xml_tag_symbols"&gt;=&lt;/span&gt;&lt;span class="xml_attribute_value"&gt;&amp;quot;credit_card_num&amp;quot;&lt;/span&gt;&lt;span class="xml_plain"&gt;&lt;/span&gt;&lt;br /&gt;
&lt;span class="xml_plain"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class="xml_attribute_name"&gt;read&lt;/span&gt;&lt;span class="xml_tag_symbols"&gt;=&lt;/span&gt;&lt;span class="xml_attribute_value"&gt;&amp;quot;decrypt(credit_card_num)&amp;quot;&lt;/span&gt;&lt;span class="xml_plain"&gt;&lt;/span&gt;&lt;br /&gt;
&lt;span class="xml_plain"&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;span class="xml_attribute_name"&gt;write&lt;/span&gt;&lt;span class="xml_tag_symbols"&gt;=&lt;/span&gt;&lt;span class="xml_attribute_value"&gt;&amp;quot;encrypt(?)&amp;quot;&lt;/span&gt;&lt;span class="xml_tag_symbols"&gt;/&amp;gt;&lt;/span&gt;&lt;span class="xml_plain"&gt;&lt;/span&gt;&lt;br /&gt;
&lt;span class="xml_tag_symbols"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="xml_tag_name"&gt;property&lt;/span&gt;&lt;span class="xml_plain"&gt;&lt;/span&gt;&lt;br /&gt;
&lt;span class="xml_tag_symbols"&gt;&amp;gt;&lt;/span&gt;&lt;span class="xml_plain"&gt;&lt;/span&gt;&lt;br /&gt;
</pre><p>
        </p><p>每当属性在查询里被引用时，Hibernate 都自动应用自定义的表达式。这种功能和 derived-property <code class="literal">formula</code> 相似，但有两个不同的地方： </p><div class="itemizedlist"><ul compact="compact"><li><p>属性由一个或多个属性组成，它作为自动模式生成的一部分导出。 </p></li><li><p>属性是可读写的，非只读的。 </p></li></ul></div><p>
        </p><p>如果指定了 <code class="literal">write</code> 表达式，它必须只包含一个“?”占位符。 </p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="mapping-database-object"/>5.8. 辅助数据库对象（Auxiliary Database Objects） </h2></div></div></div><p>允许 CREATE 和 DROP 任意数据库对象，与 Hibernate 的 schema 交互工具组合起来，可以提供在 Hibernate 映射文件中完全定义用户 schema 的能力。虽然这是为创建和销毁 trigger（触发器）或stored procedure（存储过程）等特别设计的，实际上任何可以在 <code class="literal">java.sql.Statement.execute()</code> 方法中执行的 SQL 命令都可以在此使用（比如ALTER, INSERT，等等）。本质上有两种模式来定义辅助数据库对象...  </p><p>第一种模式是在映射文件中显式声明 CREATE 和 DROP 命令：  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">database-object</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">create</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">CREATE&nbsp;TRIGGER&nbsp;my_trigger&nbsp;...</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">create</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">drop</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain">DROP&nbsp;TRIGGER&nbsp;my_trigger</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">drop</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">database-object</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>第二种模式是提供一个类，这个类知道如何组织 CREATE 和 DROP 命令。这个特别类必须实现 <code class="literal">org.hibernate.mapping.AuxiliaryDatabaseObject</code> 接口。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">database-object</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">definition</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;MyTriggerDefinition&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">database-object</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre><p>还有，这些数据库对象可以特别指定为仅在特定的方言中才使用。  </p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;...</span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">database-object</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">definition</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">class</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;MyTriggerDefinition&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dialect-scope</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.dialect.Oracle9iDialect&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dialect-scope</span><span class="xml_plain">&nbsp;</span><span class="xml_attribute_name">name</span><span class="xml_tag_symbols">=</span><span class="xml_attribute_value">&quot;org.hibernate.dialect.Oracle10gDialect&quot;</span><span class="xml_tag_symbols">/&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">database-object</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">hibernate-mapping</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="persistent-classes.html"><strong>上一页</strong>第 4 章 持久化类（Persistent Classes）</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="collections.html"><strong>下一页</strong>第 6 章 集合映射（Collection mappings）</a></li></ul></body></html>