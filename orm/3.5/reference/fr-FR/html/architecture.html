<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapitre 2. Architecture</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="tutorial.html" title="Chapitre 1. Tutoriel"/><link rel="next" href="session-configuration.html" title="Chapitre 3. Configuration"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Précédent</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Suivant</strong></a></li></ul><div class="chapter" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Chapitre 2. Architecture</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="architecture.html#architecture-overview">2.1. Généralités</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-states">2.2. Etats des instances</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-jmx">2.3. Intégration JMX</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-jca">2.4. Support JCA</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-current-session">2.5. Sessions contextuelles </a></span></dt></dl></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. Généralités</h2></div></div></div><p>Le diagramme ci-dessus procure une vue - (très) haut niveau - de l'architecture Hibernate : </p><div class="mediaobject" align="center"><img src="images/overview.png" align="middle"/></div><p>Nous aimerions décrire une vue plus détaillée de l'architecture. Hibernate est flexible et prend en charge différentes approches. Nous allons en montrer les deux extrêmes : l'architecture "légère"  et l'architecture "complète". </p><p>Ce diagramme montre Hibernate utilisant la base de données et des données de configuration pour fournir un service de persistance, et des objets persistants, à l'application. </p><p>L'architecture "légère" permet à l'application de fournir ses propres connexions JDBC et de gérer ses propres transactions. Cette approche utilise un sous-ensemble minimum des API Hibernate : </p><div class="mediaobject" align="center"><img src="images/lite.png" align="middle"/></div><p>L'architecture "complète" abstrait l'application des API JDBC/JTA sous-jacentes et permet à Hibernate de s'occuper des détails. </p><div class="mediaobject" align="center"><img src="images/full_cream.png" align="middle"/></div><p>Voici quelques définitions des objets dans les diagrammes : </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="literal">org.hibernate.SessionFactory</code>)</span></dt><dd><p>Un cache threadsafe (immuable) de mappages compilés pour une base de données. En tant que fabrique de <code class="literal">Session</code> et que client du <code class="literal">ConnectionProvider</code>, <code class="literal">SessionFactory</code>peut contenir un cache optionnel de données (de second niveau), réutilisable entre les différentes transactions, que cela soit au sein du même processus ou au niveau d'un cluster. </p></dd><dt><span class="term">Session (<code class="literal">org.hibernate.Session</code>)</span></dt><dd><p>Un objet mono-threadé, à durée de vie courte, qui représente une conversation entre l'application et l'entrepôt de persistance. Encapsule une connexion JDBC. Fabrique des objets <code class="literal">Transaction</code>. La <code class="literal">Session</code> contient un cache (de premier niveau) des objets persistants, qui sont utilisés lors de la navigation dans le graphe d'objets ou lors de la récupération d'objets par leur identifiant. </p></dd><dt><span class="term">Objets et collections persistants</span></dt><dd><p>Objets mono-threadés à vie courte, contenant état persistant et fonction commerciale. Ceux-ci sont en général des objets ordinaires de type JavaBean (ou POJO); la seule particularité est qu'ils sont associés avec une (et une seule) <code class="literal">Session</code>. Dès que la <code class="literal">Session</code> est fermée, ils sont détachés et libres d'être utilisés par n'importe quelle couche de l'application (par ex. de et vers la présentation). </p></dd><dt><span class="term">Objets et collections éphémères (transient) et détachés</span></dt><dd><p>Instances de classes persistantes qui ne sont actuellement pas associées à une <code class="literal">Session</code>. Elles ont pu être instanciées par l'application et ne pas avoir (encore) été persistées, ou elle ont pu être instanciées par une <code class="literal">Session</code> fermée. </p></dd><dt><span class="term">Transaction (<code class="literal">org.hibernate.Transaction</code>)</span></dt><dd><p>(Optionnel) Un objet mono-threadé à vie courte utilisé par l'application pour définir une unité de travail atomique. Abstrait l'application des transactions sous-jacentes, qu'elles soient JDBC, JTA ou CORBA. Une <code class="literal">Session</code> peut fournir plusieurs <code class="literal">Transaction</code>s dans certains cas. Toutefois, la délimitation des transactions, via l'API d'Hibernate ou par la <code class="literal">Transaction</code> sous-jacente, n'est jamais optionnelle.  </p></dd><dt><span class="term">ConnectionProvider (<code class="literal">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(Optionnel) Une fabrique de (pool de) connexions JDBC. Abstrait l'application de la <code class="literal">Datasource</code> ou du <code class="literal">DriverManager</code> sous-jacent. Non exposé à l'application, mais peut être étendu/implémenté par le développeur.  </p></dd><dt><span class="term">TransactionFactory (<code class="literal">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(Optionnel) Une fabrique d'instances de <code class="literal">Transaction</code>. Non exposée à l'application, mais peut être étendue/implémentée par le développeur.  </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>Hibernate fournit de nombreuses interfaces d'extensions optionnelles que vous pouvez implémenter pour personnaliser le comportement de votre couche de persistance. Reportez vous à la documentation de l'API pour plus de détails.  </p></dd></dl></div><p>
        </p><p>Dans une architecture légère, l'application n'aura pas à utiliser les API <code class="literal">Transaction</code>/<code class="literal">TransactionFactory</code> et/ou n'utilisera pas les API <code class="literal">ConnectionProvider</code> pour utiliser directement JTA ou JDBC.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-states"/>2.2. Etats des instances</h2></div></div></div><p>Une instance d'une classe persistante peut être dans l'un des trois états suivants, définis par rapport à un <span class="emphasis"><em>contexte de persistance</em></span>. L'objet <code class="literal">Session</code> Hibernate correspond à ce contexte de persistance. Les trois états distincts sont: </p><div class="variablelist"><dl><dt><span class="term">éphémère (transient)</span></dt><dd><p>L'instance n'est pas et n'a jamais été associée à un contexte de persistance. Elle ne possède pas d'identité persistante (valeur de clé primaire). </p></dd><dt><span class="term">persistant</span></dt><dd><p>L'instance est associée à un contexte de persistance. Elle possède une identité persistante (valeur de clé primaire) et, peut-être un enregistrement correspondant dans la base de données. Pour un contexte de persistance particulier, Hibernate <span class="emphasis"><em>garantit</em></span> que l'identité persistante soit équivalente à l'identité Java (emplacement mémoire de l'objet).  </p></dd><dt><span class="term">détaché</span></dt><dd><p>L'instance a été associée au contexte de persistance mais ce contexte a été fermé, ou l'instance a été sérialisée vers un autre processus. Elle possède une identité persistante et peut-être un enregistrement correspondant dans la base de données. Pour des instances détachées, Hibernate ne donne aucune garantie sur la relation entre l'identité persistante et l'identité Java.  </p></dd></dl></div></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.3. Intégration JMX</h2></div></div></div><p>JMX est le standard J2EE de gestion des composants Java. Hibernate peut être géré via un service JMX standard. Nous fournissons une implémentation d'un MBean dans la distribution : <code class="literal">org.hibernate.jmx.HibernateService</code>.  </p><p>Pour un exemple sur la manière de déployer Hibernate en tant que service JMX dans le serveur d'application JBoss Application Server, référez vous au guide de l'utilisateur JBoss (JBoss User Guide). Si vous déployez Hibernate via JMX sur JBoss AS, vous aurez également les avantages suivants :  </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Gestion de la session</em></span> : le cycle de vie de la <code class="literal">Session</code> Hibernate peut être automatiquement liée à la portée d'une transaction JTA. Cela signifie que vous n'avez plus besoin d'ouvrir et de fermer la <code class="literal">Session</code> manuellement, cela devient le travail de l'intercepteur EJB de JBoss. Vous n'avez pas non plus à vous occuper des démarcations des transactions dans votre code (sauf si vous voulez écrire une couche de persistance qui soit portable, dans ce cas vous pouvez utiliser l'API optionnelle <code class="literal">Transaction</code> de Hibernate). Vous appelez le <code class="literal">HibernateContext</code> pour accéder à la <code class="literal">Session</code>.  </p></li><li><p><span class="emphasis"><em>Déploiement HAR :</em></span>: habituellement vous déployez le service JMX Hibernate en utilisant le descripteur de déploiement de JBoss dans un fichier EAR et/ou un SAR, car il supporte toutes les options de configuration usuelles d'une <code class="literal">SessionFactory</code> Hibernate. Cependant, vous devez toujours nommer tous vos fichiers de mappage dans le descripteur de déploiement. Si vous décidez d'utiliser le déploiement optionnel sous forme de HAR, JBoss détectera automatiquement tous vos fichiers de mapping dans votre fichier HAR. </p></li></ul></div><p>Consultez le guide d'utilisation de JBoss AS pour plus d'informations sur ces options. </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a class="xref" href="session-configuration.html#configuration-optional-statistics" title="3.4.6. Statistiques Hibernate">Section 3.4.6, « Statistiques Hibernate »</a> for more information. </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jca"/>2.4. Support JCA</h2></div></div></div><p>Hibernate peut aussi être configuré en tant que connecteur JCA. Référez-vous au site web pour de plus amples détails. Il est important de noter que le support JCA de Hibernate est encore considéré comme expérimental.  </p></div><div class="section" lang="fr-FR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.5. Sessions contextuelles </h2></div></div></div><p>Certaines applications utilisant Hibernate ont besoin d'une sorte de session "contextuelle", où une session donnée est en effet liée à la portée d'un contexte particulier. Cependant, les applications ne définissent pas toutes la notion de contexte de la même manière, et différents contextes définissent différentes portées à la notion de "courant". Les applications qui utilisaient Hibernate, versions précédentes à la 3.0, avaient tendance à employer un principe maison de sessions contextuelles basées sur le <code class="literal">ThreadLocal</code>, ainsi que sur des classes utilitaires comme <code class="literal">HibernateUtil</code>, ou utilisaient des framework tiers (comme Spring ou Pico) qui fournissaient des sessions contextuelles basées sur l'utilisation de proxy/interception.  </p><p>A partir de la version 3.0.1, Hibernate a ajouté la méthode <code class="literal">SessionFactory.getCurrentSession()</code>. Initialement, cela demandait l'usage de transactions <code class="literal">JTA</code>, où la transaction <code class="literal">JTA</code> définissait la portée et le contexte de la session courante. L'équipe Hibernate pense que, étant donnée la maturité des nombreuses implémentations autonomes du <code class="literal">JTA TransactionManager</code>, la plupart (sinon toutes) des applications devraient utiliser la gestion des transactions par <code class="literal">JTA</code> qu'elles soient ou non déployées dans un conteneur <code class="literal">J2EE</code>. Par conséquent, il vous suffira de contextualiser vos sessions via la méthode basée sur <code class="literal">JTA</code>.  </p><p>Cependant, depuis la version 3.1, la logique derrière <code class="literal">SessionFactory.getCurrentSession()</code> est désormais enfichable. A cette fin, une nouvelle interface d'extension(<code class="literal">org.hibernate.context.CurrentSessionContext</code> et un nouveau paramètre de configuration <code class="literal">hibernate.current_session_context_class</code> ont été ajoutés pour enficher la portée et le contexte de sessions courantes caractéristiques. </p><p>Pour une description détaillée de son contrat, consultez les Javadocs de l'interface <code class="literal">org.hibernate.context.CurrentSessionContext</code>. Elle définit une seule méthode, <code class="literal">currentSession()</code>, par laquelle l'implémentation est responsable de traquer la session contextuelle courante. Hibernate fournit trois implémentations de cette interface : </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code> - les sessions courantes sont associées à une transaction <code class="literal">JTA</code>. La logique est la même que l'ancienne approche basée sur JTA. Consultez les javadocs pour pour plus d'informations.  </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code> - les sessions courantes sont traquées par l'exécution du thread. Consultez les javadocs pour plus d'informations.  </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code> - les sessions courantes sont traquées par l'exécution du thread. Toutefois, vous êtes responsable de lier et de délier une instance de <code class="literal">Session</code> avec des méthodes statiques de cette classe.  Elle n'ouvre jamais, ni ne nettoie ou ne ferme une <code class="literal">Session</code>. </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a class="xref" href="transactions.html" title="Chapitre 12. Transactions et Accès concurrents">Chapitre 12, <i>Transactions et Accès concurrents</i></a> for more information and code examples. </p><p>Le paramètre de configuration <code class="literal">hibernate.current_session_context_class</code> définit quelle implémentation de <code class="literal">org.hibernate.context.CurrentSessionContext</code> doit être utilisée. Notez que pour assurer la compatibilité avec les versions précédentes, si ce paramètre n'est pas défini mais qu'un <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code> est configuré, Hibernate utilisera le <code class="literal">org.hibernate.context.JTASessionContext</code>. La valeur de ce paramètre devrait juste nommer la classe d'implémentation à utiliser. Pour les trois implémentations prêtes à utiliser, toutefois, il y a trois noms brefs correspondants : "jta", "thread" et "managed". </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Précédent</strong>Chapitre 1. Tutoriel</a></li><li class="up"><a accesskey="u" href="#"><strong>Niveau supérieur</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Sommaire</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Suivant</strong>Chapitre 3. Configuration</a></li></ul></body></html>