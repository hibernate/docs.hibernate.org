<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>6.0 Migration Guide</title>
<link rel="stylesheet" href="./css/hibernate.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
<h1>6.0 Migration Guide</h1>
<div class="details">
<span id="revnumber">version 6.0.3-SNAPSHOT</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_java_11">Java 11</a></li>
<li><a href="#_jakarta_persistence">Jakarta Persistence</a></li>
<li><a href="#read-jdbc">Reading from JDBC</a></li>
<li><a href="#sql">Generated SQL</a></li>
<li><a href="#identifier-object">Identifier as Object</a></li>
<li><a href="#id-gen-type">@IdGeneratorType</a></li>
<li><a href="#id-sequence-table-name">Implicit Identifier Sequence and Table Name</a></li>
<li><a href="#id-sequence-defaults">Defaults for implicit sequence generators</a></li>
<li><a href="#type">Type system</a>
<ul class="sectlevel2">
<li><a href="#rename-java-type">Renaming of JavaTypeDescriptor contract</a></li>
<li><a href="#rename-jdbc-type">Renaming of SqlTypeDescriptor contract</a></li>
<li><a href="#basic-type">Basic types</a>
<ul class="sectlevel3">
<li><a href="#_usertype">UserType</a></li>
<li><a href="#_boolean_converters">Boolean converters</a></li>
</ul>
</li>
<li><a href="#_embeddables_components">Embeddables / components</a>
<ul class="sectlevel3">
<li><a href="#_different_embeddable_mappings">Different embeddable mappings</a></li>
<li><a href="#_embeddableinstantiator">EmbeddableInstantiator</a></li>
<li><a href="#_compositeusertype_changes">CompositeUserType changes</a></li>
</ul>
</li>
<li><a href="#_plural_attributes">Plural attributes</a>
<ul class="sectlevel3">
<li><a href="#collection-type-ann"><code>@CollectionType</code></a></li>
<li><a href="#collection-type-reg-ann"><code>@CollectionTypeRegistration</code></a></li>
</ul>
</li>
<li><a href="#bigint-long-mapping">SQL <code>BIGINT</code>/<code>count()</code> mapping changes</a></li>
<li><a href="#_duration_mapping_changes">Duration mapping changes</a></li>
<li><a href="#_uuid_mapping_changes">UUID mapping changes</a></li>
<li><a href="#_instant_mapping_changes">Instant mapping changes</a></li>
</ul>
</li>
<li><a href="#query">Query</a>
<ul class="sectlevel2">
<li><a href="#query-sqm">SQM (HQL/Criteria)</a>
<ul class="sectlevel3">
<li><a href="#query-sqm-rows">Result "rows"</a></li>
<li><a href="#_multi_table_mutation_queries">Multi-table Mutation Queries</a></li>
<li><a href="#query-criteria-copy">Hibernate Criteria behavior change</a></li>
<li><a href="#query-sqm-pass-thru">Pass-through tokens</a></li>
<li><a href="#query-sqm-update-from">FROM token now disallowed for UPDATE</a></li>
<li><a href="#query-sqm-distinct">DISTINCT</a></li>
<li><a href="#_association_comparisons">Association Comparisons</a></li>
</ul>
</li>
<li><a href="#query-path-comparison">Query Path comparison</a>
<ul class="sectlevel3">
<li><a href="#query-sqm-pseudo-attr">Collection pseudo-attributes</a></li>
</ul>
</li>
<li><a href="#query-native">NativeQuery</a></li>
<li><a href="#query-ordinal-param">Ordinal Parameters binding</a></li>
<li><a href="#proc-call-param">ProcedureCall / StoredProcedureQuery Parameters</a></li>
<li><a href="#query-result-cache">Query result cache</a></li>
<li><a href="#query-stream">Stream</a></li>
</ul>
</li>
<li><a href="#_interceptor">Interceptor</a></li>
<li><a href="#_fetch_circularity_determination">Fetch circularity determination</a></li>
<li><a href="#_restructuring_of_org_hibernate_loader">Restructuring of <code>org.hibernate.loader</code></a></li>
<li><a href="#_restructuring_of_the_sql_package">Restructuring of the sql package</a></li>
<li><a href="#_deprecation_of_hbm_xml_mappings">Deprecation of hbm.xml mappings</a></li>
<li><a href="#_association_laziness_now_respected">Association laziness now respected</a></li>
<li><a href="#_hbm_xml_return_join_behavior_change">hbm.xml &lt;return-join/&gt; behavior change</a></li>
<li><a href="#_removals">Removals</a>
<ul class="sectlevel2">
<li><a href="#_hbm_xml_multiple_column_now_disallowed">hbm.xml multiple &lt;column/&gt; now disallowed</a></li>
<li><a href="#_legacy_hibernate_criteria_api">Legacy Hibernate Criteria API</a></li>
<li><a href="#query-iterate">Iterate</a></li>
<li><a href="#proc-call-nativequery">Callable via NativeQuery</a></li>
<li><a href="#_hql_fetch_all_properties_clause">HQL fetch all properties clause</a></li>
<li><a href="#_jmx_integration">JMX integration</a></li>
<li><a href="#_jacc_integration">JACC integration</a></li>
<li><a href="#release-artifacts">Release artifacts</a></li>
<li><a href="#_previously_deprecated_features">Previously Deprecated features</a></li>
</ul>
</li>
<li><a href="#configs">Configuration property renames</a></li>
<li><a href="#_dialects">Dialects</a>
<ul class="sectlevel2">
<li><a href="#community-dialects">"Community" dialects moved to a separate module</a></li>
<li><a href="#version-specific-and-spatial-dialects">Version-specific and spatial-specific dialects are deprecated</a></li>
</ul>
</li>
<li><a href="#multitenancy">Multitenancy simplification</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This guide discusses migration from Hibernate ORM version 6.0.  For migration from
earlier versions, see any other pertinent migration guides as well.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_java_11">Java 11</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With 6.0, Hibernate ORM has moved to expect Java 11 as its baseline version.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jakarta_persistence">Jakarta Persistence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>6.0 moves from Java Persistence as defined by the Java EE specs to
Jakarta Persistence as defined by the Jakarta EE spec.  The most immediate
impact of this change is that applications would need to be updated to use
the Jakarata Persistence classes (<code>jakarta.persistence.*</code>) instead of the Java
Persistence ones (<code>javax.persistence.*</code>).</p>
</div>
<div class="paragraph">
<p>The Jakarta spec also renames the JPA settings (again, from <code>javax.persistence.*</code> to
<code>jakarta.persistence.*</code>) and defines a new set of XSD namespaces for <code>orm.xml</code> and
<code>persistence.xml</code> files.</p>
</div>
<div class="paragraph">
<p>Jakarta provides a <a href="https://github.com/eclipse/transformer">transformer</a>
tool which, along with appropriate "rules", will transform a project from Java Persistence to
Jakarta Persistence.  This can update package names in source, settings, xsd references and more.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As far as the XSD and setting changes, Hibernate does support both sets as a temporary aid
in migration.  It logs a deprecation warning when the Java EE variants are used.  See the <code>rules/</code>
directory in the project root for the configuration used to migrate Hibernate itself.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="read-jdbc">Reading from JDBC</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the main reasons for 6.0 development was the move from reading results
from the JDBC <code>ResultSet</code> by name (read-by-name) as done in previous versions
of Hibernate, to reading the results by position (read-by-position).</p>
</div>
<div class="paragraph">
<p>Throughput testing of Hibernate showed that its use of read-by-name was its limiting factor
in any further scaling in terms of throughput - much of the issue was actually the call into
the <code>ResultSet</code>.  We like to improve performance all the time :)</p>
</div>
<div class="paragraph">
<p>This change, along with <a href="#sql">Generated SQL</a>, helped achieve this goal.</p>
</div>
<div class="paragraph">
<p>As discussed in <a href="#type">Type system</a> though, this change has a very big impact on Hibernate&#8217;s mapping type system</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sql">Generated SQL</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Column aliases are no longer generated.</p>
</li>
<li>
<p>Column references are "unique-d".</p>
</li>
<li>
<p>Better definition of joins</p>
</li>
<li>
<p>Better determination of unnecessary joins (secondary tables, inheritance tables)</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="identifier-object">Identifier as Object</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Previous versions of Hibernate required that all identifier types implement <code>Serializable</code>.  6.0
removes this restriction - identifiers can be any <code>Object</code>.</p>
</div>
<div class="paragraph">
<p>This change affects many api and spi methods previously defined using <code>Serializable</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="id-gen-type">@IdGeneratorType</h2>
<div class="sectionbody">
<div class="paragraph">
<p>6.0 adds a new <code>@IdGeneratorType</code> annotation that allows better, type-safe way
to define custom generators to use for identifier generation.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="id-sequence-table-name">Implicit Identifier Sequence and Table Name</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The way in which Hibernate determines implicit names for sequences and tables associated with identifier
generation has changed in 6.0 which may affect migrating applications.</p>
</div>
<div class="paragraph">
<p>As of 6.0, Hibernate by default creates a sequence per entity hierarchy instead of a single sequence <code>hibernate_sequence</code>.</p>
</div>
<div class="paragraph">
<p>Due to this change, users that previously used <code>@GeneratedValue(strategy = GenerationStrategy.AUTO)</code> or simply <code>@GeneratedValue</code> (since <code>AUTO</code> is the default),
need to ensure that the database now contains sequences for every entity, named <code>&lt;entity name&gt;_seq</code>. For an entity <code>Person</code>, a sequence <code>person_seq</code> is expected to exist. It&#8217;s best to run hbm2ddl (e.g. by temporarily setting <code>hbm2ddl.auto=create</code>) to obtain a list of DDL statements for the sequences.</p>
</div>
<div class="paragraph">
<p>Users that use a <code>import.sql</code> file to import test or static data during application boot or for tests have to make sure the new sequences match expectations of Hibernate. If a <code>import.sql</code> file contains references to the <code>hibernate_sequence</code>, these have to be replaced with <code>&lt;entity name&gt;_seq</code>. Also note that the <a href="#id-sequence-defaults">default allocation size changed</a> for such implicit sequences.</p>
</div>
<div class="paragraph">
<p>To help with backwards compatibility, or to apply any general naming strategy, 6.0 introduces the
<code>org.hibernate.id.enhanced.ImplicitDatabaseObjectNamingStrategy</code> contract which can be specified using
the <code>hibernate.id.db_structure_naming_strategy</code> setting.  See discussion at
link:https://docs.jboss.org/hibernate/orm/6.0/javadocs/org/hibernate/cfg/AvailableSettings.html#ID_DB_STRUCTURE_NAMING_STRATEGY</p>
</div>
<div class="paragraph">
<p>For backwards compatibility, use either <code>hibernate.id.db_structure_naming_strategy=single</code> or
<code>hibernate.id.db_structure_naming_strategy=legacy</code> depending on needs</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="id-sequence-defaults">Defaults for implicit sequence generators</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Implicit sequences, like the <code>hibernate_sequence</code> before, now respect the defaults of the JPA <code>@SequenceGenerator</code> annotation,
which means that the sequences have an allocation size of 50.</p>
</div>
<div class="paragraph">
<p>Users that use a <code>import.sql</code> file to import test or static data during application boot or for tests have to make sure the new sequences match expectations of Hibernate. If a <code>import.sql</code> file contains inserts to a table, the sequence for that table has to be reset to <code>&lt;max id value of table&gt; + 1 + &lt;allocation size&gt;</code>. This is because Hibernate interprets the value returned by the sequence as hi-value for its pooled optimizer. An alternative is to reset the sequence to <code>&lt;max id value of table&gt; + 1</code> and also configure the sequence generator to that initial value, by specifying <code>@SequenceGenerator(sequenceName = "&lt;entity name&gt;_seq", initialValue = &lt;max id value of table&gt; + 1)</code> on every entity.</p>
</div>
<div class="paragraph">
<p>Users are recommended to do the former and add statements like <code>alter sequence &lt;entity name&gt;_seq restart with &lt;max id value of table&gt; + 1 + &lt;allocation size&gt;</code> e.g. <code>alter sequence person_seq restart with 53</code> if id values 1 and 2 are used.</p>
</div>
<div class="paragraph">
<p>To help with backwards compatibility, or to apply any general naming strategy, 6.0 introduces the
<code>org.hibernate.id.enhanced.ImplicitDatabaseObjectNamingStrategy</code> contract which can be specified using
the <code>hibernate.id.db_structure_naming_strategy</code> setting.  See discussion at
link:https://docs.jboss.org/hibernate/orm/6.0/javadocs/org/hibernate/cfg/AvailableSettings.html#ID_DB_STRUCTURE_NAMING_STRATEGY</p>
</div>
<div class="paragraph">
<p>For backwards compatibility, use <code>hibernate.id.db_structure_naming_strategy=legacy</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type">Type system</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another change is to generally modernize Hibernate&#8217;s mapping annotations and make them
more type-safe.</p>
</div>
<div class="paragraph">
<p>We decided this is the right time since 6.0 is a major release and most of the type-related
contracts were already changing to implement the <a href="#read-jdbc">read-by-position</a> changes.</p>
</div>
<div class="paragraph">
<p>One part of this work was the removal of various String-based approaches for specifying Types to use from annotations, including
the removal of <code>@AnyMetaDef</code>, <code>@AnyMetaDefs</code>, <code>@TypeDef</code> and <code>@TypeDefs</code>, as well as
removing annotation attributes accepting the type to use as a String (e.g. <code>org.hibernate.annotations.CollectionType#type</code>)</p>
</div>
<div class="paragraph">
<p>The <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#domain-model">User Guide</a>
covers the details of mapping your domain model.</p>
</div>
<div class="sect2">
<h3 id="rename-java-type">Renaming of JavaTypeDescriptor contract</h3>
<div class="paragraph">
<p>The interface <code>org.hibernate.type.descriptor.java.JavaTypeDescriptor</code> has been renamed to
<code>org.hibernate.type.descriptor.java.JavaType</code></p>
</div>
</div>
<div class="sect2">
<h3 id="rename-jdbc-type">Renaming of SqlTypeDescriptor contract</h3>
<div class="paragraph">
<p>The interface <code>org.hibernate.type.descriptor.sql.SqlTypeDescriptor</code> has been renamed to
<code>org.hibernate.type.descriptor.jdbc.JdbcType</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="basic-type">Basic types</h3>
<div class="paragraph">
<p>Basic mappings are no longer configurable through the <code>BasicType</code> contract.  Instead,
users configure the different aspects of mapping the basic value to the database -</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JavaType</code></p>
</li>
<li>
<p><code>JdbcType</code></p>
</li>
<li>
<p><code>BasicValueConverter</code> <sup class="footnote" id="_footnote_converter">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</li>
<li>
<p><code>MutabilityPlan</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This also made the various implementations of <code>BasicType</code> obsolete, thus they have been removed.
<code>NamedBasicTypeImpl</code> takes the role of all the previous specific implementations by wrapping a
<code>JdbcType</code> and <code>JavaType</code>.</p>
</div>
<div class="paragraph">
<p>The <code>StandardBasicTypes</code> class previously exposed <code>BasicType</code> instance fields, which now have been
replaced with fields of the type <code>BasicTypeReference</code>. APIs that previously accepted just a <code>BasicType</code>
have been adapted to also accept a <code>BasicTypeReference</code> which allows for uses of <code>StandardBasicType</code>
fields to stay mostly source compatible.</p>
</div>
<div class="paragraph">
<p>See <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#basic" class="bare">https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#basic</a> for details.</p>
</div>
<div class="sect3">
<h4 id="_usertype">UserType</h4>
<div class="paragraph">
<p><code>UserType</code> is still supported, and is specified using the new <code>Type</code> annotation.</p>
</div>
<div class="paragraph">
<p>See <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#basic-mapping-custom" class="bare">https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#basic-mapping-custom</a> for details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_boolean_converters">Boolean converters</h4>
<div class="paragraph">
<p>Hibernate now provides standard <code>AttributeConverter</code> implementations for handling different database representations
as boolean values in the domain model:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>YesNoConverter</code></dt>
<dd>
<p>Handles values stored in the database as either <code>Y</code> or <code>N</code>.  Replaces the removed <code>YesNoBooleanType</code> (<code>yes_no</code>)</p>
</dd>
<dt class="hdlist1"><code>TrueFalseConverter</code></dt>
<dd>
<p>Handles values stored in the database as either <code>T</code> or <code>F</code>.  Replaces the removed <code>TrueFalseBooleanType</code> (<code>true_false</code>)</p>
</dd>
<dt class="hdlist1"><code>NumericBooleanConverter</code></dt>
<dd>
<p>Handles values stored in the database as either <code>1</code> or <code>0</code>.  Replaces the removed <code>NumericBooleanType</code> (<code>numeric_boolean</code>)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>E.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>@Type(type="yes_no")
boolean isActive;</code></pre>
</div>
</div>
<div class="paragraph">
<p>becomes</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>@Convert(converter=YesNoConverter.class)
boolean isActive;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In fact, if your application consistently maps booleans to the same database representation you can
even register one as an auto-apply converter.</p>
</div>
<div class="paragraph">
<p>See <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#basic-boolean" class="bare">https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#basic-boolean</a> for details.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_embeddables_components">Embeddables / components</h3>
<div class="paragraph">
<p>Mapping of embeddables had a few changes as well.</p>
</div>
<div class="sect3">
<h4 id="_different_embeddable_mappings">Different embeddable mappings</h4>
<div class="paragraph">
<p>Multiple component mappings for the same Java class with different property mappings is no
longer supported. Every property mapping combination should have its own Java class</p>
</div>
</div>
<div class="sect3">
<h4 id="_embeddableinstantiator">EmbeddableInstantiator</h4>
<div class="paragraph">
<p>6.0 introduces the new <code>EmbeddableInstantiator</code> contract.</p>
</div>
<div class="paragraph">
<p><code>EmbeddableInstantiator</code> supports constructor-injection!  Note, however, that embeddables used as
identifiers cannot use constructor injection.</p>
</div>
<div class="paragraph">
<p>See <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#embeddable-instantiator" class="bare">https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#embeddable-instantiator</a> for details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_compositeusertype_changes">CompositeUserType changes</h4>
<div class="paragraph">
<p>The <code>CompositeUserType</code> interface was re-implemented to be able to model user types as proper embeddable types.
A major difference to 5.x is the introduction of an "embeddable projection" that is used to determine the mapping structure.</p>
</div>
<div class="paragraph">
<p>Previously, a <code>CompositeUserType</code> had to provide property names and types through dedicated accessor methods,
but this was complicated for non-basic mappings and required quite some knowledge about Hibernate internals.
With 6.0 these methods are replaced with a method that returns an "embeddable projection" class.
The class is like a regular <code>@Embeddable</code> class and is used to determine the mapping structure for the <code>CompositeUserType</code>.</p>
</div>
<div class="paragraph">
<p>Component values of a user type object are accessed by property index. The property index is 0-based and can be determined
by sorting the persistent attribute names lexicographically ascending and using the 0-based position as property index.</p>
</div>
<div class="paragraph">
<p>For example, the following component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">public class MonetaryAmountEmbeddable {
	BigDecimal value;
	Currency currency;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will assign property index 0 to <code>currency</code> and index 1 to <code>value</code>.</p>
</div>
<div class="paragraph">
<p>Note that it is not possible anymore to use <code>@Columns</code> to specify the names of columns of a composite user type mapping.
Since a <code>CompositeUserType</code> now constructs a proper component, it is necessary to use the <code>@AttributeOverride</code> annotation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_plural_attributes">Plural attributes</h3>
<div class="paragraph">
<p>6.0 defines 2 main ways to influence collection mapping <code>@CollectionType</code> and <code>@CollectionTypeRegistration</code></p>
</div>
<div class="sect3">
<h4 id="collection-type-ann"><code>@CollectionType</code></h4>
<div class="paragraph">
<p>The <code>@CollectionType</code> annotation is kept from 5.x.  However, where it used to define</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>String type();</code></pre>
</div>
</div>
<div class="paragraph">
<p>it now defines</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Class&lt;? extends UserCollectionType&gt; type();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type to use must be a <code>UserCollectionType</code> (can no longer be a <code>CollectionType</code>) and
it no longer works with type-definitions.  See <a href="#type">Type system</a> for further discussion of general type changes.</p>
</div>
<div class="paragraph">
<p>See <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#collection-type-ann" class="bare">https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#collection-type-ann</a>
for details of using <code>@CollectionType</code></p>
</div>
</div>
<div class="sect3">
<h4 id="collection-type-reg-ann"><code>@CollectionTypeRegistration</code></h4>
<div class="paragraph">
<p>Allows to "auto apply" a <code>UserCollectionType</code> whenever Hibernate encounters a particular
plural attribute classification</p>
</div>
<div class="paragraph">
<p>See <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#collection-type-reg-ann" class="bare">https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#collection-type-reg-ann</a>
for details of using <code>@CollectionTypeRegistration</code></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bigint-long-mapping">SQL <code>BIGINT</code>/<code>count()</code> mapping changes</h3>
<div class="paragraph">
<p>The type code <code>SqlType.BIGINT</code> is now mapped to the Java type <code>Long</code> by default; it previously was (incorrectly) mapped to <code>BigInteger</code>.</p>
</div>
<div class="paragraph">
<p>As a result, native queries whose "select" clause returns a <code>BIGINT</code> element will now convert that element to <code>Long</code>,
instead of <code>BigInteger</code> previously. This will be the case for native queries returning a <code>count()</code> in particular.</p>
</div>
</div>
<div class="sect2">
<h3 id="_duration_mapping_changes">Duration mapping changes</h3>
<div class="paragraph">
<p>Duration now maps to the type code <code>SqlType.INTERVAL_SECOND</code> by default, which maps to the SQL type <code>interval second</code>
if possible, and falls back to <code>numeric(21)</code>.
In either case, schema validation errors could occur as 5.x used the type code <code>Types.BIGINT</code>.</p>
</div>
<div class="paragraph">
<p>Migration to <code>numeric(21)</code> should be easy. The migration to <code>interval second</code> might require a migration expression like
<code>cast(cast(old as numeric(21,9) / 1000000000) as interval second(9))</code>.</p>
</div>
<div class="paragraph">
<p>To retain backwards compatibility, configure the setting <code>hibernate.type.preferred_duration_jdbc_type</code> to <code>BIGINT</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_uuid_mapping_changes">UUID mapping changes</h3>
<div class="paragraph">
<p>UUID now maps to the type code <code>SqlType.UUID</code> by default, which maps to the SQL type <code>uuid</code>
if possible, and falls back to <code>binary(16)</code>.
Due to the change to the native <code>uuid</code> type, schema validation errors could occur on database with native data type support.</p>
</div>
<div class="paragraph">
<p>The migration to <code>uuid</code> might require a migration expression like <code>cast(old as uuid)</code>.</p>
</div>
<div class="paragraph">
<p>To retain backwards compatibility, configure the setting <code>hibernate.type.preferred_uuid_jdbc_type</code> to <code>BINARY</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_instant_mapping_changes">Instant mapping changes</h3>
<div class="paragraph">
<p>Instant now maps to the type code <code>SqlType.TIMESTAMP_UTC</code> by default, which maps to the SQL type <code>timestamp with time zone</code>
if possible, and falls back to <code>timestamp</code>.
Due to this change, schema validation errors could occur on some databases.</p>
</div>
<div class="paragraph">
<p>The migration to <code>timestamp with time zone</code> might require a migration expression like <code>cast(old as timestamp with time zone)</code>.</p>
</div>
<div class="paragraph">
<p>To retain backwards compatibility, configure the setting <code>hibernate.type.preferred_instant_jdbc_type</code> to <code>TIMESTAMP</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="query">Query</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quite a few changes have been made to how Query works.</p>
</div>
<div class="sect2">
<h3 id="query-sqm">SQM (HQL/Criteria)</h3>
<div class="paragraph">
<p>Another major change in 6.0 is the move to a dedicated tree structure to model
HQL and Criteria queries.  This tree structure is called the Semantic Query Model, or
SQM for short.</p>
</div>
<div class="sect3">
<h4 id="query-sqm-rows">Result "rows"</h4>
<div class="paragraph">
<p>Queries that use joins without specifying a select clause (e.g. <code>from Person p join p.address</code>)
used to return a <code>List&lt;Object[]&gt;</code>.  Starting with 6.0, such a query instead returns
<code>List&lt;Person&gt;</code></p>
</div>
<div class="paragraph">
<p>The HQL query <code>select p, a from Person p join p.address a</code> returns instead a <code>List&lt;Object[]&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>List&lt;Person&gt; result = session.createQuery("from Person p join p.address").list();
List&lt;Object[]&gt; results</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multi_table_mutation_queries">Multi-table Mutation Queries</h4>
<div class="paragraph">
<p>The implementations for bulk SQM DML statements like <code>insert</code>, <code>update</code> and <code>delete</code> were significantly improved in 6.0.
An important bug fix is, that <code>delete</code> statements now properly clean up collection tables.
<code>insert</code> statements now also support inserting into multi-table entities by making use of special purpose temporary tables
into which the insert goes and is then split up into the respective tables.</p>
</div>
<div class="paragraph">
<p>There are currently 2 implementation strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Using temporary tables (the default)</p>
</li>
<li>
<p>Using DML in CTEs (used on DB2 and PostgreSQL)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The temporary table approach is pretty simple and works in a similar way to how 5.x already implemented it.
Data or primary key values are first inserted into a temporary table and then the DML changes are applied to the various
tables that are affected by the SQM DML statement.</p>
</div>
<div class="paragraph">
<p>The CTE approach is new and implements a more performant approach by executing a single statement,
containing the various individual DML statements that would normally be executed separately.
This allows to run SQM DML statements in a single JDBC operation that does not move any data between the database and the application,
which should provide a significant boost for statements that involve many rows.</p>
</div>
<div class="paragraph">
<p>Note that the configuration property <code>hibernate.hql.bulk_id_strategy</code> was changed to <code>hibernate.query.mutation_strategy</code>
which will now refer to classes or objects implementing <code>org.hibernate.query.sqm.mutation.spi.SqmMultiTableMutationStrategy</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="query-criteria-copy">Hibernate Criteria behavior change</h4>
<div class="paragraph">
<p>By default, when bootstrapping Hibernate through the native bootstrap APIs or when explicitly disabling the newly introduced
<code>hibernate.criteria.copy_tree</code> configuration property, it is expected that criteria queries passed to
<code>jakarta.persistence.EntityManager#createQuery(CriteriaQuery)</code>, <code>jakarta.persistence.EntityManager#createQuery(CriteriaUpdate)</code>
or <code>jakarta.persistence.EntityManager#createQuery(CriteriaDelete)</code> are not mutated afterwards to avoid the need for copying the criteria query.</p>
</div>
<div class="paragraph">
<p>Prior to 6.0, mutations to criteria queries didn&#8217;t affect <code>Query</code> instances created from that.
To retain backwards compatibility, enable the <code>hibernate.criteria.copy_tree</code> configuration property.</p>
</div>
</div>
<div class="sect3">
<h4 id="query-sqm-pass-thru">Pass-through tokens</h4>
<div class="paragraph">
<p>The use of plain HQL identifiers in e.g. functions which couldn&#8217;t be interpreted as an attribute of a <code>FROM</code> root
were passed through as-is to SQL in Hibernate 5.x which was dropped in 6.0 because we believe this is unsafe
and might lead to surprising results. HQL queries that relied on this, need to be changed and use the newly introduced
<code>sql</code> function, which allows passing through the content of a string literal to SQL.</p>
</div>
<div class="paragraph">
<p>An HQL query like <code>select substring( e.description, 21, 11, octets ) from AnEntity e</code>, which relies on this for passing through <code>octets</code>
can be migrated to <code>select substring( e.description, 21, 11, sql('octets') ) from AnEntity e</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="query-sqm-update-from">FROM token now disallowed for UPDATE</h4>
<div class="paragraph">
<p>In Hibernate 5, the optional keyword <code>FROM</code> was allowed for <code>update</code> statements like <code>update from MyEntity e set e.attr = null</code>.
Support for this was removed to more align with JPQL. Just remove the <code>from</code> keyword from your existing <code>update</code> statements.</p>
</div>
</div>
<div class="sect3">
<h4 id="query-sqm-distinct">DISTINCT</h4>
<div class="paragraph">
<p>Starting with Hibernate ORM 6 it is no longer necessary to use <strong>distinct</strong> in JPQL and HQL
to filter out the same parent entity references when join fetching a child collection.
The returning duplicates of entities are now always filtered by Hibernate.</p>
</div>
<div class="paragraph">
<p>Which means that for instance it is no longer necessary to set <code>QueryHints#HINT_PASS_DISTINCT_THROUGH</code> to <code>false</code>
in order to skip the entity duplicates without producing a <code>distinct</code> in the SQL query.</p>
</div>
<div class="paragraph">
<p>From Hibernate ORM 6, <code>distinct</code> is always passed to the SQL query and the flag <code>QueryHints#HINT_PASS_DISTINCT_THROUGH</code>
has been removed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_association_comparisons">Association Comparisons</h4>
<div class="paragraph">
<p>Previously Hibernate did allow comparing an association with an FK value like <code>&#8230;&#8203; where alias.association = 1</code>
or <code>&#8230;&#8203; where alias.association = alias.association.id</code> or even <code>&#8230;&#8203; where alias.association = :param</code> where <code>param</code>
is bound to an integer <code>1</code>. This was supported prior to Hibernate 6.0 if the foreign key for the association is an integer.</p>
</div>
<div class="paragraph">
<p>The right way to do this is de-referencing the association by the FK attribute <code>&#8230;&#8203; where alias.association.id = 1</code>
which is guaranteed to not produce a join, or use an entity reference for <code>&#8230;&#8203; where alias.association = :param</code>
where <code>param</code> is bound to <code>entityManager.getReference(EntityClass.class, 1)</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-path-comparison">Query Path comparison</h3>
<div class="paragraph">
<p>Prior to 6.0 it was possible to compare two paths of different types or comparing an entity path against a literal e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>session.createQuery( "select a from MyEntity a, MyEntity b where a = b.id" )</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>session.createQuery( "select a from MyEntity a where a = 123")</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is not allowed anymore. The queries have to be changed to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>session.createQuery( "select a from MyEntity a, MyEntity b where a = b" )</code></pre>
</div>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>session.createQuery( "select a from MyEntity a where a.id = 123");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same is true for the left and right hand side types of a comparison predicate. Queries like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Root&lt;Participation&gt; root = criteria.from( Participation.class );
Root&lt;Submission&gt; rootSubQuery = subQuery.from( Submission.class );
subQuery.select( rootSubQuery.join( "submitters" ) );

// left hand side of type Submission.id and right hand side of Submissions types
criteria.where( root.get( "id" ).in( subQuery ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>will be considered invalid and should be changed into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Root&lt;Participation&gt; root = criteria.from( Participation.class );
Root&lt;Submission&gt; rootSubQuery = subQuery.from( Submission.class );
subQuery.select( rootSubQuery.join( "submitters" ) );

// left hand side of type Submission.id and right hand side of Submissions types
criteria.where( root.in( subQuery ) );</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="query-sqm-pseudo-attr">Collection pseudo-attributes</h4>
<div class="paragraph">
<p>Prior to 6.0, it was possible to de-reference special properties on plural attributes like <code>size</code> which was dropped.
The special properties lead to confusion and were sometimes ambiguous. The replacement is the function syntax.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">size</dt>
<dd>
<p>The collection size can be determined by using the <code>size( pluralAttribute )</code> function instead</p>
</dd>
<dt class="hdlist1">elements</dt>
<dd>
<p>The collection elements can be referred to by using the <code>value( pluralAttribute )</code> function instead</p>
</dd>
<dt class="hdlist1">indices</dt>
<dd>
<p>The collection indices can be referred to by using the <code>index( pluralAttribute )</code> or <code>key( pluralAttribute )</code> function instead</p>
</dd>
<dt class="hdlist1">index</dt>
<dd>
<p>The collection index can be referred to by using the <code>index( pluralAttribute )</code> or <code>key( pluralAttribute )</code> function instead</p>
</dd>
<dt class="hdlist1">maxindex</dt>
<dd>
<p>The collection maximum index can be determined by using the <code>maxindex( pluralAttribute )</code> function instead</p>
</dd>
<dt class="hdlist1">minindex</dt>
<dd>
<p>The collection minimum index can be determined by using the <code>minindex( pluralAttribute )</code> function instead</p>
</dd>
<dt class="hdlist1">maxelement</dt>
<dd>
<p>The collection maximum element can be determined by using the <code>maxelement( pluralAttribute )</code> function instead</p>
</dd>
<dt class="hdlist1">minelement</dt>
<dd>
<p>The collection minimum element can be determined by using the <code>minelement( pluralAttribute )</code> function instead</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-native">NativeQuery</h3>
<div class="paragraph">
<p>As <code>NativeQuery</code> extends from <code>Query</code>, all the changes listed in <a href="#query">Query</a> also apply
to <code>NativeQuery</code>.</p>
</div>
<div class="paragraph">
<p>Some additional changes apply specifically to <code>NativeQuery</code></p>
</div>
</div>
<div class="sect2">
<h3 id="query-ordinal-param">Ordinal Parameters binding</h3>
<div class="paragraph">
<p>HQL ordinal parameter binding is 1-based, this means that queries like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>s.createQuery( "select p from Parent p where id in ?0", Parent.class );
query.setParameter( 0, Arrays.asList( 0, 1, 2, 3 ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>that uses a 0-based positional binding are not supported, and they should be changed to the following</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>s.createQuery( "select p from Parent p where id in ?`", Parent.class );
query.setParameter( 1, Arrays.asList( 0, 1, 2, 3 ) );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="proc-call-param">ProcedureCall / StoredProcedureQuery Parameters</h3>
<div class="paragraph">
<p>For parameters defined on a ProcedureCall as accepting binding (IN and INOUT), a distinction is now
made between whether <code>setParameter</code> is called or not.  If <code>setParameter</code> was called, whatever value
was set by the user is passed to the database.  If it was not called, Hibernate will not
set any value which triggers the default value defined on the database procedure argument be used</p>
</div>
</div>
<div class="sect2">
<h3 id="query-result-cache">Query result cache</h3>
<div class="paragraph">
<p>Another change in 6.0 is related to the query result cache.</p>
</div>
<div class="paragraph">
<p>In previous versions, when the query-cache is enabled and a query returning entities is executed, only the entity identifiers were stored in the query-cache.  If second-level caching is enabled for a returned entity, the entity data was stored in its second-level cache region.</p>
</div>
<div class="paragraph">
<p>Storing just the identifiers in the query-cache has a major drawback when fetching is defined for the query (dynamic fetch, entity-graph, etc) as it can, and often does, lead to N+1 selects.</p>
</div>
<div class="paragraph">
<p>Starting in 6.0, we now store the complete set of data for the entity into the query-cache.  This also can have a drawback related to the size of caches.  We plan to address this further in later 6.x releases to allow storing just the identifiers along the lines of the previous behavior.</p>
</div>
<div class="paragraph">
<p>E.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Statistics stats = sessionFacroty.getStatistics();

// First time the query is executed, query and results are cached and both the query and entity chache will be populated.

TypedQuery&lt;Employee&gt; query = session.createQuery( "select e from Employee e", Employee.class )
							.setHint( HINT_CACHEABLE, true );

List&lt;Employee&gt; employees = query.getResultList();
assertEquals( 1, employees.size() );

assertEquals( 0, stats.getQueryCacheHitCount() );
assertEquals( 1, stats.getQueryCacheMissCount() );
assertEquals( 1, stats.getQueryCachePutCount() ); // query cache is populated.

assertEquals( 0, stats.getSecondLevelCacheHitCount() );
assertEquals( 0, stats.getSecondLevelCacheMissCount() );
assertEquals( 1, stats.getSecondLevelCachePutCount() ); // entity cache is populated as well.

stats.clear();

// Second time the same query is executed only the query cache will be hit.

TypedQuery&lt;Employee&gt; query = session.createQuery( "select e from Employee e", Employee.class )
							.setHint( HINT_CACHEABLE, true );
List&lt;Employee&gt; employees = query.getResultList();
assertEquals( 1, employees.size() );

assertEquals( 1, stats.getQueryCacheHitCount() ); // the query cache is hit.
assertEquals( 0, stats.getQueryCacheMissCount() );
assertEquals( 0, stats.getQueryCachePutCount() );

assertEquals( 0, stats.getSecondLevelCacheHitCount() );
assertEquals( 0, stats.getSecondLevelCacheMissCount() );
assertEquals( 0, stats.getSecondLevelCachePutCount() ); // No need to hit the entity cache because the query cache contains all the entity data.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-stream">Stream</h3>
<div class="paragraph">
<p><code>jakarta.persistence.Query#getResultStream()</code> and <code>org.hibernate.query.Query#stream()</code> no longer
return a <code>Stream</code> decorator.  In order to close the underlying IO resources, it is now necessary to
explicitly call the <code>Stream#close()</code> method.</p>
</div>
<div class="paragraph">
<p>This change makes the Streams returned by Hibernate behave as defined in the JDK
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Stream.html">Stream</a>
documentation, which is quite explicit about the need for an explicit call to <code>close</code> by the user
to avoid resource leakages.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_interceptor">Interceptor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The signature of the <code>#onSave</code> method has been changed from</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)</code></pre>
</div>
</div>
<div class="paragraph">
<p>to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>boolean onSave(Object entity, Object id, Object[] state, String[] propertyNames, Type[] types)</code></pre>
</div>
</div>
<div class="paragraph">
<p>to account for the general change in expected identifier type from <code>Serializable</code> to <code>Object</code>.
See <a href="#identifier-object">Identifier as Object</a>.</p>
</div>
<div class="paragraph">
<p>If custom Interceptor implementations do not use <code>@Override</code> on their implementations, this
can lead to situations where a custom Interceptor no longer overrides this method.  Moral
of the story&#8230;&#8203; always use <code>@Override</code> - this is why it exists</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_fetch_circularity_determination">Fetch circularity determination</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As back-ground, Hibernate does understand whether a fetch is actually, truly circular.  It simply
understands that while walking a fetch-graph it encounters the same table/column(s) making up a particular
foreign-key.  In this case, it simply stops walking the graph any deeper.</p>
</div>
<div class="paragraph">
<p>Previous versions of Hibernate determined fetches using a depth-first approach, which occasionally led
to odd "circularity" determination.  Starting with 6.0, we now perform fetch determination using a width
first approach.</p>
</div>
<div class="paragraph">
<p>Given a model such as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>@Entity
class Node {

    @ManyToOne

    Node node1;

    @ManyToOne
    Node node2;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hibernate previously generated joins by walking the entity association graph for the <code>Node#node1</code> sub-tree prior to walking the <code>Node#node2</code> sub-tree.
Since the associations are all eager, Hibernate 6.0 now executes a query with 4 joins</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM Node
JOIN Node.node1
JOIN Node.node1.node2
JOIN Node.node2
JOIN Node.node2.node1</code></pre>
</div>
</div>
<div class="paragraph">
<p>whereas before it executed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM Node
JOIN Node.node1
JOIN Node.node1.node2</code></pre>
</div>
</div>
<div class="paragraph">
<p>and issued a select for <code>Node.node2</code> if the FK of <code>Node.node2</code> was not null</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM Node.node2
JOIN Node.node2.node1
JOIN Node.node2.node1.node2</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this simple example this is not such a big deal, but if the number of eager fetched self-associations
is increased to e.g. 3 like here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>@Entity
class Node {

    @ManyToOne
    Node node1;

    @ManyToOne
    Node node2;

    @ManyToOne
    Node node3;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>this results in mind-blowing 15 joins</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM Node
JOIN Node.node1
JOIN Node.node1.node2
JOIN Node.node1.node2.node3
JOIN Node.node1.node3
JOIN Node.node1.node3.node2
JOIN Node.node2
JOIN Node.node2.node1
JOIN Node.node2.node1.node3
JOIN Node.node2.node3
JOIN Node.node2.node3.node1
JOIN Node.node3
JOIN Node.node3.node1
JOIN Node.node3.node1.node2
JOIN Node.node3.node2
JOIN Node.node3.node2.node1</code></pre>
</div>
</div>
<div class="paragraph">
<p>as you can see, this leads to a lot of joins very quickly, but the behavior of 5.x simply was not intuitive.
To avoid creating so many joins, and also in general, we recommend that you use lazy fetching i.e. <code>@ManyToOne(fetch = FetchType.LAZY)</code>
or <code>@OneToOne(fetch = FetchType.LAZY)</code> for most associations, but this is especially important if you have multiple self-referencing associations as you can see in the example.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_restructuring_of_org_hibernate_loader">Restructuring of <code>org.hibernate.loader</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The contents of the <code>loader.collection</code> package were restructured into <code>loader.ast.spi</code> and <code>loader.ast.internal</code>
as well as adapted to the SQM API.</p>
</div>
<div class="paragraph">
<p>The contents of <code>loader.custom</code> were adapted and moved to <code>query.sql</code>.</p>
</div>
<div class="paragraph">
<p>The contents of <code>loader.entity</code> and <code>loader.plan</code> were removed</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_restructuring_of_the_sql_package">Restructuring of the sql package</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The contents of <code>sql.ordering</code> were adapted and moved to <code>metamodel.mapping.ordering.ast</code>.</p>
</div>
<div class="paragraph">
<p>Classes of the <code>sql</code> package that were previously used for building SQL, but aren&#8217;t needed anymore, were removed.
The SQL generation is now fully handled through the <code>SqlAstTranslator</code> which a <code>Dialect</code> exposes a factory for.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_deprecation_of_hbm_xml_mappings">Deprecation of hbm.xml mappings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Legacy <code>hbm.xml</code> mapping format is considered deprecated and will no longer supported beyond 6.x.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_association_laziness_now_respected">Association laziness now respected</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Prior to Hibernate 6.0, lazy associations that used <code>fetch="join"</code> or <code>@Fetch(FetchMode.JOIN)</code> were considered eager
when loaded by-id i.e. through <code>Session#get</code>/<code>EntityManager#find</code>, even though for queries the association was treated as lazy.</p>
</div>
<div class="paragraph">
<p>Starting with Hibernate 6.0, the laziness of such associations is properly respected, regardless of the fetch mechanism.
Backwards compatibility can be achieved by specifying <code>lazy="false"</code> or <code>@ManyToOne(fetch = EAGER)</code>/<code>@OneToOne(fetch = EAGER)</code>/<code>@OneToMany(fetch = EAGER)</code>/<code>@ManyToMany(fetch = EAGER)</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hbm_xml_return_join_behavior_change">hbm.xml &lt;return-join/&gt; behavior change</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As of Hibernate 6.0, a <code>&lt;return-join/&gt;</code> will cause a fetch of an association, rather than adding a selection item.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="xml">&lt;sql-query name="organizationreturnproperty"&gt;
    &lt;return alias="org" class="Organization"&gt;
        &lt;return-property name="id" column="ORGID"/&gt;
        &lt;return-property name="name" column="NAME"/&gt;
    &lt;/return&gt;
    &lt;return-join alias="emp" property="org.employments"&gt;
        &lt;return-property name="key" column="EMPLOYER"/&gt;
        &lt;return-property name="element" column="EMPID"/&gt;
        &lt;return-property name="element.employee" column="EMPLOYEE"/&gt;
    &lt;/return-join&gt;
    ...
&lt;/sql-query&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Prior to 6.0, a query would return a list of tuples [<code>Organization</code>, <code>Employee</code>],
but now this will return a list of <code>Organization</code> with an initialized <code>employments</code> collection.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_removals">Removals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following features have been removed</p>
</div>
<div class="sect2">
<h3 id="_hbm_xml_multiple_column_now_disallowed">hbm.xml multiple &lt;column/&gt; now disallowed</h3>
<div class="paragraph">
<p>In 6.0 the support for basic property mappings with multiple columns was removed. The only use case for that was when a
<code>CompositeUserType</code> was in use, which was reworked to now work on top of components.</p>
</div>
<div class="paragraph">
<p>Uses like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="xml">&lt;property name="salary" type="org.hibernate.orm.test.sql.hand.MonetaryAmountUserType"&gt;
    &lt;column name="CURRENCY"/&gt;
    &lt;column name="AMOUNT" sql-type="float"/&gt;
&lt;/property&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>have to be migrated to proper components:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="xml">&lt;component name="salary" class="org.hibernate.orm.test.sql.hand.MonetaryAmountUserType"&gt;
    &lt;property name="value" column="AMOUNT"&gt;
        &lt;type name="float"/&gt;
    &lt;/property&gt;
    &lt;property name="currency" column="CURRENCY"/&gt;
&lt;/component&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The component class attribute now supports interpreting a <code>CompositeUserType</code> class properly.</p>
</div>
</div>
<div class="sect2">
<h3 id="_legacy_hibernate_criteria_api">Legacy Hibernate Criteria API</h3>
<div class="paragraph">
<p>The legacy Hibernate Criteria API which was deprecated back in Hibernate 5.x and removed in 6.0.
Usually, all queries using the legacy API can be modeled with the JPA Criteria API.
In some cases it is necessary to use the Hibernate JPA Criteria extensions.</p>
</div>
</div>
<div class="sect2">
<h3 id="query-iterate">Iterate</h3>
<div class="paragraph">
<p>The <code>Query#iterate()</code> method has been removed. The alternative is to use one of</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Query#stream()</code></p>
</li>
<li>
<p><code>Query#getResultStream()</code></p>
</li>
<li>
<p>Get the <code>Iterator</code> from <code>List</code> returned by <code>Query#list()</code> / <code>Query#getResultList()</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="proc-call-nativequery">Callable via NativeQuery</h3>
<div class="paragraph">
<p>Using <code>NativeQuery</code> to call SQL functions and procedures is no longer
supported.  <code>org.hibernate.procedure.ProcedureCall</code> or
<code>jakarta.persistence.StoredProcedureQuery</code> should be used instead.</p>
</div>
<div class="paragraph">
<p><code>@NamedNativeQuery</code> references defining execution of procedure or
functions should be migrated to use <code>@NamedStoredProcedureQuery</code>
instead.</p>
</div>
<div class="paragraph">
<p>E.g., the following <code>@NamedNativeQuery</code> -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>@NamedNativeQuery(
    name = "personAndPhones",
    query = "{ ? = call fn_person_and_phones( ? ) }",
    callable = true,
    resultSetMapping = "personWithPhonesResultMapping"
)

...

final List&lt;Object[]&gt; personAndPhones = entityManager
        .createNamedQuery("personAndPhones" )
        .setParameter( 1, 1L )
        .getResultList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>should be changed to use <code>@NamedStoredProcedureQuery</code> instead -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>@NamedStoredProcedureQuery(
    name = "personAndPhones",
    procedureName = "fn_person_and_phones",
    resultSetMappings = "personWithPhonesResultMapping",
    hints = @QueryHint(name = "org.hibernate.callableFunction", value = "true"),
    parameters = @StoredProcedureParameter(type = Long.class)
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Callable named native queries in hbm.xml files should be migrated to the orm.xml version.</p>
</div>
<div class="paragraph">
<p>E.g., the following <code>&lt;sql-query callable="true"&gt;</code> -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>&lt;sql-query name="simpleScalar" callable="true"&gt;
    &lt;return-scalar column="name" type="string"/&gt;
    &lt;return-scalar column="`value`" type="long"/&gt;
    { ? = call simpleScalar(:number) }
&lt;/sql-query&gt;

...

final List&lt;Object[]&gt; results = entityManager
        .createNamedQuery("simpleScalar" )
        .setParameter( 1, 1L )
        .getResultList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>should be changed to use <code>&lt;named-stored-procedure-query/&gt;</code> instead -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="xml">&lt;named-stored-procedure-query name="simpleScalar" procedure-name="simpleScalar"&gt;
    &lt;parameter class="java.lang.Integer" mode="IN" name="number"/&gt;
    &lt;result-set-mapping&gt;simpleScalar&lt;/result-set-mapping&gt;
    &lt;hint name="org.hibernate.callableFunction" value="true"/&gt;
&lt;/named-stored-procedure-query&gt;
&lt;sql-result-set-mapping name="simpleScalar"&gt;
    &lt;column-result name="name" class="java.lang.String"/&gt;
    &lt;column-result name="value" class="java.lang.Long"/&gt;
&lt;/sql-result-set-mapping&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
To ease the migration, <code>&lt;sql-query callable="true"/&gt;</code> and <code>@NamedNativeQuery(callable = true)</code> queries
will be translated and registered as named stored procedure in 6.0, but future versions will drop this automatic translation.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Either <code>org.hibernate.procedure.ProcedureCall</code> or <code>jakarta.persistence.StoredProcedureQuery</code>
can be used to execute the named query -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>// Use StoredProcedureQuery
final List&lt;Object[]&gt; personAndPhones = entityManager
        .createNamedStoredProcedureQuery( "simpleScalar" )
        .setParameter( 1, 1L )
        .getResultList();

// Use ProcedureCall
final List&lt;Object[]&gt; personAndPhones = entityManager
        .unwrap( Session.class )
        .getNamedProcedureCall( "simpleScalar" )
        .setParameter( 1, 1L )
        .getResultList();</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also no longer supported to execute procedures and functions
via a dynamic (unnamed) <code>NativeQuery</code>.  All such usages should be converted
to use <code>ProcedureCall</code> or <code>StoredProcedureQuery</code> instead via
<code>Session#createStoredProcedureCall</code> or <code>EntityManager#createStoredProcedureQuery</code>,
respectively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>// Use StoredProcedureQuery
final List&lt;Object[]&gt; personAndPhones = entityManager
        .createStoredProcedureQuery( "fn_person_and_phones", "personWithPhonesResultMapping" )
        .setParameter( 1, 1L )
        .getResultList();

// Use ProcedureCall
final List&lt;Object[]&gt; personAndPhones = entityManager
        .unwrap( Session.class )
        .createStoredProcedureCall( "fn_person_and_phones", "personWithPhonesResultMapping" )
        .setParameter( 1, 1L )
        .getResultList();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hql_fetch_all_properties_clause">HQL fetch all properties clause</h3>
<div class="paragraph">
<p>The <code>fetch all properties</code> clause was removed from the HQL language without a replacement.
A similar behavior can be achieved by constructing an entity graph and applying that as load graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code data-lang="java">EntityGraph&lt;Document&gt; entityGraph = entityManager.createEntityGraph( Document.class );
for ( Attribute&lt;Document, ?&gt; attr : entityManager.getMetamodel().entity( Document.class ).getAttributes() ) {
    entityGraph.addAttributeNodes( attr.getName() );
}
List&lt;Document&gt; documents = s.createQuery( "from Document", Document.class )
        .setHint( "jakarta.persistence.loadgraph", entityGraph )
        .getResultList();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jmx_integration">JMX integration</h3>
<div class="paragraph">
<p>Hibernate no longer provides built-in support for integrating itself with JMX environments.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jacc_integration">JACC integration</h3>
<div class="paragraph">
<p>Hibernate no longer provides built-in support for integrating itself with JACC environments.</p>
</div>
</div>
<div class="sect2">
<h3 id="release-artifacts">Release artifacts</h3>
<div class="paragraph">
<p>We no longer publishing zip and tgz bundles to SourceForge.</p>
</div>
<div class="paragraph">
<p>We now publish additional documentation artifacts, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>This <a href="{migration-guide-url}">Migration Guide</a></p>
</li>
<li>
<p>The generated <a href="{docs-url}/logging/logging.html">logging</a> report</p>
</li>
<li>
<p>The generated <a href="{docs-url}/incubating/incubating.txt">incubation</a> report</p>
</li>
<li>
<p>The generated <a href="{docs-url}/internals/internal.txt">internals</a> report</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_previously_deprecated_features">Previously Deprecated features</h3>
<div class="ulist">
<ul>
<li>
<p>'hibernate.classLoader.application', 'hibernate.classLoader.resources', 'hibernate.classLoader.hibernate' and 'hibernate.classLoader.environment': use 'hibernate.classLoaders' instead.</p>
</li>
<li>
<p>'hibernate.hbm2dll.create_namespaces': use 'jakarta.persistence.create-database-schemas' or 'hibernate.hbm2ddl.create_namespaces'</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configs">Configuration property renames</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some configuration properties that were deprecated for a long time were finally removed for consistency reasons:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Old property</th>
<th class="tableblock halign-left valign-top">New property</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.metamodel.population</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.jpa.metamodel.population</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.cfgfile</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.cfg_xml_file</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.xml_files</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.orm_xml_files</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.hbmxml.files</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.hbm_xml_files</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.loaded.classes</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.loaded_classes</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.persistenceUnitName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.persistenceUnitName</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.discard_pc_on_close</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.discard_pc_on_close</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.entitymanager_factory_name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.session_factory_name</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.session_factory_observer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.session_factory_observer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.identifier_generator_strategy_provider</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.identifier_generator_strategy_provider</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>There are also some property prefixes where the deprecated variant was finally removed:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Old prefix</th>
<th class="tableblock halign-left valign-top">New prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.classcache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.classcache</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.collectioncache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.collectioncache</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.ejb.event</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hibernate.event</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>We decided this is the right time since 6.0 is a major release.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dialects">Dialects</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="community-dialects">"Community" dialects moved to a separate module</h3>
<div class="paragraph">
<p>As of Hibernate 6.0, some dialect classes that are maintained by vendors or individuals, as opposed to the Hibernate team.
have moved to a separate Maven artifact: <code>org.hibernate.orm:hibernate-community-dialects</code>.</p>
</div>
<div class="paragraph">
<p>For more information, see <a href="https://github.com/hibernate/hibernate-orm/blob/6.0/dialects.adoc#community-dialects" class="bare">https://github.com/hibernate/hibernate-orm/blob/6.0/dialects.adoc#community-dialects</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="version-specific-and-spatial-dialects">Version-specific and spatial-specific dialects are deprecated</h3>
<div class="paragraph">
<p>As of Hibernate 6.0, dialects can detect and adapt to the version of the database in use and its spatial capabilities.</p>
</div>
<div class="paragraph">
<p>As a result, version-specific dialects (e.g. <code>org.hibernate.dialect.PostgreSQL91Dialect</code>)
or spatial-specific dialects (e.g. <code>org.hibernate.spatial.dialect.postgis.PostgisPG94Dialect</code>) should no longer be used.
Use these dialects instead, and ignore their deprecated subclasses:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.hibernate.dialect.CockroachDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.DB2Dialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.DB2iDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.DB2zDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.DerbyDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.H2Dialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.HANAColumnStoreDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.HANARowStoreDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.HSQLDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.MariaDBDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.MySQLDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.OracleDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.PostgreSQLDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.PostgresPlusDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.SpannerDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.SQLServerDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.SQLServerDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.SybaseAnywhereDialect</code></p>
</li>
<li>
<p><code>org.hibernate.dialect.SybaseASEDialect</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The same recommendation applies for <a href="#community-dialects">community-supported dialects</a>;
use these and not their deprecated subclasses:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.hibernate.community.dialect.CacheDialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.CUBRIDDialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.FirebirdDialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.IngresDialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.InformixDialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.MaxDBDialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.MimerSQLDialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.RDMSOS2200Dialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.SQLiteDialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.TeradataDialect</code></p>
</li>
<li>
<p><code>org.hibernate.community.dialect.TimesTenDialect</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="multitenancy">Multitenancy simplification</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#multitenacy">Multitenancy in Hibernate ORM</a> has been simplified.
Hibernate will now infer whether multitenancy is enabled or not automatically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#multitenacy-hibernate-MultiTenantConnectionProvider"><code>MultiTenantConnectionProvider</code></a>
is configured, Hibernate ORM will assume either <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-database">database-</a>
or <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#multitenacy-separate-schema">schema-based</a>
multitenancy (there is no difference between those two as far as Hibernate ORM is concerned).</p>
</li>
<li>
<p>If an entity property is annotated with the new <code>@TenantId</code> annotation,
Hibernate ORM will assume <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#multitenacy-hibernate-TenantId">discriminator-based multitenancy</a>
(which is a new feature).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To migrate:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Remove any reference to the configuration property <code>hibernate.multiTenancy</code> (<code>AvailableSettings.MULTI_TENANT</code>)
or to <code>MultiTenancyStrategy</code> from your application: they are no longer necessary.
<code>hibernate.multiTenancy</code> will be ignored
and <code>AvailableSettings.MULTI_TENANT</code>/<code>MultiTenancyStrategy</code> will lead to compilation errors since they have been removed.</p>
</li>
<li>
<p>If your application was somehow achieving discriminator-based multitenancy through custom code (e.g. custom filters),
consider relying on the new <code>@TenantId</code> annotation
and <a href="https://docs.jboss.org/hibernate/orm/6.0/userguide/html_single/Hibernate_User_Guide.html#multitenacy-hibernate-session-configuration">setting the session&#8217;s tenant ID</a> instead.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Think `AttributeConverter`
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 6.0.3-SNAPSHOT<br>
Last updated 2023-03-30 14:48:43 -0500
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js"></script>
</body>
</html>