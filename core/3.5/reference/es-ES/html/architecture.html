<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 2. Arquitectura</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistencia relacional para Java idiomático"/><link rel="prev" href="tutorial.html" title="Capítulo 1. Tutorial"/><link rel="next" href="session-configuration.html" title="Capítulo 3. Configuración"/><link rel="copyright" href="Legal_Notice.html" title="Advertencia legal"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Siguiente</strong></a></li></ul><div class="chapter" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Capítulo 2. Arquitectura</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="architecture.html#architecture-overview">2.1. Sinopsis</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-states">2.2. Estados de instancia</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-jmx">2.3. Integración JMX</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-jca">2.4. Soporte JCA</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-current-session">2.5. Sesiones contextuales</a></span></dt></dl></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. Sinopsis</h2></div></div></div><p>El diagrama a continuación brinda una perspectiva a alto nivel de la arquitectura de Hibernate: </p><div class="mediaobject" align="center"><img src="images/overview.png" align="middle"/></div><p>Este documento no incluye una sinopsis detallada de la arquitecturas en tiempo de ejecución disponibles; Hibernate es flexible y soporta diferentes enfoques. Sin embargo, mostraremos los dos extremos: la arquitectura "mínima" y la arquitectura "completa". </p><p>Este diagrama ilustra la manera en que Hibernate utiliza la base de datos y los datos de configuración para proporcionar servicios de persistencia y objetos persistentes a la aplicación. </p><p>La arquitectura "mínima" hace que la aplicación proporcione sus propias conexiones JDBC y que administre sus propias transacciones. Este enfoque utiliza un subgrupo mínimo de las APIs de Hibernate: </p><div class="mediaobject" align="center"><img src="images/lite.png" align="middle"/></div><p>La arquitectura "completa" abstrae la aplicación de las APIs de JDBC/JTA y permite que Hibernate se encargue de los detalles. </p><div class="mediaobject" align="center"><img src="images/full_cream.png" align="middle"/></div><p>He aquí algunas definiciones de los objetos en los diagramas:  </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="literal">org.hibernate.SessionFactory</code>)</span></dt><dd><p>Un caché threadsafe (inmutable) de mapeos compilados para una sola base de datos. Una fábrica de <code class="literal">Session</code> y un cliente de <code class="literal">ConnectionProvider</code>, <code class="literal">SessionFactory</code> puede mantener un caché opcional (de segundo nivel) de datos reusables entre transacciones a nivel de proceso o de clúster. </p></dd><dt><span class="term">Session (<code class="literal">org.hibernate.Session</code>)</span></dt><dd><p>Un objeto mono-hebra, de corta vida que representa una conversación entre la aplicación y el almacenamiento persistente. Envuelve una conexión JDBC y es una fábrica de <code class="literal">Transaction</code>. <code class="literal">Session</code> mantiene un caché requerido de primer nivel de objetos persistentes, que se utiliza cuando se navega el gráfico de objetos o mientras se buscan objetos por identificador. </p></dd><dt><span class="term">Objetos y colecciones persistentes</span></dt><dd><p>Objetos de corta vida, mono-hebra contienen un estado persistente así como una funcionalidad empresarial. Estos pueden ser JavaBeans/POJOs normales. Estos se encuentran asociados con exactamente una <code class="literal">Session</code>. Tan pronto como la <code class="literal">Session</code> se cierre, serán separados y estarán libres para utilizarlos en cualquier capa de aplicación, (por ejemplo, directamente como objetos de transferencia de datos hacia y desde la presentación). </p></dd><dt><span class="term">Objetos y colecciones transitorios y separados</span></dt><dd><p>Instancias de clases persistentes que no se encuentran actualmente asociadas con una <code class="literal">Session</code>. Pueden haber sido instanciadas por la aplicación y aún no haber sido persistidas, o pueden haber sido instanciadas por una <code class="literal">Session</code> cerrada. </p></dd><dt><span class="term">Transaction (<code class="literal">org.hibernate.Transaction</code>)</span></dt><dd><p>(Opcional) Un objeto de corta vida, mono-hebra que la aplicación utiliza para especificar unidades atómicas de trabajo. Abstrae la aplicación de las transacciones subyacentes JDBC, JTA o CORBA. En algunos casos, una <code class="literal">Session</code> puede extenderse sobre varias <code class="literal">Transaction</code>es. Sin embargo, la demarcación de la transacción, ya sea utilizando la API subyacente o <code class="literal">Transaction</code>, nunca es opcional. </p></dd><dt><span class="term">ConnectionProvider (<code class="literal">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(Opcional) Una fábrica y pool de conexiones JDBC. Abstrae a la aplicación del <code class="literal">Datasource</code> o <code class="literal">DriverManager</code> subyacente. No se expone a la aplicación, pero puede ser extendido/implementado por el desarrollador. </p></dd><dt><span class="term">TransactionFactory (<code class="literal">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(Opcional) Una fábrica de instancias de <code class="literal">Transaction</code>. No se expone a la aplicación pero puede ser extendido/implementado por el desarrollador.  </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>Hibernate ofrece un rango de interfaces de extensión opcionales que puede implementar para personalizar el comportamiento de su capa de persistencia. Para obtener más detalles, vea la documentación de la API. </p></dd></dl></div><p>
        </p><p>Dada una arquitectura "sencilla", la aplicación evita las APIs de <code class="literal">Transaction</code>/<code class="literal">TransactionFactory</code> y/o <code class="literal">ConnectionProvider</code>, para comunicarse directamente con JTA o JDBC. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-states"/>2.2. Estados de instancia</h2></div></div></div><p>Una instancia de una clase persistente puede estar en uno de tres estados diferentes. Estos estados se definen con respecto a su <span class="emphasis"><em>contexto de persistencia</em></span>. El objeto <code class="literal">Session</code> de Hibernate es el contexto de persistencia. Los tres estados diferentes son los siguientes: </p><div class="variablelist"><dl><dt><span class="term">transitorio</span></dt><dd><p>La instancia no está asociada con un contexto de persistencia. No tiene identidad persistente o valor de clave principal. </p></dd><dt><span class="term">persistente</span></dt><dd><p>La instancia se encuentra actualmente asociada con un contexto de persistencia. Tiene una identidad persistente (valor de clave principal) y puede tener una fila correspondiente en la base de datos. Para un contexto de persistencia en particular, Hibernate <span class="emphasis"><em>garantiza</em></span> que la identidad persistente es equivalente a la identidad Java en relación con la ubicación del objeto. </p></dd><dt><span class="term">separado</span></dt><dd><p>La instancia estuvo alguna vez asociada con un contexto de persistencia, pero ese contexto se cerró, o la instancia fue serializada a otro proceso. Tiene una identidad persistente y puede tener una fila correspondiente en la base de datos. Para las instancias separadas, Hibernate no establece ninguna garantía sobre la relación entre identidad persistente e identidad Java. </p></dd></dl></div></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.3. Integración JMX</h2></div></div></div><p>JMX es el estándar J2EE para la gestión de componentes Java. Hibernate se puede administrar por medio de un servicio estándar JMX. Brindamos una implementación de MBean en la distribución: <code class="literal">org.hibernate.jmx.HibernateService</code>. </p><p>Para ver un ejemplo de cómo desplegar Hibernate como un servicio JMX en un servidor de aplicaciones JBoss, por favor, refiérase al manual del usuario de JBoss. JBoss AS también proporciona estos beneficios si despliega utilizando JMX: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Administración de Sesión:</em></span> El ciclo de vida de la <code class="literal">Session</code> de Hibernate puede estar ligado automáticamente al ámbito de una transacción JTA. Esto significa que ya no tiene que abrir ni cerrar la <code class="literal">Session</code> manualmente, esto pasa a ser el trabajo de un interceptor EJB de JBoss. Además tampoco tiene que preocuparse más de la demarcación de la transacción en su código (a menos de que quiera escribir una capa de persitencia portátil, utilice la API de <code class="literal">Transaction</code> de Hibernate para hacer esto). Para acceder a una <code class="literal">Session</code> llame al <code class="literal">HibernateContext</code>. </p></li><li><p><span class="emphasis"><em>Despliegue HAR:</em></span>: el servicio JMX de Hibernate se implementa usando un descriptor de despliegue de servicio de JBoss en un archivo EAR y/o SAR, que soporta todas las opciones de configuración usuales de una <code class="literal">SessionFactory</code> de Hibernate. Sin embargo, todavía tiene que nombrar todos sus archivos de mapeo en el descriptor de despliegue. Si utiliza el depliegue HAR opcional, JBoss detectará automáticamente todos los archivos de mapeo en su archivo HAR. </p></li></ul></div><p>Para más información sobre estas opciones, consulte el Manual de Usuario de JBoss AS. </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a class="xref" href="session-configuration.html#configuration-optional-statistics" title="3.4.6. Estadísticas de Hibernate">Sección 3.4.6, “Estadísticas de Hibernate”</a> for more information. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jca"/>2.4. Soporte JCA</h2></div></div></div><p>Hibernate también puede ser configurado como un conector JCA. Por favor refiérase al sitio web para encontrar más detalles. Sin embargo, tenga en cuenta que el soporte de JCA de Hibernate aún está bajo desarrollo. </p></div><div class="section" lang="es-ES"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.5. Sesiones contextuales</h2></div></div></div><p>La mayoría de las aplicaciones que utilizan Hibernate necesitan alguna forma de sesiones "contextuales", en donde una sesión dada se encuentra en efecto en todo el campo de acción de un contexto dado. Sin embargo, a través de las aplicaciones la definición de lo que constituye un contexto es usualmente diferente y diferentes contextos definen diferentes campos de acción para la noción de actual. Las aplicaciones que utiliza Hibernate antes de la version 3.0 tienden a utilizar ya sea sesiones contextuales con base <code class="literal">ThreadLocal</code> desarrollados en casa, las clases ayudantes tales como <code class="literal">HibernateUtil</code>, o enfoques de terceros utilizados, como Spring o Pico, los cuales brindaban sesiones contextuales con base proxy/intercepción. </p><p>Comenzando con la version 3.0.1, Hibernate agregó el método <code class="literal">SessionFactory.getCurrentSession()</code>. Inicialmente, este asumió la utilización de las transacciones <code class="literal">JTA</code>, en donde la transacción <code class="literal">JTA</code> definia tanto el contexto como el campo de acción de una sesión actual. Dada la madurez de númerosas implementaciones <code class="literal">JTA TransactionManager</code> autónomas existentes, la mayoría, si no es que todas, las aplicaciones deberían utilizar la administración de transacciones <code class="literal">JTA</code> en el caso de que se deplieguen o no en un contenedor <code class="literal">J2EE</code>. Con base en esto, las sesiones contextuales basadas en <code class="literal">JTA</code> es todo lo que usted necesita utilizar. </p><p>Sin embargo, desde la versión 3.1, el procesamiento detrás de <code class="literal">SessionFactory.getCurrentSession()</code> ahora es conectable. Para ese fin, se ha añadido una nueva interfaz de extensión, <code class="literal">org.hibernate.context.CurrentSessionContext</code>, y un nuevo parámetro de configuración, <code class="literal">hibernate.current_session_context_class</code> para permitir la conexión del campo de acción y el contexto de definición de las sesiones actuales. </p><p>Refiérase a los Javadocs para la interfaz <code class="literal">org.hibernate.context.CurrentSessionContext</code> para poder ver una discusión detallada de su contrato. Define un método único, <code class="literal">currentSession()</code>, por medio del cual la implementación es responsable de rastrear la sesión contextual actual. Tal como viene empacada, Hibernate incluye tres implementaciones de esta interfaz: </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code>: una transacción <code class="literal">JTA</code> rastrea y asume las sesiones actuales. Aquí el procesamiento es exactamente el mismo que en el enfoque más antiguo de JTA-sólamente. Refiérase a los Javadocs para obtener más información. </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code>: las sesiones actuales son rastreadas por un hilo de ejecución. Consulte los Javadocs para obtener más detalles. </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code>: las sesiones actuales son rastreadas por un hilo de ejecución. Sin embargo, usted es responsable de vincular y desvincular una instancia <code class="literal">Session</code> con métodos estáticos en esta clase: no abre, vacia o cierra una <code class="literal">Session</code>. </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a class="xref" href="transactions.html" title="Capítulo 12. Transacciones y concurrencia">Capítulo 12, <i>Transacciones y concurrencia</i></a> for more information and code examples. </p><p>El parámetro de configuración <code class="literal">hibernate.current_session_context_class</code> define cuales implementaciones <code class="literal">org.hibernate.context.CurrentSessionContext</code> deben utilizarse. Para compatibilidad con versiones anteriores, si este parámetro de configuración no está establecido pero si tiene configurado un <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code>, Hibernate utilizará el <code class="literal">org.hibernate.context.JTASessionContext</code>. Usualmente el valor de este parámetro sólamente nombraría la clase de implementación a utilizar. Sin embargo, para las tres implementaciones incluídas existen tress nombres cortos: "jta", "thread" y "managed". </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Anterior</strong>Capítulo 1. Tutorial</a></li><li class="up"><a accesskey="u" href="#"><strong>Subir</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Inicio</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Siguiente</strong>Capítulo 3. Configuración</a></li></ul></body></html>