<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第2章 アーキテクチャ</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="up" href="index.html" title="HIBERNATE - Relational Persistence for Idiomatic Java"/><link rel="prev" href="tutorial.html" title="第1章 Tutorial"/><link rel="next" href="session-configuration.html" title="第3章 設定"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>前のページ</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>次のページ</strong></a></li></ul><div class="chapter" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>第2章 アーキテクチャ</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="architecture.html#architecture-overview">2.1. 概観</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-states">2.2. インスタンスの状態</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-jmx">2.3. JMX との統合</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-jca">2.4. JCA サポート</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-current-session">2.5. コンテキスト上のセッション</a></span></dt></dl></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. 概観</h2></div></div></div><p>Hibernate アーキテクチャの（非常に）高いレベルからのビュー： </p><div class="mediaobject" align="center"><img src="images/overview.png" align="middle"/></div><p>We do not have the scope in this document to provide a more detailed view of all the runtime architectures available; Hibernate is flexible and supports several different approaches. We will, however, show the two extremes: "minimal" architecture and "comprehensive" architecture. </p><p>この図は Hibernate が、アプリケーションに対して永続化サービス （と永続オブジェクト）を提供するために、データベースと設定データを使うことを示しています。 </p><p>The "minimal" architecture has the application provide its own JDBC connections and manage its own transactions. This approach uses a minimal subset of Hibernate's APIs: </p><div class="mediaobject" align="center"><img src="images/lite.png" align="middle"/></div><p>The "comprehensive" architecture abstracts the application away from the underlying JDBC/JTA APIs and allows Hibernate to manage the details. </p><div class="mediaobject" align="center"><img src="images/full_cream.png" align="middle"/></div><p>以下は、図に含まれるオブジェクトの定義です： </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="literal">org.hibernate.SessionFactory</code>)</span></dt><dd><p>A threadsafe, immutable cache of compiled mappings for a single database. A factory for <code class="literal">Session</code> and a client of <code class="literal">ConnectionProvider</code>, <code class="literal">SessionFactory</code> can hold an optional (second-level) cache of data that is reusable between transactions at a process, or cluster, level. </p></dd><dt><span class="term">Session (<code class="literal">org.hibernate.Session</code>)</span></dt><dd><p>A single-threaded, short-lived object representing a conversation between the application and the persistent store. It wraps a JDBC connection and is a factory for <code class="literal">Transaction</code>. <code class="literal">Session</code> holds a mandatory first-level cache of persistent objects that are used when navigating the object graph or looking up objects by identifier. </p></dd><dt><span class="term">Persistent objects と Collections</span></dt><dd><p>永続化状態とビジネス機能を持つ、短命でシングルスレッドのオブジェクト。これは通常の JavaBeans/POJO のこともありますが、特徴的なことは、その時点での（ただ1つの） <code class="literal">Session</code> と関連していることです。 <code class="literal">Session</code> がクローズされるとすぐに、それらは切り離されて他のアプリケーション層から自由に使うことができます（例えばデータトランスファオブジェクトとして、プレゼンテーション層から、またはプレゼンテーション層へ直接使用できます）。 </p></dd><dt><span class="term">Transient と detached な objects と Collections</span></dt><dd><p>現時点では <code class="literal">Session</code> と関連していない、永続クラスのインスタンス。すでにアプリケーション側でインスタンス化されていて、まだ永続化されていないか、クローズされた <code class="literal">Session</code> でインスタンス化されたかのどちらかです。 </p></dd><dt><span class="term">Transaction (<code class="literal">org.hibernate.Transaction</code>)</span></dt><dd><p>(オプション) 原子性を持つ作業単位 (Unit of Work) を指定するために、アプリケーションが使用する、シングルスレッドで短命なオブジェクト。下に位置する JDBC 、 JTA 、 CORBA トランザクションからアプリケーションを抽象化します。 <code class="literal">Session</code> は、時にはいくつかの <code class="literal">Transaction</code> をまたがるかもしれません。しかし、下の層の API を使うにせよ、 <code class="literal">Transaction</code> を使うにせよ、トランザクション境界を設定することは、決してオプションではありません。 </p></dd><dt><span class="term">ConnectionProvider (<code class="literal">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(オプション) JDBC コネクション（とそのプール）のファクトリ。下の層に位置する <code class="literal">Datasource</code> や <code class="literal">DriverManager</code> からアプリケーションを抽象化します。アプリケーションには公開されませんが、開発者が継承または実装することは可能です。 </p></dd><dt><span class="term">TransactionFactory (<code class="literal">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(オプション) <code class="literal">Transaction</code> インスタンスのファクトリ。アプリケーションには公開されませんが、開発者が継承または実装することは可能です。 </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>Hibernate は、永続層の振る舞いをカスタマイズするために、多くのオプション拡張インタフェースを用意しています。詳細は API ドキュメントを参照してください。 </p></dd></dl></div><p>
        </p><p>「軽い」アーキテクチャでは、アプリケーションは直接 JTA や JDBC と対話するために、 <code class="literal">Transaction</code> や <code class="literal">TransactionFactory</code> や <code class="literal">ConnectionProvider</code> の API をバイパスします。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-states"/>2.2. インスタンスの状態</h2></div></div></div><p>永続クラスのインスタンスは、次の３つの異なる状態のどれかになります。それは、 <span class="emphasis"><em>永続コンテキスト</em></span> によって決まります。 Hibernate の <code class="literal">Session</code> オブジェクトが、永続コンテキストになります: </p><div class="variablelist"><dl><dt><span class="term">transient</span></dt><dd><p>The instance is not associated with any persistence context. It has no persistent identity or primary key value. </p></dd><dt><span class="term">persistent</span></dt><dd><p>この状態のインスタンスは、その時点で永続コンテキストに関連づいています。また、永続 ID （主キーの値）を持ち、たいていはデータベースに対応する行を持っているでしょう。特定の永続コンテキストのなかでは、永続 ID が Java の ID （オブジェクトのメモリ上の位置）と同じであることを Hibernate が <span class="emphasis"><em>保証</em></span> します。 </p></dd><dt><span class="term">detached</span></dt><dd><p>この状態のインスタンスは、かつて永続コンテキストに関連づけられたが、そのコンテキストがクローズされたか、あるいは、他のプロセスにそのインスタンスがシリアライズされたかです。このインスタンスは、永続 ID を持ち、たいていはデータベースに対応する行を持っているでしょう。分離インスタンスに対しては、永続 ID と Java の ID との関連は、 Hibernate が保証しません。 </p></dd></dl></div></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.3. JMX との統合</h2></div></div></div><p>JMX は Java コンポーネント管理の J2EE 標準です。 JMX 標準サービスを通して、 Hibernate は管理されます。ディストリビューションの中に <code class="literal">org.hibernate.jmx.HibernateService</code> という MBean 実装を用意しています。 </p><p>JBoss アプリケーションサーバー上に Hibernate を JMX サービスとしてデプロイする方法の例としては、 JBoss ユーザーガイドを参照してください。 JBoss アプリケーションサーバーにおいて、 JMX を使ってデプロイすると、次のメリットが得られます: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>セッション管理:</em></span> Hibernate の <code class="literal">Session</code> のライフサイクルは、自動的に JTA トランザクションのスコープに結びつけられます。これは、もはや手動で <code class="literal">Session</code> をオープンしたり、クローズしたりする必要がないことを意味します。これは、 JBoss EJB インターセプタの仕事になります。また、コードのどこでトランザクション境界を設定するかについて、もはや悩む必要がありません（もちろん移植可能な永続層を書かかなくていいのならば、オプションの Hibernate の <code class="literal">Transaction</code> を使用してください。） <code class="literal">Session</code> にアクセスするためには、 <code class="literal">HibernateContext</code> をコールしてください。 </p></li><li><p><span class="emphasis"><em>HAR デプロイ:</em></span> 通常、( EAR または SAR ファイルにある） JBoss サービスデプロイメントディスクリプタを使って、 Hibernate JMX サービスをデプロイします。それは、 Hibernate の <code class="literal">SessionFactory</code> の全ての一般的な設定オプションをサポートします。しかし依然としてデプロイメントディスクリプタのなかにすべてのマッピングファイルの名前を挙げる必要があります。もし、オプションの HAR デプロイメントを使うことを決めたなら、 JBoss は自動的に HAR ファイルのなかの全てのマッピングファイルを検出します。 </p></li></ul></div><p>これらのオプションについての詳細な情報は、 JBoss アプリケーションサーバーユーザーガイドを参考にしてください。 </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a class="xref" href="session-configuration.html#configuration-optional-statistics" title="3.4.6. Hibernate 統計">「Hibernate 統計」</a> for more information. </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jca"/>2.4. JCA サポート</h2></div></div></div><p>Hibernate は JCA コネクタとしても設定できます。詳細については、 Web サイトを見てください。 Hibernate JCA サポートは、今のところ実験段階として考えられていることに注意してください。 </p></div><div class="section" lang="ja-JP"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.5. コンテキスト上のセッション</h2></div></div></div><p>Hibernate を使ったアプリケーションは、ほとんど、なんらかの形で「コンテキスト上の」セッションが必要になります。「コンテキスト上のセッション」は、特定のコンテキストのスコープのなかで有効なセッションのことです。しかし、通常アプリケーションごとにコンテキストを構成するものの定義は異なります。しかも、異なる複数のコンテキストは、現時点に対して異なるスコープを定義します。バージョン3.0より前の Hibernate では、自作の <code class="literal">ThreadLocal</code> ベースの「コンテキスト上のセッション」を利用するか、 <code class="literal">HibernateUtil</code> のようなヘルパークラスを利用するか、 proxy/interception ベースの「コンテキスト上のセッション」を提供する （Spring や Pico のような）サードパーティのフレームワークを利用するかのいずれかでした。 </p><p>Starting with version 3.0.1, Hibernate added the <code class="literal">SessionFactory.getCurrentSession()</code> method. Initially, this assumed usage of <code class="literal">JTA</code> transactions, where the <code class="literal">JTA</code> transaction defined both the scope and context of a current session. Given the maturity of the numerous stand-alone <code class="literal">JTA TransactionManager</code> implementations, most, if not all, applications should be using <code class="literal">JTA</code> transaction management, whether or not they are deployed into a <code class="literal">J2EE</code> container. Based on that, the <code class="literal">JTA</code>-based contextual sessions are all you need to use. </p><p>しかし、バージョン 3.1 からは、 <code class="literal">SessionFactory.getCurrentSession()</code> の後の処理が、プラガブルになりました。これを受けて、現在のセッションを定義するスコープとコンテキストのプラガビリティを可能にするために、新しい拡張インタフェース ( <code class="literal">org.hibernate.context.CurrentSessionContext</code> ) と新しい構成パラメータ ( <code class="literal">hibernate.current_session_context_class</code> ) が追加されました。 </p><p>See the Javadocs for the <code class="literal">org.hibernate.context.CurrentSessionContext</code> interface for a detailed discussion of its contract. It defines a single method, <code class="literal">currentSession()</code>, by which the implementation is responsible for tracking the current contextual session. Out-of-the-box, Hibernate comes with three implementations of this interface: </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code> - <code class="literal">JTA</code> トランザクションによって、現在のセッションが追跡され、スコープを決められます。この処理は、古い JTA だけのアプローチとまったく同じです。詳細は Javadoc を参照してください。 </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code> - スレッドの実行によって、現在のセッションが追跡されます。詳細は Javadoc を参照してください。 </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code> - スレッドの実行によって、現在のセッションが追跡されます。しかし、このクラスの static メソッドで <code class="literal">Session</code> インスタンスをバインド/アンバインドする責任はあなたにあります。これは決して <code class="literal">Session</code> をオープン、フラッシュ、クローズしません。 </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a class="xref" href="transactions.html" title="第12章 Transactions and Concurrency">12章<i>Transactions and Concurrency</i></a> for more information and code examples. </p><p><code class="literal">hibernate.current_session_context_class</code> 設定パラメータは、 <code class="literal">org.hibernate.context.CurrentSessionContext</code> のどの実装を使うかを指定します。下位互換性のため、このパラメータが設定されず <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code> が設定されていた場合、 Hibernate は <code class="literal">org.hibernate.context.JTASessionContext</code> を使うことに注意してください。通常このパラメータの値には、3つの実装の中から使用する実装クラスの名前を直接指定します。しかし、"jta"、 "thread"、 "managed"というそれぞれの省略名も用意されています。 </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">製作著作 © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>前のページ</strong>第1章 Tutorial</a></li><li class="up"><a accesskey="u" href="#"><strong>上に戻る</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>ホーム</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>次のページ</strong>第3章 設定</a></li></ul></body></html>