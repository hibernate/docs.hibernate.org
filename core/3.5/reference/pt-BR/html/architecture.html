<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Capítulo 2. Arquitetura</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="up" href="index.html" title="HIBERNATE - Persistência Relacional para Java Idiomático"/><link rel="prev" href="tutorial.html" title="Capítulo 1. Tutorial"/><link rel="next" href="session-configuration.html" title="Capítulo 3. Configuration"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Anterior</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Próxima</strong></a></li></ul><div class="chapter" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Capítulo 2. Arquitetura </h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="architecture.html#architecture-overview">2.1. Visão Geral</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-states">2.2. Estados de instância</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-jmx">2.3. Integração JMX</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-jca">2.4. Suporte JCA</a></span></dt><dt><span class="section"><a href="architecture.html#architecture-current-session">2.5. Sessões Contextuais</a></span></dt></dl></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-overview"/>2.1. Visão Geral</h2></div></div></div><p>O diagrama abaixo fornece uma visão de altíssimo nível da arquitetura do Hibernate: </p><div class="mediaobject" align="center"><img src="images/overview.png" align="middle"/></div><p>Nós não temos o escopo neste documento para mostrar uma visão mais detalhada da arquitetura em execução. O Hibernate é muito flexível e suporta várias abordagens. Mostraremos os dois extremos. No entanto, nós apresentaremos os dois extremos: arquitetura "mínima" e arquitetura "compreensiva".  </p><p>Este diagrama mostra o Hibernate usando o banco de dados e a configuração de dados para prover persistência de serviços e persistência de objetos para o aplicativo. </p><p>Na arquitetura "mínima", o aplicativo fornece suas próprias conexões JDBC e gerencia suas transações. Esta abordagem usa o mínimo de subconjuntos das APIs do Hibernate: </p><div class="mediaobject" align="center"><img src="images/lite.png" align="middle"/></div><p>A arquitetura "compreensiva" abstrai a aplicação do JDBC/JTA e APIs adjacentes e deixa o Hibernate tomar conta dos detalhes. </p><div class="mediaobject" align="center"><img src="images/full_cream.png" align="middle"/></div><p>Algumas definições dos objetos descritos nos diagramas:  </p><div class="variablelist"><dl><dt><span class="term">SessionFactory (<code class="literal">org.hibernate.SessionFactory</code>)</span></dt><dd><p>O threadsafe, cachê imutável composto de mapeamentos compilados para um único banco de dados. Uma fábrica para <code class="literal">Session</code> e um cliente de <code class="literal">ConnectionProvider</code>, <code class="literal">SessionFactory</code> pode conter um cachê opcional de dados (segundo nível) reutilizáveis entre transações, no nível de processo ou cluster. </p></dd><dt><span class="term">Session (<code class="literal">org.hibernate.Session</code>)</span></dt><dd><p>Objeto single-threaded, de vida curta, representa uma conversação entre o aplicativo e o armazenamento persistente. Cria uma camada sobre uma conexão JDBC. É uma fabrica de <code class="literal">Transaction</code>. A <code class="literal">Session</code> possui um cachê obrigatório (primeiro nível) de objetos persistentes, usado para navegação nos gráficos de objetos e pesquisa de objetos pelo identificador. </p></dd><dt><span class="term">Objetos persistentes e coleções</span></dt><dd><p>Objetos, de vida curta, single threaded contendo estado persistente e função de negócios. Esses podem ser JavaBeans/POJOs, onde a única coisa especial sobre eles é que são associados a (exatamente uma) <code class="literal">Session</code>. Quando a <code class="literal">Session</code> é fechada, eles são separados e liberados para serem usados dentro de qualquer camada da aplicação (Ex. diretamente como objetos de transferência de dados de e para a camada de apresentação). </p></dd><dt><span class="term">Objetos e coleções desanexados e transientes</span></dt><dd><p>Instâncias de classes persistentes que ainda não estão associadas a uma <code class="literal">Session</code>. Eles podem ter sido instanciados pela aplicação e não persistidos (ainda) ou eles foram instanciados por uma <code class="literal">Session</code> encerrada. </p></dd><dt><span class="term">Transaction (<code class="literal">org.hibernate.Transaction</code>)</span></dt><dd><p>(Opcional) Objeto de vida curta, single threaded, usado pela aplicação para especificar unidades atômicas de trabalho. Abstrai o aplicativo das transações JDBC, JTA ou CORBA adjacentes. Uma <code class="literal">Session</code> pode, em alguns casos, iniciar várias <code class="literal">Transaction</code>s. Entretanto, a demarcação da transação, mesmo utilizando API ou <code class="literal">Transaction</code> subjacentes, nunca é opcional. </p></dd><dt><span class="term">Connection Provider (<code class="literal">org.hibernate.connection.ConnectionProvider</code>)</span></dt><dd><p>(Opcional) Uma fábrica de, e pool de, conexões JDBC. Abstrai a aplicação dos <code class="literal">Datasource</code> ou <code class="literal">DriverManager</code> adjacentes. Não exposto para a aplicação, mas pode ser implementado ou estendido pelo programador.  </p></dd><dt><span class="term">Transaction Factory (<code class="literal">org.hibernate.TransactionFactory</code>)</span></dt><dd><p>(Opcional) Uma fábrica para instâncias de <code class="literal">Transaction</code>. Não exposta a aplicação, mas pode ser estendida/implementada pelo programador. </p></dd><dt><span class="term"><span class="emphasis"><em>Extension Interfaces</em></span></span></dt><dd><p>O Hibernate oferece várias opções de interfaces estendidas que você pode implementar para customizar sua camada persistente. Veja a documentação da API para maiores detalhes.  </p></dd></dl></div><p>
        </p><p>Dada uma arquitetura "mínima", o aplicativo passa pelas APIs <code class="literal">Transaction</code>/<code class="literal">TransactionFactory</code> e/ou <code class="literal">ConnectionProvider</code> para se comunicar diretamente com a transação JTA ou JDBC. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-states"/>2.2. Estados de instância</h2></div></div></div><p>Uma instância de classes persistentes pode estar em um dos três diferentes estados, que são definidos respeitando um <span class="emphasis"><em>contexto persistente</em></span>. O objeto <code class="literal">Session</code> do Hibernate é o contexto persistente. Os três diferentes estados são os seguintes: </p><div class="variablelist"><dl><dt><span class="term">transiente</span></dt><dd><p>A instância não é associada a nenhum contexto persistente. Não possui uma identidade persistente ou valor de chave primária. </p></dd><dt><span class="term">persistente</span></dt><dd><p>A instância está atualmente associada a um contexto persistente. Possui uma identidade persistente (valor de chave primária) e, talvez, correspondente a uma fila no banco de dados. Para um contexto persistente em particular, o Hibernate <span class="emphasis"><em>garante</em></span> que a identidade persistente é equivalente à identidade Java (na localização em memória do objeto). </p></dd><dt><span class="term">desanexado</span></dt><dd><p>A instância foi associada com um contexto persistente, porém este contexto foi fechado, ou a instância foi serializada por outro processo. Possui uma identidade persistente, e, talvez, corresponda a uma fila no banco de dados. Para instâncias desanexadas, o Hibernate não garante o relacionamento entre identidade persistente e identidade Java. </p></dd></dl></div></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jmx"/>2.3. Integração JMX</h2></div></div></div><p>JMX é o padrão do J2EE para manipulação de componentes Java. O Hibernate pode ser manipulado por um serviço JMX padrão. Nós fornecemos uma implementação do MBean na distribuição: <code class="literal">org.hibernate.jmx.HibernateService</code>. </p><p>Para um exemplo de como implementar o Hibernate como um serviço JMX em um Servidor de Aplicativo JBoss, por favor, consulte o Guia do Usuário do JBoss. No JBoss As, você poderá ver os benefícios de se fazer a implementação usando JMX: </p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Session Management:</em></span> O ciclo de vida de uma <code class="literal">Session</code> do Hibernate pode ser automaticamente conectada a um escopo de transação JTA. Isso significa que você não precisará mais abrir e fechar manualmente uma <code class="literal">Session</code>, isso se torna uma tarefa para um interceptor EJB do JBoss. Você também não precisará mais se preocupar com demarcação de transação em seu código (caso você prefira escrever uma camada persistente portável, use a API opcional do Hibernate <code class="literal">Transaction</code>). Você deve chamar <code class="literal">HibernateContext</code> para acessar uma <code class="literal">Session</code>. </p></li><li><p><span class="emphasis"><em>HAR deployment:</em></span>: Normalmente você implementa o serviço JMX do Hibernate usando um serviço descritor de implementação do JBoss em um EAR e/ou arquivo SAR, que suporta todas as configurações comuns de uma <code class="literal">SessionFactory</code> do Hibernate. Entretanto, você ainda precisa nomear todos os seus arquivos de mapeamento no descritor de implementação. Se você decidir usar a implementaçao opcional HAR, o JBoss irá automaticamente detectar todos os seus arquivos de mapeamento no seu arquivo HAR. </p></li></ul></div><p>Consulte o manual do usuário do JBoss AS, para obter maiores informações sobre essas opções. </p><p>Another feature available as a JMX service is runtime Hibernate statistics. See <a class="xref" href="session-configuration.html#configuration-optional-statistics" title="3.4.6. Estatísticas do Hibernate">Seção 3.4.6, “Estatísticas do Hibernate”</a> for more information. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-jca"/>2.4. Suporte JCA</h2></div></div></div><p>O Hibernate pode também ser configurado como um conector JCA. Por favor, visite o website para maiores detalhes. Observe também, que o suporte do JCA do Hibernate ainda é considerado experimental. </p></div><div class="section" lang="pt-BR"><div class="titlepage"><div><div><h2 class="title"><a id="architecture-current-session"/>2.5. Sessões Contextuais</h2></div></div></div><p>A maioria das aplicações que usa o Hibernate necessita de algum tipo de sessão "contextual", onde uma sessão dada é na verdade um escopo de um contexto. Entretanto, através de aplicações, a definição sobre um contexto é geralmente diferente; e contextos diferentes definem escopos diferentes. Aplicações usando versões anteriores ao Hibernate 3.0 tendem a utilizar tanto sessões contextuais baseadas em <code class="literal">ThreadLocal</code>, classes utilitárias como <code class="literal">HibernateUtil</code>, ou utilizar frameworks de terceiros (como Spring ou Pico) que provê sessões contextuais baseadas em proxy. </p><p>A partir da versão 3.0.1, o Hibernate adicionou o método <code class="literal">SessionFactory.getCurrentSession()</code>. Inicialmente, este considerou o uso de transações <code class="literal">JTA</code>, onde a transação <code class="literal">JTA</code> definia tanto o escopo quanto o contexto de uma sessão atual. Dada a maturidade de diversas implementações autônomas disponíveis do <code class="literal">JTA TransactionManager</code>, a maioria (se não todos) dos aplicativos deveria utilizar o gerenciador de transações <code class="literal">JTA</code> sendo ou não instalados dentro de um recipiente <code class="literal">J2EE</code>. Baseado neste recurso, você deve sempre utilizar sessões contextuais baseadas em <code class="literal">JTA</code>.  </p><p>Entretanto, a partir da versão 3.1, o processo por trás do método <code class="literal">SessionFactory.getCurrentSession()</code> é agora plugável. Com isso, uma nova interface (<code class="literal">org.hibernate.context.CurrentSessionContext</code>) e um novo parâmetro de configuração (<code class="literal">hibernate.current_session_context_class</code>) foram adicionados para possibilitar a compatibilidade do contexto e do escopo na definição de sessões correntes. </p><p>Consulte no Javadocs sobre a interface <code class="literal">org.hibernate.context.CurrentSessionContext</code> para uma discussão detalhada. Ela define um método único, <code class="literal">currentSession()</code>, pelo qual a implementação é responsável por rastrear a sessão contextual atual. Fora da caixa, o Hibernate surge com três implementações dessa interface: </p><div class="itemizedlist"><ul><li><p><code class="literal">org.hibernate.context.JTASessionContext</code>: As sessões correntes são rastreadas e recebem um escopo por uma transação <code class="literal">JTA</code>. O processamento aqui é exatamente igual à abordagem anterior do JTA somente. Consulte em Javadocs para maiores detalhes. </p></li><li><p><code class="literal">org.hibernate.context.ThreadLocalSessionContext</code> - As sessões correntes são rastreadas por uma thread de execução. Novamente, consulte em Javadocs para maiores detalhes.  </p></li><li><p><code class="literal">org.hibernate.context.ManagedSessionContext</code>. As sessões atuais são rastreadas por uma thread de execução. Entretanto, você é responsável por vincular e desvincular uma instância <code class="literal">Session</code> com métodos estáticos nesta classe, que nunca abre, libera ou fecha uma <code class="literal">Session</code>.  </p></li></ul></div><p>The first two implementations provide a "one session - one database transaction" programming model. This is also known and used as <span class="emphasis"><em>session-per-request</em></span>. The beginning and end of a Hibernate session is defined by the duration of a database transaction. If you use programmatic transaction demarcation in plain JSE without JTA, you are advised to use the Hibernate <code class="literal">Transaction</code> API to hide the underlying transaction system from your code. If you use JTA, you can utilize the JTA interfaces to demarcate transactions. If you execute in an EJB container that supports CMT, transaction boundaries are defined declaratively and you do not need any transaction or session demarcation operations in your code. Refer to <a class="xref" href="transactions.html" title="Capítulo 12. Transações e Concorrência">Capítulo 12, <i>Transações e Concorrência </i></a> for more information and code examples. </p><p>O parâmetro de configuração <code class="literal">hibernate.current_session_context_class</code> define qual implementação <code class="literal">org.hibernate.context.CurrentSessionContext</code> deve ser usada. Note que para compatibilidade anterior, se este parâmetro de configuração não for determinado mas um <code class="literal">org.hibernate.transaction.TransactionManagerLookup</code> for configurado, Hibernate usará o <code class="literal">org.hibernate.context.JTASessionContext</code>. Tipicamente, o valor deste parâmetro nomearia apenas a classe de implementação para usar; para as três implementações fora da caixa, entretanto, há dois pequenos nomes correspondentes, "jta", "thread", e "managed". </p></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="tutorial.html"><strong>Anterior</strong>Capítulo 1. Tutorial</a></li><li class="up"><a accesskey="u" href="#"><strong>Acima</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Principal</strong></a></li><li class="next"><a accesskey="n" href="session-configuration.html"><strong>Próxima</strong>Capítulo 3. Configuration</a></li></ul></body></html>