<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">第 8 章 Hibernate Validator Specifics</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="Hibernate Validator"/><link rel="up" href="index.html" title="Hibernate Validator"/><link rel="prev" href="validator-integration.html" title="第 7 章 与其他框架集成"/><link rel="next" href="validator-annotation-processor.html" title="第 9 章 Annotation Processor"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="validator-integration.html"><strong>上一页</strong></a></li><li class="next"><a accesskey="n" href="validator-annotation-processor.html"><strong>下一页</strong></a></li></ul><div class="chapter" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="validator-specifics"/>第 8 章 Hibernate Validator Specifics</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="validator-specifics.html#d0e3169">8.1. Public API</a></span></dt><dt><span class="section"><a href="validator-specifics.html#d0e3315">8.2. Fail fast mode</a></span></dt><dt><span class="section"><a href="validator-specifics.html#validator-customoptions-methodvalidation">8.3. Method validation</a></span></dt><dd><dl><dt><span class="section"><a href="validator-specifics.html#d0e3388">8.3.1. Defining method-level constraints</a></span></dt><dt><span class="section"><a href="validator-specifics.html#d0e3463">8.3.2. Evaluating method-level constraints</a></span></dt><dt><span class="section"><a href="validator-specifics.html#d0e3553">8.3.3. Retrieving method-level constraint meta data</a></span></dt></dl></dd><dt><span class="section"><a href="validator-specifics.html#programmaticapi">8.4. Programmatic constraint definition</a></span></dt><dt><span class="section"><a href="validator-specifics.html#d0e3685">8.5. Boolean composition for constraint composition</a></span></dt></dl></div><p>In the following sections we are having a closer look at some of the Hibernate Validator specific features (features which are not part of the Bean Validation specification). This includes the fail fast mode, the programmatic constraint configuration API and boolean composition of composing constraints.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>The features described in the following sections are not portable between Bean Validation providers/implementations.</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3169"/>8.1. Public API</h2></div></div></div><p>Let's start, however, with a look at the public API of Hibernate Validator. <a class="xref" href="validator-specifics.html#validator-public-api" title="表 8.1. Hibernate Validator public API">表 8.1 “Hibernate Validator public API”</a> lists all packages belonging to this API and describes their purpose.</p><p>Any packages not listed in that table are internal packages of Hibernate Validator and are not intended to be accessed by clients. The contents of these internal packages can change from release to release without notice, thus possibly breaking any client code relying on it.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>In the following table, when a package is public its not necessarily true for its nested packages.</p></div><div class="table"><a id="validator-public-api"/><p class="title"><b>表 8.1. Hibernate Validator public API</b></p><div class="table-contents"><table summary="Hibernate Validator public API" border="1"><colgroup><col/><col/></colgroup><thead><tr><th>Packages</th><th>Description</th></tr></thead><tbody valign="top"><tr><td valign="top"><span class="package">org.hibernate.validator</span></td><td valign="top">This package contains the classes used by the Bean Validation bootstrap mechanism (eg. validation provider, configuration class). For more details see <a class="xref" href="validator-bootstrapping.html" title="第 5 章 Bootstrapping">第 5 章 <i>Bootstrapping</i></a>.</td></tr><tr><td valign="top"><span class="package">org.hibernate.validator.cfg</span>, <span class="package">org.hibernate.validator.cfg.context</span>, <span class="package">org.hibernate.validator.cfg.defs</span></td><td valign="top">With Hibernate Validator you can define constraints via a fluent API. These packages contain all classes needed to use this feature. In the package <span class="package">org.hibernate.validator.cfg</span> you will find the <code class="classname">ConstraintMapping</code> class and in package <span class="package">org.hibernate.validator.cfg.defs</span> all constraint definitions. For more details see <a class="xref" href="validator-specifics.html#programmaticapi" title="8.4. Programmatic constraint definition">第 8.4 节 “Programmatic constraint definition”</a>.</td></tr><tr><td valign="top"><span class="package">org.hibernate.validator.constraints</span>, <span class="package">org.hibernate.validator.constraints.br</span></td><td valign="top">In addition to Bean Validation constraints, Hibernate Validator provides some useful custom constraints. These packages contain all custom annotation classes. For more details see <a class="xref" href="validator-usingvalidator.html#validator-defineconstraints-hv-constraints" title="2.4.2. Additional constraints">第 2.4.2 节 “Additional constraints”</a>.</td></tr><tr><td valign="top"><span class="package">org.hibernate.validator.group</span>, <span class="package">org.hibernate.validator.spi.group</span></td><td valign="top">With Hibernate Validator you can define dynamic default group sequences in function of the validated object state. These packages contain all classes needed to use this feature (<code class="classname">GroupSequenceProvider</code> annotation and <code class="classname">DefaultGroupSequenceProvider</code> contract). For more details see <a class="xref" href="validator-usingvalidator.html#section-default-group-class" title="2.3.2. 对一个类重定义其默认校验组">第 2.3.2 节 “对一个类重定义其默认校验组”</a>.</td></tr><tr><td valign="top"><span class="package">org.hibernate.validator.messageinterpolation</span>, <span class="package">org.hibernate.validator.resourceloading</span>, <span class="package">org.hibernate.validator.spi.resourceloading</span></td><td valign="top">These packages contain the classes related to constraint message interpolation. The first package contains two implementations of <code class="classname">MessageInterpolator</code>. The first one, <code class="classname">ValueFormatterMessageInterpolator</code> allows to interpolate the validated value into the constraint message, see <a class="xref" href="validator-bootstrapping.html#section-message-interpolator" title="5.3. MessageInterpolator">第 5.3 节 “MessageInterpolator”</a>. The second implementation named <code class="classname">ResourceBundleMessageInterpolator</code> is the implementation used by default by Hibernate Validator. This implementation relies on a <code class="classname">ResourceBundleLocator</code>, see <a class="xref" href="validator-bootstrapping.html#section-resource-bundle-locator" title="5.3.1. ResourceBundleLocator">第 5.3.1 节 “ResourceBundleLocator”</a>. Hibernate Validator provides different <code class="classname">ResourceBundleLocator</code> implementations located in the package <span class="package">org.hibernate.validator.resourceloading</span>.</td></tr><tr><td valign="top"><span class="package">org.hibernate.validator.method</span>, <span class="package">org.hibernate.validator.method.metadata</span></td><td valign="top">Hibernate Validator provides support for method-level constraints based on appendix C of the Bean Validation specification. The first package contains the <code class="classname">MethodValidator</code> interface allowing you to validate method return values and parameters. The second package contains meta data for constraints hosted on parameters and methods which can be retrieved via the <code class="classname">MethodValidator</code>.</td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>The public packages of Hibernate Validator fall into two categories: while the actual API parts are intended to be <span class="emphasis"><em>invoked</em></span> or <span class="emphasis"><em>used</em></span> by clients (e.g. the API for programmatic constraint declaration or the custom constraints), the SPI (service provider interface) packages contain interfaces which are intended to be <span class="emphasis"><em>implemented</em></span> by clients (e.g. <code class="classname">ResourceBundleLocator</code>).</p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3315"/>8.2. Fail fast mode</h2></div></div></div><p>First off, the fail fast mode. Hibernate Validator allows to return from the current validation as soon as the first constraint violation occurs. This is called the <span class="emphasis"><em>fail fast mode</em></span> and can be useful for validation of large object graphs where one is only interested whether there is a constraint violation or not. <a class="xref" href="validator-specifics.html#example-fail-fast-property" title="例 8.1. Enabling failFast via a property">例 8.1 “Enabling failFast via a property”</a>, <a class="xref" href="validator-specifics.html#example-fail-fast-configuration" title="例 8.2. Enabling failFast at the Configuration level">例 8.2 “Enabling failFast at the Configuration level”</a> and <a class="xref" href="validator-specifics.html#example-fail-fast-factory" title="例 8.3. Enabling failFast at the ValidatorFactory level">例 8.3 “Enabling failFast at the ValidatorFactory level”</a> show multiple ways to enable the fail fast mode.</p><div class="example"><a id="example-fail-fast-property"/><p class="title"><b>例 8.1. Enabling <code class="option">failFast</code> via a property</b></p><div class="example-contents"><pre class="programlisting">HibernateValidatorConfiguration configuration = Validation.byProvider( HibernateValidator.class ).configure();
ValidatorFactory factory = configuration.addProperty( "hibernate.validator.fail_fast", "true" ).buildValidatorFactory();
Validator validator = factory.getValidator();

// do some actual fail fast validation
...</pre></div></div><br class="example-break"/><div class="example"><a id="example-fail-fast-configuration"/><p class="title"><b>例 8.2. Enabling <code class="option">failFast</code> at the <code class="classname">Configuration</code> level</b></p><div class="example-contents"><pre class="programlisting">HibernateValidatorConfiguration configuration = Validation.byProvider( HibernateValidator.class ).configure();
ValidatorFactory factory = configuration.failFast( true ).buildValidatorFactory();
Validator validator = factory.getValidator();

// do some actual fail fast validation
...</pre></div></div><br class="example-break"/><div class="example"><a id="example-fail-fast-factory"/><p class="title"><b>例 8.3. Enabling <code class="option">failFast</code> at the <code class="classname">ValidatorFactory</code> level</b></p><div class="example-contents"><pre class="programlisting">HibernateValidatorConfiguration configuration = Validation.byProvider( HibernateValidator.class ).configure();
ValidatorFactory factory = configuration.buildValidatorFactory();

Validator validator = factory.getValidator();

// do some non fail fast validation
...

validator = factory.unwrap( HibernateValidatorFactory.class )
            .usingContext()
            .failFast( true )
            .getValidator();

// do fail fast validation
...</pre></div></div><br class="example-break"/></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="validator-customoptions-methodvalidation"/>8.3. Method validation</h2></div></div></div><p>The Bean Validation API allows to specify constraints for fields, properties and types. Hibernate Validator goes one step further and allows to place contraint annotations also on method parameters and method return values, thus enabling a programming style known as "Programming by Contract".</p><p>More specifically this means that Bean Validation constraints can be used to specify</p><div class="itemizedlist"><ul><li><p>the preconditions that must be met before a method invocation (by annotating method parameters with constraints) and</p></li><li><p>the postconditions that are guaranteed after a method invocation (by annotating methods)</p></li></ul></div><p>This approach has several advantages over traditional ways of parameter and return value checking:</p><div class="itemizedlist"><ul><li><p>The checks don't have to be performed manually (e.g. by throwing <code class="classname">IllegalArgumentExceptions</code> or similar), resulting in less code to write and maintain.</p></li><li><p>A method's pre- and postconditions don't have to be expressed again in the method's JavaDoc, since the constraint annotations will automatically be included in the generated JavaDoc. This avoids redundancy and reduces the chance of inconsistencies between implementation and documentation.</p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>Method validation was also considered to be included in the Bean Validation API as defined by JSR 303, but it didn't become part of the 1.0 version. A basic draft is outlined in appendix C of the specification, and the implementation in Hibernate Validator is largely influenced by this draft. The feature is considered again for inclusion in BV 1.1.</p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3388"/>8.3.1. Defining method-level constraints</h3></div></div></div><p><a class="xref" href="validator-specifics.html#example-method-constraints" title="例 8.4. Using method-level constraints">例 8.4 “Using method-level constraints”</a> demonstrates the definition of method-level constraints.</p><div class="example"><a id="example-method-constraints"/><p class="title"><b>例 8.4. Using method-level constraints</b></p><div class="example-contents"><pre class="programlisting">public class RentalStation {

    @NotNull 
    public Car rentCar(@NotNull Customer customer, @NotNull @Future Date startDate, @Min(1) int durationInDays) { 
        //...
    }
}</pre></div></div><p><br class="example-break"/></p><p>Here the following pre- and postconditions for the <code class="methodname">rentCar()</code> method are declared:</p><div class="itemizedlist"><ul><li><p>The renting customer may not be null</p></li><li><p>The rental's start date must not be null and must be in the future</p></li><li><p>The rental duration must be at least one day</p></li><li><p>The returned <code class="classname">Car</code> instance may not be null</p></li></ul></div><p>Using the <code class="classname">@Valid</code> annotation it's also possible to define that a cascaded validation of parameter or return value objects shall be performed. An example can be found in <a class="xref" href="validator-specifics.html#example-cascaded-method-constraints" title="例 8.5. Cascaded validation of method-level constraints">例 8.5 “Cascaded validation of method-level constraints”</a>.</p><div class="example"><a id="example-cascaded-method-constraints"/><p class="title"><b>例 8.5. Cascaded validation of method-level constraints</b></p><div class="example-contents"><pre class="programlisting">public class RentalStation {

    @Valid
    public Set&lt;Rental&gt; getRentalsByCustomer(@Valid Customer customer) { 
        //...
    }
}</pre></div></div><br class="example-break"/><p>Here all the constraints declared at the <code class="classname">Customer</code> type will be evaluated when validating the method parameter and all constraints declared at the returned <code class="classname">Rental</code> objects will be evaluated when validating the method's return value.</p><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3440"/>8.3.1.1. Using method constraints in type hierarchies</h4></div></div></div><p>Special care must be taken when defining parameter constraints in inheritance hierarchies.</p><p>When a method is overridden in sub-types method parameter constraints can only be declared at the base type. The reason for this restriction is that the preconditions to be fulfilled by a type's client must not be strengthened in sub-types (which may not even be known to the base type's client). Note that also if the base method doesn't declare any parameter constraints at all, no parameter constraints may be added in overriding methods.</p><p>The same restriction applies to interface methods: no parameter constraints may be defined at the implementing method (or the same method declared in sub-interfaces).</p><p>If a violation of this rule is detected by the validation engine, a <code class="classname">javax.validation.ConstraintDeclarationException</code> will be thrown. In <a class="xref" href="validator-specifics.html#example-illegal-method-constraints" title="例 8.6. Illegal parameter constraint declarations">例 8.6 “Illegal parameter constraint declarations”</a> some examples for illegal parameter constraints declarations are shown.</p><div class="example"><a id="example-illegal-method-constraints"/><p class="title"><b>例 8.6. Illegal parameter constraint declarations</b></p><div class="example-contents"><pre class="programlisting">public class Car {

    public void drive(Person driver) { ... }

}

public class RentalCar extends Car {

    //not allowed, parameter constraint added in overriding method
    public void drive(@NotNull Person driver) { ... }

}

public interface ICar {

    void drive(Person driver);

}

public class CarImpl implements ICar {

    //not allowed, parameter constraint added in implementation of interface method
    public void drive(@NotNull Person driver) { ... }

}</pre></div></div><br class="example-break"/><p>This rule only applies to parameter constraints, return value constraints may be added in sub-types without any restrictions as it is alright to strengthen the postconditions guaranteed to a type's client.</p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3463"/>8.3.2. Evaluating method-level constraints</h3></div></div></div><p>To validate method-level constraints Hibernate Validator provides the interface <code class="classname">org.hibernate.validator.method.MethodValidator</code>.</p><p>As shown in <a class="xref" href="validator-specifics.html#example-methodvalidator" title="例 8.7. The MethodValidator interface">例 8.7 “The MethodValidator interface”</a> this interface defines methods for the evaluation of parameter as well as return value constraints and for retrieving an extended type descriptor providing method constraint related meta data.</p><div class="example"><a id="example-methodvalidator"/><p class="title"><b>例 8.7. The <code class="classname">MethodValidator</code> interface</b></p><div class="example-contents"><pre class="programlisting">public interface MethodValidator {

    &lt;T&gt; Set&lt;MethodConstraintViolation&lt;T&gt;&gt; validateParameter(T object, Method method, Object parameterValue, int parameterIndex, Class&lt;?&gt;... groups);
    
    &lt;T&gt; Set&lt;MethodConstraintViolation&lt;T&gt;&gt; validateAllParameters(T object, Method method, Object[] parameterValues, Class&lt;?&gt;... groups);
    
    &lt;T&gt; Set&lt;MethodConstraintViolation&lt;T&gt;&gt; validateReturnValue(T object, Method method, Object returnValue, Class&lt;?&gt;... groups);
 
    TypeDescriptor getConstraintsForType(Class&lt;?&gt; clazz);
}    </pre></div></div><br class="example-break"/><p>To retrieve a method validator get hold of an instance of HV's <code class="classname">javax.validation.Validator</code> implementation and unwrap it to <code class="classname">MethodValidator</code> as shown in <a class="xref" href="validator-specifics.html#example-retrieving-methodvalidator" title="例 8.8. Retrieving a MethodValidator instance">例 8.8 “Retrieving a MethodValidator instance”</a>.</p><div class="example"><a id="example-retrieving-methodvalidator"/><p class="title"><b>例 8.8. Retrieving a <code class="classname">MethodValidator</code> instance</b></p><div class="example-contents"><pre class="programlisting">MethodValidator methodValidator = Validation.byProvider( HibernateValidator.class )
    .configure()
    .buildValidatorFactory()
    .getValidator()
    .unwrap( MethodValidator.class ); </pre></div></div><br class="example-break"/><p>The validation methods defined on <code class="classname">MethodValidator</code> each return a <code class="classname">Set&lt;MethodConstraintViolation&gt;</code>. The type <code class="classname">MethodConstraintViolation</code> (see <a class="xref" href="validator-specifics.html#example-methodconstraintviolation" title="例 8.9. The MethodConstraintViolation type">例 8.9 “The MethodConstraintViolation type”</a>) extends <code class="classname">javax.validation.ConstraintViolation</code> and provides additional method level validation specific information such as the method and index of the parameter which caused the constraint violation.</p><div class="example"><a id="example-methodconstraintviolation"/><p class="title"><b>例 8.9. The <code class="classname">MethodConstraintViolation</code> type</b></p><div class="example-contents"><pre class="programlisting">public interface MethodConstraintViolation&lt;T&gt; extends ConstraintViolation&lt;T&gt; {
    
    public static enum Kind { PARAMETER, RETURN_VALUE }

    Method getMethod();

    Integer getParameterIndex();

    String getParameterName();

    Kind getKind();
}</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>注意</h2><p>The method <code class="methodname">getParameterName()</code> currently returns synthetic parameter identifiers such as "arg0", "arg1" etc. In a future version of Hibernate Validator support for specifying parameter identifiers might be added.</p></div><p>Typically the validation of method-level constraints is not invoked manually but automatically upon method invocation by an integration layer using AOP (aspect-oriented programming) or similar method interception facilities such as the JDK's <code class="classname">java.lang.reflect.Proxy</code> API or CDI ("JSR 299: Contexts and Dependency Injection for the Java<sup>TM</sup> EE platform").</p><p>If a parameter or return value constraint can't be validated sucessfully such an integration layer typically will throw a <code class="classname">MethodConstraintViolationException</code> which similar to <code class="classname">javax.validation.ConstraintViolationException</code> contains a set with the occurred constraint violations.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>提示</h2><p>If you are using CDI you might be interested in the <a class="ulink" href="http://seamframework.org/Seam3/ValidationModule">Seam Validation</a> project. This Seam module provides an interceptor which integrates the method validation functionality with CDI.</p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3553"/>8.3.3. Retrieving method-level constraint meta data</h3></div></div></div><p>As outlined in <a class="xref" href="validator-metadata-api.html" title="第 6 章 Metadata API">第 6 章 <i>Metadata API</i></a> the Bean Validation API provides rich capabilities for retrieving constraint related meta data. Hibernate Validator extends this API and allows to retrieve constraint meta data also for method-level constraints.</p><p><a class="xref" href="validator-specifics.html#example-method-level-meta-data" title="例 8.10. Retrieving meta data for method-level constraints">例 8.10 “Retrieving meta data for method-level constraints”</a> shows how to use this extended API to retrieve constraint meta data for the <code class="methodname">rentCar()</code> method from the <code class="classname">RentalStation</code> type.</p><div class="example"><a id="example-method-level-meta-data"/><p class="title"><b>例 8.10. Retrieving meta data for method-level constraints</b></p><div class="example-contents"><pre class="programlisting">TypeDescriptor typeDescriptor = methodValidator.getConstraintsForType(RentalStation.class)

//retrieve a descriptor for the rentCar() method
MethodDescriptor rentCarMethod = typeDescriptor.getConstraintsForMethod("rentCar", Customer.class, Date.class, int.class);
assertEquals(rentCarMethod.getMethodName(), "rentCar");
assertTrue(rentCarMethod.hasConstraints());
assertFalse(rentCarMethod.isCascaded());

//retrieve constraints from the return value
Set&lt;ConstraintDescriptor&lt;?&gt;&gt; returnValueConstraints = rentCarMethod.findConstraints().getConstraintDescriptors();
assertEquals(returnValueConstraints.size(), 1);
assertEquals(returnValueConstraints.iterator().next().getAnnotation().annotationType(), NotNull.class);

List&lt;ParameterDescriptor&gt; allParameters = rentCarMethod.getParameterDescriptors();
assertEquals(allParameters.size(), 3);

//retrieve a descriptor for the startDate parameter
ParameterDescriptor startDateParameter = allParameters.get(1);
assertEquals(startDateParameter.getIndex(), 1);
assertFalse(startDateParameter.isCascaded());
assertEquals(startDateParameter.findConstraints().getConstraintDescriptors().size(), 2);</pre></div></div><br class="example-break"/><p>Refer to the <a class="ulink" href="http://docs.jboss.org/hibernate/validator/4.2/api/index.html?org/hibernate/validator/method/metadata/package-summary.html">JavaDoc</a> of the package <code class="classname">org.hibernate.validator.method.metadata</code> for more details on the extended meta data API.</p></div></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="programmaticapi"/>8.4. Programmatic constraint definition</h2></div></div></div><p>Another addition to the Bean Validation specification is the ability to configure constraints via a fluent API. This API can be used exclusively or in combination with annotations and xml. If used in combination programmatic constraints are additive to constraints configured via the standard configuration capabilities.</p><p>The API is centered around the <code class="classname">ConstraintMapping</code> class which can be found in the package<span class="package"> org.hibernate.validator.cfg</span>. Starting with the instantiation of a new <code class="classname">ConstraintMapping</code>, constraints can be defined in a fluent manner as shown in <a class="xref" href="validator-specifics.html#example-constraint-mapping" title="例 8.11. Programmatic constraint definition">例 8.11 “Programmatic constraint definition”</a>.</p><div class="example"><a id="example-constraint-mapping"/><p class="title"><b>例 8.11. Programmatic constraint definition</b></p><div class="example-contents"><pre class="programlisting">ConstraintMapping mapping = new ConstraintMapping();
mapping.type( Car.class )
    .property( "manufacturer", FIELD )
        .constraint( new NotNullDef() )
    .property( "licensePlate", FIELD )
        .constraint( new NotNullDef() )
        .constraint( new SizeDef().min( 2 ).max( 14 ) )
    .property( "seatCount", FIELD )
        .constraint( new MinDef()value ( 2 ) )
.type( RentalCar.class )
    .property( "rentalStation", METHOD )
        .constraint( new NotNullDef() );      </pre></div></div><p><br class="example-break"/></p><p>As you can see constraints can be configured on multiple classes and properties using method chaining. The constraint definition classes <code class="classname">NotNullDef</code>, <code class="classname">SizeDef</code> and <code class="classname">MinDef</code> are helper classes which allow to configure constraint parameters in a type-safe fashion. Definition classes exist for all built-in constraints in the <code class="classname">org.hibernate.validator.cfg.defs</code> package.</p><p>For custom constraints you can either create your own definition classes extending <code class="classname">ConstraintDef</code> or you can use <code class="classname">GenericConstraintDef</code> as seen in <a class="xref" href="validator-specifics.html#example-generic-constraint-mapping" title="例 8.12. Programmatic constraint definition using createGeneric()">例 8.12 “Programmatic constraint definition using createGeneric()”</a>.</p><div class="example"><a id="example-generic-constraint-mapping"/><p class="title"><b>例 8.12. Programmatic constraint definition using <code class="methodname">createGeneric()</code></b></p><div class="example-contents"><pre class="programlisting">ConstraintMapping mapping = new ConstraintMapping();
mapping.type( Car.class )
    .property( "licensePlate", FIELD )
        .constraint( new GenericConstraintDef&lt;CheckCase.class&gt;( CheckCase.class ).param( "value", CaseMode.UPPER ) );   </pre></div></div><p><br class="example-break"/></p><p>Not only standard class- and property-level constraints but also method constraints can be configured using the API. As shown in <a class="xref" href="validator-specifics.html#example-method-constraint-mapping" title="例 8.13. Programmatic definition of method constraints">例 8.13 “Programmatic definition of method constraints”</a> methods are identified by their name and their parameters (if there are any). Having selected a method, constraints can be placed on the method's parameters and/or return value.</p><div class="example"><a id="example-method-constraint-mapping"/><p class="title"><b>例 8.13. Programmatic definition of method constraints</b></p><div class="example-contents"><pre class="programlisting">ConstraintMapping mapping = new ConstraintMapping();
mapping.type( Car.class )
    .method( "drive", String.class, Integer.class )
        .parameter( 0 )
            .constraint( new NotNullDef() )
            .constraint( new MinDef().value ( 1 ) )
        .parameter( 1 )
            .constraint( new NotNullDef() )
        .returnValue()
            .constraint( new NotNullDef() )
    .method( "check" )
        .returnValue()
            .constraint( new NotNullDef() );      </pre></div></div><br class="example-break"/><p>Using the API it's also possible to mark properties, method parameters and method return values as cascading (equivalent to annotating them with <code class="classname">@Valid</code>). An example can be found in <a class="xref" href="validator-specifics.html#example-cascading-constraints" title="例 8.14. Marking constraints for cascaded validation">例 8.14 “Marking constraints for cascaded validation”</a>.</p><div class="example"><a id="example-cascading-constraints"/><p class="title"><b>例 8.14. Marking constraints for cascaded validation</b></p><div class="example-contents"><pre class="programlisting">ConstraintMapping mapping = new ConstraintMapping();
mapping.type( Car.class )
    .property( "manufacturer", FIELD )
        .valid()
    .property( "licensePlate", METHOD )
        .valid()
    .method( "drive", String.class, Integer.class )
        .parameter( 0 )
            .valid()
        .parameter( 1 )
            .valid()
        .returnValue()
            .valid()
.type( RentalCar.class )
    .property( "rentalStation", METHOD )
        .valid();</pre></div></div><p><br class="example-break"/></p><p>Last but not least you can configure the default group sequence or the default group sequence provider of a type as shown in <a class="xref" href="validator-specifics.html#example-sequences" title="例 8.15. Configuration of default group sequence and default group sequence provider">例 8.15 “Configuration of default group sequence and default group sequence provider”</a>.</p><div class="example"><a id="example-sequences"/><p class="title"><b>例 8.15. Configuration of default group sequence and default group sequence provider</b></p><div class="example-contents"><pre class="programlisting">ConstraintMapping mapping = new ConstraintMapping();
mapping.type( Car.class )
    .defaultGroupSequence( Car.class, CarChecks.class )
.type( RentalCar.class )
    .defaultGroupSequenceProvider( RentalCarGroupSequenceProvider.class ); </pre></div></div><p><br class="example-break"/></p><p>Once a <code class="classname">ConstraintMapping</code> is set up it has to be passed to the configuration. Since the programmatic API is not part of the official Bean Validation specification you need to get hold of a <code class="classname">HibernateValidatorConfiguration</code> instance as shown in <a class="xref" href="validator-specifics.html#example-hibernate-specific-config" title="例 8.16. Creating a Hibernate Validator specific configuration">例 8.16 “Creating a Hibernate Validator specific configuration”</a>.</p><div class="example"><a id="example-hibernate-specific-config"/><p class="title"><b>例 8.16. Creating a Hibernate Validator specific configuration</b></p><div class="example-contents"><pre class="programlisting">ConstraintMapping mapping = new ConstraintMapping();
// configure mapping instance

HibernateValidatorConfiguration config = Validation.byProvider( HibernateValidator.class ).configure();
config.addMapping( mapping );
ValidatorFactory factory = config.buildValidatorFactory();
Validator validator = factory.getValidator();</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="zh-CN"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3685"/>8.5. Boolean composition for constraint composition</h2></div></div></div><p>As per Bean Validation specification the constraints of a composed constraint (see <a class="xref" href="validator-customconstraints.html#section-constraint-composition">第 3.2 节 “约束条件组合”</a>) are all combined via a logical <span class="emphasis"><em>AND</em></span>. This means all of the composing constraints need to return <code class="constant">true</code> in order for an overall successful validation. Hibernate Validator offers an extension to this logical <span class="emphasis"><em>AND</em></span> combination which allows you to compose constraints via a logical <span class="emphasis"><em>OR</em></span> or <span class="emphasis"><em>NOT</em></span>. To do so you have to use the <code class="classname">ConstraintComposition</code> annotation and the enum <code class="classname">CompositionType</code> with its values <span class="emphasis"><em>AND</em></span>, <span class="emphasis"><em>OR</em></span> and <span class="emphasis"><em>ALL_FALSE</em></span>. <a class="xref" href="validator-specifics.html#example-boolean-constraint-composition" title="例 8.17. OR composition of constraints">例 8.17 “OR composition of constraints”</a> shows how to build a composing constraint where only one of the constraints has to be successful in order to pass the validation. Either the validated string is all lowercased or it is between two and three characters long.</p><div class="example"><a id="example-boolean-constraint-composition"/><p class="title"><b>例 8.17. OR composition of constraints</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA">@ConstraintComposition(OR)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Pattern</span><span class="java_separator">(</span><span class="java_plain">regexp&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;[a-z]&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Size</span><span class="java_separator">(</span><span class="java_plain">min&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">2</span><span class="java_separator">,</span><span class="java_plain">&nbsp;max&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">3</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">ReportAsSingleViolation</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Target</span><span class="java_separator">({</span><span class="java_plain">&nbsp;METHOD</span><span class="java_separator">,</span><span class="java_plain">&nbsp;FIELD&nbsp;</span><span class="java_separator">})</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Retention</span><span class="java_separator">(</span><span class="java_plain">RUNTIME</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Constraint</span><span class="java_separator">(</span><span class="java_plain">validatedBy&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">})</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;@</span><span class="java_keyword">interface</span><span class="java_plain">&nbsp;</span><span class="java_type">PatternOrSize</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">abstract</span><span class="java_plain">&nbsp;</span><span class="java_type">String</span><span class="java_plain">&nbsp;message</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">default</span><span class="java_plain">&nbsp;</span><span class="java_literal">&quot;{PatternOrSize.message}&quot;</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">abstract</span><span class="java_plain">&nbsp;</span><span class="java_type">Class</span><span class="java_operator">&lt;?&gt;</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;groups</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">default</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">};</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">abstract</span><span class="java_plain">&nbsp;</span><span class="java_type">Class</span><span class="java_operator">&lt;?</span><span class="java_plain">&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">Payload</span><span class="java_operator">&gt;</span><span class="java_separator">[]</span><span class="java_plain">&nbsp;payload</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_keyword">default</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span><span class="java_plain">&nbsp;</span><span class="java_separator">};</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>提示</h2><p>Using <span class="emphasis"><em>ALL_FALSE</em></span> as composition type implicitly enforces that only a single violation will get reported in case validation of the constraint composition fails.</p></div></div></div><HR xmlns=""/><a xmlns="" href=""><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">版权 © 2009 - 2011 Red Hat, Inc. &amp; Gunnar Morling</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="validator-integration.html"><strong>上一页</strong>第 7 章 与其他框架集成</a></li><li class="up"><a accesskey="u" href="#"><strong>上一级</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>起始页</strong></a></li><li class="next"><a accesskey="n" href="validator-annotation-processor.html"><strong>下一页</strong>第 9 章 Annotation Processor</a></li></ul></body></html>