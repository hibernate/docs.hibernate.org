<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Chapter&nbsp;4.&nbsp;Mapping entities to the index structure</title>
      <link rel="stylesheet" href="css/html.css" type="text/css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
      <link rel="start" href="index.html" title="Hibernate Search">
      <link rel="up" href="index.html" title="Hibernate Search">
      <link rel="prev" href="lucene-indexing-performance.html" title="3.8.&nbsp;Tuning Lucene indexing performance">
      <link rel="next" href="search-mapping-bridge.html" title="4.2.&nbsp;Property/Field Bridge">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div class="navheader">
         <table width="100%" summary="Navigation header">
            <tr>
               <th colspan="3" align="center">Chapter&nbsp;4.&nbsp;Mapping entities to the index structure</th>
            </tr>
            <tr>
               <td width="20%" align="left"><a accesskey="p" href="lucene-indexing-performance.html">Prev</a>&nbsp;
               </td>
               <th width="60%" align="center">&nbsp;</th>
               <td width="20%" align="right">&nbsp;<a accesskey="n" href="search-mapping-bridge.html">Next</a></td>
            </tr>
         </table>
         <hr>
      </div>
      <div class="chapter" lang="en-US">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title"><a name="search-mapping"></a>Chapter&nbsp;4.&nbsp;Mapping entities to the index structure
                  </h2>
               </div>
            </div>
         </div>
         <p>All the metadata information needed to index entities is described
              through annotations. There is no need for xml mapping files. In fact there
              is currently no xml configuration option available (see <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://opensource.atlassian.com/projects/hibernate/browse/HSEARCH-210" target="_top">HSEARCH-210</a>).
              You can still use hibernate mapping files for the basic Hibernate
              configuration, but the Search specific configuration has to be expressed via
              annotations.
         </p>
         <div class="section" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="search-mapping-entity"></a>4.1.&nbsp;Mapping an entity
                     </h2>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="basic-mapping"></a>4.1.1.&nbsp;Basic mapping
                        </h3>
                     </div>
                  </div>
               </div>
               <p>First, we must declare a persistent class as indexable. This is
                        done by annotating the class with <code class="literal">@Indexed</code> (all
                        entities not annotated with <code class="literal">@Indexed</code> will be ignored
                        by the indexing process):
               </p>
               <div class="example"><a name="d0e1474"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Making a class indexable using the
                                <code class="classname">@Indexed</code> annotation</b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
<span class="bold"><strong>@Indexed(index="indexes/essays")</strong></span>
public class Essay {
    ...
}</pre></div>
               </div><br class="example-break"><p>The <code class="literal">index</code> attribute tells Hibernate what the
                        Lucene directory name is (usually a directory on your file system). It
                        is recommended to define a base directory for all Lucene indexes using
                        the <code class="literal">hibernate.search.default.indexBase</code> property in
                        your configuration file. Alternatively you can specify a base directory
                        per indexed entity by specifying
                        <code class="literal">hibernate.search.&lt;index&gt;.indexBase, </code>where
                        <code class="literal">&lt;index&gt;</code> is the fully qualified classname of the
                        indexed entity. Each entity instance will be represented by a Lucene
                        <code class="classname">Document</code> inside the given index (aka
                        Directory).
               </p>
               <p>For each property (or attribute) of your entity, you have the
                        ability to describe how it will be indexed. The default (no annotation
                        present) means that the property is completely ignored by the indexing
                        process. <code class="literal">@Field</code> does declare a property as indexed.
                        When indexing an element to a Lucene document you can specify how it is
                        indexed:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p><code class="literal">name</code> : describe under which name, the
                                     property should be stored in the Lucene Document. The default value
                                     is the property name (following the JavaBeans convention)
                        </p>
                     </li>
                     <li>
                        <p><code class="literal">store</code> : describe whether or not the
                                     property is stored in the Lucene index. You can store the value
                                     <code class="literal">Store.YES</code> (consuming more space in the index but
                                     allowing projection, see <a href="search-query.html#projections" title="5.1.2.5.&nbsp;Projection">Section&nbsp;5.1.2.5, &#8220;Projection&#8221;</a> for more
                                     information), store it in a compressed way
                                     <code class="literal">Store.COMPRESS</code> (this does consume more CPU), or
                                     avoid any storage <code class="literal">Store.NO</code> (this is the default
                                     value). When a property is stored, you can retrieve its original
                                     value from the Lucene Document. This is not related to whether the
                                     element is indexed or not.
                        </p>
                     </li>
                     <li>
                        <p>index: describe how the element is indexed and the type of
                                     information store. The different values are
                                     <code class="literal">Index.NO</code> (no indexing, ie cannot be found by a
                                     query), <code class="literal">Index.TOKENIZED</code> (use an analyzer to
                                     process the property), <code class="literal">Index.UN_TOKENIZED</code> (no
                                     analyzer pre-processing), <code class="literal">Index.NO_NORMS</code> (do not
                                     store the normalization data). The default value is
                                     <code class="literal">TOKENIZED</code>.
                        </p>
                     </li>
                     <li>
                        <p>termVector: describes collections of term-frequency pairs.
                                     This attribute enables term vectors being stored during indexing so
                                     they are available within documents. The default value is
                                     TermVector.NO.
                        </p>
                        <p>The different values of this attribute are:</p>
                        <div class="informaltable">
                           <table border="1">
                              <colgroup>
                                 <col>
                                 <col>
                              </colgroup>
                              <thead>
                                 <tr>
                                    <th align="center">Value</th>
                                    <th align="center">Definition</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr>
                                    <td align="left">TermVector.YES</td>
                                    <td align="left">Store the term vectors of each document. This
                                                         produces two synchronized arrays, one contains document
                                                         terms and the other contains the term's frequency.
                                    </td>
                                 </tr>
                                 <tr>
                                    <td align="left">TermVector.NO</td>
                                    <td align="left">Do not store term vectors.</td>
                                 </tr>
                                 <tr>
                                    <td align="left">TermVector.WITH_OFFSETS</td>
                                    <td align="left">Store the term vector and token offset information.
                                                         This is the same as TermVector.YES plus it contains the
                                                         starting and ending offset position information for the
                                                         terms.
                                    </td>
                                 </tr>
                                 <tr>
                                    <td align="left">TermVector.WITH_POSITIONS</td>
                                    <td align="left">Store the term vector and token position information.
                                                         This is the same as TermVector.YES plus it contains the
                                                         ordinal positions of each occurrence of a term in a
                                                         document.
                                    </td>
                                 </tr>
                                 <tr>
                                    <td align="left">TermVector.WITH_POSITION_OFFSETS</td>
                                    <td align="left">Store the term vector, token position and offset
                                                         information. This is a combination of the YES, WITH_OFFSETS
                                                         and WITH_POSITIONS.
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </li>
                  </ul>
               </div>
               <p>Whether or not you want to store the original data in the index
                        depends on how you wish to use the index query result. For a regular
                        Hibernate Search usage storing is not necessary. However you might want
                        to store some fields to subsequently project them (see <a href="search-query.html#projections" title="5.1.2.5.&nbsp;Projection">Section&nbsp;5.1.2.5, &#8220;Projection&#8221;</a> for more information).
               </p>
               <p>Whether or not you want to tokenize a property depends on whether
                        you wish to search the element as is, or by the words it contains. It
                        make sense to tokenize a text field, but tokenizing a date field
                        probably not. Note that fields used for sorting must not be
                        tokenized.
               </p>
               <p>Finally, the id property of an entity is a special property used
                        by Hibernate Search to ensure index unicity of a given entity. By
                        design, an id has to be stored and must not be tokenized. To mark a
                        property as index id, use the <code class="literal">@DocumentId</code> annotation.
                        If you are using Hibernate Annotations and you have specified @Id you
                        can omit @DocumentId. The chosen entity id will also be used as document
                        id.
               </p>
               <div class="example"><a name="d0e1597"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Adding <code class="classname">@DocumentId</code> ad
                                <code class="classname">@Field</code> annotations to an indexed entity</b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
public class Essay {
    ...

    @Id
    <span class="bold"><strong>@DocumentId</strong></span>
    public Long getId() { return id; }

    <span class="bold"><strong>@Field(name="Abstract", index=Index.TOKENIZED, store=Store.YES)</strong></span>
    public String getSummary() { return summary; }

    @Lob
    <span class="bold"><strong>@Field(index=Index.TOKENIZED)</strong></span>
    public String getText() { return text; }
}</pre></div>
               </div><br class="example-break"><p>The above annotations define an index with three fields:
                        <code class="literal">id</code> , <code class="literal">Abstract</code> and
                        <code class="literal">text</code> . Note that by default the field name is
                        decapitalized, following the JavaBean specification
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="d0e1628"></a>4.1.2.&nbsp;Mapping properties multiple times
                        </h3>
                     </div>
                  </div>
               </div>
               <p>Sometimes one has to map a property multiple times per index, with
                        slightly different indexing strategies. For example, sorting a query by
                        field requires the field to be <code class="literal">UN_TOKENIZED</code>. If one
                        wants to search by words in this property and still sort it, one need to
                        index it twice - once tokenized and once untokenized. @Fields allows to
                        achieve this goal.
               </p>
               <div class="example"><a name="d0e1636"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Using @Fields to map a property multiple times</b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index = "Book" )
public class Book {
    <span class="bold"><strong>@Fields( {</strong></span>
            @Field(index = Index.TOKENIZED),
            @Field(name = "summary_forSort", index = Index.UN_TOKENIZED, store = Store.YES)
            <span class="bold"><strong>} )</strong></span>
    public String getSummary() {
        return summary;
    }

    ...
}</pre></div>
               </div><br class="example-break"><p>The field <code class="literal">summary</code> is indexed twice, once as
                        <code class="literal">summary</code> in a tokenized way, and once as
                        <code class="literal">summary_forSort</code> in an untokenized way. @Field
                        supports 2 attributes useful when @Fields is used:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>analyzer: defines a @Analyzer annotation per field rather than
                                     per property
                        </p>
                     </li>
                     <li>
                        <p>bridge: defines a @FieldBridge annotation per field rather
                                     than per property
                        </p>
                     </li>
                  </ul>
               </div>
               <p>See below for more information about analyzers and field
                        bridges.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="search-mapping-associated"></a>4.1.3.&nbsp;Embedded and associated objects
                        </h3>
                     </div>
                  </div>
               </div>
               <p>Associated objects as well as embedded objects can be indexed as
                        part of the root entity index. This is useful if you expect to search a
                        given entity based on properties of associated objects. In the following
                        example the aim is to return places where the associated city is Atlanta
                        (In the Lucene query parser language, it would translate into
                        <code class="code">address.city:Atlanta</code>).
               </p>
               <div class="example"><a name="d0e1675"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Using @IndexedEmbedded to index associations</b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field( index = Index.TOKENIZED )
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <span class="bold"><strong>@IndexedEmbedded</strong></span>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field(index=Index.TOKENIZED)
    private String street;

    @Field(index=Index.TOKENIZED)
    private String city;

    <span class="bold"><strong>@ContainedIn</strong></span>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</pre></div>
               </div><br class="example-break"><p>In this example, the place fields will be indexed in the
                        <code class="literal">Place</code> index. The <code class="literal">Place</code> index
                        documents will also contain the fields <code class="literal">address.id</code>,
                        <code class="literal">address.street</code>, and <code class="literal">address.city</code>
                        which you will be able to query. This is enabled by the
                        <code class="literal">@IndexedEmbedded</code> annotation.
               </p>
               <p>Be careful. Because the data is denormalized in the Lucene index
                        when using the <code class="classname">@IndexedEmbedded</code> technique,
                        Hibernate Search needs to be aware of any change in the
                        <code class="classname">Place</code> object and any change in the
                        <code class="classname">Address</code> object to keep the index up to date. To
                        make sure the <code class="literal"><code class="classname">Place</code></code> Lucene
                        document is updated when it's <code class="classname">Address</code> changes,
                        you need to mark the other side of the bidirectional relationship with
                        <code class="classname">@ContainedIn</code>.
               </p>
               <p><code class="literal">@ContainedIn</code> is only useful on associations
                        pointing to entities as opposed to embedded (collection of)
                        objects.
               </p>
               <p>Let's make our example a bit more complex:</p>
               <div class="example"><a name="d0e1733"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;Nested usage of <code class="classname">@IndexedEmbedded</code> and
                                <code class="classname">@ContainedIn</code></b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field( index = Index.TOKENIZED )
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <span class="bold"><strong>@IndexedEmbedded</strong></span>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field(index=Index.TOKENIZED)
    private String street;

    @Field(index=Index.TOKENIZED)
    private String city;

    <span class="bold"><strong>@IndexedEmbedded(depth = 1, prefix = "ownedBy_")</strong></span>
    private Owner ownedBy;

    <span class="bold"><strong>@ContainedIn</strong></span>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}

@Embeddable
public class Owner {
    @Field(index = Index.TOKENIZED)
    private String name;
   ...
}</pre></div>
               </div><br class="example-break"><p>Any <code class="literal">@*ToMany, @*ToOne</code> and
                        <code class="literal">@Embedded</code> attribute can be annotated with
                        <code class="literal">@IndexedEmbedded</code>. The attributes of the associated
                        class will then be added to the main entity index. In the previous
                        example, the index will contain the following fields
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>id</p>
                     </li>
                     <li>
                        <p>name</p>
                     </li>
                     <li>
                        <p>address.street</p>
                     </li>
                     <li>
                        <p>address.city</p>
                     </li>
                     <li>
                        <p>address.ownedBy_name</p>
                     </li>
                  </ul>
               </div>
               <p>The default prefix is <code class="literal">propertyName.</code>, following
                        the traditional object navigation convention. You can override it using
                        the <code class="literal">prefix</code> attribute as it is shown on the
                        <code class="literal">ownedBy</code> property.
               </p>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p>The prefix cannot be set to the empty string.</p>
               </div>
               <p>The<code class="literal"> depth</code> property is necessary when the object
                        graph contains a cyclic dependency of classes (not instances). For
                        example, if <code class="classname">Owner</code> points to
                        <code class="classname">Place</code>. Hibernate Search will stop including
                        Indexed embedded attributes after reaching the expected depth (or the
                        object graph boundaries are reached). A class having a self reference is
                        an example of cyclic dependency. In our example, because
                        <code class="literal">depth</code> is set to 1, any
                        <code class="literal">@IndexedEmbedded</code> attribute in Owner (if any) will be
                        ignored.
               </p>
               <p>Using <code class="literal">@IndexedEmbedded</code> for object associations
                        allows you to express queries such as:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>Return places where name contains JBoss and where address city
                                     is Atlanta. In Lucene query this would be
                        </p><pre class="programlisting">+name:jboss +address.city:atlanta  </pre></li>
                     <li>
                        <p>Return places where name contains JBoss and where owner's name
                                     contain Joe. In Lucene query this would be
                        </p><pre class="programlisting">+name:jboss +address.orderBy_name:joe  </pre></li>
                  </ul>
               </div>
               <p>In a way it mimics the relational join operation in a more
                        efficient way (at the cost of data duplication). Remember that, out of
                        the box, Lucene indexes have no notion of association, the join
                        operation is simply non-existent. It might help to keep the relational
                        model normalized while benefiting from the full text index speed and
                        feature richness.
               </p>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p>An associated object can itself (but does not have to) be
                               <code class="literal">@Indexed</code></p>
               </div>
               <p>When @IndexedEmbedded points to an entity, the association has to
                        be directional and the other side has to be annotated
                        <code class="literal">@ContainedIn</code> (as seen in the previous example). If
                        not, Hibernate Search has no way to update the root index when the
                        associated entity is updated (in our example, a <code class="literal">Place</code>
                        index document has to be updated when the associated
                        <code class="classname">Address</code> instance is updated).
               </p>
               <p>Sometimes, the object type annotated by
                        <code class="classname">@IndexedEmbedded</code> is not the object type targeted
                        by Hibernate and Hibernate Search. This is especially the case when
                        interfaces are used in lieu of their implementation. For this reason you
                        can override the object type targeted by Hibernate Search using the
                        <code class="methodname">targetElement</code> parameter.
               </p>
               <div class="example"><a name="d0e1853"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;Using the <code class="literal">targetElement</code> property of
                                <code class="classname">@IndexedEmbedded</code></b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field(index= Index.TOKENIZED)
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", <span class="bold"><strong>targetElement = Owner.class</strong></span>)
    @Target(Owner.class)
    private Person ownedBy;


    ...
}

@Embeddable
public class Owner implements Person { ... }</pre></div>
               </div><br class="example-break"></div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="d0e1866"></a>4.1.4.&nbsp;Boost factor
                        </h3>
                     </div>
                  </div>
               </div>
               <p>Lucene has the notion of <span class="emphasis"><em>boost factor</em></span>. It's a
                        way to give more weight to a field or to an indexed element over others
                        during the indexation process. You can use <code class="literal">@Boost</code> at
                        the @Field, method or class level.
               </p>
               <div class="example"><a name="d0e1877"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;Using different ways of increasing the weight of an indexed
                                element using a boost factor</b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
<span class="bold"><strong>@Boost(1.7f)</strong></span>
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", index=Index.TOKENIZED, store=Store.YES, boost=<span class="bold"><strong>@Boost(2f)</strong></span>)
    <span class="bold"><strong>@Boost(1.5f)</strong></span>
    public String getSummary() { return summary; }

    @Lob
    @Field(index=Index.TOKENIZED, boost=<span class="bold"><strong>@Boost(1.2f)</strong></span>)
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }

}        </pre></div>
               </div><br class="example-break"><p>In our example, <code class="classname">Essay</code>'s probability to
                        reach the top of the search list will be multiplied by 1.7. The
                        <code class="methodname">summary</code> field will be 3.0 (2 * 1.5 -
                        <code class="methodname">@Field.boost</code> and <code class="classname">@Boost</code>
                        on a property are cumulative) more important than the
                        <code class="methodname">isbn</code> field. The <code class="methodname">text</code>
                        field will be 1.2 times more important than the
                        <code class="methodname">isbn</code> field. Note that this explanation in
                        strictest terms is actually wrong, but it is simple and close enough to
                        reality for all practical purposes. Please check the Lucene
                        documentation or the excellent <em class="citetitle">Lucene In Action </em>
                        from Otis Gospodnetic and Erik Hatcher.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="analyzer"></a>4.1.5.&nbsp;Analyzer
                        </h3>
                     </div>
                  </div>
               </div>
               <p>The default analyzer class used to index tokenized fields is
                        configurable through the <code class="literal">hibernate.search.analyzer</code>
                        property. The default value for this property is
                        <code class="classname">org.apache.lucene.analysis.standard.StandardAnalyzer</code>.
               </p>
               <p>You can also define the analyzer class per entity, property and
                        even per @Field (useful when multiple fields are indexed from a single
                        property).
               </p>
               <div class="example"><a name="d0e1933"></a><p class="title"><b>Example&nbsp;4.8.&nbsp;Different ways of specifying an analyzer</b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
<span class="bold"><strong>@Analyzer(impl = EntityAnalyzer.class)</strong></span>
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field(index = Index.TOKENIZED)
    private String name;

    @Field(index = Index.TOKENIZED)
    <span class="bold"><strong>@Analyzer(impl = PropertyAnalyzer.class)</strong></span>
    private String summary;

    @Field(index = Index.TOKENIZED, <span class="emphasis"><em><span class="bold"><strong>analyzer = @Analyzer(impl = FieldAnalyzer.class</strong></span>)</em></span>
    private String body;

    ...
}</pre></div>
               </div><br class="example-break"><p>In this example, <code class="classname">EntityAnalyzer</code> is used to
                        index all tokenized properties (eg. <code class="literal">name</code>), except
                        <code class="literal">summary</code> and <code class="literal">body</code> which are indexed
                        with <code class="classname">PropertyAnalyzer</code> and
                        <code class="classname">FieldAnalyzer</code> respectively.
               </p>
               <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Caution</h3>
                  <p>Mixing different analyzers in the same entity is most of the
                             time a bad practice. It makes query building more complex and results
                             less predictable (for the novice), especially if you are using a
                             QueryParser (which uses the same analyzer for the whole query). As a
                             rule of thumb, for any given field the same analyzer should be used
                             for indexing and querying.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="d0e1972"></a>4.1.5.1.&nbsp;Analyzer definitions
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p>Analyzers can become quite complex to deal with for which reason
                             Hibernate Search introduces the notion of analyzer definitions. An
                             analyzer definition can be reused by many
                             <code class="classname">@Analyzer</code> declarations. An analyzer definition
                             is composed of:
                  </p>
                  <div class="itemizedlist">
                     <ul type="disc">
                        <li>
                           <p>a name: the unique string used to refer to the
                                          definition
                           </p>
                        </li>
                        <li>
                           <p>a tokenizer: responsible for tokenizing the input stream
                                          into individual words
                           </p>
                        </li>
                        <li>
                           <p>a list of filters: each filter is responsible to remove,
                                          modify or sometimes even add words into the stream provided by the
                                          tokenizer
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p>This separation of tasks - a tokenizer followed by a list of
                             filters - allows for easy reuse of each individual component and let
                             you build your customized analyzer in a very flexible way (just like
                             Lego). Generally speaking the <code class="classname">Tokenizer</code> starts
                             the analysis process by turning the character input into tokens which
                             are then further processed by the <code class="classname">TokenFilter</code>s.
                             Hibernate Search supports this infrastructure by utilizing the Solr
                             analyzer framework. Make sure to add<code class="filename"> solr-core.jar and
                                </code><code class="filename">solr-common.jar</code> to your classpath to
                             use analyzer definitions. In case you also want to utilizing a
                             snowball stemmer also include the
                             <code class="filename">lucene-snowball.jar.</code> Other Solr analyzers might
                             depend on more libraries. For example, the
                             <code class="classname">PhoneticFilterFactory</code> depends on <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://commons.apache.org/codec" target="_top">commons-codec</a>. Your
                             distribution of Hibernate Search provides these dependencies in its
                             <code class="filename">lib</code> directory.
                  </p>
                  <div class="example"><a name="d0e2015"></a><p class="title"><b>Example&nbsp;4.9.&nbsp;<code class="classname">@AnalyzerDef</code> and the Solr
                                     framework</b></p>
                     <div class="example-contents"><pre class="programlisting">@AnalyzerDef(name="customanalyzer",
        tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
        filters = {
                @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
                @TokenFilterDef(factory = LowerCaseFilterFactory.class),
                @TokenFilterDef(factory = StopFilterFactory.class, params = {
                    @Parameter(name="words", value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
                    @Parameter(name="ignoreCase", value="true")
                })
})
public class Team {
    ...
}</pre></div>
                  </div><br class="example-break"><p>A tokenizer is defined by its factory which is responsible for
                             building the tokenizer and using the optional list of parameters. This
                             example use the standard tokenizer. A filter is defined by its factory
                             which is responsible for creating the filter instance using the
                             optional parameters. In our example, the StopFilter filter is built
                             reading the dedicated words property file and is expected to ignore
                             case. The list of parameters is dependent on the tokenizer or filter
                             factory.
                  </p>
                  <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Warning</h3>
                     <p>Filters are applied in the order they are defined in the
                                  <code class="classname">@AnalyzerDef</code> annotation. Make sure to think
                                  twice about this order.
                     </p>
                  </div>
                  <p>Once defined, an analyzer definition can be reused by an
                             <code class="classname">@Analyzer</code> declaration using the definition name
                             rather than declaring an implementation class.
                  </p>
                  <div class="example"><a name="d0e2035"></a><p class="title"><b>Example&nbsp;4.10.&nbsp;Referencing an analyzer by name</b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field <span class="bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
    private String description;
}</pre></div>
                  </div><br class="example-break"><p>Analyzer instances declared by
                             <code class="classname">@AnalyzerDef</code> are available by their name in the
                             <code class="classname">SearchFactory</code>.
                  </p><pre class="programlisting">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</pre><p>This is quite useful wen building queries. Fields in queries
                             should be analyzed with the same analyzer used to index the field so
                             that they speak a common "language": the same tokens are reused
                             between the query and the indexing process. This rule has some
                             exceptions but is true most of the time. Respect it unless you know
                             what you are doing.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="d0e2055"></a>4.1.5.2.&nbsp;Available analyzers
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p>Solr and Lucene come with a lot of useful default tokenizers and
                             filters. You can find a complete list of tokenizer factories and
                             filter factories at <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters" target="_top">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</a>.
                             Let check a few of them.
                  </p>
                  <div class="table"><a name="d0e2063"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Some of the available tokenizers</b></p>
                     <div class="table-contents">
                        <table summary="Some of the available tokenizers" border="1">
                           <colgroup>
                              <col>
                              <col>
                              <col>
                           </colgroup>
                           <thead>
                              <tr>
                                 <th align="center">Factory</th>
                                 <th align="center">Description</th>
                                 <th align="center">parameters</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td>StandardTokenizerFactory</td>
                                 <td>Use the Lucene StandardTokenizer</td>
                                 <td>none</td>
                              </tr>
                              <tr>
                                 <td>HTMLStripStandardTokenizerFactory</td>
                                 <td>Remove HTML tags, keep the text and pass it to a
                                                    StandardTokenizer
                                 </td>
                                 <td>none</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </div><br class="table-break"><div class="table"><a name="d0e2090"></a><p class="title"><b>Table&nbsp;4.2.&nbsp;Some of the available filters</b></p>
                     <div class="table-contents">
                        <table summary="Some of the available filters" border="1">
                           <colgroup>
                              <col>
                              <col>
                              <col>
                           </colgroup>
                           <thead>
                              <tr>
                                 <th align="center">Factory</th>
                                 <th align="center">Description</th>
                                 <th align="center">parameters</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td>StandardFilterFactory</td>
                                 <td>Remove dots from acronyms and 's from words</td>
                                 <td>none</td>
                              </tr>
                              <tr>
                                 <td>LowerCaseFilterFactory</td>
                                 <td>Lowercase words</td>
                                 <td>none</td>
                              </tr>
                              <tr>
                                 <td>StopFilterFactory</td>
                                 <td>remove words (tokens) matching a list of stop
                                                    words
                                 </td>
                                 <td>
                                    <p><code class="literal">words</code>: points to a resource
                                                       file containing the stop words
                                    </p>
                                    <p>ignoreCase: true if
                                                       <code class="literal">case</code> should be ignore when comparing stop
                                                       words, <code class="literal">false</code> otherwise 
                                    </p>
                                 </td>
                              </tr>
                              <tr>
                                 <td>SnowballPorterFilterFactory</td>
                                 <td>Reduces a word to it's root in a given language. (eg.
                                                    protect, protects, protection share the same root). Using such
                                                    a filter allows searches matching related words.
                                 </td>
                                 <td>
                                    <p><code class="literal">language</code>: Danish, Dutch,
                                                       English, Finnish, French, German, Italian, Norwegian,
                                                       Portuguese, Russian, Spanish, Swedish
                                    </p>and a few
                                                    more
                                 </td>
                              </tr>
                              <tr>
                                 <td>ISOLatin1AccentFilterFactory</td>
                                 <td>remove accents for languages like French</td>
                                 <td>none</td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </div><br class="table-break"><p>We recommend to check all the implementations of
                             <code class="classname">org.apache.solr.analysis.TokenizerFactory</code> and
                             <code class="classname">org.apache.solr.analysis.TokenFilterFactory</code> in
                             your IDE to see the implementations available.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="d0e2161"></a>4.1.5.3.&nbsp;Analyzer discriminator (experimental)
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p>So far all the introduced ways to specify an analyzer were
                             static. However, there are use cases where it is useful to select an
                             analyzer depending on the current state of the entity to be indexed,
                             for example in multilingual application. For an
                             <code class="classname">BlogEntry</code> class for example the analyzer could
                             depend on the language property of the entry. Depending on this
                             property the correct language specific stemmer should be chosen to
                             index the actual text.
                  </p>
                  <p>To enable this dynamic analyzer selection Hibernate Search
                             introduces the <code class="classname">AnalyzerDiscriminator</code>
                             annotation. The following example demonstrates the usage of this
                             annotation:
                  </p>
                  <div class="example"><a name="d0e2175"></a><p class="title"><b>Example&nbsp;4.11.&nbsp;Usage of @AnalyzerDiscriminator in order to select an
                                       analyzer depending on the entity state</b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class
      )
    }),
  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
    })
})
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;
    
    @Field
    private String text;
    
    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    ...
}</pre><pre class="programlisting">public class LanguageDiscriminator implements Discriminator {

    public String getAnanyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof Article ) ) {
            return null;
        }
        return (String) value;
    }
}</pre></div>
                  </div>
                  <p><br class="example-break">The prerequisite for using
                             <code class="classname">@AnalyzerDiscriminator</code> is that all analyzers
                             which are going to be used are predefined via
                             <code class="classname">@AnalyzerDef</code> definitions. If this is the case
                             one can place the <code class="classname">@AnalyzerDiscriminator</code>
                             annotation either on the class or on a specific property of the entity
                             for which to dynamically select an analyzer. Via the
                             <code class="literal">impl</code> parameter of the
                             <code class="classname">AnalyzerDiscriminator</code> you specify a concrete
                             implementation of the <code class="classname">Discriminator</code> interface.
                             It is up to you to provide an implementation for this interface. The
                             only method you have to implement is
                             <code class="classname">getAnanyzerDefinitionName()</code> which gets called
                             for each field added to the Lucene document. The entity which is
                             getting indexed is also passed to the interface method. The
                             <code class="literal">value</code> parameter is only set if the
                             <code class="classname">AnalyzerDiscriminator</code> is placed on property
                             level instead of class level. In this case the value represents the
                             current value of this property.
                  </p>
                  <p>An implemention of the <code class="classname">Discriminator</code>
                             interface has to return the name of an existing analyzer definition if
                             the analyzer should be set dynamically or <code class="classname">null</code>
                             if the default analyzer should not be overridden. The given example
                             assumes that the language parameter is either 'de' or 'en' which
                             matches the specified names in the
                             <code class="classname">@AnalyzerDef</code>s.
                  </p>
                  <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Note</h3>
                     <p>The <code class="classname">@AnalyzerDiscriminator</code> is currently
                                  still experimental and the API might still change. We are hoping for
                                  some feedback from the community about the usefulness and usability
                                  of this feature.
                     </p>
                  </div>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h4 class="title"><a name="analyzer-retrievinganalyzer"></a>4.1.5.4.&nbsp;Retrieving an analyzer
                           </h4>
                        </div>
                     </div>
                  </div>
                  <p>During indexing time, Hibernate Search is using analyzers under
                             the hood for you. In some situations, retrieving analyzers can be
                             handy. If your domain model makes use of multiple analyzers (maybe to
                             benefit from stemming, use phonetic approximation and so on), you need
                             to make sure to use the same analyzers when you build your
                             query.
                  </p>
                  <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Note</h3>
                     <p>This rule can be broken but you need a good reason for it. If
                                  you are unsure, use the same analyzers.
                     </p>
                  </div>
                  <p>You can retrieve the scoped analyzer for a given entity used at
                             indexing time by Hibernate Search. A scoped analyzer is an analyzer
                             which applies the right analyzers depending on the field indexed:
                             multiple analyzers can be defined on a given entity each one working
                             on an individual field, a scoped analyzer unify all these analyzers
                             into a context-aware analyzer. While the theory seems a bit complex,
                             using the right analyzer in a query is very easy.
                  </p>
                  <div class="example"><a name="d0e2237"></a><p class="title"><b>Example&nbsp;4.12.&nbsp;Using the scoped analyzer when building a full-text
                                     query</b></p>
                     <div class="example-contents"><pre class="programlisting">org.apache.lucene.queryParser.QueryParser parser = new QueryParser(
    "title", 
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery = 
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects    </pre></div>
                  </div><br class="example-break"><p>In the example above, the song title is indexed in two fields:
                             the standard analyzer is used in the field <code class="literal">title</code>
                             and a stemming analyzer is used in the field
                             <code class="literal">title_stemmed</code>. By using the analyzer provided by
                             the search factory, the query uses the appropriate analyzer depending
                             on the field targeted.
                  </p>
                  <p>If your query targets more that one query and you wish to use
                             your standard analyzer, make sure to describe it using an analyzer
                             definition. You can retrieve analyzers by their definition name using
                             <code class="code">searchFactory.getAnalyzer(String)</code>.
                  </p>
               </div>
            </div>
         </div>
      </div>
      <div class="navfooter">
         <hr>
         <table width="100%" summary="Navigation footer">
            <tr>
               <td width="40%" align="left"><a accesskey="p" href="lucene-indexing-performance.html">Prev</a>&nbsp;
               </td>
               <td width="20%" align="center">&nbsp;</td>
               <td width="40%" align="right">&nbsp;<a accesskey="n" href="search-mapping-bridge.html">Next</a></td>
            </tr>
            <tr>
               <td width="40%" align="left" valign="top">3.8.&nbsp;Tuning Lucene indexing performance&nbsp;</td>
               <td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
               <td width="40%" align="right" valign="top">&nbsp;4.2.&nbsp;Property/Field Bridge</td>
            </tr>
         </table>
      </div>
   <!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("search"); });</script><!-- /HibernateDoc.OutdatedContent --></body>
</html>