<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   
      <title>Hibernate Search</title>
      <link rel="stylesheet" href="css/html.css" type="text/css">
      <meta name="generator" content="DocBook XSL Stylesheets V1.72.0">
   </head>
   <body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
      <div class="book" lang="en-US">
         <div class="titlepage">
            <div>
               <div>
                  <h1 class="title"><a name="d0e3"></a>Hibernate Search
                  </h1>
               </div>
               <div>
                  <h2 class="subtitle">Apache <span class="trademark">Lucene</span>&#8482; Integration
                  </h2>
               </div>
               <div>
                  <h2 class="subtitle">Reference Guide</h2>
               </div>
               <div>
                  <p class="releaseinfo">3.1.1.GA</p>
               </div>
            </div>
            <hr>
         </div>
         <div class="toc">
            <dl>
               <dt><span class="preface"><a href="#preface">Preface</a></span></dt>
               <dt><span class="chapter"><a href="#getting-started">1.  Getting started</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#d0e45">1.1.  System Requirements</a></span></dt>
                     <dt><span class="section"><a href="#d0e113">1.2.  Using Maven</a></span></dt>
                     <dt><span class="section"><a href="#d0e158">1.3.  Configuration</a></span></dt>
                     <dt><span class="section"><a href="#d0e365">1.4.  Indexing</a></span></dt>
                     <dt><span class="section"><a href="#d0e396">1.5.  Searching</a></span></dt>
                     <dt><span class="section"><a href="#d0e414">1.6.  Analyzer</a></span></dt>
                     <dt><span class="section"><a href="#d0e496">1.7.  What's next</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="chapter"><a href="#search-architecture">2.  Architecture</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#d0e528">2.1.  Overview</a></span></dt>
                     <dt><span class="section"><a href="#d0e576">2.2.  Back end</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="#d0e581">2.2.1.  Back end types</a></span></dt>
                           <dd>
                              <dl>
                                 <dt><span class="section"><a href="#d0e584">2.2.1.1.  Lucene</a></span></dt>
                                 <dt><span class="section"><a href="#d0e601">2.2.1.2.  JMS</a></span></dt>
                              </dl>
                           </dd>
                           <dt><span class="section"><a href="#d0e621">2.2.2.  Work execution</a></span></dt>
                           <dd>
                              <dl>
                                 <dt><span class="section"><a href="#d0e626">2.2.2.1.  Synchronous</a></span></dt>
                                 <dt><span class="section"><a href="#d0e631">2.2.2.2.  Asynchronous</a></span></dt>
                              </dl>
                           </dd>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="#search-architecture-readerstrategy">2.3.  Reader strategy</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="#d0e644">2.3.1.  Shared</a></span></dt>
                           <dt><span class="section"><a href="#d0e669">2.3.2.  Not-shared</a></span></dt>
                           <dt><span class="section"><a href="#d0e685">2.3.3.  Custom</a></span></dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt><span class="chapter"><a href="#search-configuration">3.  Configuration</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#search-configuration-directory">3.1.  Directory configuration</a></span></dt>
                     <dt><span class="section"><a href="#search-configuration-directory-sharding">3.2.  Sharding indexes</a></span></dt>
                     <dt><span class="section"><a href="#d0e979">3.3.  Sharing indexes (two entities into the same directory)</a></span></dt>
                     <dt><span class="section"><a href="#d0e1034">3.4.  Worker configuration</a></span></dt>
                     <dt><span class="section"><a href="#jms-backend">3.5.  JMS Master/Slave configuration</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="#d0e1124">3.5.1.  Slave nodes</a></span></dt>
                           <dt><span class="section"><a href="#d0e1138">3.5.2.  Master node</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="#configuration-reader-strategy">3.6.  Reader strategy configuration</a></span></dt>
                     <dt><span class="section"><a href="#search-configuration-event">3.7.  Enabling Hibernate Search and automatic indexing</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="#d0e1210">3.7.1.  Enabling Hibernate Search</a></span></dt>
                           <dt><span class="section"><a href="#d0e1233">3.7.2.  Automatic indexing</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="#lucene-indexing-performance">3.8.  Tuning Lucene indexing performance</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="chapter"><a href="#search-mapping">4.  Mapping entities to the index structure</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#search-mapping-entity">4.1.  Mapping an entity</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="#basic-mapping">4.1.1.  Basic mapping</a></span></dt>
                           <dt><span class="section"><a href="#d0e1628">4.1.2.  Mapping properties multiple times</a></span></dt>
                           <dt><span class="section"><a href="#search-mapping-associated">4.1.3.  Embedded and associated objects</a></span></dt>
                           <dt><span class="section"><a href="#d0e1866">4.1.4.  Boost factor</a></span></dt>
                           <dt><span class="section"><a href="#analyzer">4.1.5.  Analyzer</a></span></dt>
                           <dd>
                              <dl>
                                 <dt><span class="section"><a href="#d0e1972">4.1.5.1.  Analyzer definitions</a></span></dt>
                                 <dt><span class="section"><a href="#d0e2055">4.1.5.2.  Available analyzers</a></span></dt>
                                 <dt><span class="section"><a href="#d0e2161">4.1.5.3.  Analyzer discriminator (experimental)</a></span></dt>
                                 <dt><span class="section"><a href="#analyzer-retrievinganalyzer">4.1.5.4.  Retrieving an analyzer</a></span></dt>
                              </dl>
                           </dd>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="#search-mapping-bridge">4.2.  Property/Field Bridge</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="#d0e2263">4.2.1.  Built-in bridges</a></span></dt>
                           <dt><span class="section"><a href="#d0e2334">4.2.2.  Custom Bridge</a></span></dt>
                           <dd>
                              <dl>
                                 <dt><span class="section"><a href="#d0e2339">4.2.2.1.  StringBridge</a></span></dt>
                                 <dt><span class="section"><a href="#d0e2439">4.2.2.2.  FieldBridge</a></span></dt>
                                 <dt><span class="section"><a href="#d0e2466">4.2.2.3.  ClassBridge</a></span></dt>
                              </dl>
                           </dd>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="#provided-id">4.3.  Providing your own id</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="#ProvidedId">4.3.1.  The ProvidedId annotation</a></span></dt>
                        </dl>
                     </dd>
                  </dl>
               </dd>
               <dt><span class="chapter"><a href="#search-query">5.  Querying</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#d0e2612">5.1.  Building queries</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="#d0e2620">5.1.1.  Building a Lucene query</a></span></dt>
                           <dt><span class="section"><a href="#d0e2625">5.1.2.  Building a Hibernate Search query</a></span></dt>
                           <dd>
                              <dl>
                                 <dt><span class="section"><a href="#d0e2628">5.1.2.1.  Generality</a></span></dt>
                                 <dt><span class="section"><a href="#d0e2668">5.1.2.2.  Pagination</a></span></dt>
                                 <dt><span class="section"><a href="#d0e2685">5.1.2.3.  Sorting</a></span></dt>
                                 <dt><span class="section"><a href="#d0e2709">5.1.2.4.  Fetching strategy</a></span></dt>
                                 <dt><span class="section"><a href="#projections">5.1.2.5.  Projection</a></span></dt>
                              </dl>
                           </dd>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="#d0e2812">5.2.  Retrieving the results</a></span></dt>
                     <dd>
                        <dl>
                           <dt><span class="section"><a href="#d0e2829">5.2.1.  Performance considerations</a></span></dt>
                           <dt><span class="section"><a href="#d0e2874">5.2.2.  Result size</a></span></dt>
                           <dt><span class="section"><a href="#d0e2905">5.2.3.  ResultTransformer</a></span></dt>
                           <dt><span class="section"><a href="#d0e2926">5.2.4.  Understanding results</a></span></dt>
                        </dl>
                     </dd>
                     <dt><span class="section"><a href="#d0e2970">5.3.  Filters</a></span></dt>
                     <dt><span class="section"><a href="#d0e3232">5.4.  Optimizing the query process</a></span></dt>
                     <dt><span class="section"><a href="#d0e3249">5.5.  Native Lucene Queries</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="chapter"><a href="#search-batchindex">6.  Manual indexing</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#search-batchindex-indexing">6.1.  Indexing</a></span></dt>
                     <dt><span class="section"><a href="#d0e3330">6.2.  Purging</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="chapter"><a href="#search-optimize">7.  Index Optimization</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#d0e3394">7.1.  Automatic optimization</a></span></dt>
                     <dt><span class="section"><a href="#d0e3433">7.2.  Manual optimization</a></span></dt>
                     <dt><span class="section"><a href="#d0e3456">7.3.  Adjusting optimization</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="chapter"><a href="#search-lucene-native">8.  Advanced features</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#d0e3490">8.1.  SearchFactory</a></span></dt>
                     <dt><span class="section"><a href="#d0e3511">8.2.  Accessing a Lucene Directory</a></span></dt>
                     <dt><span class="section"><a href="#d0e3539">8.3.  Using an IndexReader</a></span></dt>
                     <dt><span class="section"><a href="#d0e3576">8.4.  Customizing Lucene's scoring formula</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <div class="preface" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="preface"></a>Preface
                     </h2>
                  </div>
               </div>
            </div>
            <p>Full text search engines like Apache Lucene are very powerful
               technologies to add efficient free text search capabilities to
               applications. However, Lucene suffers several mismatches when dealing with
               object domain model. Amongst other things indexes have to be kept up to
               date and mismatches between index structure and domain model as well as
               query mismatches have to be avoided.
            </p>
            <p>Hibernate Search addresses these shortcomings - it indexes your
               domain model with the help of a few annotations, takes care of
               database/index synchronization and brings back regular managed objects
               from free text queries. To achieve this Hibernate Search is combining the
               power of <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.hibernate.org" target="_top">Hibernate</a> and
               <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://lucene.apache.org" target="_top">Apache Lucene</a>.
            </p>
         </div>
         <div class="chapter" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="getting-started"></a>Chapter&nbsp;1.&nbsp;Getting started
                     </h2>
                  </div>
               </div>
            </div>
            <p>Welcome to Hibernate Search! The following chapter will guide you
               through the initial steps required to integrate Hibernate Search into an
               existing Hibernate enabled application. In case you are a Hibernate new
               timer we recommend you start <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://hibernate.org/152.html" target="_top">here</a>.
            </p>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e45"></a>1.1.&nbsp;System Requirements
                        </h2>
                     </div>
                  </div>
               </div>
               <div class="table"><a name="d0e48"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;System requirements</b></p>
                  <div class="table-contents">
                     <table summary="System requirements" border="1">
                        <colgroup>
                           <col>
                           <col>
                        </colgroup>
                        <tbody>
                           <tr>
                              <td>Java Runtime</td>
                              <td>A JDK or JRE version <span class="emphasis"><em>5</em></span> or greater. You
                                           can download a Java Runtime for Windows/Linux/Solaris <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://java.sun.com/javase/downloads/" target="_top">here</a>.
                              </td>
                           </tr>
                           <tr>
                              <td>Hibernate Search</td>
                              <td><code class="literal">hibernate-search.jar</code> and all runtime
                                             dependencies from the <code class="literal">lib</code> directory of the
                                             Hibernate Search distribution. Please refer to
                                             <code class="filename">README.txt </code>in the lib directory to understand
                                             which dependencies are required.
                              </td>
                           </tr>
                           <tr>
                              <td>Hibernate Core</td>
                              <td>This instructions have been tested against Hibernate 3.3.x.
                                             You will need <code class="literal">hibernate-core.jar</code> and its
                                             transitive dependencies from the <code class="literal">lib</code> directory
                                             of the distribution. Refer to <code class="literal">README.txt</code> in the
                                             <code class="literal">lib</code> directory of the distribution to determine
                                             the minimum runtime requirements.
                              </td>
                           </tr>
                           <tr>
                              <td>Hibernate Annotations</td>
                              <td>Even though Hibernate Search can be used without Hibernate
                                             Annotations the following instructions will use them for basic
                                             entity configuration (<span class="emphasis"><em>@Entity, @Id,
                                                   @OneToMany,...</em></span>). This part of the configuration could
                                             also be expressed in xml or code. However, Hibernate Search itself
                                             has its own set of annotations (<span class="emphasis"><em>@Indexed, @DocumentId,
                                                   @Field,...</em></span>) for which there exists so far no
                                             alternative configuration. The tutorial is tested against version
                                             3.4.x of Hibernate Annotations.
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div><br class="table-break"><p>You can download all dependencies from the Hibernate <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.hibernate.org/6.html" target="_top">download site</a>. You can also
                  verify the dependency versions against the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.hibernate.org/6.html#A3" target="_top">Hibernate Compatibility
                     Matrix</a>.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e113"></a>1.2.&nbsp;Using Maven
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Instead of managing all dependencies manually, maven users have the
                  possibility to use the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://repository.jboss.com/maven2" target="_top">JBoss maven repository</a>.
                  Just add the JBoss repository url to the <span class="emphasis"><em>repositories</em></span>
                  section of your <code class="filename">pom.xml</code> or
                  <code class="filename">settings.xml</code>:
               </p>
               <div class="example"><a name="d0e130"></a><p class="title"><b>Example&nbsp;1.1.&nbsp;Adding the JBoss maven repository to
                        <code class="filename">settings.xml</code></b></p>
                  <div class="example-contents"><pre class="programlisting">
&lt;repository&gt;
  &lt;id&gt;repository.jboss.org&lt;/id&gt;
  &lt;name&gt;JBoss Maven Repository&lt;/name&gt;
  &lt;url&gt;http://repository.jboss.org/maven2&lt;/url&gt;
  &lt;layout&gt;default&lt;/layout&gt;
&lt;/repository&gt;
      </pre></div>
               </div><br class="example-break"><p>Then add the following dependencies to your pom.xml:</p>
               <div class="example"><a name="d0e139"></a><p class="title"><b>Example&nbsp;1.2.&nbsp;Maven dependencies for Hibernate Search</b></p>
                  <div class="example-contents"><pre class="programlisting">
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search&lt;/artifactId&gt;
   &lt;version&gt;3.1.1.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
   &lt;version&gt;3.4.0.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
   &lt;version&gt;3.4.0.GA&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;
   &lt;artifactId&gt;solr-common&lt;/artifactId&gt;
   &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;
   &lt;artifactId&gt;solr-core&lt;/artifactId&gt;
   &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt;
   &lt;artifactId&gt;lucene-snowball&lt;/artifactId&gt;
   &lt;version&gt;2.4.1&lt;/version&gt;
&lt;/dependency&gt;
      </pre></div>
               </div><br class="example-break"><p>Not all dependencies are required. Only the
                  <span class="emphasis"><em>hibernate-search</em></span> dependency is mandatory. This
                  dependency, together with its required transitive dependencies, contain
                  all required classes needed to use Hibernate Search.
                  <span class="emphasis"><em>hibernate-annotations</em></span> is only needed if you want to
                  use annotations to configure your domain model as we do in this tutorial.
                  However, even if you choose not to use Hibernate Annotations you still
                  have to use the Hibernate Search specific annotations, which are bundled
                  with the hibernate-search jar file, to configure your Lucene index.
                  Currently there is no XML configuration available for Hibernate Search.
                  <span class="emphasis"><em>hibernate-entitymanager</em></span> is required if you want to
                  use Hibernate Search in conjunction with JPA. The Solr dependencies are
                  needed if you want to utilize Solr's analyzer framework. More about this
                  later. And finally, the <code class="literal">lucene-snowball</code> dependency is
                  needed if you want to use Lucene's snowball stemmer.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e158"></a>1.3.&nbsp;Configuration
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Once you have downloaded and added all required dependencies to your
                  application you have to add a couple of properties to your hibernate
                  configuration file. If you are using Hibernate directly this can be done
                  in <code class="literal">hibernate.properties</code> or
                  <code class="literal">hibernate.cfg.xml</code>. If you are using Hibernate via JPA
                  you can also add the properties to <code class="literal">persistence.xml</code>. The
                  good news is that for standard use most properties offer a sensible
                  default. An example <code class="filename">persistence.xml</code> configuration
                  could look like this:
               </p>
               <div class="example"><a name="d0e175"></a><p class="title"><b>Example&nbsp;1.3.&nbsp;Basic configuration options to be added to
                        <code class="literal"><code class="filename">hibernate.properties</code></code>,
                              <code class="literal"><code class="filename">hibernate.cfg.xml</code></code> or
                              <code class="filename">persistence.xml</code></b></p>
                  <div class="example-contents"><pre class="programlisting">
...
&lt;property name="hibernate.search.default.directory_provider" 
   value="org.hibernate.search.store.FSDirectoryProvider"/&gt; 

&lt;property name="hibernate.search.default.indexBase" value="/var/lucene/indexes"/&gt; 
...
    </pre></div>
               </div><br class="example-break"><p>First you have to tell Hibernate Search which
                  <code class="classname">DirectoryProvider</code> to use. This can be achieved by
                  setting the <code class="literal">hibernate.search.default.directory_provider</code>
                  property. Apache Lucene has the notion of a <code class="literal">Directory</code>
                  to store the index files. Hibernate Search handles the initialization and
                  configuration of a Lucene <code class="literal">Directory</code> instance via a
                  <code class="literal">DirectoryProvider</code>. In this tutorial we will use a
                  subclass of <code class="literal">DirectoryProvider</code> called
                  <code class="classname">FSDirectoryProvider</code>. This will give us the ability
                  to physically inspect the Lucene indexes created by Hibernate Search (eg
                  via <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.getopt.org/luke/" target="_top">Luke</a>). Once you have
                  a working configuration you can start experimenting with other directory
                  providers (see <a href="#search-configuration-directory" title="3.1.&nbsp;Directory configuration">Section&nbsp;3.1, &#8220;Directory configuration&#8221;</a>). Next to
                  the directory provider you also have to specify the default root directory
                  for all indexes via
                  <code class="literal">hibernate.search.default.indexBase</code>.
               </p>
               <p>Lets assume that your application contains the Hibernate managed
                  classes <code class="classname">example.Book</code> and
                  <code class="classname">example.Author</code> and you want to add free text search
                  capabilities to your application in order to search the books contained in
                  your database.
               </p>
               <div class="example"><a name="d0e229"></a><p class="title"><b>Example&nbsp;1.4.&nbsp;Example entities Book and Author before adding Hibernate Search
                        specific annotations</b></p>
                  <div class="example-contents"><pre class="programlisting">
package example;
...
@Entity
public class Book {

  @Id
  @GeneratedValue
  private Integer id; 

  private String title;  

  private String subtitle; 

  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ...
} 
    </pre><pre class="programlisting">
package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {
  } 
 
  // standard getters/setters follow here
  ...
}

</pre></div>
               </div><br class="example-break"><p>To achieve this you have to add a few annotations to the
                  <code class="classname">Book</code> and <code class="classname">Author</code> class. The
                  first annotation <code class="literal">@Indexed</code> marks
                  <code class="classname">Book</code> as indexable. By design Hibernate Search needs
                  to store an untokenized id in the index to ensure index unicity for a
                  given entity. <code class="literal">@DocumentId</code> marks the property to use for
                  this purpose and is in most cases the same as the database primary key. In
                  fact since the 3.1.0 release of Hibernate Search
                  <code class="literal">@DocumentId</code> is optional in the case where an
                  <code class="classname">@Id</code> annotation exists.
               </p>
               <p>Next you have to mark the fields you want to make searchable. Let's
                  start with <code class="literal">title</code> and <code class="literal">subtitle</code> and
                  annotate both with <code class="literal">@Field</code>. The parameter
                  <code class="literal">index=Index.TOKENIZED</code> will ensure that the text will be
                  tokenized using the default Lucene analyzer. Usually, tokenizing means
                  chunking a sentence into individual words and potentially excluding common
                  words like <code class="literal">'a'</code> or '<code class="literal">the</code>'. We will
                  talk more about analyzers a little later on. The second parameter we
                  specify within <code class="literal">@Field</code>,<code class="literal">
                     store=Store.NO</code>, ensures that the actual data will not be stored
                  in the index. Whether this data is stored in the index or not has nothing
                  to do with the ability to search for it. From Lucene's perspective it is
                  not necessary to keep the data once the index is created. The benefit of
                  storing it is the ability to retrieve it via projections (<a href="#projections" title="5.1.2.5.&nbsp;Projection">Section&nbsp;5.1.2.5, &#8220;Projection&#8221;</a>). 
               </p>
               <p>Without projections, Hibernate Search will per default execute a
                  Lucene query in order to find the database identifiers of the entities
                  matching the query critera and use these identifiers to retrieve managed
                  objects from the database. The decision for or against projection has to
                  be made on a case to case basis. The default behaviour -
                  <code class="literal">Store.NO</code> - is recommended since it returns managed
                  objects whereas projections only return object arrays.
               </p>
               <p>After this short look under the hood let's go back to annotating the
                  <code class="classname">Book</code> class. Another annotation we have not yet
                  discussed is <code class="literal">@DateBridge</code>. This annotation is one of the
                  built-in field bridges in Hibernate Search. The Lucene index is purely
                  string based. For this reason Hibernate Search must convert the data types
                  of the indexed fields to strings and vice versa. A range of predefined
                  bridges are provided, including the <code class="classname">DateBridge</code>
                  which will convert a <code class="classname">java.util.Date</code> into a
                  <code class="classname">String</code> with the specified resolution. For more
                  details see <a href="#search-mapping-bridge" title="4.2.&nbsp;Property/Field Bridge">Section&nbsp;4.2, &#8220;Property/Field Bridge&#8221;</a>.
               </p>
               <p>This leaves us with <code class="literal">@IndexedEmbedded. </code>This
                  annotation is used to index associated entities
                  (<code class="literal">@ManyToMany</code>, <code class="literal">@*ToOne</code> and
                  <code class="literal">@Embedded</code>) as part of the owning entity. This is needed
                  since a Lucene index document is a flat data structure which does not know
                  anything about object relations. To ensure that the authors' name wil be
                  searchable you have to make sure that the names are indexed as part of the
                  book itself. On top of <code class="literal">@IndexedEmbedded</code> you will also
                  have to mark all fields of the associated entity you want to have included
                  in the index with <code class="literal">@Indexed</code>. For more details see <a href="#search-mapping-associated" title="4.1.3.&nbsp;Embedded and associated objects">Section&nbsp;4.1.3, &#8220;Embedded and associated objects&#8221;</a>.
               </p>
               <p>These settings should be sufficient for now. For more details on
                  entity mapping refer to <a href="#search-mapping-entity" title="4.1.&nbsp;Mapping an entity">Section&nbsp;4.1, &#8220;Mapping an entity&#8221;</a>.
               </p>
               <div class="example"><a name="d0e337"></a><p class="title"><b>Example&nbsp;1.5.&nbsp;Example entities after adding Hibernate Search
                        annotations</b></p>
                  <div class="example-contents"><pre class="programlisting">
package example;
...
@Entity
<span class="bold"><strong>@Indexed</strong></span>
public class Book {

  @Id
  @GeneratedValue
  <span class="bold"><strong>@DocumentId</strong></span>
  private Integer id;
  
  <span class="bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String title;
  
  <span class="bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String subtitle; 

  <span class="bold"><strong>@IndexedEmbedded</strong></span>
  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

<span class="bold"><strong>  @Field(index = Index.UN_TOKENIZED, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)</strong></span>
  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ... 
}
  </pre><pre class="programlisting">
package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  <span class="bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String name;

  public Author() {
  } 
 
  // standard getters/setters follow here
  ...
}
  </pre></div>
               </div><br class="example-break"></div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e365"></a>1.4.&nbsp;Indexing
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Hibernate Search will transparently index every entity persisted,
                  updated or removed through Hibernate Core. However, you have to trigger an
                  initial indexing to populate the Lucene index with the data already present
                  in your database. Once you have added the above properties and annotations
                  it is time to trigger an initial batch index of your books. You can
                  achieve this by using one of the following code snippets (see also <a href="#search-batchindex" title="Chapter&nbsp;6.&nbsp;Manual indexing">Chapter&nbsp;6, <i xmlns:xlink="http://www.w3.org/1999/xlink">Manual indexing</i></a>):
               </p>
               <div class="example"><a name="d0e372"></a><p class="title"><b>Example&nbsp;1.6.&nbsp;Using Hibernate Session to index data</b></p>
                  <div class="example-contents"><pre class="programlisting">
FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

List books = session.createQuery("from Book as book").list();
for (Book book : books) {
    <span class="bold"><strong>fullTextSession.index(book);</strong></span>
}

tx.commit(); //index is written at commit time       
    </pre></div>
               </div><br class="example-break"><div class="example"><a name="d0e380"></a><p class="title"><b>Example&nbsp;1.7.&nbsp;Using JPA to index data</b></p>
                  <div class="example-contents"><pre class="programlisting">
EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(em);
em.getTransaction().begin();

List books = em.createQuery("select book from Book as book").getResultList();
for (Book book : books) {
    <span class="bold"><strong>fullTextEntityManager.index(book);</strong></span>
} 

em.getTransaction().commit();
em.close();


    </pre></div>
               </div><br class="example-break"><p>After executing the above code, you should be able to see a Lucene
                  index under <code class="literal">/var/lucene/indexes/example.Book</code>. Go ahead
                  an inspect this index with <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://www.getopt.org/luke/" target="_top">Luke</a>. It will help you to
                  understand how Hibernate Search works.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e396"></a>1.5.&nbsp;Searching
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Now it is time to execute a first search. The general approach is to
                  create a native Lucene query and then wrap this query into a
                  org.hibernate.Query in order to get all the functionality one is used to
                  from the Hibernate API. The following code will prepare a query against
                  the indexed fields, execute it and return a list of
                  <code class="classname">Book</code>s. 
               </p>
               <div class="example"><a name="d0e404"></a><p class="title"><b>Example&nbsp;1.8.&nbsp;Using Hibernate Session to create and execute a search</b></p>
                  <div class="example-contents"><pre class="programlisting">
FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

// create native Lucene query
String[] fields = new String[]{"title", "subtitle", "authors.name", "publicationDate"};
MultiFieldQueryParser parser = new MultiFieldQueryParser(fields, new StandardAnalyzer());
org.apache.lucene.search.Query query = parser.parse( "Java rocks!" );

// wrap Lucene query in a org.hibernate.Query
org.hibernate.Query hibQuery = fullTextSession.createFullTextQuery(query, Book.class);

// execute search
List result = hibQuery.list();
  
tx.commit();
session.close();  
    </pre></div>
               </div><br class="example-break"><div class="example"><a name="d0e409"></a><p class="title"><b>Example&nbsp;1.9.&nbsp;Using JPA to create and execute a search</b></p>
                  <div class="example-contents"><pre class="programlisting">
EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = 
    org.hibernate.hibernate.search.jpa.Search.getFullTextEntityManager(em);
em.getTransaction().begin();

// create native Lucene query
String[] fields = new String[]{"title", "subtitle", "authors.name", "publicationDate"};
MultiFieldQueryParser parser = new MultiFieldQueryParser(fields, new StandardAnalyzer());
org.apache.lucene.search.Query query = parser.parse( "Java rocks!" );

// wrap Lucene query in a javax.persistence.Query
javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, Book.class);

// execute search
List result = persistenceQuery.getResultList();

em.getTransaction().commit();
em.close();

    </pre></div>
               </div><br class="example-break"></div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e414"></a>1.6.&nbsp;Analyzer
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Let's make things a little more interesting now. Assume that one of
                  your indexed book entities has the title "Refactoring: Improving the
                  Design of Existing Code" and you want to get hits for all of the following
                  queries: "refactor", "refactors", "refactored" and "refactoring". In
                  Lucene this can be achieved by choosing an analyzer class which applies
                  word stemming during the indexing <span class="bold"><strong>as well
                        as</strong></span> search process. Hibernate Search offers several ways to
                  configure the analyzer to use (see <a href="#analyzer" title="4.1.5.&nbsp;Analyzer">Section&nbsp;4.1.5, &#8220;Analyzer&#8221;</a>):
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>Setting the <code class="literal">hibernate.search.analyzer</code>
                           property in the configuration file. The specified class will then be
                           the default analyzer.
                        </p>
                     </li>
                     <li>
                        <p>Setting the <code class="literal"><code class="literal">@Analyzer</code></code>
                           annotation at the entity level.
                        </p>
                     </li>
                     <li>
                        <p>Setting the <code class="literal">@<code class="literal">Analyzer</code></code>
                           annotation at the field level.
                        </p>
                     </li>
                  </ul>
               </div>
               <p>When using the <code class="literal">@Analyzer</code> annotation one can
                  either specify the fully qualified classname of the analyzer to use or one
                  can refer to an analyzer definition defined by the
                  <code class="literal">@AnalyzerDef</code> annotation. In the latter case the Solr
                  analyzer framework with its factories approach is utilized. To find out
                  more about the factory classes available you can either browse the Solr
                  JavaDoc or read the corresponding section on the <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters" target="_top">Solr
                     Wiki.</a> Note that depending on the chosen factory class additional
                  libraries on top of the Solr dependencies might be required. For example,
                  the <code class="classname">PhoneticFilterFactory</code> depends on <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://commons.apache.org/codec" target="_top">commons-codec</a>.
               </p>
               <p>In the example below a
                  <code class="classname">StandardTokenizerFactory</code> is used followed by two
                  filter factories, <code class="classname">LowerCaseFilterFactory</code> and
                  <code class="classname">SnowballPorterFilterFactory</code>. The standard tokenizer
                  splits words at punctuation characters and hyphens while keeping email
                  addresses and internet hostnames intact. It is a good general purpose
                  tokenizer. The lowercase filter lowercases the letters in each token
                  whereas the snowball filter finally applies language specific
                  stemming.
               </p>
               <p>Generally, when using the Solr framework you have to start with a
                  tokenizer followed by an arbitrary number of filters.
               </p>
               <div class="example"><a name="d0e476"></a><p class="title"><b>Example&nbsp;1.10.&nbsp;Using <code class="classname">@AnalyzerDef</code> and the Solr framework
                           to define and use an analyzer</b></p>
                  <div class="example-contents"><pre class="programlisting">

package example;
...
@Entity
@Indexed
<span class="bold"><strong>@AnalyzerDef(name = "customanalyzer",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = SnowballPorterFilterFactory.class, params = {
      @Parameter(name = "language", value = "English")
    })
  })</strong></span>
public class Book {

  @Id
  @GeneratedValue
  @DocumentId
  private Integer id;
  
  @Field(index=Index.TOKENIZED, store=Store.NO)
  <span class="bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
  private String title;
  
  @Field(index=Index.TOKENIZED, store=Store.NO)
  <span class="bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
  private String subtitle; 

  @IndexedEmbedded
  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

<span class="bold"><strong> </strong></span> @Field(index = Index.UN_TOKENIZED, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ... 
}

  </pre></div>
               </div><br class="example-break"></div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e496"></a>1.7.&nbsp;What's next
                        </h2>
                     </div>
                  </div>
               </div>
               <p>The above paragraphs hopefully helped you getting an overview of
                  Hibernate Search. Using the maven archetype plugin and the following
                  command you can create an initial runnable maven project structure
                  populated with the example code of this tutorial.
               </p>
               <div class="example"><a name="d0e501"></a><p class="title"><b>Example&nbsp;1.11.&nbsp;Using the Maven archetype to create tutorial sources</b></p>
                  <div class="example-contents"><pre class="programlisting">mvn archetype:create \ 
    -DarchetypeGroupId=org.hibernate \
    -DarchetypeArtifactId=hibernate-search-quickstart \ 
    -DarchetypeVersion=3.1.1.GA \
    -DgroupId=my.company -DartifactId=quickstart</pre></div>
               </div><br class="example-break"><p>Using the maven project you can execute the examples, inspect the
                  file system based index and search and retrieve a list of managed objects.
                  Just run <span class="emphasis"><em>mvn package</em></span> to compile the sources and run
                  the unit tests.
               </p>
               <p>The next step after this tutorial is to get more familiar with the
                  overall architecture of Hibernate Search (<a href="#search-architecture" title="Chapter&nbsp;2.&nbsp;Architecture">Chapter&nbsp;2, <i xmlns:xlink="http://www.w3.org/1999/xlink">Architecture</i></a>) and explore the basic features in more
                  detail. Two topics which were only briefly touched in this tutorial were
                  analyzer configuration (<a href="#analyzer" title="4.1.5.&nbsp;Analyzer">Section&nbsp;4.1.5, &#8220;Analyzer&#8221;</a>) and field bridges
                  (<a href="#search-mapping-bridge" title="4.2.&nbsp;Property/Field Bridge">Section&nbsp;4.2, &#8220;Property/Field Bridge&#8221;</a>), both important features
                  required for more fine-grained indexing. More advanced topics cover
                  clustering (<a href="#jms-backend" title="3.5.&nbsp;JMS Master/Slave configuration">Section&nbsp;3.5, &#8220;JMS Master/Slave configuration&#8221;</a>) and large indexes handling
                  (<a href="#search-configuration-directory-sharding" title="3.2.&nbsp;Sharding indexes">Section&nbsp;3.2, &#8220;Sharding indexes&#8221;</a>).
               </p>
            </div>
         </div>
         <div class="chapter" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="search-architecture"></a>Chapter&nbsp;2.&nbsp;Architecture
                     </h2>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e528"></a>2.1.&nbsp;Overview
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Hibernate Search consists of an indexing component and an index
                  search component. Both are backed by Apache Lucene.
               </p>
               <p>Each time an entity is inserted, updated or removed in/from the
                  database, Hibernate Search keeps track of this event (through the
                  Hibernate event system) and schedules an index update. All the index
                  updates are handled without you having to use the Apache Lucene APIs (see
                  <a href="#search-configuration-event" title="3.7.&nbsp;Enabling Hibernate Search and automatic indexing">Section&nbsp;3.7, &#8220;Enabling Hibernate Search and automatic indexing&#8221;</a>).
               </p>
               <p>To interact with Apache Lucene indexes, Hibernate Search has the
                  notion of <code class="classname">DirectoryProvider</code>s. A directory provider
                  will manage a given Lucene <code class="classname">Directory</code> type. You can
                  configure directory providers to adjust the directory target (see <a href="#search-configuration-directory" title="3.1.&nbsp;Directory configuration">Section&nbsp;3.1, &#8220;Directory configuration&#8221;</a>).
               </p>
               <p>Hibernate Search uses the Lucene index to search an entity and
                  return a list of managed entities saving you the tedious object to Lucene
                  document mapping. The same persistence context is shared between Hibernate
                  and Hibernate Search. As a matter of fact, the
                  <code class="classname">FullTextSession</code> is built on top of the Hibernate
                  Session. so that the application code can use the unified
                  <code class="classname">org.hibernate.Query</code> or
                  <code class="classname">javax.persistence.Query</code> APIs exactly the way a HQL,
                  JPA-QL or native queries would do.
               </p>
               <p>To be more efficient, Hibernate Search batches the write
                  interactions with the Lucene index. There is currently two types of
                  batching depending on the expected scope. Outside a transaction, the index
                  update operation is executed right after the actual database operation.
                  This scope is really a no scoping setup and no batching is performed.
                  However, it is recommended - for both your database and Hibernate Search -
                  to execute your operation in a transaction be it JDBC or JTA. When in a
                  transaction, the index update operation is scheduled for the transaction
                  commit phase and discarded in case of transaction rollback. The batching
                  scope is the transaction. There are two immediate benefits:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>Performance: Lucene indexing works better when operation are
                           executed in batch.
                        </p>
                     </li>
                     <li>
                        <p>ACIDity: The work executed has the same scoping as the one
                           executed by the database transaction and is executed if and only if
                           the transaction is committed. This is not ACID in the strict sense of
                           it, but ACID behavior is rarely useful for full text search indexes
                           since they can be rebuilt from the source at any time.
                        </p>
                     </li>
                  </ul>
               </div>
               <p>You can think of those two scopes (no scope vs transactional) as the
                  equivalent of the (infamous) autocommit vs transactional behavior. From a
                  performance perspective, the <span class="emphasis"><em>in transaction</em></span> mode is
                  recommended. The scoping choice is made transparently. Hibernate Search
                  detects the presence of a transaction and adjust the scoping.
               </p>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                         Hibernate Search works perfectly fine in the Hibernate / EntityManager long conversation pattern aka. atomic conversation.
                  
                      
               </div>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                         Depending on user demand, additional scoping will be considered, the pluggability mechanism being already in place.
                  
                      
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e576"></a>2.2.&nbsp;Back end
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Hibernate Search offers the ability to let the scoped work being
                  processed by different back ends. Two back ends are provided out of the
                  box for two different scenarios.
               </p>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e581"></a>2.2.1.&nbsp;Back end types
                           </h3>
                        </div>
                     </div>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e584"></a>2.2.1.1.&nbsp;Lucene
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>In this mode, all index update operations applied on a given
                        node (JVM) will be executed to the Lucene directories (through the
                        directory providers) by the same node. This mode is typically used in
                        non clustered environment or in clustered environments where the
                        directory store is shared.
                     </p>
                     <div class="mediaobject" align="center"><img src="lucene-backend.png" align="middle"><div class="caption">
                           <p>Lucene back end configuration.</p>
                        </div>
                     </div>
                     <p>This mode targets non clustered applications, or clustered
                        applications where the Directory is taking care of the locking
                        strategy.
                     </p>
                     <p>The main advantage is simplicity and immediate visibility of the
                        changes in Lucene queries (a requirement in some applications).
                     </p>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e601"></a>2.2.1.2.&nbsp;JMS
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>All index update operations applied on a given node are sent to
                        a JMS queue. A unique reader will then process the queue and update
                        the master index. The master index is then replicated on a regular
                        basis to the slave copies. This is known as the master/slaves pattern.
                        The master is the sole responsible for updating the Lucene index. The
                        slaves can accept read as well as write operations. However, they only
                        process the read operation on their local index copy and delegate the
                        update operations to the master.
                     </p>
                     <div class="mediaobject" align="center"><img src="jms-backend.png" align="middle"><div class="caption">
                           <p>JMS back end configuration.</p>
                        </div>
                     </div>
                     <p>This mode targets clustered environments where throughput is
                        critical, and index update delays are affordable. Reliability is
                        ensured by the JMS provider and by having the slaves working on a
                        local copy of the index.
                     </p>
                  </div>
                  <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Note</h3>Hibernate Search is an extensible architecture. Feel free to drop
                           ideas for other third party back ends to
                           <code class="literal">hibernate-dev@lists.jboss.org</code>.
                  </div>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e621"></a>2.2.2.&nbsp;Work execution
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>The indexing work (done by the back end) can be executed
                     synchronously with the transaction commit (or update operation if out of
                     transaction), or asynchronously.
                  </p>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e626"></a>2.2.2.1.&nbsp;Synchronous
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>This is the safe mode where the back end work is executed in
                        concert with the transaction commit. Under highly concurrent
                        environment, this can lead to throughput limitations (due to the
                        Apache Lucene lock mechanism) and it can increase the system response
                        time if the backend is significantly slower than the transactional
                        process and if a lot of IO operations are involved.
                     </p>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e631"></a>2.2.2.2.&nbsp;Asynchronous
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>This mode delegates the work done by the back end to a different
                        thread. That way, throughput and response time are (to a certain
                        extend) decorrelated from the back end performance. The drawback is
                        that a small delay appears between the transaction commit and the
                        index update and a small overhead is introduced to deal with thread
                        management.
                     </p>
                     <p>It is recommended to use synchronous execution first and
                        evaluate asynchronous execution if performance problems occur and
                        after having set up a proper benchmark (ie not a lonely cowboy hitting
                        the system in a completely unrealistic way).
                     </p>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="search-architecture-readerstrategy"></a>2.3.&nbsp;Reader strategy
                        </h2>
                     </div>
                  </div>
               </div>
               <p>When executing a query, Hibernate Search interacts with the Apache
                  Lucene indexes through a reader strategy. Choosing a reader strategy will
                  depend on the profile of the application (frequent updates, read mostly,
                  asynchronous index update etc). See also <a href="#configuration-reader-strategy" title="3.6.&nbsp;Reader strategy configuration">Section&nbsp;3.6, &#8220;Reader strategy configuration&#8221;</a></p>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e644"></a>2.3.1.&nbsp;Shared
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>With this strategy, Hibernate Search will share the same
                     <code class="classname">IndexReader</code>, for a given Lucene index, across
                     multiple queries and threads provided that the
                     <code class="classname">IndexReader</code> is still up-to-date. If the
                     <code class="classname">IndexReader</code> is not up-to-date, a new one is
                     opened and provided. Each <code class="classname">IndexReader</code> is made of
                     several <code class="classname">SegmentReader</code>s. This strategy only
                     reopens segments that have been modified or created after last opening
                     and shares the already loaded segments from the previous instance. This
                     strategy is the default.
                  </p>
                  <p>The name of this strategy is <code class="literal">shared</code>.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e669"></a>2.3.2.&nbsp;Not-shared
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Every time a query is executed, a Lucene
                     <code class="classname">IndexReader</code> is opened. This strategy is not the
                     most efficient since opening and warming up an
                     <code class="classname">IndexReader</code> can be a relatively expensive
                     operation.
                  </p>
                  <p>The name of this strategy is <code class="literal">not-shared</code>.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e685"></a>2.3.3.&nbsp;Custom
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>You can write your own reader strategy that suits your application
                     needs by implementing
                     <code class="classname">org.hibernate.search.reader.ReaderProvider</code>. The
                     implementation must be thread safe.
                  </p>
               </div>
            </div>
         </div>
         <div class="chapter" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="search-configuration"></a>Chapter&nbsp;3.&nbsp;Configuration
                     </h2>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="search-configuration-directory"></a>3.1.&nbsp;Directory configuration
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Apache Lucene has a notion of <code class="literal">Directory</code> to store
                  the index files. The <code class="classname">Directory</code> implementation can
                  be customized, but Lucene comes bundled with a file system
                  (<code class="literal">FSDirectoryProvider</code>) and an in memory
                  (<code class="literal">RAMDirectoryProvider</code>) implementation.
                  <code class="literal">DirectoryProvider</code>s are the Hibernate Search abstraction
                  around a Lucene <code class="classname">Directory</code> and handle the
                  configuration and the initialization of the underlying Lucene resources.
                  <a href="#directory-provider-table" title="Table&nbsp;3.1.&nbsp;List of built-in Directory Providers">Table&nbsp;3.1, &#8220;List of built-in Directory Providers&#8221;</a> shows the list of the
                  directory providers bundled with Hibernate Search.
               </p>
               <div class="table"><a name="directory-provider-table"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;List of built-in Directory Providers</b></p>
                  <div class="table-contents">
                     <table summary="List of built-in Directory Providers" border="1">
                        <colgroup>
                           <col>
                           <col>
                           <col>
                        </colgroup>
                        <thead>
                           <tr>
                              <th align="center">Class</th>
                              <th align="center">Description</th>
                              <th align="center">Properties</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td>org.hibernate.search.store.FSDirectoryProvider</td>
                              <td>File system based directory. The directory used will be
                                             &lt;indexBase&gt;/&lt; indexName &gt;
                              </td>
                              <td>
                                 <p><code class="literal">indexBase</code> : Base
                                                directory
                                 </p>
                                 <p><code class="literal">indexName</code>: override
                                                @Indexed.index (useful for sharded indexes)
                                 </p>
                              </td>
                           </tr>
                           <tr>
                              <td>org.hibernate.search.store.FSMasterDirectoryProvider</td>
                              <td>
                                 <p>File system based directory. Like
                                                FSDirectoryProvider. It also copies the index to a source
                                                directory (aka copy directory) on a regular basis.
                                                
                                 </p>
                                 <p>The recommended value for the refresh period is (at
                                                least) 50% higher that the time to copy the information (default
                                                3600 seconds - 60 minutes).
                                 </p>
                                 <p>Note that the copy is
                                                based on an incremental copy mechanism reducing the average copy
                                                time.
                                 </p>
                                 <p>DirectoryProvider typically used on the master
                                                node in a JMS back end cluster.
                                 </p>
                                 <p>The <code class="literal">
                                                   buffer_size_on_copy</code> optimum depends on your operating
                                                system and available RAM; most people reported good results using
                                                values between 16 and 64MB.
                                 </p>
                              </td>
                              <td>
                                 <p><code class="literal">indexBase</code>: Base
                                                directory
                                 </p>
                                 <p><code class="literal">indexName</code>: override
                                                @Indexed.index (useful for sharded
                                                indexes)
                                 </p>
                                 <p><code class="literal">sourceBase</code>: Source (copy)
                                                base directory.
                                 </p>
                                 <p><code class="literal">source</code>: Source
                                                directory suffix (default to <code class="literal">@Indexed.index</code>).
                                                The actual source directory name being
                                                <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
                                                
                                 </p>
                                 <p><code class="literal">refresh</code>: refresh period in second
                                                (the copy will take place every refresh seconds).
                                 </p>
                                 <p>
                                                <code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to
                                                move in a single low level copy instruction; defaults to
                                                16MB.
                                 </p>
                              </td>
                           </tr>
                           <tr>
                              <td>org.hibernate.search.store.FSSlaveDirectoryProvider</td>
                              <td>
                                 <p>File system based directory. Like
                                                FSDirectoryProvider, but retrieves a master version (source) on a
                                                regular basis. To avoid locking and inconsistent search results, 2
                                                local copies are kept. 
                                 </p>
                                 <p>The recommended value for the
                                                refresh period is (at least) 50% higher that the time to copy the
                                                information (default 3600 seconds - 60 minutes).
                                 </p>
                                 <p>Note
                                                that the copy is based on an incremental copy mechanism reducing
                                                the average copy time.
                                 </p>
                                 <p>DirectoryProvider typically
                                                used on slave nodes using a JMS back end.
                                 </p>
                                 <p>The
                                                <code class="literal"> buffer_size_on_copy</code> optimum depends on your
                                                operating system and available RAM; most people reported good
                                                results using values between 16 and 64MB.
                                 </p>
                              </td>
                              <td>
                                 <p><code class="literal">indexBase</code>: Base
                                                directory
                                 </p>
                                 <p><code class="literal">indexName</code>: override
                                                @Indexed.index (useful for sharded
                                                indexes)
                                 </p>
                                 <p><code class="literal">sourceBase</code>: Source (copy)
                                                base directory.
                                 </p>
                                 <p><code class="literal">source</code>: Source
                                                directory suffix (default to <code class="literal">@Indexed.index</code>).
                                                The actual source directory name being
                                                <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
                                                
                                 </p>
                                 <p><code class="literal">refresh</code>: refresh period in second
                                                (the copy will take place every refresh seconds).
                                 </p>
                                 <p>
                                                <code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to
                                                move in a single low level copy instruction; defaults to
                                                16MB.
                                 </p>
                              </td>
                           </tr>
                           <tr>
                              <td>org.hibernate.search.store.RAMDirectoryProvider</td>
                              <td>Memory based directory, the directory will be uniquely
                                             identified (in the same deployment unit) by the
                                             <code class="literal">@Indexed.index</code> element
                              </td>
                              <td>none</td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div><br class="table-break"><p>If the built-in directory providers do not fit your needs, you can
                  write your own directory provider by implementing the
                  <code class="classname">org.hibernate.store.DirectoryProvider</code>
                  interface.
               </p>
               <p>Each indexed entity is associated to a Lucene index (an index can be
                  shared by several entities but this is not usually the case). You can
                  configure the index through properties prefixed by
                  <code class="constant">hibernate.search.</code><em class="replaceable"><code>indexname</code></em>
                  . Default properties inherited to all indexes can be defined using the
                  prefix <code class="constant">hibernate.search.default.</code></p>
               <p>To define the directory provider of a given index, you use the
                  <code class="constant">hibernate.search.<em class="replaceable"><code>indexname</code></em>.directory_provider
                     </code></p>
               <div class="example"><a name="d0e879"></a><p class="title"><b>Example&nbsp;3.1.&nbsp;Configuring directory providers</b></p>
                  <div class="example-contents"><pre class="programlisting">hibernate.search.default.directory_provider org.hibernate.search.store.FSDirectoryProvider
hibernate.search.default.indexBase=/usr/lucene/indexes
hibernate.search.Rules.directory_provider org.hibernate.search.store.RAMDirectoryProvider</pre></div>
               </div><br class="example-break"><p>applied on</p>
               <div class="example"><a name="d0e886"></a><p class="title"><b>Example&nbsp;3.2.&nbsp;Specifying the index name using the <code class="literal">index</code>
                              parameter of <code class="classname">@Indexed</code></b></p>
                  <div class="example-contents"><pre class="programlisting">@Indexed(index="Status")
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }</pre></div>
               </div><br class="example-break"><p>will create a file system directory in
                  <code class="filename">/usr/lucene/indexes/Status</code> where the Status entities
                  will be indexed, and use an in memory directory named
                  <code class="literal">Rules</code> where Rule entities will be indexed.
               </p>
               <p>You can easily define common rules like the directory provider and
                  base directory, and override those defaults later on on a per index
                  basis.
               </p>
               <p>Writing your own <code class="classname">DirectoryProvider</code>, you can
                  utilize this configuration mechanism as well.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="search-configuration-directory-sharding"></a>3.2.&nbsp;Sharding indexes
                        </h2>
                     </div>
                  </div>
               </div>
               <p>In some extreme cases involving huge indexes (in size), it is
                  necessary to split (shard) the indexing data of a given entity type into
                  several Lucene indexes. This solution is not recommended until you reach
                  significant index sizes and index update times are slowing the application
                  down. The main drawback of index sharding is that searches will end up
                  being slower since more files have to be opened for a single search. In
                  other words don't do it until you have problems :)
               </p>
               <p>Despite this strong warning, Hibernate Search allows you to index a
                  given entity type into several sub indexes. Data is sharded into the
                  different sub indexes thanks to an
                  <code class="classname">IndexShardingStrategy</code>. By default, no sharding
                  strategy is enabled, unless the number of shards is configured. To
                  configure the number of shards use the following property
               </p>
               <div class="example"><a name="d0e921"></a><p class="title"><b>Example&nbsp;3.3.&nbsp;Enabling index sharding by specifying nbr_of_shards for a
                        specific index</b></p>
                  <div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards 5</pre></div>
               </div><br class="example-break"><p>This will use 5 different shards.</p>
               <p>The default sharding strategy, when shards are set up, splits the
                  data according to the hash value of the id string representation
                  (generated by the Field Bridge). This ensures a fairly balanced sharding.
                  You can replace the strategy by implementing
                  <code class="literal">IndexShardingStrategy</code> and by setting the following
                  property
               </p>
               <div class="example"><a name="d0e933"></a><p class="title"><b>Example&nbsp;3.4.&nbsp;Specifying a custom sharding strategy</b></p>
                  <div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy my.shardingstrategy.Implementation</pre></div>
               </div><br class="example-break"><p>Each shard has an independent directory provider configuration as
                  described in <a href="#search-configuration-directory" title="3.1.&nbsp;Directory configuration">Section&nbsp;3.1, &#8220;Directory configuration&#8221;</a>. The
                  DirectoryProvider default name for the previous example are
                  <code class="literal">&lt;indexName&gt;.0</code> to
                  <code class="literal">&lt;indexName&gt;.4</code>. In other words, each shard has the
                  name of it's owning index followed by <code class="constant">.</code> (dot) and its
                  index number.
               </p>
               <div class="example"><a name="d0e951"></a><p class="title"><b>Example&nbsp;3.5.&nbsp;Configuring the sharding configuration for an example entity
                        <code class="classname">Animal</code></b></p>
                  <div class="example-contents"><pre class="programlisting">hibernate.search.default.indexBase /usr/lucene/indexes

hibernate.search.Animal.sharding_strategy.nbr_of_shards 5
hibernate.search.Animal.directory_provider org.hibernate.search.store.FSDirectoryProvider
hibernate.search.Animal.0.indexName Animal00
hibernate.search.Animal.3.indexBase /usr/lucene/sharded
hibernate.search.Animal.3.indexName Animal03</pre></div>
               </div><br class="example-break"><p>This configuration uses the default id string hashing strategy and
                  shards the Animal index into 5 subindexes. All subindexes are
                  <code class="classname">FSDirectoryProvider</code> instances and the directory
                  where each subindex is stored is as followed:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>for subindex 0: /usr/lucene/indexes/Animal00 (shared indexBase
                           but overridden indexName)
                        </p>
                     </li>
                     <li>
                        <p>for subindex 1: /usr/lucene/indexes/Animal.1 (shared indexBase,
                           default indexName)
                        </p>
                     </li>
                     <li>
                        <p>for subindex 2: /usr/lucene/indexes/Animal.2 (shared indexBase,
                           default indexName)
                        </p>
                     </li>
                     <li>
                        <p>for subindex 3: /usr/lucene/shared/Animal03 (overridden
                           indexBase, overridden indexName)
                        </p>
                     </li>
                     <li>
                        <p>for subindex 4: /usr/lucene/indexes/Animal.4 (shared indexBase,
                           default indexName)
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e979"></a>3.3.&nbsp;Sharing indexes (two entities into the same directory)
                        </h2>
                     </div>
                  </div>
               </div>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p>This is only presented here so that you know the option is
                     available. There is really not much benefit in sharing indexes.
                  </p>
               </div>
               <p>It is technically possible to store the information of more than one
                  entity into a single Lucene index. There are two ways to accomplish
                  this:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>Configuring the underlying directory providers to point to the
                           same physical index directory. In practice, you set the property
                           <code class="literal">hibernate.search.[fully qualified entity
                              name].indexName</code> to the same value. As an example let&#8217;s use
                           the same index (directory) for the <code class="classname">Furniture</code>
                           and <code class="classname">Animal</code> entity. We just set
                           <code class="literal">indexName</code> for both entities to for example
                           &#8220;Animal&#8221;. Both entities will then be stored in the Animal
                           directory
                        </p><pre class="programlisting"><code class="code">hibernate.search.org.hibernate.search.test.shards.Furniture.indexName = Animal
hibernate.search.org.hibernate.search.test.shards.Animal.indexName = Animal</code></pre></li>
                     <li>
                        <p>Setting the <code class="code">@Indexed</code> annotation&#8217;s
                           <code class="methodname">index</code> attribute of the entities you want to
                           merge to the same value. If we again wanted all
                           <code class="classname">Furniture</code> instances to be indexed in the
                           <code class="classname">Animal</code> index along with all instances of
                           <code class="classname">Animal</code> we would specify
                           <code class="code">@Indexed(index=&#8221;Animal&#8221;)</code> on both
                           <code class="classname">Animal</code> and <code class="classname">Furniture</code>
                           classes.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e1034"></a>3.4.&nbsp;Worker configuration
                        </h2>
                     </div>
                  </div>
               </div>
               <p>It is possible to refine how Hibernate Search interacts with Lucene
                  through the worker configuration. The work can be executed to the Lucene
                  directory or sent to a JMS queue for later processing. When processed to
                  the Lucene directory, the work can be processed synchronously or
                  asynchronously to the transaction commit.
               </p>
               <p>You can define the worker configuration using the following
                  properties
               </p>
               <div class="table"><a name="d0e1041"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;worker configuration</b></p>
                  <div class="table-contents">
                     <table summary="worker configuration" border="1">
                        <colgroup>
                           <col align="center">
                           <col>
                        </colgroup>
                        <tbody>
                           <tr>
                              <td align="center">Property</td>
                              <td>Description</td>
                           </tr>
                           <tr>
                              <td align="center"><code class="literal">hibernate.search.worker.backend</code></td>
                              <td>Out of the box support for the Apache Lucene back end and
                                             the JMS back end. Default to <code class="literal">lucene</code>. Supports
                                             also <code class="literal">jms</code>.
                              </td>
                           </tr>
                           <tr>
                              <td align="center"><code class="literal">hibernate.search.worker.execution</code></td>
                              <td>Supports synchronous and asynchronous execution. Default
                                             to <code class="literal"><code class="literal">sync</code></code>. Supports also
                                             <code class="literal">async</code>.
                              </td>
                           </tr>
                           <tr>
                              <td align="center"><code class="literal">hibernate.search.worker.thread_pool.size</code></td>
                              <td>Defines the number of threads in the pool. useful only for
                                             asynchronous execution. Default to 1.
                              </td>
                           </tr>
                           <tr>
                              <td align="center"><code class="literal">hibernate.search.worker.buffer_queue.max</code></td>
                              <td>Defines the maximal number of work queue if the thread poll
                                             is starved. Useful only for asynchronous execution. Default to
                                             infinite. If the limit is reached, the work is done by the main
                                             thread.
                              </td>
                           </tr>
                           <tr>
                              <td align="center"><code class="literal">hibernate.search.worker.jndi.*</code></td>
                              <td>Defines the JNDI properties to initiate the InitialContext
                                             (if needed). JNDI is only used by the JMS back end.
                              </td>
                           </tr>
                           <tr>
                              <td align="center"><code class="literal">
                                                hibernate.search.worker.jms.connection_factory</code></td>
                              <td>Mandatory for the JMS back end. Defines the JNDI name to
                                             lookup the JMS connection factory from
                                             (<code class="literal">/ConnectionFactory</code> by default in JBoss
                                             AS)
                              </td>
                           </tr>
                           <tr>
                              <td align="center"><code class="literal">hibernate.search.worker.jms.queue</code></td>
                              <td>Mandatory for the JMS back end. Defines the JNDI name to
                                             lookup the JMS queue from. The queue will be used to post work
                                             messages.
                              </td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div><br class="table-break"></div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="jms-backend"></a>3.5.&nbsp;JMS Master/Slave configuration
                        </h2>
                     </div>
                  </div>
               </div>
               <p>This section describes in greater detail how to configure the Master
                  / Slaves Hibernate Search architecture.
               </p>
               <div class="mediaobject" align="center"><img src="jms-backend.png" align="middle"><div class="caption">
                     <p>JMS Master/Slave architecture
                        overview.
                     </p>
                  </div>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e1124"></a>3.5.1.&nbsp;Slave nodes
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Every index update operation is sent to a JMS queue. Index querying
                     operations are executed on a local index copy.
                  </p>
                  <div class="example"><a name="d0e1129"></a><p class="title"><b>Example&nbsp;3.6.&nbsp;JMS Slave configuration</b></p>
                     <div class="example-contents"><pre class="programlisting">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSSlaveDirectoryProvider

## Backend configuration
hibernate.search.worker.backend = jms
hibernate.search.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.worker.jms.queue = queue/hibernatesearch
#optional jndi configuration (check your JMS provider for more information)

## Optional asynchronous execution strategy
# hibernate.search.worker.execution = async
# hibernate.search.worker.thread_pool.size = 2
# hibernate.search.worker.buffer_queue.max = 50</pre></div>
                  </div><br class="example-break"><p>A file system local copy is recommended for faster search
                     results.
                  </p>
                  <p>The refresh period should be higher that the expected time
                     copy.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e1138"></a>3.5.2.&nbsp;Master node
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Every index update operation is taken from a JMS queue and
                     executed. The master index is copied on a regular basis.
                  </p>
                  <div class="example"><a name="d0e1143"></a><p class="title"><b>Example&nbsp;3.7.&nbsp;JMS Master configuration</b></p>
                     <div class="example-contents"><pre class="programlisting">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSMasterDirectoryProvider

## Backend configuration
#Backend is the default lucene one</pre></div>
                  </div><br class="example-break"><p>The refresh period should be higher that the expected time
                     copy.
                  </p>
                  <p>In addition to the Hibernate Search framework configuration, a
                     Message Driven Bean should be written and set up to process the index
                     works queue through JMS.
                  </p>
                  <div class="example"><a name="d0e1152"></a><p class="title"><b>Example&nbsp;3.8.&nbsp;Message Driven Bean processing the indexing queue</b></p>
                     <div class="example-contents"><pre class="programlisting">@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType", propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination", propertyValue="queue/hibernatesearch"),
      @ActivationConfigProperty(propertyName="DLQMaxResent", propertyValue="1")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController implements MessageListener {
    @PersistenceContext EntityManager em;
    
    //method retrieving the appropriate session
    protected Session getSession() {
        return (Session) em.getDelegate();
    }

    //potentially close the session opened in #getSession(), not needed here
    protected void cleanSessionIfNeeded(Session session) 
    }
}</pre></div>
                  </div><br class="example-break"><p>This example inherits from the abstract JMS controller class
                     available in the Hibernate Search source code and implements a JavaEE 5
                     MDB. This implementation is given as an example and, while most likely
                     be more complex, can be adjusted to make use of non Java EE Message
                     Driven Beans. For more information about the
                     <code class="methodname">getSession()</code> and
                     <code class="methodname">cleanSessionIfNeeded()</code>, please check
                     <code class="classname">AbstractJMSHibernateSearchController</code>'s
                     javadoc.
                  </p>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="configuration-reader-strategy"></a>3.6.&nbsp;Reader strategy configuration
                        </h2>
                     </div>
                  </div>
               </div>
               <p>The different reader strategies are described in <a href="#search-architecture-readerstrategy" title="2.3.&nbsp;Reader strategy">Reader strategy</a>. Out of the box strategies
                  are:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p><code class="literal">shared</code>: share index readers across several
                           queries. This strategy is the most efficient.
                        </p>
                     </li>
                     <li>
                        <p><code class="literal">not-shared</code>: create an index reader for each
                           individual query
                        </p>
                     </li>
                  </ul>
               </div>
               <p>The default reader strategy is <code class="literal">shared</code>. This can
                  be adjusted:
               </p><pre class="programlisting">hibernate.search.reader.strategy = not-shared</pre><p>Adding this property switches to the <code class="literal">not-shared</code>
                  strategy.
               </p>
               <p>Or if you have a custom reader strategy:</p><pre class="programlisting">hibernate.search.reader.strategy = my.corp.myapp.CustomReaderProvider</pre><p>where <code class="classname">my.corp.myapp.CustomReaderProvider</code> is
                  the custom strategy implementation.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="search-configuration-event"></a>3.7.&nbsp;Enabling Hibernate Search and automatic indexing
                        </h2>
                     </div>
                  </div>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e1210"></a>3.7.1.&nbsp;Enabling Hibernate Search
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Hibernate Search is enabled out of the box when using Hibernate
                     Annotations or Hibernate EntityManager. If, for some reason you need to
                     disable it, set
                     <code class="literal">hibernate.search.autoregister_listeners</code> to false.
                     Note that there is no performance penalty when the listeners are enabled
                     even though no entities are indexed.
                  </p>
                  <p>To enable Hibernate Search in Hibernate Core (ie. if you don't use
                     Hibernate Annotations), add the
                     <code class="literal">FullTextIndexEventListener</code> for the following six
                     Hibernate events and also add it after the default
                     <code class="literal">DefaultFlushEventListener</code>, as in the following
                     example.
                  </p>
                  <div class="example"><a name="d0e1226"></a><p class="title"><b>Example&nbsp;3.9.&nbsp;Explicitly enabling Hibernate Search by configuring the
                           <code class="classname">FullTextIndexEventListener</code></b></p>
                     <div class="example-contents"><pre class="programlisting">&lt;hibernate-configuration&gt;
     &lt;session-factory&gt;
        ...
        &lt;event type="post-update"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-insert"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-delete"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-recreate"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-remove"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-update"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="flush"&gt;
            &lt;listener class="org.hibernate.event.def.DefaultFlushEventListener"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre></div>
                  </div><br class="example-break"></div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e1233"></a>3.7.2.&nbsp;Automatic indexing
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>By default, every time an object is inserted, updated or deleted
                     through Hibernate, Hibernate Search updates the according Lucene index.
                     It is sometimes desirable to disable that features if either your index
                     is read-only or if index updates are done in a batch way (see <a href="#search-batchindex" title="Chapter&nbsp;6.&nbsp;Manual indexing">Chapter&nbsp;6, <i xmlns:xlink="http://www.w3.org/1999/xlink">Manual indexing</i></a>).
                  </p>
                  <p>To disable event based indexing, set</p><pre class="programlisting">hibernate.search.indexing_strategy manual</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Note</h3>
                     <p>In most case, the JMS backend provides the best of both world, a
                        lightweight event based system keeps track of all changes in the
                        system, and the heavyweight indexing process is done by a separate
                        process or machine.
                     </p>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="lucene-indexing-performance"></a>3.8.&nbsp;Tuning Lucene indexing performance
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Hibernate Search allows you to tune the Lucene indexing performance
                  by specifying a set of parameters which are passed through to underlying
                  Lucene <code class="literal">IndexWriter</code> such as
                  <code class="literal">mergeFactor</code>, <code class="literal">maxMergeDocs</code> and
                  <code class="literal">maxBufferedDocs</code>. You can specify these parameters
                  either as default values applying for all indexes, on a per index basis,
                  or even per shard.
               </p>
               <p>There are two sets of parameters allowing for different performance
                  settings depending on the use case. During indexing operations triggered
                  by database modifications, the parameters are grouped by the
                  <code class="literal">transaction</code> keyword: 
               </p><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.transaction.&lt;parameter_name&gt;</pre><p>
                  When indexing occurs via <code class="literal">FullTextSession.index()</code> (see
                  <a href="#search-batchindex" title="Chapter&nbsp;6.&nbsp;Manual indexing">Chapter&nbsp;6, <i xmlns:xlink="http://www.w3.org/1999/xlink">Manual indexing</i></a>), the used properties are those
                  grouped under the <code class="literal">batch</code> keyword: 
               </p><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.&lt;parameter_name&gt;</pre><p>Unless the corresponding <code class="literal">.batch</code> property is
                  explicitly set, the value will default to the
                  <code class="literal">.transaction</code> property. If no value is set for a
                  <code class="literal">.batch</code> value in a specific shard configuration,
                  Hibernate Search will look at the index section, then at the default
                  section and after that it will look for a <code class="literal">.transaction</code>
                  in the same order: 
               </p><pre class="programlisting">hibernate.search.Animals.2.indexwriter.transaction.max_merge_docs 10
hibernate.search.Animals.2.indexwriter.transaction.merge_factor 20
hibernate.search.default.indexwriter.batch.max_merge_docs 100</pre><p>
                  This configuration will result in these settings applied to the second
                  shard of Animals index:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p><code class="literal">transaction.max_merge_docs</code> = 10
                        </p>
                     </li>
                     <li>
                        <p><code class="literal">batch.max_merge_docs</code> = 100
                        </p>
                     </li>
                     <li>
                        <p><code class="literal">transaction.merge_factor</code> = 20
                        </p>
                     </li>
                     <li>
                        <p><code class="literal">batch.merge_factor</code> = 20
                        </p>
                     </li>
                  </ul>
               </div>
               <p>All other values will use the defaults defined in Lucene.</p>
               <p>The default for all values is to leave them at Lucene's own default,
                  so the listed values in the following table actually depend on the version
                  of Lucene you are using; values shown are relative to version
                  <code class="literal">2.4</code>. For more information about Lucene indexing
                  performances, please refer to the Lucene documentation.
               </p>
               <div class="table"><a name="d0e1327"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;List of indexing performance and behavior properties</b></p>
                  <div class="table-contents">
                     <table summary="List of indexing performance and behavior properties" border="1">
                        <colgroup>
                           <col>
                           <col>
                           <col>
                        </colgroup>
                        <thead>
                           <tr>
                              <th align="center">Property</th>
                              <th align="center">Description</th>
                              <th align="center">Default Value</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_delete_terms</code></td>
                              <td>
                                 <p>Determines the minimal number of delete terms
                                    required before the buffered in-memory delete terms are applied
                                                and flushed. If there are documents buffered in memory at the
                                                time, they are merged and a new segment is created.
                                 </p>
                              </td>
                              <td>Disabled (flushes by RAM usage)</td>
                           </tr>
                           <tr>
                              <td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_docs</code></td>
                              <td>
                                 <p>Controls the amount of documents buffered in memory
                                                during indexing. The bigger the more RAM is
                                                consumed.
                                 </p>
                              </td>
                              <td>Disabled (flushes by RAM usage)</td>
                           </tr>
                           <tr>
                              <td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_field_length</code></td>
                              <td>
                                 <p>The maximum number of terms that will be indexed for
                                                a single field. This limits the amount of memory required for
                                                indexing so that very large data will not crash the indexing
                                                process by running out of memory. This setting refers to the
                                                number of running terms, not to the number of different
                                                terms.
                                 </p> 
                                 <p>This silently truncates large documents,
                                                excluding from the index all terms that occur further in the
                                                document. If you know your source documents are large, be sure to
                                                set this value high enough to accommodate the expected size. If you
                                                set it to Integer.MAX_VALUE, then the only limit is your memory,
                                                but you should anticipate an OutOfMemoryError. 
                                 </p> 
                                 <p>If
                                                setting this value in <code class="literal">batch</code> differently than in
                                                <code class="literal">transaction</code> you may get different data (and
                                                results) in your index depending on the indexing
                                                mode.
                                 </p>
                              </td>
                              <td>10000</td>
                           </tr>
                           <tr>
                              <td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_merge_docs</code></td>
                              <td>
                                 <p>Defines the largest number of documents allowed in a
                                                segment. Larger values are best for batched indexing and speedier
                                                searches. Small values are best for transaction
                                                indexing.
                                 </p>
                              </td>
                              <td>Unlimited (Integer.MAX_VALUE)</td>
                           </tr>
                           <tr>
                              <td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].merge_factor</code></td>
                              <td>
                                 <p>Controls segment merge frequency and size. </p>
                                             
                                 <p>Determines how often segment indexes are merged when
                                                insertion occurs. With smaller values, less RAM is used while
                                                indexing, and searches on unoptimized indexes are faster, but
                                                indexing speed is slower. With larger values, more RAM is used
                                                during indexing, and while searches on unoptimized indexes are
                                                slower, indexing is faster. Thus larger values (&gt; 10) are best
                                                for batch index creation, and smaller values (&lt; 10) for indexes
                                                that are interactively maintained. The value must no be lower than
                                                2.
                                 </p>
                              </td>
                              <td>10</td>
                           </tr>
                           <tr>
                              <td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].ram_buffer_size</code></td>
                              <td>
                                 <p>Controls the amount of RAM in MB dedicated to
                                                document buffers. When used together max_buffered_docs a flush
                                                occurs for whichever event happens first.
                                 </p> 
                                 <p>Generally
                                                for faster indexing performance it's best to flush by RAM usage
                                                instead of document count and use as large a RAM buffer as you
                                                can.
                                 </p>
                              </td>
                              <td>16 MB</td>
                           </tr>
                           <tr>
                              <td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].term_index_interval</code></td>
                              <td>
                                 <p>Expert: Set the interval between indexed
                                                terms.
                                 </p> 
                                 <p>Large values cause less memory to be used by
                                                IndexReader, but slow random-access to terms. Small values cause
                                                more memory to be used by an IndexReader, and speed random-access
                                                to terms. See Lucene documentation for more
                                                details.
                                 </p>
                              </td>
                              <td>128</td>
                           </tr>
                           <tr>
                              <td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].use_compound_file</code></td>
                              <td>The advantage of using the compound file format is that
                                             less file descriptors are used. The disadvantage is that indexing
                                             takes more time and temporary disk space. You can set this
                                             parameter to <code class="literal">false</code> in an attempt to improve the
                                             indexing time, but you could run out of file descriptors if
                                             <code class="literal">mergeFactor</code> is also
                                             large.
                                 <p></p>
                                 <p>Boolean parameter, use
                                                "<code class="literal">true</code>" or "<code class="literal">false</code>". The
                                                default value for this option is
                                                <code class="literal">true</code>.
                                 </p>
                              </td>
                              <td>true</td>
                           </tr>
                        </tbody>
                     </table>
                  </div>
               </div><br class="table-break"></div>
         </div>
         <div class="chapter" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="search-mapping"></a>Chapter&nbsp;4.&nbsp;Mapping entities to the index structure
                     </h2>
                  </div>
               </div>
            </div>
            <p>All the metadata information needed to index entities is described
               through annotations. There is no need for xml mapping files. In fact there
               is currently no xml configuration option available (see <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://opensource.atlassian.com/projects/hibernate/browse/HSEARCH-210" target="_top">HSEARCH-210</a>).
               You can still use hibernate mapping files for the basic Hibernate
               configuration, but the Search specific configuration has to be expressed via
               annotations.
            </p>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="search-mapping-entity"></a>4.1.&nbsp;Mapping an entity
                        </h2>
                     </div>
                  </div>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="basic-mapping"></a>4.1.1.&nbsp;Basic mapping
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>First, we must declare a persistent class as indexable. This is
                     done by annotating the class with <code class="literal">@Indexed</code> (all
                     entities not annotated with <code class="literal">@Indexed</code> will be ignored
                     by the indexing process):
                  </p>
                  <div class="example"><a name="d0e1474"></a><p class="title"><b>Example&nbsp;4.1.&nbsp;Making a class indexable using the
                           <code class="classname">@Indexed</code> annotation</b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
<span class="bold"><strong>@Indexed(index="indexes/essays")</strong></span>
public class Essay {
    ...
}</pre></div>
                  </div><br class="example-break"><p>The <code class="literal">index</code> attribute tells Hibernate what the
                     Lucene directory name is (usually a directory on your file system). It
                     is recommended to define a base directory for all Lucene indexes using
                     the <code class="literal">hibernate.search.default.indexBase</code> property in
                     your configuration file. Alternatively you can specify a base directory
                     per indexed entity by specifying
                     <code class="literal">hibernate.search.&lt;index&gt;.indexBase, </code>where
                     <code class="literal">&lt;index&gt;</code> is the fully qualified classname of the
                     indexed entity. Each entity instance will be represented by a Lucene
                     <code class="classname">Document</code> inside the given index (aka
                     Directory).
                  </p>
                  <p>For each property (or attribute) of your entity, you have the
                     ability to describe how it will be indexed. The default (no annotation
                     present) means that the property is completely ignored by the indexing
                     process. <code class="literal">@Field</code> does declare a property as indexed.
                     When indexing an element to a Lucene document you can specify how it is
                     indexed:
                  </p>
                  <div class="itemizedlist">
                     <ul type="disc">
                        <li>
                           <p><code class="literal">name</code> : describe under which name, the
                              property should be stored in the Lucene Document. The default value
                              is the property name (following the JavaBeans convention)
                           </p>
                        </li>
                        <li>
                           <p><code class="literal">store</code> : describe whether or not the
                              property is stored in the Lucene index. You can store the value
                              <code class="literal">Store.YES</code> (consuming more space in the index but
                              allowing projection, see <a href="#projections" title="5.1.2.5.&nbsp;Projection">Section&nbsp;5.1.2.5, &#8220;Projection&#8221;</a> for more
                              information), store it in a compressed way
                              <code class="literal">Store.COMPRESS</code> (this does consume more CPU), or
                              avoid any storage <code class="literal">Store.NO</code> (this is the default
                              value). When a property is stored, you can retrieve its original
                              value from the Lucene Document. This is not related to whether the
                              element is indexed or not.
                           </p>
                        </li>
                        <li>
                           <p>index: describe how the element is indexed and the type of
                              information store. The different values are
                              <code class="literal">Index.NO</code> (no indexing, ie cannot be found by a
                              query), <code class="literal">Index.TOKENIZED</code> (use an analyzer to
                              process the property), <code class="literal">Index.UN_TOKENIZED</code> (no
                              analyzer pre-processing), <code class="literal">Index.NO_NORMS</code> (do not
                              store the normalization data). The default value is
                              <code class="literal">TOKENIZED</code>.
                           </p>
                        </li>
                        <li>
                           <p>termVector: describes collections of term-frequency pairs.
                              This attribute enables term vectors being stored during indexing so
                              they are available within documents. The default value is
                              TermVector.NO.
                           </p>
                           <p>The different values of this attribute are:</p>
                           <div class="informaltable">
                              <table border="1">
                                 <colgroup>
                                    <col>
                                    <col>
                                 </colgroup>
                                 <thead>
                                    <tr>
                                       <th align="center">Value</th>
                                       <th align="center">Definition</th>
                                    </tr>
                                 </thead>
                                 <tbody>
                                    <tr>
                                       <td align="left">TermVector.YES</td>
                                       <td align="left">Store the term vectors of each document. This
                                          produces two synchronized arrays, one contains document
                                          terms and the other contains the term's frequency.
                                       </td>
                                    </tr>
                                    <tr>
                                       <td align="left">TermVector.NO</td>
                                       <td align="left">Do not store term vectors.</td>
                                    </tr>
                                    <tr>
                                       <td align="left">TermVector.WITH_OFFSETS</td>
                                       <td align="left">Store the term vector and token offset information.
                                                            This is the same as TermVector.YES plus it contains the
                                                            starting and ending offset position information for the
                                                            terms.
                                       </td>
                                    </tr>
                                    <tr>
                                       <td align="left">TermVector.WITH_POSITIONS</td>
                                       <td align="left">Store the term vector and token position information.
                                                            This is the same as TermVector.YES plus it contains the
                                                            ordinal positions of each occurrence of a term in a
                                                            document.
                                       </td>
                                    </tr>
                                    <tr>
                                       <td align="left">TermVector.WITH_POSITION_OFFSETS</td>
                                       <td align="left">Store the term vector, token position and offset
                                                            information. This is a combination of the YES, WITH_OFFSETS
                                                            and WITH_POSITIONS.
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <p>Whether or not you want to store the original data in the index
                     depends on how you wish to use the index query result. For a regular
                     Hibernate Search usage storing is not necessary. However you might want
                     to store some fields to subsequently project them (see <a href="#projections" title="5.1.2.5.&nbsp;Projection">Section&nbsp;5.1.2.5, &#8220;Projection&#8221;</a> for more information).
                  </p>
                  <p>Whether or not you want to tokenize a property depends on whether
                     you wish to search the element as is, or by the words it contains. It
                     make sense to tokenize a text field, but tokenizing a date field
                     probably not. Note that fields used for sorting must not be
                     tokenized.
                  </p>
                  <p>Finally, the id property of an entity is a special property used
                     by Hibernate Search to ensure index unicity of a given entity. By
                     design, an id has to be stored and must not be tokenized. To mark a
                     property as index id, use the <code class="literal">@DocumentId</code> annotation.
                     If you are using Hibernate Annotations and you have specified @Id you
                     can omit @DocumentId. The chosen entity id will also be used as document
                     id.
                  </p>
                  <div class="example"><a name="d0e1597"></a><p class="title"><b>Example&nbsp;4.2.&nbsp;Adding <code class="classname">@DocumentId</code> ad
                                   <code class="classname">@Field</code> annotations to an indexed entity</b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
public class Essay {
    ...

    @Id
    <span class="bold"><strong>@DocumentId</strong></span>
    public Long getId() { return id; }

    <span class="bold"><strong>@Field(name="Abstract", index=Index.TOKENIZED, store=Store.YES)</strong></span>
    public String getSummary() { return summary; }

    @Lob
    <span class="bold"><strong>@Field(index=Index.TOKENIZED)</strong></span>
    public String getText() { return text; }
}</pre></div>
                  </div><br class="example-break"><p>The above annotations define an index with three fields:
                     <code class="literal">id</code> , <code class="literal">Abstract</code> and
                     <code class="literal">text</code> . Note that by default the field name is
                     decapitalized, following the JavaBean specification
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e1628"></a>4.1.2.&nbsp;Mapping properties multiple times
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Sometimes one has to map a property multiple times per index, with
                     slightly different indexing strategies. For example, sorting a query by
                     field requires the field to be <code class="literal">UN_TOKENIZED</code>. If one
                     wants to search by words in this property and still sort it, one need to
                     index it twice - once tokenized and once untokenized. @Fields allows to
                     achieve this goal.
                  </p>
                  <div class="example"><a name="d0e1636"></a><p class="title"><b>Example&nbsp;4.3.&nbsp;Using @Fields to map a property multiple times</b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index = "Book" )
public class Book {
    <span class="bold"><strong>@Fields( {</strong></span>
            @Field(index = Index.TOKENIZED),
            @Field(name = "summary_forSort", index = Index.UN_TOKENIZED, store = Store.YES)
            <span class="bold"><strong>} )</strong></span>
    public String getSummary() {
        return summary;
    }

    ...
}</pre></div>
                  </div><br class="example-break"><p>The field <code class="literal">summary</code> is indexed twice, once as
                     <code class="literal">summary</code> in a tokenized way, and once as
                     <code class="literal">summary_forSort</code> in an untokenized way. @Field
                     supports 2 attributes useful when @Fields is used:
                  </p>
                  <div class="itemizedlist">
                     <ul type="disc">
                        <li>
                           <p>analyzer: defines a @Analyzer annotation per field rather than
                              per property
                           </p>
                        </li>
                        <li>
                           <p>bridge: defines a @FieldBridge annotation per field rather
                              than per property
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p>See below for more information about analyzers and field
                     bridges.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="search-mapping-associated"></a>4.1.3.&nbsp;Embedded and associated objects
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Associated objects as well as embedded objects can be indexed as
                     part of the root entity index. This is useful if you expect to search a
                     given entity based on properties of associated objects. In the following
                     example the aim is to return places where the associated city is Atlanta
                     (In the Lucene query parser language, it would translate into
                     <code class="code">address.city:Atlanta</code>).
                  </p>
                  <div class="example"><a name="d0e1675"></a><p class="title"><b>Example&nbsp;4.4.&nbsp;Using @IndexedEmbedded to index associations</b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field( index = Index.TOKENIZED )
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <span class="bold"><strong>@IndexedEmbedded</strong></span>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field(index=Index.TOKENIZED)
    private String street;

    @Field(index=Index.TOKENIZED)
    private String city;

    <span class="bold"><strong>@ContainedIn</strong></span>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</pre></div>
                  </div><br class="example-break"><p>In this example, the place fields will be indexed in the
                     <code class="literal">Place</code> index. The <code class="literal">Place</code> index
                     documents will also contain the fields <code class="literal">address.id</code>,
                     <code class="literal">address.street</code>, and <code class="literal">address.city</code>
                     which you will be able to query. This is enabled by the
                     <code class="literal">@IndexedEmbedded</code> annotation.
                  </p>
                  <p>Be careful. Because the data is denormalized in the Lucene index
                     when using the <code class="classname">@IndexedEmbedded</code> technique,
                     Hibernate Search needs to be aware of any change in the
                     <code class="classname">Place</code> object and any change in the
                     <code class="classname">Address</code> object to keep the index up to date. To
                     make sure the <code class="literal"><code class="classname">Place</code></code> Lucene
                     document is updated when it's <code class="classname">Address</code> changes,
                     you need to mark the other side of the bidirectional relationship with
                     <code class="classname">@ContainedIn</code>.
                  </p>
                  <p><code class="literal">@ContainedIn</code> is only useful on associations
                     pointing to entities as opposed to embedded (collection of)
                     objects.
                  </p>
                  <p>Let's make our example a bit more complex:</p>
                  <div class="example"><a name="d0e1733"></a><p class="title"><b>Example&nbsp;4.5.&nbsp;Nested usage of <code class="classname">@IndexedEmbedded</code> and
                                   <code class="classname">@ContainedIn</code></b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field( index = Index.TOKENIZED )
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <span class="bold"><strong>@IndexedEmbedded</strong></span>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field(index=Index.TOKENIZED)
    private String street;

    @Field(index=Index.TOKENIZED)
    private String city;

    <span class="bold"><strong>@IndexedEmbedded(depth = 1, prefix = "ownedBy_")</strong></span>
    private Owner ownedBy;

    <span class="bold"><strong>@ContainedIn</strong></span>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}

@Embeddable
public class Owner {
    @Field(index = Index.TOKENIZED)
    private String name;
   ...
}</pre></div>
                  </div><br class="example-break"><p>Any <code class="literal">@*ToMany, @*ToOne</code> and
                     <code class="literal">@Embedded</code> attribute can be annotated with
                     <code class="literal">@IndexedEmbedded</code>. The attributes of the associated
                     class will then be added to the main entity index. In the previous
                     example, the index will contain the following fields
                  </p>
                  <div class="itemizedlist">
                     <ul type="disc">
                        <li>
                           <p>id</p>
                        </li>
                        <li>
                           <p>name</p>
                        </li>
                        <li>
                           <p>address.street</p>
                        </li>
                        <li>
                           <p>address.city</p>
                        </li>
                        <li>
                           <p>address.ownedBy_name</p>
                        </li>
                     </ul>
                  </div>
                  <p>The default prefix is <code class="literal">propertyName.</code>, following
                     the traditional object navigation convention. You can override it using
                     the <code class="literal">prefix</code> attribute as it is shown on the
                     <code class="literal">ownedBy</code> property.
                  </p>
                  <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Note</h3>
                     <p>The prefix cannot be set to the empty string.</p>
                  </div>
                  <p>The<code class="literal"> depth</code> property is necessary when the object
                     graph contains a cyclic dependency of classes (not instances). For
                     example, if <code class="classname">Owner</code> points to
                     <code class="classname">Place</code>. Hibernate Search will stop including
                     Indexed embedded attributes after reaching the expected depth (or the
                     object graph boundaries are reached). A class having a self reference is
                     an example of cyclic dependency. In our example, because
                     <code class="literal">depth</code> is set to 1, any
                     <code class="literal">@IndexedEmbedded</code> attribute in Owner (if any) will be
                     ignored.
                  </p>
                  <p>Using <code class="literal">@IndexedEmbedded</code> for object associations
                     allows you to express queries such as:
                  </p>
                  <div class="itemizedlist">
                     <ul type="disc">
                        <li>
                           <p>Return places where name contains JBoss and where address city
                              is Atlanta. In Lucene query this would be
                           </p><pre class="programlisting">+name:jboss +address.city:atlanta  </pre></li>
                        <li>
                           <p>Return places where name contains JBoss and where owner's name
                              contain Joe. In Lucene query this would be
                           </p><pre class="programlisting">+name:jboss +address.orderBy_name:joe  </pre></li>
                     </ul>
                  </div>
                  <p>In a way it mimics the relational join operation in a more
                     efficient way (at the cost of data duplication). Remember that, out of
                     the box, Lucene indexes have no notion of association, the join
                     operation is simply non-existent. It might help to keep the relational
                     model normalized while benefiting from the full text index speed and
                     feature richness.
                  </p>
                  <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Note</h3>
                     <p>An associated object can itself (but does not have to) be
                        <code class="literal">@Indexed</code></p>
                  </div>
                  <p>When @IndexedEmbedded points to an entity, the association has to
                     be directional and the other side has to be annotated
                     <code class="literal">@ContainedIn</code> (as seen in the previous example). If
                     not, Hibernate Search has no way to update the root index when the
                     associated entity is updated (in our example, a <code class="literal">Place</code>
                     index document has to be updated when the associated
                     <code class="classname">Address</code> instance is updated).
                  </p>
                  <p>Sometimes, the object type annotated by
                     <code class="classname">@IndexedEmbedded</code> is not the object type targeted
                     by Hibernate and Hibernate Search. This is especially the case when
                     interfaces are used in lieu of their implementation. For this reason you
                     can override the object type targeted by Hibernate Search using the
                     <code class="methodname">targetElement</code> parameter.
                  </p>
                  <div class="example"><a name="d0e1853"></a><p class="title"><b>Example&nbsp;4.6.&nbsp;Using the <code class="literal">targetElement</code> property of
                                   <code class="classname">@IndexedEmbedded</code></b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field(index= Index.TOKENIZED)
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", <span class="bold"><strong>targetElement = Owner.class</strong></span>)
    @Target(Owner.class)
    private Person ownedBy;


    ...
}

@Embeddable
public class Owner implements Person { ... }</pre></div>
                  </div><br class="example-break"></div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e1866"></a>4.1.4.&nbsp;Boost factor
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Lucene has the notion of <span class="emphasis"><em>boost factor</em></span>. It's a
                     way to give more weight to a field or to an indexed element over others
                     during the indexation process. You can use <code class="literal">@Boost</code> at
                     the @Field, method or class level.
                  </p>
                  <div class="example"><a name="d0e1877"></a><p class="title"><b>Example&nbsp;4.7.&nbsp;Using different ways of increasing the weight of an indexed
                           element using a boost factor</b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
<span class="bold"><strong>@Boost(1.7f)</strong></span>
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", index=Index.TOKENIZED, store=Store.YES, boost=<span class="bold"><strong>@Boost(2f)</strong></span>)
    <span class="bold"><strong>@Boost(1.5f)</strong></span>
    public String getSummary() { return summary; }

    @Lob
    @Field(index=Index.TOKENIZED, boost=<span class="bold"><strong>@Boost(1.2f)</strong></span>)
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }

}        </pre></div>
                  </div><br class="example-break"><p>In our example, <code class="classname">Essay</code>'s probability to
                     reach the top of the search list will be multiplied by 1.7. The
                     <code class="methodname">summary</code> field will be 3.0 (2 * 1.5 -
                     <code class="methodname">@Field.boost</code> and <code class="classname">@Boost</code>
                     on a property are cumulative) more important than the
                     <code class="methodname">isbn</code> field. The <code class="methodname">text</code>
                     field will be 1.2 times more important than the
                     <code class="methodname">isbn</code> field. Note that this explanation in
                     strictest terms is actually wrong, but it is simple and close enough to
                     reality for all practical purposes. Please check the Lucene
                     documentation or the excellent <em class="citetitle">Lucene In Action </em>
                     from Otis Gospodnetic and Erik Hatcher.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="analyzer"></a>4.1.5.&nbsp;Analyzer
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>The default analyzer class used to index tokenized fields is
                     configurable through the <code class="literal">hibernate.search.analyzer</code>
                     property. The default value for this property is
                     <code class="classname">org.apache.lucene.analysis.standard.StandardAnalyzer</code>.
                  </p>
                  <p>You can also define the analyzer class per entity, property and
                     even per @Field (useful when multiple fields are indexed from a single
                     property).
                  </p>
                  <div class="example"><a name="d0e1933"></a><p class="title"><b>Example&nbsp;4.8.&nbsp;Different ways of specifying an analyzer</b></p>
                     <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
<span class="bold"><strong>@Analyzer(impl = EntityAnalyzer.class)</strong></span>
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field(index = Index.TOKENIZED)
    private String name;

    @Field(index = Index.TOKENIZED)
    <span class="bold"><strong>@Analyzer(impl = PropertyAnalyzer.class)</strong></span>
    private String summary;

    @Field(index = Index.TOKENIZED, <span class="emphasis"><em><span class="bold"><strong>analyzer = @Analyzer(impl = FieldAnalyzer.class</strong></span>)</em></span>
    private String body;

    ...
}</pre></div>
                  </div><br class="example-break"><p>In this example, <code class="classname">EntityAnalyzer</code> is used to
                     index all tokenized properties (eg. <code class="literal">name</code>), except
                     <code class="literal">summary</code> and <code class="literal">body</code> which are indexed
                     with <code class="classname">PropertyAnalyzer</code> and
                     <code class="classname">FieldAnalyzer</code> respectively.
                  </p>
                  <div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Caution</h3>
                     <p>Mixing different analyzers in the same entity is most of the
                        time a bad practice. It makes query building more complex and results
                        less predictable (for the novice), especially if you are using a
                        QueryParser (which uses the same analyzer for the whole query). As a
                        rule of thumb, for any given field the same analyzer should be used
                        for indexing and querying.
                     </p>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e1972"></a>4.1.5.1.&nbsp;Analyzer definitions
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>Analyzers can become quite complex to deal with for which reason
                        Hibernate Search introduces the notion of analyzer definitions. An
                        analyzer definition can be reused by many
                        <code class="classname">@Analyzer</code> declarations. An analyzer definition
                        is composed of:
                     </p>
                     <div class="itemizedlist">
                        <ul type="disc">
                           <li>
                              <p>a name: the unique string used to refer to the
                                 definition
                              </p>
                           </li>
                           <li>
                              <p>a tokenizer: responsible for tokenizing the input stream
                                 into individual words
                              </p>
                           </li>
                           <li>
                              <p>a list of filters: each filter is responsible to remove,
                                 modify or sometimes even add words into the stream provided by the
                                 tokenizer
                              </p>
                           </li>
                        </ul>
                     </div>
                     <p>This separation of tasks - a tokenizer followed by a list of
                        filters - allows for easy reuse of each individual component and let
                        you build your customized analyzer in a very flexible way (just like
                        Lego). Generally speaking the <code class="classname">Tokenizer</code> starts
                        the analysis process by turning the character input into tokens which
                        are then further processed by the <code class="classname">TokenFilter</code>s.
                        Hibernate Search supports this infrastructure by utilizing the Solr
                        analyzer framework. Make sure to add<code class="filename"> solr-core.jar and
                           </code><code class="filename">solr-common.jar</code> to your classpath to
                        use analyzer definitions. In case you also want to utilizing a
                        snowball stemmer also include the
                        <code class="filename">lucene-snowball.jar.</code> Other Solr analyzers might
                        depend on more libraries. For example, the
                        <code class="classname">PhoneticFilterFactory</code> depends on <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://commons.apache.org/codec" target="_top">commons-codec</a>. Your
                        distribution of Hibernate Search provides these dependencies in its
                        <code class="filename">lib</code> directory.
                     </p>
                     <div class="example"><a name="d0e2015"></a><p class="title"><b>Example&nbsp;4.9.&nbsp;<code class="classname">@AnalyzerDef</code> and the Solr
                                        framework</b></p>
                        <div class="example-contents"><pre class="programlisting">@AnalyzerDef(name="customanalyzer",
        tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
        filters = {
                @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
                @TokenFilterDef(factory = LowerCaseFilterFactory.class),
                @TokenFilterDef(factory = StopFilterFactory.class, params = {
                    @Parameter(name="words", value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
                    @Parameter(name="ignoreCase", value="true")
                })
})
public class Team {
    ...
}</pre></div>
                     </div><br class="example-break"><p>A tokenizer is defined by its factory which is responsible for
                        building the tokenizer and using the optional list of parameters. This
                        example use the standard tokenizer. A filter is defined by its factory
                        which is responsible for creating the filter instance using the
                        optional parameters. In our example, the StopFilter filter is built
                        reading the dedicated words property file and is expected to ignore
                        case. The list of parameters is dependent on the tokenizer or filter
                        factory.
                     </p>
                     <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <h3 class="title">Warning</h3>
                        <p>Filters are applied in the order they are defined in the
                           <code class="classname">@AnalyzerDef</code> annotation. Make sure to think
                           twice about this order.
                        </p>
                     </div>
                     <p>Once defined, an analyzer definition can be reused by an
                        <code class="classname">@Analyzer</code> declaration using the definition name
                        rather than declaring an implementation class.
                     </p>
                     <div class="example"><a name="d0e2035"></a><p class="title"><b>Example&nbsp;4.10.&nbsp;Referencing an analyzer by name</b></p>
                        <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field <span class="bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
    private String description;
}</pre></div>
                     </div><br class="example-break"><p>Analyzer instances declared by
                        <code class="classname">@AnalyzerDef</code> are available by their name in the
                        <code class="classname">SearchFactory</code>.
                     </p><pre class="programlisting">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</pre><p>This is quite useful wen building queries. Fields in queries
                        should be analyzed with the same analyzer used to index the field so
                        that they speak a common "language": the same tokens are reused
                        between the query and the indexing process. This rule has some
                        exceptions but is true most of the time. Respect it unless you know
                        what you are doing.
                     </p>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e2055"></a>4.1.5.2.&nbsp;Available analyzers
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>Solr and Lucene come with a lot of useful default tokenizers and
                        filters. You can find a complete list of tokenizer factories and
                        filter factories at <a xmlns:xlink="http://www.w3.org/1999/xlink" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters" target="_top">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</a>.
                        Let check a few of them.
                     </p>
                     <div class="table"><a name="d0e2063"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Some of the available tokenizers</b></p>
                        <div class="table-contents">
                           <table summary="Some of the available tokenizers" border="1">
                              <colgroup>
                                 <col>
                                 <col>
                                 <col>
                              </colgroup>
                              <thead>
                                 <tr>
                                    <th align="center">Factory</th>
                                    <th align="center">Description</th>
                                    <th align="center">parameters</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr>
                                    <td>StandardTokenizerFactory</td>
                                    <td>Use the Lucene StandardTokenizer</td>
                                    <td>none</td>
                                 </tr>
                                 <tr>
                                    <td>HTMLStripStandardTokenizerFactory</td>
                                    <td>Remove HTML tags, keep the text and pass it to a
                                                       StandardTokenizer
                                    </td>
                                    <td>none</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </div><br class="table-break"><div class="table"><a name="d0e2090"></a><p class="title"><b>Table&nbsp;4.2.&nbsp;Some of the available filters</b></p>
                        <div class="table-contents">
                           <table summary="Some of the available filters" border="1">
                              <colgroup>
                                 <col>
                                 <col>
                                 <col>
                              </colgroup>
                              <thead>
                                 <tr>
                                    <th align="center">Factory</th>
                                    <th align="center">Description</th>
                                    <th align="center">parameters</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr>
                                    <td>StandardFilterFactory</td>
                                    <td>Remove dots from acronyms and 's from words</td>
                                    <td>none</td>
                                 </tr>
                                 <tr>
                                    <td>LowerCaseFilterFactory</td>
                                    <td>Lowercase words</td>
                                    <td>none</td>
                                 </tr>
                                 <tr>
                                    <td>StopFilterFactory</td>
                                    <td>remove words (tokens) matching a list of stop
                                                       words
                                    </td>
                                    <td>
                                       <p><code class="literal">words</code>: points to a resource
                                                          file containing the stop words
                                       </p>
                                       <p>ignoreCase: true if
                                                          <code class="literal">case</code> should be ignore when comparing stop
                                                          words, <code class="literal">false</code> otherwise 
                                       </p>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td>SnowballPorterFilterFactory</td>
                                    <td>Reduces a word to it's root in a given language. (eg.
                                                       protect, protects, protection share the same root). Using such
                                                       a filter allows searches matching related words.
                                    </td>
                                    <td>
                                       <p><code class="literal">language</code>: Danish, Dutch,
                                                          English, Finnish, French, German, Italian, Norwegian,
                                                          Portuguese, Russian, Spanish, Swedish
                                       </p>and a few
                                                       more
                                    </td>
                                 </tr>
                                 <tr>
                                    <td>ISOLatin1AccentFilterFactory</td>
                                    <td>remove accents for languages like French</td>
                                    <td>none</td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </div><br class="table-break"><p>We recommend to check all the implementations of
                        <code class="classname">org.apache.solr.analysis.TokenizerFactory</code> and
                        <code class="classname">org.apache.solr.analysis.TokenFilterFactory</code> in
                        your IDE to see the implementations available.
                     </p>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e2161"></a>4.1.5.3.&nbsp;Analyzer discriminator (experimental)
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>So far all the introduced ways to specify an analyzer were
                        static. However, there are use cases where it is useful to select an
                        analyzer depending on the current state of the entity to be indexed,
                        for example in multilingual application. For an
                        <code class="classname">BlogEntry</code> class for example the analyzer could
                        depend on the language property of the entry. Depending on this
                        property the correct language specific stemmer should be chosen to
                        index the actual text.
                     </p>
                     <p>To enable this dynamic analyzer selection Hibernate Search
                        introduces the <code class="classname">AnalyzerDiscriminator</code>
                        annotation. The following example demonstrates the usage of this
                        annotation:
                     </p>
                     <div class="example"><a name="d0e2175"></a><p class="title"><b>Example&nbsp;4.11.&nbsp;Usage of @AnalyzerDiscriminator in order to select an
                              analyzer depending on the entity state</b></p>
                        <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class
      )
    }),
  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
    })
})
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;
    
    @Field
    private String text;
    
    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    ...
}</pre><pre class="programlisting">public class LanguageDiscriminator implements Discriminator {

    public String getAnanyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof Article ) ) {
            return null;
        }
        return (String) value;
    }
}</pre></div>
                     </div>
                     <p><br class="example-break">The prerequisite for using
                        <code class="classname">@AnalyzerDiscriminator</code> is that all analyzers
                        which are going to be used are predefined via
                        <code class="classname">@AnalyzerDef</code> definitions. If this is the case
                        one can place the <code class="classname">@AnalyzerDiscriminator</code>
                        annotation either on the class or on a specific property of the entity
                        for which to dynamically select an analyzer. Via the
                        <code class="literal">impl</code> parameter of the
                        <code class="classname">AnalyzerDiscriminator</code> you specify a concrete
                        implementation of the <code class="classname">Discriminator</code> interface.
                        It is up to you to provide an implementation for this interface. The
                        only method you have to implement is
                        <code class="classname">getAnanyzerDefinitionName()</code> which gets called
                        for each field added to the Lucene document. The entity which is
                        getting indexed is also passed to the interface method. The
                        <code class="literal">value</code> parameter is only set if the
                        <code class="classname">AnalyzerDiscriminator</code> is placed on property
                        level instead of class level. In this case the value represents the
                        current value of this property.
                     </p>
                     <p>An implemention of the <code class="classname">Discriminator</code>
                        interface has to return the name of an existing analyzer definition if
                        the analyzer should be set dynamically or <code class="classname">null</code>
                        if the default analyzer should not be overridden. The given example
                        assumes that the language parameter is either 'de' or 'en' which
                        matches the specified names in the
                        <code class="classname">@AnalyzerDef</code>s.
                     </p>
                     <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <h3 class="title">Note</h3>
                        <p>The <code class="classname">@AnalyzerDiscriminator</code> is currently
                           still experimental and the API might still change. We are hoping for
                           some feedback from the community about the usefulness and usability
                           of this feature.
                        </p>
                     </div>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="analyzer-retrievinganalyzer"></a>4.1.5.4.&nbsp;Retrieving an analyzer
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>During indexing time, Hibernate Search is using analyzers under
                        the hood for you. In some situations, retrieving analyzers can be
                        handy. If your domain model makes use of multiple analyzers (maybe to
                        benefit from stemming, use phonetic approximation and so on), you need
                        to make sure to use the same analyzers when you build your
                        query.
                     </p>
                     <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <h3 class="title">Note</h3>
                        <p>This rule can be broken but you need a good reason for it. If
                           you are unsure, use the same analyzers.
                        </p>
                     </div>
                     <p>You can retrieve the scoped analyzer for a given entity used at
                        indexing time by Hibernate Search. A scoped analyzer is an analyzer
                        which applies the right analyzers depending on the field indexed:
                        multiple analyzers can be defined on a given entity each one working
                        on an individual field, a scoped analyzer unify all these analyzers
                        into a context-aware analyzer. While the theory seems a bit complex,
                        using the right analyzer in a query is very easy.
                     </p>
                     <div class="example"><a name="d0e2237"></a><p class="title"><b>Example&nbsp;4.12.&nbsp;Using the scoped analyzer when building a full-text
                              query</b></p>
                        <div class="example-contents"><pre class="programlisting">org.apache.lucene.queryParser.QueryParser parser = new QueryParser(
    "title", 
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery = 
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects    </pre></div>
                     </div><br class="example-break"><p>In the example above, the song title is indexed in two fields:
                        the standard analyzer is used in the field <code class="literal">title</code>
                        and a stemming analyzer is used in the field
                        <code class="literal">title_stemmed</code>. By using the analyzer provided by
                        the search factory, the query uses the appropriate analyzer depending
                        on the field targeted.
                     </p>
                     <p>If your query targets more that one query and you wish to use
                        your standard analyzer, make sure to describe it using an analyzer
                        definition. You can retrieve analyzers by their definition name using
                        <code class="code">searchFactory.getAnalyzer(String)</code>.
                     </p>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="search-mapping-bridge"></a>4.2.&nbsp;Property/Field Bridge
                        </h2>
                     </div>
                  </div>
               </div>
               <p>In Lucene all index fields have to be represented as Strings. For
                  this reason all entity properties annotated with <code class="literal">@Field</code>
                  have to be indexed in a String form. For most of your properties,
                  Hibernate Search does the translation job for you thanks to a built-in set
                  of bridges. In some cases, though you need a more fine grain control over
                  the translation process.
               </p>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e2263"></a>4.2.1.&nbsp;Built-in bridges
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Hibernate Search comes bundled with a set of built-in bridges
                     between a Java property type and its full text representation.
                  </p>
                  <div class="variablelist">
                     <dl>
                        <dt><span class="term">null</span></dt>
                        <dd>
                           <p>null elements are not indexed. Lucene does not support null
                              elements and this does not make much sense either.
                           </p>
                        </dd>
                        <dt><span class="term">java.lang.String</span></dt>
                        <dd>
                           <p>String are indexed as is</p>
                        </dd>
                        <dt><span class="term">short, Short, integer, Integer, long, Long, float, Float,
                              double, Double, BigInteger, BigDecimal</span></dt>
                        <dd>
                           <p>Numbers are converted in their String representation. Note
                              that numbers cannot be compared by Lucene (ie used in ranged
                              queries) out of the box: they have to be padded 
                           </p>
                           <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                              <h3 class="title">Note</h3>
                              <p>Using a Range query is debatable and has drawbacks, an
                                 alternative approach is to use a Filter query which will
                                 filter the result query to the appropriate range.
                              </p>
                              <p>Hibernate Search will support a padding mechanism</p>
                           </div>
                        </dd>
                        <dt><span class="term">java.util.Date</span></dt>
                        <dd>
                           <p>Dates are stored as yyyyMMddHHmmssSSS in GMT time
                              (200611072203012 for Nov 7th of 2006 4:03PM and 12ms EST). You
                              shouldn't really bother with the internal format. What is
                              important is that when using a DateRange Query, you should know
                              that the dates have to be expressed in GMT time.
                           </p>
                           <p>Usually, storing the date up to the millisecond is not
                              necessary. <code class="literal">@DateBridge</code> defines the appropriate
                              resolution you are willing to store in the index ( <code class="literal">
                                 <code class="literal">@DateBridge(resolution=Resolution.DAY)</code>
                                 </code> ). The date pattern will then be truncated
                              accordingly.
                           </p><pre class="programlisting">@Entity 
@Indexed
public class Meeting {
    @Field(index=Index.UN_TOKENIZED)
    <span class="bold"><strong>@DateBridge(resolution=Resolution.MINUTE)</strong></span>
    private Date date;
    ...                 </pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                              <h3 class="title">Warning</h3>
                              <p>A Date whose resolution is lower than
                                 <code class="literal">MILLISECOND</code> cannot be a
                                 <code class="literal">@DocumentId</code></p>
                           </div>
                        </dd>
                        <dt><span class="term">java.net.URI, java.net.URL</span></dt>
                        <dd>
                           <p>URI and URL are converted to their string
                              representation
                           </p>
                        </dd>
                        <dt><span class="term">java.lang.Class</span></dt>
                        <dd>
                           <p>Class are converted to their fully qualified class name. The
                              thread context classloader is used when the class is
                              rehydrated
                           </p>
                        </dd>
                     </dl>
                  </div>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e2334"></a>4.2.2.&nbsp;Custom Bridge
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Sometimes, the built-in bridges of Hibernate Search do not cover
                     some of your property types, or the String representation used by the
                     bridge does not meet your requirements. The following paragraphs
                     describe several solutions to this problem.
                  </p>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e2339"></a>4.2.2.1.&nbsp;StringBridge
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>The simplest custom solution is to give Hibernate Search an
                        implementation of your expected
                        <span class="emphasis"><em><code class="classname">Object</code> </em></span>to
                        <code class="classname">String</code> bridge. To do so you need to implements
                        the <code class="literal">org.hibernate.search.bridge.StringBridge</code>
                        interface. All implementations have to be thread-safe as they are used
                        concurrently.
                     </p>
                     <div class="example"><a name="d0e2355"></a><p class="title"><b>Example&nbsp;4.13.&nbsp;Implementing your own
                              <code class="classname">StringBridge</code></b></p>
                        <div class="example-contents"><pre class="programlisting">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements <span class="bold"><strong>StringBridge</strong></span> {

    private int PADDING = 5;

    <span class="bold"><strong>public String objectToString(Object object)</strong></span> {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; PADDING) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; PADDING ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}                </pre></div>
                     </div><br class="example-break"><p>Then any property or field can use this bridge thanks to the
                        <code class="literal">@FieldBridge</code> annotation
                     </p><pre class="programlisting"><span class="bold"><strong>@FieldBridge(impl = PaddedIntegerBridge.class)</strong></span>
private Integer length;                </pre><p>Parameters can be passed to the Bridge implementation making it
                        more flexible. The Bridge implementation implements a
                        <code class="classname">ParameterizedBridge</code> interface, and the
                        parameters are passed through the <code class="literal">@FieldBridge</code>
                        annotation.
                     </p>
                     <div class="example"><a name="d0e2385"></a><p class="title"><b>Example&nbsp;4.14.&nbsp;Passing parameters to your bridge implementation</b></p>
                        <div class="example-contents"><pre class="programlisting">public class PaddedIntegerBridge implements StringBridge, <span class="bold"><strong>ParameterizedBridge</strong></span> {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    <span class="bold"><strong>public void setParameterValues(Map parameters)</strong></span> {
        Object padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}


//property
@FieldBridge(impl = PaddedIntegerBridge.class,
             <span class="bold"><strong>params = @Parameter(name="padding", value="10")</strong></span>
            )
private Integer length;                </pre></div>
                     </div><br class="example-break"><p>The <code class="classname">ParameterizedBridge</code> interface can be
                        implemented by <code class="classname">StringBridge</code>,
                        <code class="classname">TwoWayStringBridge</code>,
                        <code class="classname">FieldBridge</code> implementations.
                     </p>
                     <p>All implementations have to be thread-safe, but the parameters
                        are set during initialization and no special care is required at this
                        stage.
                     </p>
                     <p>If you expect to use your bridge implementation on an id
                        property (ie annotated with <code class="literal">@DocumentId</code> ), you need
                        to use a slightly extended version of <code class="literal">StringBridge</code>
                        named <code class="classname">TwoWayStringBridge</code>. Hibernate Search
                        needs to read the string representation of the identifier and generate
                        the object out of it. There is not difference in the way the
                        <code class="literal">@FieldBridge</code> annotation is used.
                     </p>
                     <div class="example"><a name="d0e2429"></a><p class="title"><b>Example&nbsp;4.15.&nbsp;Implementing a TwoWayStringBridge which can for example be
                              used for id properties</b></p>
                        <div class="example-contents"><pre class="programlisting">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }

    <span class="bold"><strong>public Object stringToObject(String stringValue)</strong></span> {
        return new Integer(stringValue);
    }
}


//id property
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10") 
private Integer id;
                </pre></div>
                     </div><br class="example-break"><p>It is critically important for the two-way process to be
                        idempotent (ie object = stringToObject( objectToString( object ) )
                        ).
                     </p>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e2439"></a>4.2.2.2.&nbsp;FieldBridge
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>Some use cases require more than a simple object to string
                        translation when mapping a property to a Lucene index. To give you the
                        greatest possible flexibility you can also implement a bridge as a
                        <code class="classname">FieldBridge</code>. This interface gives you a
                        property value and let you map it the way you want in your Lucene
                        <code class="classname">Document</code>.The interface is very similar in its
                        concept to the Hibernate<code class="classname"> UserType</code>s.
                     </p>
                     <p>You can for example store a given property in two different
                        document fields:
                     </p>
                     <div class="example"><a name="d0e2455"></a><p class="title"><b>Example&nbsp;4.16.&nbsp;Implementing the FieldBridge interface in order to a given
                              property into multiple document fields</b></p>
                        <div class="example-contents"><pre class="programlisting">/**
 * Store the date in 3 different fields - year, month, day - to ease Range Query per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * 
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    <span class="bold"><strong>public void set(String name, Object value, Document document, 
                    LuceneOptions luceneOptions)</strong></span> {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);
  
        // set year
        Field field = new Field(name + ".year", String.valueOf(year),
            luceneOptions.getStore(), luceneOptions.getIndex(),
            luceneOptions.getTermVector());
        field.setBoost(luceneOptions.getBoost());
        document.add(field);
  
        // set month and pad it if needed
        field = new Field(name + ".month", month &lt; 10 ? "0" : ""
            + String.valueOf(month), luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector());
        field.setBoost(luceneOptions.getBoost());
        document.add(field);
  
        // set day and pad it if needed
        field = new Field(name + ".day", day &lt; 10 ? "0" : ""
            + String.valueOf(day), luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector());
        field.setBoost(luceneOptions.getBoost());
        document.add(field);
    }
}

//property
<span class="bold"><strong>@FieldBridge(impl = DateSplitBridge.class)</strong></span>
private Date date;                </pre></div>
                     </div><br class="example-break"></div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e2466"></a>4.2.2.3.&nbsp;ClassBridge
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>It is sometimes useful to combine more than one property of a
                        given entity and index this combination in a specific way into the
                        Lucene index. The <code class="classname">@ClassBridge</code> and
                        <code class="classname">@ClassBridge</code> annotations can be defined at the
                        class level (as opposed to the property level). In this case the
                        custom field bridge implementation receives the entity instance as the
                        value parameter instead of a particular property. Though not shown in
                        this example, <code class="classname">@ClassBridge</code> supports the
                        <code class="methodname">termVector</code> attribute discussed in section
                        <a href="#basic-mapping" title="4.1.1.&nbsp;Basic mapping">Section&nbsp;4.1.1, &#8220;Basic mapping&#8221;</a>.
                     </p>
                     <div class="example"><a name="d0e2485"></a><p class="title"><b>Example&nbsp;4.17.&nbsp;Implementing a class bridge</b></p>
                        <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
<span class="bold"><strong>@ClassBridge</strong></span>(name="branchnetwork",
             index=Index.TOKENIZED,
             store=Store.YES,
             impl = <span class="bold"><strong>CatFieldsClassBridge.class</strong></span>,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees
    ...
}


public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    <span class="bold"><strong>public void set(String name, Object value, Document document, LuceneOptions luceneOptions)</strong></span> {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        Field field = new Field( name, fieldValue, luceneOptions.getStore(), luceneOptions.getIndex(), luceneOptions.getTermVector() );
        field.setBoost( luceneOptions.getBoost() );
        document.add( field );
   }
}</pre></div>
                     </div><br class="example-break"><p>In this example, the particular
                        <code class="classname">CatFieldsClassBridge</code> is applied to the
                        <code class="literal">department</code> instance, the field bridge then
                        concatenate both branch and network and index the
                        concatenation.
                     </p>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="provided-id"></a>4.3.&nbsp;Providing your own id
                        </h2>
                     </div>
                  </div>
               </div>
               <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Warning</h3>
                  <p>This part of the documentation is a work in progress.</p>
               </div>
               <p>You can provide your own id for Hibernate Search if you are
                  extending the internals. You will have to generate a unique value so it
                  can be given to Lucene to be indexed. This will have to be given to
                  Hibernate Search when you create an org.hibernate.search.Work object - the
                  document id is required in the constructor.
               </p>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="ProvidedId"></a>4.3.1.&nbsp;The ProvidedId annotation
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Unlike conventional Hibernate Search API and @DocumentId, this
                     annotation is used on the class and not a field. You also can provide
                     your own bridge implementation when you put in this annotation by
                     calling the bridge() which is on @ProvidedId. Also, if you annotate a
                     class with @ProvidedId, your subclasses will also get the annotation -
                     but it is not done by using the java.lang.annotations.@Inherited. Be
                     sure however, to <span class="emphasis"><em>not</em></span> use this annotation with
                     @DocumentId as your system will break.
                  </p>
                  <div class="example"><a name="d0e2523"></a><p class="title"><b>Example&nbsp;4.18.&nbsp;Providing your own id</b></p>
                     <div class="example-contents"><pre class="programlisting">@ProvidedId (bridge = org.my.own.package.MyCustomBridge)
@Indexed
public class MyClass{
    @Field
    String MyString;
    ...
}</pre></div>
                  </div><br class="example-break"></div>
            </div>
         </div>
         <div class="chapter" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="search-query"></a>Chapter&nbsp;5.&nbsp;Querying
                     </h2>
                  </div>
               </div>
            </div>
            <p>The second most important capability of Hibernate Search is the
               ability to execute a Lucene query and retrieve entities managed by an
               Hibernate session, providing the power of Lucene without leaving the
               Hibernate paradigm, and giving another dimension to the Hibernate classic
               search mechanisms (HQL, Criteria query, native SQL query). Preparing and
               executing a query consists of four simple steps:
            </p>
            <div class="itemizedlist">
               <ul type="disc">
                  <li>
                     <p>Creating a <code class="classname">FullTextSession</code></p>
                  </li>
                  <li>
                     <p>Creating a Lucene query</p>
                  </li>
                  <li>
                     <p>Wrapping the Lucene query using a
                        <code class="classname">org.hibernate.Query</code></p>
                  </li>
                  <li>
                     <p>Executing the search by calling for example
                        <code class="methodname">list()</code> or
                        <code class="methodname">scroll()</code></p>
                  </li>
               </ul>
            </div>
            <p>To access the querying facilities, you have to use an
               <code class="classname">FullTextSession</code>. This Search specific session wraps a
               regular <code class="classname">org.hibernate.Session</code> to provide query and
               indexing capabilities.
            </p>
            <div class="example"><a name="d0e2565"></a><p class="title"><b>Example&nbsp;5.1.&nbsp;Creating a FullTextSession</b></p>
               <div class="example-contents"><pre class="programlisting">Session session = sessionFactory.openSession();
...
FullTextSession fullTextSession = Search.getFullTextSession(session);    </pre></div>
            </div><br class="example-break"><p>The actual search facility is built on native Lucene queries which the
               following example illustrates.
            </p>
            <div class="example"><a name="d0e2572"></a><p class="title"><b>Example&nbsp;5.2.&nbsp;Creating a Lucene query</b></p>
               <div class="example-contents"><pre class="programlisting">org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", new StopAnalyzer() );

org.apache.lucene.search.Query luceneQuery = parser.parse( "summary:Festina Or brand:Seiko" );
<span class="bold"><strong>org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );
        </strong></span>
List result = fullTextQuery.list(); //return a list of managed objects    </pre></div>
            </div><br class="example-break"><p>The Hibernate query built on top of the Lucene query is a regular
               <code class="literal">org.hibernate.Query</code>, which means you are in the same
               paradigm as the other Hibernate query facilities (HQL, Native or Criteria).
               The regular <code class="literal">list()</code> , <code class="literal">uniqueResult()</code>,
               <code class="literal">iterate()</code> and <code class="literal">scroll()</code> methods can be
               used.
            </p>
            <p>In case you are using the Java Persistence APIs of Hibernate (aka EJB
               3.0 Persistence), the same extensions exist:
            </p>
            <div class="example"><a name="d0e2599"></a><p class="title"><b>Example&nbsp;5.3.&nbsp;Creating a Search query using the JPA API</b></p>
               <div class="example-contents"><pre class="programlisting">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager = 
    org.hibernate.hibernate.search.jpa.Search.getFullTextEntityManager(em);

...
org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", new StopAnalyzer() );

org.apache.lucene.search.Query luceneQuery = parser.parse( "summary:Festina Or brand:Seiko" );
<span class="bold"><strong>javax.persistence.Query fullTextQuery = fullTextEntityManager.createFullTextQuery( luceneQuery );</strong></span>

List result = fullTextQuery.getResultList(); //return a list of managed objects  </pre></div>
            </div><br class="example-break"><p>The following examples we will use the Hibernate APIs but the same
               example can be easily rewritten with the Java Persistence API by just
               adjusting the way the <code class="classname">FullTextQuery</code> is
               retrieved.
            </p>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e2612"></a>5.1.&nbsp;Building queries
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Hibernate Search queries are built on top of Lucene queries which
                  gives you total freedom on the type of Lucene query you want to execute.
                  However, once built, Hibernate Search wraps further query processing using
                  <code class="classname">org.hibernate.Query</code> as your primary query
                  manipulation API. 
               </p>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e2620"></a>5.1.1.&nbsp;Building a Lucene query
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>It is out of the scope of this documentation on how to exactly
                     build a Lucene query. Please refer to the online Lucene documentation or
                     get hold of a copy of either Lucene In Action or Hibernate Search in
                     Action.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e2625"></a>5.1.2.&nbsp;Building a Hibernate Search query
                           </h3>
                        </div>
                     </div>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e2628"></a>5.1.2.1.&nbsp;Generality
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>Once the Lucene query is built, it needs to be wrapped into an
                        Hibernate Query.
                     </p>
                     <div class="example"><a name="d0e2633"></a><p class="title"><b>Example&nbsp;5.4.&nbsp;Wrapping a Lucene query into a Hibernate Query</b></p>
                        <div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</pre></div>
                     </div><br class="example-break"><p>If not specified otherwise, the query will be executed against
                        all indexed entities, potentially returning all types of indexed
                        classes. It is advised, from a performance point of view, to restrict
                        the returned types:
                     </p>
                     <div class="example"><a name="d0e2640"></a><p class="title"><b>Example&nbsp;5.5.&nbsp;Filtering the search result by entity type</b></p>
                        <div class="example-contents"><pre class="programlisting">org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
// or
fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Item.class, Actor.class );</pre></div>
                     </div><br class="example-break"><p>The first example returns only matching
                        <code class="classname">Customer</code>s, the second returns matching
                        <code class="classname">Actor</code>s and <code class="classname">Item</code>s. The
                        type restriction is fully polymorphic which means that if there are
                        two indexed subclasses <code class="classname">Salesman</code> and
                        <code class="classname">Customer</code> of the baseclass
                        <code class="classname">Person</code>, it is possible to just specify
                        <code class="classname">Person.class</code> in order to filter on result
                        types. 
                     </p>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e2668"></a>5.1.2.2.&nbsp;Pagination
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>Out of performance reasons it is recommended to restrict the
                        number of returned objects per query. In fact is a very common use
                        case anyway that the user navigates from one page to an other. The way
                        to define pagination is exactly the way you would define pagination in
                        a plain HQL or Criteria query.
                     </p>
                     <div class="example"><a name="d0e2673"></a><p class="title"><b>Example&nbsp;5.6.&nbsp;Defining pagination for a search query</b></p>
                        <div class="example-contents"><pre class="programlisting">org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</pre></div>
                     </div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                        <h3 class="title">Note</h3>
                        <p>It is still possible to get the total number of matching
                           elements regardless of the pagination via
                           <code class="methodname">fulltextQuery.</code><code class="methodname">getResultSize()</code></p>
                     </div>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e2685"></a>5.1.2.3.&nbsp;Sorting
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>Apache Lucene provides a very flexible and powerful way to sort
                        results. While the default sorting (by relevance) is appropriate most
                        of the time, it can be interesting to sort by one or several other
                        properties. In order to do so set the Lucene Sort object to apply a
                        Lucene sorting strategy.
                     </p>
                     <div class="example"><a name="d0e2690"></a><p class="title"><b>Example&nbsp;5.7.&nbsp;Specifying a Lucene <code class="classname">Sort</code> in order to
                                        sort the results</b></p>
                        <div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( query, Book.class );
org.apache.lucene.search.Sort sort = new Sort(new SortField("title"));
<span class="bold"><strong>query.setSort(sort);</strong></span>
List results = query.list();</pre></div>
                     </div><br class="example-break"><p>One can notice the <code class="classname">FullTextQuery</code>
                        interface which is a sub interface of
                        <code class="classname">org.hibernate.Query</code>. Be aware that fields used
                        for sorting must not be tokenized.
                     </p>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="d0e2709"></a>5.1.2.4.&nbsp;Fetching strategy
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>When you restrict the return types to one class, Hibernate
                        Search loads the objects using a single query. It also respects the
                        static fetching strategy defined in your domain model.
                     </p>
                     <p>It is often useful, however, to refine the fetching strategy for
                        a specific use case.
                     </p>
                     <div class="example"><a name="d0e2716"></a><p class="title"><b>Example&nbsp;5.8.&nbsp;Specifying <code class="classname">FetchMode</code> on a
                                        query</b></p>
                        <div class="example-contents"><pre class="programlisting">Criteria criteria = s.createCriteria( Book.class ).setFetchMode( "authors", FetchMode.JOIN );
s.createFullTextQuery( luceneQuery ).setCriteriaQuery( criteria );</pre></div>
                     </div><br class="example-break"><p>In this example, the query will return all Books matching the
                        luceneQuery. The authors collection will be loaded from the same query
                        using an SQL outer join.
                     </p>
                     <p>When defining a criteria query, it is not needed to restrict the
                        entity types returned while creating the Hibernate Search query from
                        the full text session: the type is guessed from the criteria query
                        itself. Only fetch mode can be adjusted, refrain from applying any
                        other restriction.
                     </p>
                     <p>One cannot use <code class="methodname">setCriteriaQuery</code> if more
                        than one entity type is expected to be returned.
                     </p>
                  </div>
                  <div class="section" lang="en-US">
                     <div class="titlepage">
                        <div>
                           <div>
                              <h4 class="title"><a name="projections"></a>5.1.2.5.&nbsp;Projection
                              </h4>
                           </div>
                        </div>
                     </div>
                     <p>For some use cases, returning the domain object (graph) is
                        overkill. Only a small subset of the properties is necessary.
                        Hibernate Search allows you to return a subset of properties:
                     </p>
                     <div class="example"><a name="d0e2738"></a><p class="title"><b>Example&nbsp;5.9.&nbsp;Using projection instead of returning the full domain
                              object</b></p>
                        <div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.<span class="bold"><strong>setProjection( "id", "summary", "body", "mainAuthor.name" )</strong></span>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
Integer id = firstResult[0];
String summary = firstResult[1];
String body = firstResult[2];
String authorName = firstResult[3];</pre></div>
                     </div><br class="example-break"><p>Hibernate Search extracts the properties from the Lucene index
                        and convert them back to their object representation, returning a list
                        of <code class="classname">Object[]</code>. Projections avoid a potential
                        database round trip (useful if the query response time is critical),
                        but has some constraints:
                     </p>
                     <div class="itemizedlist">
                        <ul type="disc">
                           <li>
                              <p>the properties projected must be stored in the index
                                 (<code class="literal">@Field(store=Store.YES)</code>), which increase the
                                 index size
                              </p>
                           </li>
                           <li>
                              <p>the properties projected must use a
                                 <code class="literal">FieldBridge</code> implementing
                                 <code class="classname">org.hibernate.search.bridge.TwoWayFieldBridge</code>
                                 or
                                 <code class="literal">org.hibernate.search.bridge.TwoWayStringBridge</code>,
                                 the latter being the simpler version. All Hibernate Search
                                 built-in types are two-way.
                              </p>
                           </li>
                           <li>
                              <p>you can only project simple properties of the indexed entity
                                 or its embedded associations. This means you cannot project a
                                 whole embedded entity.
                              </p>
                           </li>
                           <li>
                              <p>projection does not work on collections or maps which are
                                 indexed via <code class="classname">@IndexedEmbedded</code></p>
                           </li>
                        </ul>
                     </div>
                     <p>Projection is useful for another kind of use cases. Lucene
                        provides some metadata information to the user about the results. By
                        using some special placeholders, the projection mechanism can retrieve
                        them:
                     </p>
                     <div class="example"><a name="d0e2780"></a><p class="title"><b>Example&nbsp;5.10.&nbsp;Using projection in order to retrieve meta data</b></p>
                        <div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.<span class="bold"><strong>setProjection( FullTextQuery.SCORE, FullTextQuery.THIS, "mainAuthor.name" )</strong></span>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
float score = firstResult[0];
Book book = firstResult[1];
String authorName = firstResult[2];</pre></div>
                     </div><br class="example-break"><p>You can mix and match regular fields and special placeholders.
                        Here is the list of available placeholders:
                     </p>
                     <div class="itemizedlist">
                        <ul type="disc">
                           <li>
                              <p>FullTextQuery.THIS: returns the initialized and managed
                                 entity (as a non projected query would have done).
                              </p>
                           </li>
                           <li>
                              <p>FullTextQuery.DOCUMENT: returns the Lucene Document related
                                 to the object projected.
                              </p>
                           </li>
                           <li>
                              <p>FullTextQuery.OBJECT_CLASS: returns the class of the
                                 indexed entity.
                              </p>
                           </li>
                           <li>
                              <p>FullTextQuery.SCORE: returns the document score in the
                                 query. Scores are handy to compare one result against an other for
                                 a given query but are useless when comparing the result of
                                 different queries.
                              </p>
                           </li>
                           <li>
                              <p>FullTextQuery.ID: the id property value of the projected
                                 object.
                              </p>
                           </li>
                           <li>
                              <p>FullTextQuery.DOCUMENT_ID: the Lucene document id. Careful,
                                 Lucene document id can change overtime between two different
                                 IndexReader opening (this feature is experimental).
                              </p>
                           </li>
                           <li>
                              <p>FullTextQuery.EXPLANATION: returns the Lucene Explanation
                                 object for the matching object/document in the given query. Do not
                                 use if you retrieve a lot of data. Running explanation typically
                                 is as costly as running the whole Lucene query per matching
                                 element. Make sure you use projection!
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e2812"></a>5.2.&nbsp;Retrieving the results
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Once the Hibernate Search query is built, executing it is in no way
                  different than executing a HQL or Criteria query. The same paradigm and
                  object semantic applies. All the common operations are available:
                  <code class="methodname">list()</code>, <code class="methodname">uniqueResult()</code>,
                  <code class="methodname">iterate()</code>,
                  <code class="methodname">scroll()</code>.
               </p>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e2829"></a>5.2.1.&nbsp;Performance considerations
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>If you expect a reasonable number of results (for example using
                     pagination) and expect to work on all of them,
                     <code class="methodname">list()</code> or
                     <code class="methodname">uniqueResult()</code> are recommended.
                     <code class="methodname">list()</code> work best if the entity
                     <code class="literal">batch-size</code> is set up properly. Note that Hibernate
                     Search has to process all Lucene Hits elements (within the pagination)
                     when using <code class="methodname">list()</code> ,
                     <code class="methodname">uniqueResult()</code> and
                     <code class="methodname">iterate()</code>.
                  </p>
                  <p>If you wish to minimize Lucene document loading,
                     <code class="methodname">scroll()</code> is more appropriate. Don't forget to
                     close the <code class="classname">ScrollableResults</code> object when you're
                     done, since it keeps Lucene resources. If you expect to use
                     <code class="methodname">scroll,</code> but wish to load objects in batch, you
                     can use <code class="methodname">query.setFetchSize()</code>. When an object is
                     accessed, and if not already loaded, Hibernate Search will load the next
                     <code class="literal">fetchSize</code> objects in one pass.
                  </p>
                  <p>Pagination is a preferred method over scrolling though.</p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e2874"></a>5.2.2.&nbsp;Result size
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>It is sometime useful to know the total number of matching
                     documents:
                  </p>
                  <div class="itemizedlist">
                     <ul type="disc">
                        <li>
                           <p>for the Google-like feature 1-10 of about 888,000,000</p>
                        </li>
                        <li>
                           <p>to implement a fast pagination navigation</p>
                        </li>
                        <li>
                           <p>to implement a multi step search engine (adding approximation
                              if the restricted query return no or not enough results)
                           </p>
                        </li>
                     </ul>
                  </div>
                  <p>Of course it would be too costly to retrieve all the matching
                     documents. Hibernate Search allows you to retrieve the total number of
                     matching documents regardless of the pagination parameters. Even more
                     interesting, you can retrieve the number of matching elements without
                     triggering a single object load.
                  </p>
                  <div class="example"><a name="d0e2891"></a><p class="title"><b>Example&nbsp;5.11.&nbsp;Determining the result size of a query</b></p>
                     <div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
assert 3245 == <span class="bold"><strong>query.getResultSize()</strong></span>; //return the number of matching books without loading a single one

org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.setMaxResult(10);
List results = query.list();
assert 3245 == <span class="bold"><strong>query.getResultSize()</strong></span>; //return the total number of matching books regardless of pagination</pre></div>
                  </div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Note</h3>
                     <p>Like Google, the number of results is approximative if the index
                        is not fully up-to-date with the database (asynchronous cluster for
                        example).
                     </p>
                  </div>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e2905"></a>5.2.3.&nbsp;ResultTransformer
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>Especially when using projection, the data structure returned by a
                     query (an object array in this case), is not always matching the
                     application needs. It is possible to apply a
                     <code class="classname">ResultTransformer</code> operation post query to match
                     the targeted data structure:
                  </p>
                  <div class="example"><a name="d0e2913"></a><p class="title"><b>Example&nbsp;5.12.&nbsp;Using ResultTransformer in conjunction with projections</b></p>
                     <div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.setProjection( "title", "mainAuthor.name" );

<span class="bold"><strong>query.setResultTransformer( 
    new StaticAliasToBeanResultTransformer( BookView.class, "title", "author" ) 
);</strong></span>
List&lt;BookView&gt; results = (List&lt;BookView&gt;) query.list();
for(BookView view : results) {
    log.info( "Book: " + view.getTitle() + ", " + view.getAuthor() );
}</pre></div>
                  </div><br class="example-break"><p>Examples of <code class="classname">ResultTransformer</code>
                     implementations can be found in the Hibernate Core codebase.
                  </p>
               </div>
               <div class="section" lang="en-US">
                  <div class="titlepage">
                     <div>
                        <div>
                           <h3 class="title"><a name="d0e2926"></a>5.2.4.&nbsp;Understanding results
                           </h3>
                        </div>
                     </div>
                  </div>
                  <p>You will find yourself sometimes puzzled by a result showing up in
                     a query or a result not showing up in a query. Luke is a great tool to
                     understand those mysteries. However, Hibernate Search also gives you
                     access to the Lucene <code class="classname">Explanation</code> object for a
                     given result (in a given query). This class is considered fairly
                     advanced to Lucene users but can provide a good understanding of the
                     scoring of an object. You have two ways to access the Explanation object
                     for a given result:
                  </p>
                  <div class="itemizedlist">
                     <ul type="disc">
                        <li>
                           <p>Use the <code class="methodname">fullTextQuery.explain(int)</code>
                              method
                           </p>
                        </li>
                        <li>
                           <p>Use projection</p>
                        </li>
                     </ul>
                  </div>
                  <p>The first approach takes a document id as a parameter and return
                     the Explanation object. The document id can be retrieved using
                     projection and the <code class="literal">FullTextQuery.DOCUMENT_ID</code>
                     constant.
                  </p>
                  <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
                     <h3 class="title">Warning</h3>
                     <p>The Document id has nothing to do with the entity id. Do not
                        mess up these two notions.
                     </p>
                  </div>
                  <p>The second approach let's you project the
                     <code class="classname">Explanation</code> object using the
                     <code class="literal">FullTextQuery.EXPLANATION</code> constant.
                  </p>
                  <div class="example"><a name="d0e2960"></a><p class="title"><b>Example&nbsp;5.13.&nbsp;Retrieving the Lucene Explanation object using
                           projection</b></p>
                     <div class="example-contents"><pre class="programlisting">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection( FullTextQuery.DOCUMENT_ID, <span class="bold"><strong>FullTextQuery.EXPLANATION</strong></span>, FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    display( e.toString() );
}</pre></div>
                  </div><br class="example-break"><p>Be careful, building the explanation object is quite expensive, it
                     is roughly as expensive as running the Lucene query again. Don't do it
                     if you don't need the object
                  </p>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e2970"></a>5.3.&nbsp;Filters
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Apache Lucene has a powerful feature that allows to filter query
                  results according to a custom filtering process. This is a very powerful
                  way to apply additional data restrictions, especially since filters can be
                  cached and reused. Some interesting use cases are:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>security</p>
                     </li>
                     <li>
                        <p>temporal data (eg. view only last month's data)</p>
                     </li>
                     <li>
                        <p>population filter (eg. search limited to a given
                           category)
                        </p>
                     </li>
                     <li>
                        <p>and many more</p>
                     </li>
                  </ul>
               </div>
               <p>Hibernate Search pushes the concept further by introducing the
                  notion of parameterizable named filters which are transparently cached.
                  For people familiar with the notion of Hibernate Core filters, the API is
                  very similar:
               </p>
               <div class="example"><a name="d0e2990"></a><p class="title"><b>Example&nbsp;5.14.&nbsp;Enabling fulltext filters for a given query</b></p>
                  <div class="example-contents"><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter( "login", "andre" );
fullTextQuery.list(); //returns only best drivers where andre has credentials</pre></div>
               </div><br class="example-break"><p>In this example we enabled two filters on top of the query. You can
                  enable (or disable) as many filters as you like.
               </p>
               <p>Declaring filters is done through the
                  <code class="classname">@FullTextFilterDef</code> annotation. This annotation can
                  be on any <code class="literal">@Indexed</code> entity regardless of the query the
                  filter is later applied to. This implies that filter definitions are
                  global and their names must be unique. A
                  <code class="classname">SearchException</code> is thrown in case two different
                  <code class="classname">@FullTextFilterDef</code> annotations with the same name
                  are defined. Each named filter has to specify its actual filter
                  implementation.
               </p>
               <div class="example"><a name="d0e3011"></a><p class="title"><b>Example&nbsp;5.15.&nbsp;Defining and implementing a Filter</b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@FullTextFilterDefs( {
    <span class="bold"><strong>@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilter.class)</strong></span>, 
    <span class="bold"><strong>@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)</strong></span> 
})
public class Driver { ... }</pre><pre class="programlisting">public class BestDriversFilter extends <span class="bold"><strong>org.apache.lucene.search.Filter</strong></span> {

    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
        OpenBitSet bitSet = new OpenBitSet( reader.maxDoc() );
        TermDocs termDocs = reader.termDocs( new Term( "score", "5" ) );
        while ( termDocs.next() ) {
            bitSet.set( termDocs.doc() );
        }
        return bitSet;
    }
}</pre></div>
               </div><br class="example-break"><p><code class="classname">BestDriversFilter</code> is an example of a simple
                  Lucene filter which reduces the result set to drivers whose score is 5. In
                  this example the specified filter implements the
                  <code class="literal">org.apache.lucene.search.Filter</code> directly and contains a
                  no-arg constructor.
               </p>
               <p>If your Filter creation requires additional steps or if the filter
                  you want to use does not have a no-arg constructor, you can use the
                  factory pattern:
               </p>
               <div class="example"><a name="d0e3036"></a><p class="title"><b>Example&nbsp;5.16.&nbsp;Creating a filter using the factory pattern</b></p>
                  <div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
public class Driver { ... }

public class BestDriversFilterFactory {

    <span class="bold"><strong>@Factory</strong></span>
    public Filter getFilter() {
        //some additional steps to cache the filter results per IndexReader
        Filter bestDriversFilter = new BestDriversFilter();
        return new CachingWrapperFilter(bestDriversFilter);
    }
}</pre></div>
               </div><br class="example-break"><p>Hibernate Search will look for a <code class="literal">@Factory</code>
                  annotated method and use it to build the filter instance. The factory must
                  have a no-arg constructor. For people familiar with JBoss Seam, this is
                  similar to the component factory pattern, but the annotation is
                  different!
               </p>
               <p>Named filters come in handy where parameters have to be passed to
                  the filter. For example a security filter might want to know which
                  security level you want to apply:
               </p>
               <div class="example"><a name="d0e3051"></a><p class="title"><b>Example&nbsp;5.17.&nbsp;Passing parameters to a defined filter</b></p>
                  <div class="example-contents"><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("security")<span class="bold"><strong>.setParameter( "level", 5 )</strong></span>;</pre></div>
               </div><br class="example-break"><p>Each parameter name should have an associated setter on either the
                  filter or filter factory of the targeted named filter definition.
               </p>
               <div class="example"><a name="d0e3061"></a><p class="title"><b>Example&nbsp;5.18.&nbsp;Using parameters in the actual filter implementation</b></p>
                  <div class="example-contents"><pre class="programlisting">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    <span class="bold"><strong>public void setLevel(Integer level)</strong></span> {
        this.level = level;
    }

    <span class="bold"><strong>@Key
    public FilterKey getKey()</strong></span> {
        StandardFilterKey key = new StandardFilterKey();
        key.addParameter( level );
        return key;
    }

    @Factory
    public Filter getFilter() {
        Query query = new TermQuery( new Term("level", level.toString() ) );
        return new CachingWrapperFilter( new QueryWrapperFilter(query) );
    }
}</pre></div>
               </div><br class="example-break"><p>Note the method annotated <code class="classname">@Key</code> returning a
                  <code class="classname">FilterKey</code> object. The returned object has a special
                  contract: the key object must implement <code class="methodname">equals()</code>
                  / <code class="methodname">hashCode()</code> so that 2 keys are equal if and only
                  if the given <code class="classname">Filter</code> types are the same and the set
                  of parameters are the same. In other words, 2 filter keys are equal if and
                  only if the filters from which the keys are generated can be interchanged.
                  The key object is used as a key in the cache mechanism.
               </p>
               <p><code class="classname">@Key</code> methods are needed only if:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>you enabled the filter caching system (enabled by
                           default)
                        </p>
                     </li>
                     <li>
                        <p>your filter has parameters</p>
                     </li>
                  </ul>
               </div>
               <p>In most cases, using the <code class="literal">StandardFilterKey</code>
                  implementation will be good enough. It delegates the
                  <code class="methodname">equals()</code> / <code class="methodname">hashCode()</code>
                  implementation to each of the parameters equals and hashcode
                  methods.
               </p>
               <p>As mentioned before the defined filters are per default cached and
                  the cache uses a combination of hard and soft references to allow disposal
                  of memory when needed. The hard reference cache keeps track of the most
                  recently used filters and transforms the ones least used to
                  <code class="classname">SoftReferences</code> when needed. Once the limit of the
                  hard reference cache is reached additional filters are cached as
                  <code class="classname">SoftReferences</code>. To adjust the size of the hard
                  reference cache, use
                  <code class="literal">hibernate.search.filter.cache_strategy.size</code> (defaults
                  to 128). For advanced use of filter caching, you can implement your own
                  <code class="classname">FilterCachingStrategy</code>. The classname is defined by
                  <code class="literal">hibernate.search.filter.cache_strategy</code>.
               </p>
               <p>This filter caching mechanism should not be confused with caching
                  the actual filter results. In Lucene it is common practice to wrap filters
                  using the <code class="classname">IndexReader</code> around a
                  <code class="classname">CachingWrapperFilter.</code> The wrapper will cache the
                  <code class="classname">DocIdSet</code> returned from the
                  <code class="methodname">getDocIdSet(IndexReader reader)</code> method to avoid
                  expensive recomputation. It is important to mention that the computed
                  <code class="classname">DocIdSet</code> is only cachable for the same
                  <code class="classname">IndexReader</code> instance, because the reader
                  effectively represents the state of the index at the moment it was opened.
                  The document list cannot change within an opened
                  <code class="classname">IndexReader</code>. A different/new<code class="classname">
                     IndexReader</code> instance, however, works potentially on a
                  different set of <code class="classname">Document</code>s (either from a different
                  index or simply because the index has changed), hence the cached
                  <code class="classname">DocIdSet</code> has to be recomputed.
               </p>
               <p>Hibernate Search also helps with this aspect of caching. Per default
                  the <code class="literal">cache</code> flag of <code class="classname">@FullTextFilterDef
                     </code>is set to
                  <code class="literal">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</code> which
                  will automatically cache the filter instance as well as wrap the specified
                  filter around a Hibernate specific implementation of
                  <code class="classname">CachingWrapperFilter</code>
                  (<code class="classname">org.hibernate.search.filter.CachingWrapperFilter</code>).
                  In contrast to Lucene's version of this class
                  <code class="classname">SoftReference</code>s are used together with a hard
                  reference count (see discussion about filter cache). The hard reference
                  count can be adjusted using
                  <code class="literal">hibernate.search.filter.cache_docidresults.size</code>
                  (defaults to 5). The wrapping behaviour can be controlled using the
                  <code class="literal">@FullTextFilterDef.cache</code> parameter. There are three
                  different values for this parameter:
               </p>
               <div class="informaltable">
                  <table border="1">
                     <colgroup>
                        <col align="center">
                        <col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th align="center">Value</th>
                           <th align="center">Definition</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td align="left">FilterCacheModeType.NONE</td>
                           <td align="left">No filter instance and no result is cached by Hibernate
                              Search. For every filter call, a new filter instance is created.
                              This setting might be useful for rapidly changing data sets or
                              heavily memory constrained environments.
                           </td>
                        </tr>
                        <tr>
                           <td align="left">FilterCacheModeType.INSTANCE_ONLY</td>
                           <td align="left">The filter instance is cached and reused across
                              concurrent <code class="methodname">Filter.getDocIdSet()</code> calls.
                              <code class="classname">DocIdSet</code> results are not cached. This
                              setting is useful when a filter uses its own specific caching
                              mechanism or the filter results change dynamically due to
                              application specific events making
                              <code class="classname">DocIdSet</code> caching in both cases
                              unnecessary.
                           </td>
                        </tr>
                        <tr>
                           <td align="left">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</td>
                           <td align="left">Both the filter instance and the
                              <code class="classname">DocIdSet</code> results are cached. This is the
                              default value.
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>Last but not least - why should filters be cached? There
                  are two areas where filter caching shines:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>the system does not update the targeted entity index often (in
                           other words, the IndexReader is reused a lot)
                        </p>
                     </li>
                     <li>
                        <p>the Filter's DocIdSet is expensive to compute (compared to the
                           time spent to execute the query)
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3232"></a>5.4.&nbsp;Optimizing the query process
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Query performance depends on several criteria:</p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>the Lucene query itself: read the literature on this
                           subject
                        </p>
                     </li>
                     <li>
                        <p>the number of object loaded: use pagination (always ;-) ) or
                           index projection (if needed)
                        </p>
                     </li>
                     <li>
                        <p>the way Hibernate Search interacts with the Lucene readers:
                           defines the appropriate <a href="#search-architecture-readerstrategy" title="2.3.&nbsp;Reader strategy">Reader strategy</a>.
                        </p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3249"></a>5.5.&nbsp;Native Lucene Queries
                        </h2>
                     </div>
                  </div>
               </div>
               <p>If you wish to use some specific features of Lucene, you can always
                  run Lucene specific queries. Check <a href="#search-lucene-native" title="Chapter&nbsp;8.&nbsp;Advanced features">Chapter&nbsp;8, <i xmlns:xlink="http://www.w3.org/1999/xlink">Advanced features</i></a>
                  for more information.
               </p>
            </div>
         </div>
         <div class="chapter" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="search-batchindex"></a>Chapter&nbsp;6.&nbsp;Manual indexing
                     </h2>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="search-batchindex-indexing"></a>6.1.&nbsp;Indexing
                        </h2>
                     </div>
                  </div>
               </div>
               <p>It is sometimes useful to index an entity even if this entity is not
                  inserted or updated to the database. This is for example the case when you
                  want to build your index for the first time.
                  <code class="classname">FullTextSession</code>.<code class="methodname">index()</code>
                  allows you to do so.
               </p>
               <div class="example"><a name="d0e3272"></a><p class="title"><b>Example&nbsp;6.1.&nbsp;Indexing an entity via
                        <code class="methodname">FullTextSession.index()</code></b></p>
                  <div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <span class="bold"><strong>fullTextSession.index(customer);</strong></span>
}
tx.commit(); //index are written at commit time    </pre></div>
               </div><br class="example-break"><p>For maximum efficiency, Hibernate Search batches index operations
                  and executes them at commit time. If you expect to index a lot of data,
                  however, you need to be careful about memory consumption since all
                  documents are kept in a queue until the transaction commit. You can
                  potentially face an <code class="classname">OutOfMemoryException</code>. To avoid
                  this exception, you can use
                  <code class="methodname">fullTextSession.flushToIndexes()</code>. Every time
                  <code class="methodname">fullTextSession.flushToIndexes()</code> is called (or if
                  the transaction is committed), the batch queue is processed (freeing
                  memory) applying all index changes. Be aware that once flushed changes
                  cannot be rolled back.
               </p>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p><code class="literal">hibernate.search.worker.batch_size</code> has been
                     deprecated in favor of this explicit API which provides better
                     control
                  </p>
               </div>
               <p>Other parameters which also can affect indexing time and memory
                  consumption are:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_buffered_docs</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_field_length</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_merge_docs</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].merge_factor</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].ram_buffer_size</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].term_index_interval</code></li>
                  </ul>
               </div>
               <p>These parameters are Lucene specific and Hibernate Search is just
                  passing these parameters through - see <a href="#lucene-indexing-performance" title="3.8.&nbsp;Tuning Lucene indexing performance">Section&nbsp;3.8, &#8220;Tuning Lucene indexing performance&#8221;</a> for more details.
               </p>
               <div class="example"><a name="d0e3323"></a><p class="title"><b>Example&nbsp;6.2.&nbsp;Efficiently indexing a given class (useful for index
                        (re)initialization)</b></p>
                  <div class="example-contents"><pre class="programlisting">fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll( ScrollMode.FORWARD_ONLY );
int index = 0;
while( results.next() ) {
    index++;
    fullTextSession.index( results.get(0) ); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //clear since the queue is processed
    }
}
transaction.commit();</pre></div>
               </div><br class="example-break"><p>Try to use a batch size that guarantees that your application will
                  not run out of memory.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3330"></a>6.2.&nbsp;Purging
                        </h2>
                     </div>
                  </div>
               </div>
               <p>It is equally possible to remove an entity or all entities of a
                  given type from a Lucene index without the need to physically remove them
                  from the database. This operation is named purging and is also done
                  through the <code class="classname">FullTextSession</code>.
               </p>
               <div class="example"><a name="d0e3338"></a><p class="title"><b>Example&nbsp;6.3.&nbsp;Purging a specific instance of an entity from the index</b></p>
                  <div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <span class="bold"><strong>fullTextSession.purge( Customer.class, customer.getId() );</strong></span>
}
tx.commit(); //index are written at commit time    </pre></div>
               </div><br class="example-break"><p>Purging will remove the entity with the given id from the Lucene
                  index but will not touch the database.
               </p>
               <p>If you need to remove all entities of a given type, you can use the
                  <code class="methodname">purgeAll</code> method. This operation remove all
                  entities of the type passed as a parameter as well as all its
                  subtypes.
               </p>
               <div class="example"><a name="d0e3353"></a><p class="title"><b>Example&nbsp;6.4.&nbsp;Purging all instances of an entity from the index</b></p>
                  <div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
<span class="bold"><strong>fullTextSession.purgeAll( Customer.class );</strong></span>
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index are written at commit time    </pre></div>
               </div><br class="example-break"><p>It is recommended to optimize the index after such an
                  operation.
               </p>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p>Methods <code class="methodname">index</code>,
                     <code class="methodname">purge</code> and <code class="methodname">purgeAll</code> are
                     available on <code class="classname">FullTextEntityManager</code> as
                     well.
                  </p>
               </div>
            </div>
         </div>
         <div class="chapter" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="search-optimize"></a>Chapter&nbsp;7.&nbsp;Index Optimization
                     </h2>
                  </div>
               </div>
            </div>
            <p>From time to time, the Lucene index needs to be optimized. The process
               is essentially a defragmentation. Until an optimization is triggered Lucene
               only marks deleted documents as such, no physical deletions are applied.
               During the optimization process the deletions will be applied which also
               effects the number of files in the Lucene Directory.
            </p>
            <p>Optimizing the Lucene index speeds up searches but has no effect on
               the indexation (update) performance. During an optimization, searches can be
               performed, but will most likely be slowed down. All index updates will be
               stopped. It is recommended to schedule optimization:
            </p>
            <div class="itemizedlist">
               <ul type="disc">
                  <li>
                     <p>on an idle system or when the searches are less frequent</p>
                  </li>
                  <li>
                     <p>after a lot of index modifications</p>
                  </li>
               </ul>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3394"></a>7.1.&nbsp;Automatic optimization
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Hibernate Search can automatically optimize an index after:</p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>a certain amount of operations (insertion, deletion)</p>
                     </li>
                     <li>
                        <p>or a certain amount of transactions </p>
                     </li>
                  </ul>
               </div>
               <p>The configuration for automatic index optimization can be defined on
                  a global level or per index:
               </p>
               <div class="example"><a name="d0e3408"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;Defining automatic optimization parameters</b></p>
                  <div class="example-contents"><pre class="programlisting">hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre></div>
               </div><br class="example-break"><p>An optimization will be triggered to the <code class="literal">Animal</code>
                  index as soon as either:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>the number of additions and deletions reaches 1000</p>
                     </li>
                     <li>
                        <p>the number of transactions reaches 50
                           (<code class="constant">hibernate.search.Animal.optimizer.transaction_limit.max</code>
                           having priority over
                           <code class="constant">hibernate.search.default.optimizer.transaction_limit.max</code>)
                        </p>
                     </li>
                  </ul>
               </div>
               <p>If none of these parameters are defined, no optimization is
                  processed automatically.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3433"></a>7.2.&nbsp;Manual optimization
                        </h2>
                     </div>
                  </div>
               </div>
               <p>You can programmatically optimize (defragment) a Lucene index from
                  Hibernate Search through the <code class="classname">SearchFactory</code>:
               </p>
               <div class="example"><a name="d0e3441"></a><p class="title"><b>Example&nbsp;7.2.&nbsp;Programmatic index optimization</b></p>
                  <div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();

searchFactory.optimize(Order.class);
// or
searchFactory.optimize();</pre></div>
               </div><br class="example-break"><p>The first example optimizes the Lucene index holding
                  <code class="classname">Order</code>s; the second, optimizes all indexes.
               </p>
               <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;">
                  <h3 class="title">Note</h3>
                  <p><code class="literal">searchFactory.optimize()</code> has no effect on a JMS
                     backend. You must apply the optimize operation on the Master
                     node.
                  </p>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3456"></a>7.3.&nbsp;Adjusting optimization
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Apache Lucene has a few parameters to influence how optimization is
                  performed. Hibernate Search exposes those parameters.
               </p>
               <p>Further index optimization parameters include: </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_buffered_docs</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_field_length</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_merge_docs</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].merge_factor</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].ram_buffer_size</code></li>
                     <li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].term_index_interval</code></li>
                  </ul>
               </div>
               <p> See <a href="#lucene-indexing-performance" title="3.8.&nbsp;Tuning Lucene indexing performance">Section&nbsp;3.8, &#8220;Tuning Lucene indexing performance&#8221;</a> for
                  more details.
               </p>
            </div>
         </div>
         <div class="chapter" lang="en-US">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title"><a name="search-lucene-native"></a>Chapter&nbsp;8.&nbsp;Advanced features
                     </h2>
                  </div>
               </div>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3490"></a>8.1.&nbsp;SearchFactory
                        </h2>
                     </div>
                  </div>
               </div>
               <p>The <code class="classname">SearchFactory</code> object keeps track of the
                  underlying Lucene resources for Hibernate Search, it's also a convenient
                  way to access Lucene natively. The <code class="classname">SearchFactory</code>
                  can be accessed from a <code class="classname">FullTextSession</code>:
               </p>
               <div class="example"><a name="d0e3504"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;Accessing the <code class="classname">SearchFactory</code></b></p>
                  <div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();</pre></div>
               </div><br class="example-break"></div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3511"></a>8.2.&nbsp;Accessing a Lucene Directory
                        </h2>
                     </div>
                  </div>
               </div>
               <p>You can always access the Lucene directories through plain Lucene,
                  the Directory structure is in no way different with or without Hibernate
                  Search. However there are some more convenient ways to access a given
                  Directory. The <code class="classname">SearchFactory</code> keeps track of the
                  <code class="classname">DirectoryProvider</code>s per indexed class. One directory
                  provider can be shared amongst several indexed classes if the classes
                  share the same underlying index directory. While usually not the case, a
                  given entity can have several <code class="classname">DirectoryProvider</code>s if
                  the index is sharded (see <a href="#search-configuration-directory-sharding" title="3.2.&nbsp;Sharding indexes">Section&nbsp;3.2, &#8220;Sharding indexes&#8221;</a>).
               </p>
               <div class="example"><a name="d0e3527"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;Accessing the Lucene <code class="classname">Directory</code></b></p>
                  <div class="example-contents"><pre class="programlisting">DirectoryProvider[] provider = searchFactory.getDirectoryProviders(Order.class);
org.apache.lucene.store.Directory directory = provider[0].getDirectory();</pre></div>
               </div><br class="example-break"><p>In this example, directory points to the lucene index storing
                  <code class="classname">Order</code>s information. Note that the obtained Lucene
                  directory must not be closed (this is Hibernate Search
                  responsibility).
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3539"></a>8.3.&nbsp;Using an IndexReader
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Queries in Lucene are executed on an <code class="literal">IndexReader</code>.
                  Hibernate Search caches all index readers to maximize performance. Your
                  code can access this cached resources, but you have to follow some "good
                  citizen" rules.
               </p>
               <div class="example"><a name="d0e3547"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;Accessing an <code class="classname">IndexReader</code></b></p>
                  <div class="example-contents"><pre class="programlisting">DirectoryProvider orderProvider = searchFactory.getDirectoryProviders(Order.class)[0];
DirectoryProvider clientProvider = searchFactory.getDirectoryProviders(Client.class)[0];

ReaderProvider readerProvider = searchFactory.getReaderProvider();
IndexReader reader = readerProvider.openReader(orderProvider, clientProvider);

try {
    //do read-only operations on the reader
}
finally {
    readerProvider.closeReader(reader);
}</pre></div>
               </div><br class="example-break"><p>The ReaderProvider (described in <a href="#search-architecture-readerstrategy" title="2.3.&nbsp;Reader strategy">Reader strategy</a>), will open an IndexReader
                  on top of the index(es) referenced by the directory providers. Because
                  this <code class="classname">IndexReader</code> is shared amongst several clients,
                  you must adhere to the following rules:
               </p>
               <div class="itemizedlist">
                  <ul type="disc">
                     <li>
                        <p>Never call indexReader.close(), but always call
                           readerProvider.closeReader(reader), preferably in a finally
                           block.
                        </p>
                     </li>
                     <li>
                        <p>Don't use this <code class="classname">IndexReader</code> for
                           modification operations (you would get an exception). If you want to
                           use a read/write index reader, open one from the Lucene Directory
                           object.
                        </p>
                     </li>
                  </ul>
               </div>
               <p>Aside from those rules, you can use the IndexReader freely,
                  especially to do native queries. Using the shared
                  <code class="literal">IndexReader</code>s will make most queries more
                  efficient.
               </p>
            </div>
            <div class="section" lang="en-US">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title" style="clear: both"><a name="d0e3576"></a>8.4.&nbsp;Customizing Lucene's scoring formula
                        </h2>
                     </div>
                  </div>
               </div>
               <p>Lucene allows the user to customize its scoring formula by extending
                  <code class="classname">org.apache.lucene.search.Similarity</code>. The abstract
                  methods defined in this class match the factors of the following formula
                  calculating the score of query q for document d:
               </p>
               <p><span class="bold"><strong>score(q,d) = coord(q,d) &middot; queryNorm(q) &middot;
                        &#8721;<sub>t in q</sub> ( tf(t in d) &middot;
                        idf(t)<sup>2</sup> &middot; t.getBoost() &middot; norm(t,d)
                        )</strong></span></p>
               <div class="informaltable">
                  <table border="1">
                     <colgroup>
                        <col>
                        <col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th align="center">Factor</th>
                           <th align="center">Description</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td align="left">tf(t ind)</td>
                           <td align="left">Term frequency factor for the term (t) in the document
                              (d).
                           </td>
                        </tr>
                        <tr>
                           <td align="left">idf(t)</td>
                           <td align="left">Inverse document frequency of the term.</td>
                        </tr>
                        <tr>
                           <td align="left">coord(q,d)</td>
                           <td align="left">Score factor based on how many of the query terms are
                              found in the specified document.
                           </td>
                        </tr>
                        <tr>
                           <td align="left">queryNorm(q)</td>
                           <td align="left">Normalizing factor used to make scores between queries
                              comparable.
                           </td>
                        </tr>
                        <tr>
                           <td align="left">t.getBoost()</td>
                           <td align="left">Field boost.</td>
                        </tr>
                        <tr>
                           <td align="left">norm(t,d)</td>
                           <td align="left">Encapsulates a few (indexing time) boost and length
                              factors.
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
               <p>It is beyond the scope of this manual to explain this
                  formula in more detail. Please refer to
                  <code class="classname">Similarity</code>'s Javadocs for more information.
               </p>
               <p>Hibernate Search provides two ways to modify Lucene's similarity
                  calculation. First you can set the default similarity by specifying the
                  fully specified classname of your <code class="classname">Similarity</code>
                  implementation using the property
                  <code class="constant">hibernate.search.similarity</code>. The default value is
                  <code class="classname">org.apache.lucene.search.DefaultSimilarity</code>.
                  Additionally you can override the default similarity on class level using
                  the <code class="literal">@Similarity</code> annotation.
               </p><pre class="programlisting">@Entity
@Indexed
<span class="bold"><strong>@Similarity(impl = DummySimilarity.class)</strong></span>
public class Book {
   ...
}</pre><p>As an example, let's assume it is not important how often a
                  term appears in a document. Documents with a single occurrence of the term
                  should be scored the same as documents with multiple occurrences. In this
                  case your custom implementation of the method <code class="methodname">tf(float
                     freq)</code> should return 1.0.
               </p>
            </div>
         </div>
      </div>
   <!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("search"); });</script><!-- /HibernateDoc.OutdatedContent --></body>
</html>