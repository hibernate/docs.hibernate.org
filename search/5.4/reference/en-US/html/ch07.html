<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 7. Index Optimization</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate Search, full text search for your entities - Reference Documentation" /><meta name="keywords" content="hibernate, search, hibernate search, full text, lucene" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" type="text/css" href="css/hibernate.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Hibernate Search"/><link rel="up" href="index.html" title="Hibernate Search"/><link rel="prev" href="ch06.html" title="Chapter 6. Manual index changes"/><link rel="next" href="ch08.html" title="Chapter 8. Monitoring"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
</head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch06.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch08.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 7. Index Optimization"><div class="titlepage"><div><div><h2 class="title"><a id="search-optimize"/>Chapter 7. Index Optimization</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch07.html#_automatic_optimization">7.1. Automatic optimization</a></span></dt><dt><span class="section"><a href="ch07.html#_manual_optimization">7.2. Manual optimization</a></span></dt><dt><span class="section"><a href="ch07.html#_adjusting_optimization">7.3. Adjusting optimization</a></span></dt></dl></div><p>This section explains some low level tricks to keep your indexes at peak performance. We cover some
Lucene details which in most cases you don’t have to know about: Hibernate Search will handle these
operations optimally and transparently in most cases without the need for further configuration.
Still, it is good to know that there are ways to configure the behavior, if the need arises.</p><p>The index is physically stored in several smaller segments. Each segment is immutable and represents
a generation of index writes. Index segments are periodically compacted, both to merge smaller
segments and to remove stale entries; this merging process happens constantly in the background and
can be tuned with the options specified in <a class="xref" href="ch03.html#lucene-indexing-performance" title="3.8.1. Tuning indexing performance">Section 3.8.1, “Tuning indexing performance”</a>, but you can also define
policies to fully run index optimizations when it is most suited for your specific workload.</p><p>With older versions of Lucene it was important to frequently optimize the index to maintain good
performance, but with current Lucene versions this doesn’t apply anymore. The benefit of explicit
optimization is very low, and in certain cases even counter-productive. During an explicit
optimization the whole index is processed and rewritten inflicting a significant performance cost.
Optimization is for this reason a double-edged sword.</p><p>Another reason to avoid optimizing the index too often is that an optimization will, as a side
effect, invalidate cached filters and field caches and internal buffers need to be refreshed.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Optimizing the index is often not needed, does not benefit write (update) performance at all, and is
a slow operation: make sure you need it before activating it.</p></div><p>Of course optimizing the index does not only present drawbacks: after the optimization process is
completed and new IndexReader instances have loaded their buffers, queries will perform at peak
performance and you will have reclaimed all disk space potentially used by stale entries.</p><p>It is recommended to not schedule any optimization, but if you wish to perform it periodically you
should run it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">on an idle system or when the searches are less frequent</li><li class="listitem">after a lot of index modifications</li></ul></div><p>When using a MassIndexer (see <a class="xref" href="ch06.html#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a>) it will optimize involved indexes
by default at the start and at the end of processing; you can change this behavior by using
MassIndexer.optimizeAfterPurge and MassIndexer.optimizeOnFinish respectively. The initial
optimization is actually very cheap as it is performed on an empty index: its purpose is to release
the storage space occupied by the old index.</p><div class="section" title="7.1. Automatic optimization"><div class="titlepage"><div><div><h2 class="title"><a id="_automatic_optimization"/>7.1. Automatic optimization</h2></div></div></div><p>While in most cases this is not needed, Hibernate Search can automatically optimize an index after:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">a certain amount of write operations</li><li class="listitem">or after a certain amount of transactions</li></ul></div><p>The configuration for automatic index optimization can be defined on a global level or per index:</p><div class="example"><a id="d0e6817"/><p class="title"><strong>Example 7.1. Defining automatic optimization parameters</strong></p><div class="example-contents"><pre class="screen">hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre></div></div><br class="example-break"/><p>With the above example an optimization will be triggered to the <code class="literal">Animal</code> index as soon as either:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the number of additions and deletions reaches 1000</li><li class="listitem">the number of transactions reaches 50 (hibernate.search.Animal.optimizer.transaction_limit.max
having priority over hibernate.search.default.optimizer.transaction_limit.max)</li></ul></div><p>If none of these parameters are defined, no optimization is processed automatically.</p><p>The default implementation of OptimizerStrategy can be overridden by implementing
<code class="literal">org.hibernate.search.store.optimization.OptimizerStrategy</code> and setting the
<code class="literal">optimizer.implementation</code> property to the fully qualified name of your implementation. This
implementation must implement the interface, be a public class and have a public constructor taking
no arguments.</p><div class="example"><a id="d0e6844"/><p class="title"><strong>Example 7.2. Loading a custom OptimizerStrategy</strong></p><div class="example-contents"><pre class="screen">hibernate.search.default.optimizer.implementation = com.acme.worlddomination.SmartOptimizer
hibernate.search.default.optimizer.SomeOption = CustomConfigurationValue
hibernate.search.humans.optimizer.implementation = default</pre></div></div><br class="example-break"/><p>The keyword <code class="literal">default</code> can be used to select the Hibernate Search default implementation; all
properties after the <code class="literal">.optimizer</code> key separator will be passed to the implementation’s initialize
method at start.</p></div><div class="section" title="7.2. Manual optimization"><div class="titlepage"><div><div><h2 class="title"><a id="_manual_optimization"/>7.2. Manual optimization</h2></div></div></div><p>You can programmatically optimize (defragment) a Lucene index from Hibernate Search through the
SearchFactory:</p><div class="example"><a id="d0e6862"/><p class="title"><strong>Example 7.3. Programmatic index optimization</strong></p><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();

searchFactory.optimize(Order.class);
// or
searchFactory.optimize();</code></pre></div></div><br class="example-break"/><p>The first example optimizes the Lucene index holding Orders; the second, optimizes all indexes.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p><code class="literal">searchFactory.optimize()</code> has no effect on a JMS or JGroups backend: you must apply the optimize operation on the Master node.</p></div></div><div class="section" title="7.3. Adjusting optimization"><div class="titlepage"><div><div><h2 class="title"><a id="_adjusting_optimization"/>7.3. Adjusting optimization</h2></div></div></div><p>The Lucene index is constantly being merged in the background to keep a good balance between write
and read performance; in a sense this is a form of background optimization which is always applied.</p><p>The following match attributes of Lucene’s IndexWriter and are commonly used to tune how often
merging occurs and how aggressive it is applied. They are exposed by Hibernate Search via:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.term_index_interval</code></li></ul></div><p>See <a class="xref" href="ch03.html#lucene-indexing-performance" title="3.8.1. Tuning indexing performance">Section 3.8.1, “Tuning indexing performance”</a> for a description of these properties.</p></div></div><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">hljs.initHighlightingOnLoad();</script><hr xmlns="" xmlns:d="http://docbook.org/ns/docbook"/><a xmlns="" xmlns:d="http://docbook.org/ns/docbook" href="legalnotice.html"/><ul class="docnav"><li class="previous"><a accesskey="p" href="ch06.html"><strong>Prev</strong>Chapter 6. Manual index changes</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch08.html"><strong>Next</strong>Chapter 8. Monitoring</a></li></ul><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("search"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>