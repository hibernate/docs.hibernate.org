<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Hibernate Search</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate Search, full text search for your entities - Reference Documentation" /><meta name="keywords" content="hibernate, search, hibernate search, full text, lucene" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" href="css/hibernate-single.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e3"/>Hibernate Search</h1></div><div><h2 class="subtitle">Apache <span class="trademark">Lucene</span>™ Integration</h2></div><div><h2 class="subtitle">Reference Guide</h2></div><div><p class="releaseinfo">3.2.1.Final</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#getting-started">1. Getting started</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e45">1.1. System Requirements</a></span></dt><dt><span class="section"><a href="#d0e104">1.2. Using Maven</a></span></dt><dt><span class="section"><a href="#d0e146">1.3. Configuration</a></span></dt><dt><span class="section"><a href="#d0e350">1.4. Indexing</a></span></dt><dt><span class="section"><a href="#d0e375">1.5. Searching</a></span></dt><dt><span class="section"><a href="#d0e393">1.6. Analyzer</a></span></dt><dt><span class="section"><a href="#d0e468">1.7. What's next</a></span></dt></dl></dd><dt><span class="chapter"><a href="#search-architecture">2. Architecture</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e488">2.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e536">2.2. Back end</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e541">2.2.1. Back end types</a></span></dt><dt><span class="section"><a href="#d0e586">2.2.2. Work execution</a></span></dt></dl></dd><dt><span class="section"><a href="#search-architecture-readerstrategy">2.3. Reader strategy</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e609">2.3.1. Shared</a></span></dt><dt><span class="section"><a href="#d0e634">2.3.2. Not-shared</a></span></dt><dt><span class="section"><a href="#d0e650">2.3.3. Custom</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#search-configuration">3. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#search-configuration-directory">3.1. Directory configuration</a></span></dt><dt><span class="section"><a href="#search-configuration-directory-sharding">3.2. Sharding indexes</a></span></dt><dt><span class="section"><a href="#d0e986">3.3. Sharing indexes (two entities into the same directory)</a></span></dt><dt><span class="section"><a href="#d0e1041">3.4. Worker configuration</a></span></dt><dt><span class="section"><a href="#jms-backend">3.5. JMS Master/Slave configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1162">3.5.1. Slave nodes</a></span></dt><dt><span class="section"><a href="#d0e1176">3.5.2. Master node</a></span></dt></dl></dd><dt><span class="section"><a href="#jgroups-backend">3.6. JGroups Master/Slave configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1213">3.6.1. Slave nodes</a></span></dt><dt><span class="section"><a href="#d0e1223">3.6.2. Master node</a></span></dt><dt><span class="section"><a href="#d0e1233">3.6.3. JGroups channel configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#configuration-reader-strategy">3.7. Reader strategy configuration</a></span></dt><dt><span class="section"><a href="#search-configuration-event">3.8. Enabling Hibernate Search and automatic indexing</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1298">3.8.1. Enabling Hibernate Search</a></span></dt><dt><span class="section"><a href="#d0e1321">3.8.2. Automatic indexing</a></span></dt></dl></dd><dt><span class="section"><a href="#lucene-indexing-performance">3.9. Tuning Lucene indexing performance</a></span></dt><dt><span class="section"><a href="#search-configuration-directory-lockfactories">3.10. LockFactory configuration</a></span></dt><dt><span class="section"><a href="#d0e1698">3.11. Exception Handling Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#search-mapping">4. Mapping entities to the index structure</a></span></dt><dd><dl><dt><span class="section"><a href="#search-mapping-entity">4.1. Mapping an entity</a></span></dt><dd><dl><dt><span class="section"><a href="#basic-mapping">4.1.1. Basic mapping</a></span></dt><dt><span class="section"><a href="#d0e1924">4.1.2. Mapping properties multiple times</a></span></dt><dt><span class="section"><a href="#search-mapping-associated">4.1.3. Embedded and associated objects</a></span></dt><dt><span class="section"><a href="#section-boost-annotation">4.1.4. Boost factor</a></span></dt><dt><span class="section"><a href="#d0e2218">4.1.5. Dynamic boost factor</a></span></dt><dt><span class="section"><a href="#analyzer">4.1.6. Analyzer</a></span></dt></dl></dd><dt><span class="section"><a href="#search-mapping-bridge">4.2. Property/Field Bridge</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2656">4.2.1. Built-in bridges</a></span></dt><dt><span class="section"><a href="#d0e2727">4.2.2. Custom Bridge</a></span></dt></dl></dd><dt><span class="section"><a href="#provided-id">4.3. Providing your own id</a></span></dt><dd><dl><dt><span class="section"><a href="#ProvidedId">4.3.1. The ProvidedId annotation</a></span></dt></dl></dd><dt><span class="section"><a href="#hsearch-mapping-programmaticapi">4.4. Programmatic API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3009">4.4.1. Mapping an entity as indexable</a></span></dt><dt><span class="section"><a href="#d0e3046">4.4.2. Adding DocumentId to indexed entity</a></span></dt><dt><span class="section"><a href="#d0e3069">4.4.3. Defining analyzers</a></span></dt><dt><span class="section"><a href="#d0e3099">4.4.4. Defining full text filter definitions</a></span></dt><dt><span class="section"><a href="#d0e3132">4.4.5. Defining fields for indexing</a></span></dt><dt><span class="section"><a href="#d0e3178">4.4.6. Programmatically defining embedded entities</a></span></dt><dt><span class="section"><a href="#d0e3211">4.4.7. Contained In definition</a></span></dt><dt><span class="section"><a href="#d0e3237">4.4.8. Date/Calendar Bridge</a></span></dt><dt><span class="section"><a href="#d0e3279">4.4.9. Defining bridges</a></span></dt><dt><span class="section"><a href="#d0e3310">4.4.10. Mapping class bridge</a></span></dt><dt><span class="section"><a href="#d0e3333">4.4.11. Mapping dynamic boost</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#search-query">5. Querying</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3443">5.1. Building queries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3451">5.1.1. Building a Lucene query</a></span></dt><dt><span class="section"><a href="#d0e3456">5.1.2. Building a Hibernate Search query</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3643">5.2. Retrieving the results</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3660">5.2.1. Performance considerations</a></span></dt><dt><span class="section"><a href="#d0e3705">5.2.2. Result size</a></span></dt><dt><span class="section"><a href="#d0e3736">5.2.3. ResultTransformer</a></span></dt><dt><span class="section"><a href="#d0e3757">5.2.4. Understanding results</a></span></dt></dl></dd><dt><span class="section"><a href="#query-filter">5.3. Filters</a></span></dt><dd><dl><dt><span class="section"><a href="#query-filter-shard">5.3.1. Using filters in a sharded environment</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4109">5.4. Optimizing the query process</a></span></dt><dt><span class="section"><a href="#d0e4126">5.5. Native Lucene Queries</a></span></dt></dl></dd><dt><span class="chapter"><a href="#manual-index-changes">6. Manual index changes</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4142">6.1. Adding instances to the Index</a></span></dt><dt><span class="section"><a href="#d0e4170">6.2. Deleting instances from the Index: Purging</a></span></dt><dt><span class="section"><a href="#search-batchindex">6.3. Rebuilding the whole Index</a></span></dt><dd><dl><dt><span class="section"><a href="#search-batchindex-flushtoindexes">6.3.1. Using flushToIndexes()</a></span></dt><dt><span class="section"><a href="#search-batchindex-massindexer">6.3.2. Using a MassIndexer</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#search-optimize">7. Index Optimization</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4403">7.1. Automatic optimization</a></span></dt><dt><span class="section"><a href="#d0e4442">7.2. Manual optimization</a></span></dt><dt><span class="section"><a href="#d0e4465">7.3. Adjusting optimization</a></span></dt></dl></dd><dt><span class="chapter"><a href="#search-lucene-native">8. Advanced features</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e4499">8.1. SearchFactory</a></span></dt><dt><span class="section"><a href="#d0e4520">8.2. Accessing a Lucene Directory</a></span></dt><dt><span class="section"><a href="#d0e4548">8.3. Using an IndexReader</a></span></dt><dt><span class="section"><a href="#d0e4585">8.4. Customizing Lucene's scoring formula</a></span></dt></dl></dd></dl></div><div class="preface" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Preface</h2></div></div></div><p>Full text search engines like Apache Lucene are very powerful
    technologies to add efficient free text search capabilities to
    applications. However, Lucene suffers several mismatches when dealing with
    object domain model. Amongst other things indexes have to be kept up to
    date and mismatches between index structure and domain model as well as
    query mismatches have to be avoided.</p><p>Hibernate Search addresses these shortcomings - it indexes your
    domain model with the help of a few annotations, takes care of
    database/index synchronization and brings back regular managed objects
    from free text queries. To achieve this Hibernate Search is combining the
    power of <a class="ulink" href="http://www.hibernate.org">Hibernate</a> and
    <a class="ulink" href="http://lucene.apache.org">Apache Lucene</a>.</p></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="getting-started"/>Chapter 1. Getting started</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e45">1.1. System Requirements</a></span></dt><dt><span class="section"><a href="#d0e104">1.2. Using Maven</a></span></dt><dt><span class="section"><a href="#d0e146">1.3. Configuration</a></span></dt><dt><span class="section"><a href="#d0e350">1.4. Indexing</a></span></dt><dt><span class="section"><a href="#d0e375">1.5. Searching</a></span></dt><dt><span class="section"><a href="#d0e393">1.6. Analyzer</a></span></dt><dt><span class="section"><a href="#d0e468">1.7. What's next</a></span></dt></dl></div><p>Welcome to Hibernate Search. The following chapter will guide you
  through the initial steps required to integrate Hibernate Search into an
  existing Hibernate enabled application. In case you are a Hibernate new
  timer we recommend you start <a class="ulink" href="http://hibernate.org/152.html">here</a>.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e45"/>1.1. System Requirements</h2></div></div></div><div class="table"><a id="d0e48"/><p class="title"><b>Table 1.1. System requirements</b></p><div class="table-contents"><table summary="System requirements" border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>Java Runtime</td><td>A JDK or JRE version <span class="emphasis"><em>5</em></span> or greater. You
            can download a Java Runtime for Windows/Linux/Solaris <a class="ulink" href="http://java.sun.com/javase/downloads/">here</a>.</td></tr><tr><td>Hibernate Search</td><td><code class="literal">hibernate-search.jar</code> and all runtime
            dependencies from the <code class="literal">dist/lib</code> directory of the
            Hibernate Search distribution.</td></tr><tr><td>Hibernate Core</td><td>This instructions have been tested against Hibernate 3.5.
            You will need <code class="literal">hibernate-core.jar</code> and its
            transitive dependencies from the <code class="literal">lib</code> directory
            of the distribution. Refer to <code class="literal">README.txt</code> in the
            <code class="literal">lib</code> directory of the distribution to determine
            the minimum runtime requirements.</td></tr><tr><td>Hibernate Annotations</td><td>Even though Hibernate Search can be used without Hibernate
            Annotations the following instructions will use them for basic
            entity configuration (<span class="emphasis"><em>@Entity, @Id,
            @OneToMany,...</em></span>). This part of the configuration could
            also be expressed in xml or code. However, Hibernate Search itself
            has its own set of annotations (<span class="emphasis"><em>@Indexed, @DocumentId,
            @Field,...</em></span>) for which there exists so far no
            alternative configuration. The tutorial is tested against version
            3.5 of Hibernate Annotations (part of the Hibernate Core
            distribution).</td></tr></tbody></table></div></div><br class="table-break"/><p>You can download all dependencies from the Hibernate download
    site.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e104"/>1.2. Using Maven</h2></div></div></div><p>Instead of managing all dependencies manually, maven users have the
    possibility to use the <a class="ulink" href="https://repository.jboss.org/nexus/content/groups/public/">JBoss
    maven repository</a>. Add the following to your Maven
    <code class="filename">settings.xml file</code> (see also <a class="ulink" href="http://community.jboss.org/wiki/MavenGettingStarted-Users">Maven
    Getting Started</a>):</p><div class="example"><a id="d0e118"/><p class="title"><b>Example 1.1. Adding the JBoss maven repository to
      <code class="filename">settings.xml</code></b></p><div class="example-contents"><pre class="programlisting">&lt;settings&gt;
  ...
  &lt;profiles&gt;
    ...
    &lt;profile&gt;
      &lt;id&gt;jboss-public-repository&lt;/id&gt;
      &lt;repositories&gt;
        &lt;repository&gt;
          &lt;id&gt;jboss-public-repository-group&lt;/id&gt;
          &lt;name&gt;JBoss Public Maven Repository Group&lt;/name&gt;
          &lt;url&gt;https://repository.jboss.org/nexus/content/groups/public/&lt;/url&gt;
          &lt;layout&gt;default&lt;/layout&gt;
          &lt;releases&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
          &lt;/releases&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
          &lt;/snapshots&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
      &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
          &lt;id&gt;jboss-public-repository-group&lt;/id&gt;
          &lt;name&gt;JBoss Public Maven Repository Group&lt;/name&gt;
          &lt;url&gt;https://repository.jboss.org/nexus/content/groups/public/&lt;/url&gt;
          &lt;layout&gt;default&lt;/layout&gt;
          &lt;releases&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
          &lt;/releases&gt;
          &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
            &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
          &lt;/snapshots&gt;
        &lt;/pluginRepository&gt;
      &lt;/pluginRepositories&gt;
    &lt;/profile&gt;

  &lt;/profiles&gt;

  &lt;activeProfiles&gt;
    &lt;activeProfile&gt;jboss-public-repository&lt;/activeProfile&gt;
  &lt;/activeProfiles&gt;
  ...
&lt;/settings&gt;
    </pre></div></div><br class="example-break"/><p>Then add the following dependencies to your pom.xml:</p><div class="example"><a id="d0e127"/><p class="title"><b>Example 1.2. Maven dependencies for Hibernate Search</b></p><div class="example-contents"><pre class="programlisting">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search&lt;/artifactId&gt;
   &lt;version&gt;3.2.1.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
   &lt;version&gt;3.5.0-Final&lt;/version&gt;
&lt;/dependency&gt;</pre></div></div><br class="example-break"/><p>Only the <span class="emphasis"><em>hibernate-search</em></span> dependency is
    mandatory, because it contains together with its required transitive
    dependencies all required classes needed to use Hibernate
    Search.<span class="emphasis"><em> hibernate-entitymanager</em></span> is only required if
    you want to use Hibernate Search in conjunction with JPA.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>There is no XML configuration available for Hibernate Search but
        we provide a powerful programmatic mapping API that elegantly replace
        this kind of deployment form (see <a class="xref" href="#hsearch-mapping-programmaticapi" title="4.4. Programmatic API">Section 4.4, “Programmatic API”</a> for more
        information).</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e146"/>1.3. Configuration</h2></div></div></div><p>Once you have downloaded and added all required dependencies to your
    application you have to add a couple of properties to your hibernate
    configuration file. If you are using Hibernate directly this can be done
    in <code class="literal">hibernate.properties</code> or
    <code class="literal">hibernate.cfg.xml</code>. If you are using Hibernate via JPA
    you can also add the properties to <code class="literal">persistence.xml</code>. The
    good news is that for standard use most properties offer a sensible
    default. An example <code class="filename">persistence.xml</code> configuration
    could look like this:</p><div class="example"><a id="d0e163"/><p class="title"><b>Example 1.3. Basic configuration options to be added to
      <code class="literal"><code class="filename">hibernate.properties</code></code>,
      <code class="literal"><code class="filename">hibernate.cfg.xml</code></code> or
      <code class="filename">persistence.xml</code></b></p><div class="example-contents"><pre class="programlisting">...
&lt;property name="hibernate.search.default.directory_provider" 
          value="org.hibernate.search.store.FSDirectoryProvider"/&gt; 

&lt;property name="hibernate.search.default.indexBase" 
          value="/var/lucene/indexes"/&gt; 
...    </pre></div></div><br class="example-break"/><p>First you have to tell Hibernate Search which
    <code class="classname">DirectoryProvider</code> to use. This can be achieved by
    setting the <code class="literal">hibernate.search.default.directory_provider</code>
    property. Apache Lucene has the notion of a <code class="literal">Directory</code>
    to store the index files. Hibernate Search handles the initialization and
    configuration of a Lucene <code class="literal">Directory</code> instance via a
    <code class="literal">DirectoryProvider</code>. In this tutorial we will use a
    subclass of <code class="literal">DirectoryProvider</code> called
    <code class="classname">FSDirectoryProvider</code>. This will give us the ability
    to physically inspect the Lucene indexes created by Hibernate Search (eg
    via <a class="ulink" href="http://www.getopt.org/luke/">Luke</a>). Once you have
    a working configuration you can start experimenting with other directory
    providers (see <a class="xref" href="#search-configuration-directory" title="3.1. Directory configuration">Section 3.1, “Directory configuration”</a>). Next to
    the directory provider you also have to specify the default root directory
    for all indexes via
    <code class="literal">hibernate.search.default.indexBase</code>.</p><p>Lets assume that your application contains the Hibernate managed
    classes <code class="classname">example.Book</code> and
    <code class="classname">example.Author</code> and you want to add free text search
    capabilities to your application in order to search the books contained in
    your database.</p><div class="example"><a id="d0e217"/><p class="title"><b>Example 1.4. Example entities Book and Author before adding Hibernate Search
      specific annotations</b></p><div class="example-contents"><pre class="programlisting">package example;
...
@Entity
public class Book {

  @Id
  @GeneratedValue
  private Integer id; 

  private String title;  

  private String subtitle; 

  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  private Date publicationDate;
  
  public Book() {} 
  
  // standard getters/setters follow here
  ...
}</pre><pre class="programlisting">package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {} 
 
  // standard getters/setters follow here
  ...
}</pre></div></div><br class="example-break"/><p>To achieve this you have to add a few annotations to the
    <code class="classname">Book</code> and <code class="classname">Author</code> class. The
    first annotation <code class="literal">@Indexed</code> marks
    <code class="classname">Book</code> as indexable. By design Hibernate Search needs
    to store an untokenized id in the index to ensure index unicity for a
    given entity. <code class="literal">@DocumentId</code> marks the property to use for
    this purpose and is in most cases the same as the database primary key. In
    fact since the 3.1.0 release of Hibernate Search
    <code class="literal">@DocumentId</code> is optional in the case where an
    <code class="classname">@Id</code> annotation exists.</p><p>Next you have to mark the fields you want to make searchable. Let's
    start with <code class="literal">title</code> and <code class="literal">subtitle</code> and
    annotate both with <code class="literal">@Field</code>. The parameter
    <code class="literal">index=Index.TOKENIZED</code> will ensure that the text will be
    tokenized using the default Lucene analyzer. Usually, tokenizing means
    chunking a sentence into individual words and potentially excluding common
    words like <code class="literal">'a'</code> or '<code class="literal">the</code>'. We will
    talk more about analyzers a little later on. The second parameter we
    specify within <code class="literal">@Field</code>,<code class="literal">
    store=Store.NO</code>, ensures that the actual data will not be stored
    in the index. Whether this data is stored in the index or not has nothing
    to do with the ability to search for it. From Lucene's perspective it is
    not necessary to keep the data once the index is created. The benefit of
    storing it is the ability to retrieve it via projections (<a class="xref" href="#projections" title="5.1.2.5. Projection">Section 5.1.2.5, “Projection”</a>).</p><p>Without projections, Hibernate Search will per default execute a
    Lucene query in order to find the database identifiers of the entities
    matching the query critera and use these identifiers to retrieve managed
    objects from the database. The decision for or against projection has to
    be made on a case to case basis. The default behaviour -
    <code class="literal">Store.NO</code> - is recommended since it returns managed
    objects whereas projections only return object arrays.</p><p>After this short look under the hood let's go back to annotating the
    <code class="classname">Book</code> class. Another annotation we have not yet
    discussed is <code class="literal">@DateBridge</code>. This annotation is one of the
    built-in field bridges in Hibernate Search. The Lucene index is purely
    string based. For this reason Hibernate Search must convert the data types
    of the indexed fields to strings and vice versa. A range of predefined
    bridges are provided, including the <code class="classname">DateBridge</code>
    which will convert a <code class="classname">java.util.Date</code> into a
    <code class="classname">String</code> with the specified resolution. For more
    details see <a class="xref" href="#search-mapping-bridge" title="4.2. Property/Field Bridge">Section 4.2, “Property/Field Bridge”</a>.</p><p>This leaves us with <code class="literal">@IndexedEmbedded. </code>This
    annotation is used to index associated entities
    (<code class="literal">@ManyToMany</code>, <code class="literal">@*ToOne</code> and
    <code class="literal">@Embedded</code>) as part of the owning entity. This is needed
    since a Lucene index document is a flat data structure which does not know
    anything about object relations. To ensure that the authors' name wil be
    searchable you have to make sure that the names are indexed as part of the
    book itself. On top of <code class="literal">@IndexedEmbedded</code> you will also
    have to mark all fields of the associated entity you want to have included
    in the index with <code class="literal">@Indexed</code>. For more details see <a class="xref" href="#search-mapping-associated" title="4.1.3. Embedded and associated objects">Section 4.1.3, “Embedded and associated objects”</a>.</p><p>These settings should be sufficient for now. For more details on
    entity mapping refer to <a class="xref" href="#search-mapping-entity" title="4.1. Mapping an entity">Section 4.1, “Mapping an entity”</a>.</p><div class="example"><a id="d0e325"/><p class="title"><b>Example 1.5. Example entities after adding Hibernate Search
      annotations</b></p><div class="example-contents"><pre class="programlisting">package example;
...
@Entity
<span class="bold"><strong>@Indexed</strong></span>
public class Book {

  @Id
  @GeneratedValue
  private Integer id;
  
  <span class="bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String title;
  
  <span class="bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String subtitle; 

  <span class="bold"><strong>@IndexedEmbedded</strong></span>
  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

<span class="bold"><strong>  @Field(index = Index.UN_TOKENIZED, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)</strong></span>
  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ... 
}</pre><pre class="programlisting">package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  <span class="bold"><strong>@Field(index=Index.TOKENIZED, store=Store.NO)</strong></span>
  private String name;

  public Author() {
  } 
 
  // standard getters/setters follow here
  ...
}</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e350"/>1.4. Indexing</h2></div></div></div><p>Hibernate Search will transparently index every entity persisted,
    updated or removed through Hibernate Core. However, you have to create an
    initial Lucene index for the data already present in your database. Once
    you have added the above properties and annotations it is time to trigger
    an initial batch index of your books. You can achieve this by using one of
    the following code snippets (see also <a class="xref" href="#search-batchindex" title="6.3. Rebuilding the whole Index">Section 6.3, “Rebuilding the whole Index”</a>):</p><div class="example"><a id="d0e357"/><p class="title"><b>Example 1.6. Using Hibernate Session to index data</b></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
fullTextSession.createIndexer().startAndWait();</pre></div></div><br class="example-break"/><div class="example"><a id="d0e362"/><p class="title"><b>Example 1.7. Using JPA to index data</b></p><div class="example-contents"><pre class="programlisting">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(em);
fullTextEntityManager.createIndexer().startAndWait();</pre></div></div><br class="example-break"/><p>After executing the above code, you should be able to see a Lucene
    index under <code class="literal">/var/lucene/indexes/example.Book</code>. Go ahead
    an inspect this index with <a class="ulink" href="http://www.getopt.org/luke/">Luke</a>. It will help you to
    understand how Hibernate Search works.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e375"/>1.5. Searching</h2></div></div></div><p>Now it is time to execute a first search. The general approach is to
    create a native Lucene query and then wrap this query into a
    org.hibernate.Query in order to get all the functionality one is used to
    from the Hibernate API. The following code will prepare a query against
    the indexed fields, execute it and return a list of
    <code class="classname">Book</code>s.</p><div class="example"><a id="d0e383"/><p class="title"><b>Example 1.8. Using Hibernate Session to create and execute a search</b></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

// create native Lucene query
String[] fields = new String[]{"title", "subtitle", "authors.name", "publicationDate"};
MultiFieldQueryParser parser = new MultiFieldQueryParser(fields, new StandardAnalyzer());
org.apache.lucene.search.Query query = parser.parse( "Java rocks!" );

// wrap Lucene query in a org.hibernate.Query
org.hibernate.Query hibQuery = fullTextSession.createFullTextQuery(query, Book.class);

// execute search
List result = hibQuery.list();
  
tx.commit();
session.close();  </pre></div></div><br class="example-break"/><div class="example"><a id="d0e388"/><p class="title"><b>Example 1.9. Using JPA to create and execute a search</b></p><div class="example-contents"><pre class="programlisting">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = 
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
em.getTransaction().begin();

// create native Lucene query
String[] fields = new String[]{"title", "subtitle", "authors.name", "publicationDate"};
MultiFieldQueryParser parser = new MultiFieldQueryParser(fields, new StandardAnalyzer());
org.apache.lucene.search.Query query = parser.parse( "Java rocks!" );

// wrap Lucene query in a javax.persistence.Query
javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, Book.class);

// execute search
List result = persistenceQuery.getResultList();

em.getTransaction().commit();
em.close();  </pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e393"/>1.6. Analyzer</h2></div></div></div><p>Let's make things a little more interesting now. Assume that one of
    your indexed book entities has the title "Refactoring: Improving the
    Design of Existing Code" and you want to get hits for all of the following
    queries: "refactor", "refactors", "refactored" and "refactoring". In
    Lucene this can be achieved by choosing an analyzer class which applies
    word stemming during the indexing <span class="bold"><strong>as well
    as</strong></span> search process. Hibernate Search offers several ways to
    configure the analyzer to use (see <a class="xref" href="#analyzer" title="4.1.6. Analyzer">Section 4.1.6, “Analyzer”</a>):</p><div class="itemizedlist"><ul><li><p>Setting the <code class="literal">hibernate.search.analyzer</code>
        property in the configuration file. The specified class will then be
        the default analyzer.</p></li><li><p>Setting the <code class="literal"><code class="literal">@Analyzer</code></code>
        annotation at the entity level.</p></li><li><p>Setting the <code class="literal">@<code class="literal">Analyzer</code></code>
        annotation at the field level.</p></li></ul></div><p>When using the <code class="literal">@Analyzer</code> annotation one can
    either specify the fully qualified classname of the analyzer to use or one
    can refer to an analyzer definition defined by the
    <code class="literal">@AnalyzerDef</code> annotation. In the latter case the Solr
    analyzer framework with its factories approach is utilized. To find out
    more about the factory classes available you can either browse the Solr
    JavaDoc or read the corresponding section on the <a class="ulink" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">Solr
    Wiki.</a></p><p>In the example below a
    <code class="classname">StandardTokenizerFactory</code> is used followed by two
    filter factories, <code class="classname">LowerCaseFilterFactory</code> and
    <code class="classname">SnowballPorterFilterFactory</code>. The standard tokenizer
    splits words at punctuation characters and hyphens while keeping email
    addresses and internet hostnames intact. It is a good general purpose
    tokenizer. The lowercase filter lowercases the letters in each token
    whereas the snowball filter finally applies language specific
    stemming.</p><p>Generally, when using the Solr framework you have to start with a
    tokenizer followed by an arbitrary number of filters.</p><div class="example"><a id="d0e448"/><p class="title"><b>Example 1.10. Using <code class="classname">@AnalyzerDef</code> and the Solr framework
      to define and use an analyzer</b></p><div class="example-contents"><pre class="programlisting">package example;
...
@Entity
@Indexed
<span class="bold"><strong>@AnalyzerDef(name = "customanalyzer",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = SnowballPorterFilterFactory.class, params = {
      @Parameter(name = "language", value = "English")
    })
  })</strong></span>
public class Book {

  @Id
  @GeneratedValue
  @DocumentId
  private Integer id;
  
  @Field(index=Index.TOKENIZED, store=Store.NO)
  <span class="bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
  private String title;
  
  @Field(index=Index.TOKENIZED, store=Store.NO)
  <span class="bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
  private String subtitle; 

  @IndexedEmbedded
  @ManyToMany 
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

<span class="bold"><strong> </strong></span> @Field(index = Index.UN_TOKENIZED, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;
  
  public Book() {
  } 
  
  // standard getters/setters follow here
  ... 
}</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e468"/>1.7. What's next</h2></div></div></div><p>The above paragraphs helped you getting an overview of Hibernate
    Search. The next step after this tutorial is to get more familiar with the
    overall architecture of Hibernate Search (<a class="xref" href="#search-architecture" title="Chapter 2. Architecture">Chapter 2, <i>Architecture</i></a>) and explore the basic features in more
    detail. Two topics which were only briefly touched in this tutorial were
    analyzer configuration (<a class="xref" href="#analyzer" title="4.1.6. Analyzer">Section 4.1.6, “Analyzer”</a>) and field bridges
    (<a class="xref" href="#search-mapping-bridge" title="4.2. Property/Field Bridge">Section 4.2, “Property/Field Bridge”</a>), both important features
    required for more fine-grained indexing. More advanced topics cover
    clustering (<a class="xref" href="#jms-backend" title="3.5. JMS Master/Slave configuration">Section 3.5, “JMS Master/Slave configuration”</a>) and large indexes handling
    (<a class="xref" href="#search-configuration-directory-sharding" title="3.2. Sharding indexes">Section 3.2, “Sharding indexes”</a>).</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-architecture"/>Chapter 2. Architecture</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e488">2.1. Overview</a></span></dt><dt><span class="section"><a href="#d0e536">2.2. Back end</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e541">2.2.1. Back end types</a></span></dt><dt><span class="section"><a href="#d0e586">2.2.2. Work execution</a></span></dt></dl></dd><dt><span class="section"><a href="#search-architecture-readerstrategy">2.3. Reader strategy</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e609">2.3.1. Shared</a></span></dt><dt><span class="section"><a href="#d0e634">2.3.2. Not-shared</a></span></dt><dt><span class="section"><a href="#d0e650">2.3.3. Custom</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e488"/>2.1. Overview</h2></div></div></div><p>Hibernate Search consists of an indexing component and an index
    search component. Both are backed by Apache Lucene.</p><p>Each time an entity is inserted, updated or removed in/from the
    database, Hibernate Search keeps track of this event (through the
    Hibernate event system) and schedules an index update. All the index
    updates are handled without you having to use the Apache Lucene APIs (see
    <a class="xref" href="#search-configuration-event" title="3.8. Enabling Hibernate Search and automatic indexing">Section 3.8, “Enabling Hibernate Search and automatic indexing”</a>).</p><p>To interact with Apache Lucene indexes, Hibernate Search has the
    notion of <code class="classname">DirectoryProvider</code>s. A directory provider
    will manage a given Lucene <code class="classname">Directory</code> type. You can
    configure directory providers to adjust the directory target (see <a class="xref" href="#search-configuration-directory" title="3.1. Directory configuration">Section 3.1, “Directory configuration”</a>).</p><p>Hibernate Search uses the Lucene index to search an entity and
    return a list of managed entities saving you the tedious object to Lucene
    document mapping. The same persistence context is shared between Hibernate
    and Hibernate Search. As a matter of fact, the
    <code class="classname">FullTextSession</code> is built on top of the Hibernate
    Session. so that the application code can use the unified
    <code class="classname">org.hibernate.Query</code> or
    <code class="classname">javax.persistence.Query</code> APIs exactly the way a HQL,
    JPA-QL or native queries would do.</p><p>To be more efficient, Hibernate Search batches the write
    interactions with the Lucene index. There is currently two types of
    batching depending on the expected scope. Outside a transaction, the index
    update operation is executed right after the actual database operation.
    This scope is really a no scoping setup and no batching is performed.
    However, it is recommended - for both your database and Hibernate Search -
    to execute your operation in a transaction be it JDBC or JTA. When in a
    transaction, the index update operation is scheduled for the transaction
    commit phase and discarded in case of transaction rollback. The batching
    scope is the transaction. There are two immediate benefits:</p><div class="itemizedlist"><ul><li><p>Performance: Lucene indexing works better when operation are
        executed in batch.</p></li><li><p>ACIDity: The work executed has the same scoping as the one
        executed by the database transaction and is executed if and only if
        the transaction is committed. This is not ACID in the strict sense of
        it, but ACID behavior is rarely useful for full text search indexes
        since they can be rebuilt from the source at any time.</p></li></ul></div><p>You can think of those two scopes (no scope vs transactional) as the
    equivalent of the (infamous) autocommit vs transactional behavior. From a
    performance perspective, the <span class="emphasis"><em>in transaction</em></span> mode is
    recommended. The scoping choice is made transparently. Hibernate Search
    detects the presence of a transaction and adjust the scoping.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
       Hibernate Search works perfectly fine in the Hibernate / EntityManager long conversation pattern aka. atomic conversation. 
    </div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>
       Depending on user demand, additional scoping will be considered, the pluggability mechanism being already in place. 
    </div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e536"/>2.2. Back end</h2></div></div></div><p>Hibernate Search offers the ability to let the scoped work being
    processed by different back ends. Two back ends are provided out of the
    box for two different scenarios.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e541"/>2.2.1. Back end types</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e544"/>2.2.1.1. Lucene</h4></div></div></div><p>In this mode, all index update operations applied on a given
        node (JVM) will be executed to the Lucene directories (through the
        directory providers) by the same node. This mode is typically used in
        non clustered environment or in clustered environments where the
        directory store is shared.</p><div class="mediaobject" align="center"><img src="lucene-backend.png" align="middle"/><div class="caption"><p>Lucene back end configuration.</p></div></div><p>This mode targets non clustered applications, or clustered
        applications where the Directory is taking care of the locking
        strategy.</p><p>The main advantage is simplicity and immediate visibility of the
        changes in Lucene queries (a requirement in some applications).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e561"/>2.2.1.2. JMS</h4></div></div></div><p>All index update operations applied on a given node are sent to
        a JMS queue. A unique reader will then process the queue and update
        the master index. The master index is then replicated on a regular
        basis to the slave copies. This is known as the master/slaves pattern.
        The master is the sole responsible for updating the Lucene index. The
        slaves can accept read as well as write operations. However, they only
        process the read operation on their local index copy and delegate the
        update operations to the master.</p><div class="mediaobject" align="center"><img src="jms-backend.png" align="middle"/><div class="caption"><p>JMS back end configuration.</p></div></div><p>This mode targets clustered environments where throughput is
        critical, and index update delays are affordable. Reliability is
        ensured by the JMS provider and by having the slaves working on a
        local copy of the index.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e576"/>2.2.1.3. JGroups</h4></div></div></div><p>The JGroups based back end works similarly as the JMS one. Designed on the same
       master/slave pattern, instead of JMS the JGroups toolkit is used as a replication mechanism.
       This back end can be used as an alternative to JMS one when response time is still critical,
       but i.e. JNDI service is not available.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2>Hibernate Search is an extensible architecture. Feel free to drop
      ideas for other third party back ends to
      <code class="literal">hibernate-dev@lists.jboss.org</code>.</div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e586"/>2.2.2. Work execution</h3></div></div></div><p>The indexing work (done by the back end) can be executed
      synchronously with the transaction commit (or update operation if out of
      transaction), or asynchronously.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e591"/>2.2.2.1. Synchronous</h4></div></div></div><p>This is the safe mode where the back end work is executed in
        concert with the transaction commit. Under highly concurrent
        environment, this can lead to throughput limitations (due to the
        Apache Lucene lock mechanism) and it can increase the system response
        time if the backend is significantly slower than the transactional
        process and if a lot of IO operations are involved.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e596"/>2.2.2.2. Asynchronous</h4></div></div></div><p>This mode delegates the work done by the back end to a different
        thread. That way, throughput and response time are (to a certain
        extend) decorrelated from the back end performance. The drawback is
        that a small delay appears between the transaction commit and the
        index update and a small overhead is introduced to deal with thread
        management.</p><p>It is recommended to use synchronous execution first and
        evaluate asynchronous execution if performance problems occur and
        after having set up a proper benchmark (ie not a lonely cowboy hitting
        the system in a completely unrealistic way).</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-architecture-readerstrategy"/>2.3. Reader strategy</h2></div></div></div><p>When executing a query, Hibernate Search interacts with the Apache
    Lucene indexes through a reader strategy. Choosing a reader strategy will
    depend on the profile of the application (frequent updates, read mostly,
    asynchronous index update etc). See also <a class="xref" href="#configuration-reader-strategy" title="3.7. Reader strategy configuration">Section 3.7, “Reader strategy configuration”</a></p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e609"/>2.3.1. Shared</h3></div></div></div><p>With this strategy, Hibernate Search will share the same
      <code class="classname">IndexReader</code>, for a given Lucene index, across
      multiple queries and threads provided that the
      <code class="classname">IndexReader</code> is still up-to-date. If the
      <code class="classname">IndexReader</code> is not up-to-date, a new one is
      opened and provided. Each <code class="classname">IndexReader</code> is made of
      several <code class="classname">SegmentReader</code>s. This strategy only
      reopens segments that have been modified or created after last opening
      and shares the already loaded segments from the previous instance. This
      strategy is the default.</p><p>The name of this strategy is <code class="literal">shared</code>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e634"/>2.3.2. Not-shared</h3></div></div></div><p>Every time a query is executed, a Lucene
      <code class="classname">IndexReader</code> is opened. This strategy is not the
      most efficient since opening and warming up an
      <code class="classname">IndexReader</code> can be a relatively expensive
      operation.</p><p>The name of this strategy is <code class="literal">not-shared</code>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e650"/>2.3.3. Custom</h3></div></div></div><p>You can write your own reader strategy that suits your application
      needs by implementing
      <code class="classname">org.hibernate.search.reader.ReaderProvider</code>. The
      implementation must be thread safe.</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration"/>Chapter 3. Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#search-configuration-directory">3.1. Directory configuration</a></span></dt><dt><span class="section"><a href="#search-configuration-directory-sharding">3.2. Sharding indexes</a></span></dt><dt><span class="section"><a href="#d0e986">3.3. Sharing indexes (two entities into the same directory)</a></span></dt><dt><span class="section"><a href="#d0e1041">3.4. Worker configuration</a></span></dt><dt><span class="section"><a href="#jms-backend">3.5. JMS Master/Slave configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1162">3.5.1. Slave nodes</a></span></dt><dt><span class="section"><a href="#d0e1176">3.5.2. Master node</a></span></dt></dl></dd><dt><span class="section"><a href="#jgroups-backend">3.6. JGroups Master/Slave configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1213">3.6.1. Slave nodes</a></span></dt><dt><span class="section"><a href="#d0e1223">3.6.2. Master node</a></span></dt><dt><span class="section"><a href="#d0e1233">3.6.3. JGroups channel configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#configuration-reader-strategy">3.7. Reader strategy configuration</a></span></dt><dt><span class="section"><a href="#search-configuration-event">3.8. Enabling Hibernate Search and automatic indexing</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1298">3.8.1. Enabling Hibernate Search</a></span></dt><dt><span class="section"><a href="#d0e1321">3.8.2. Automatic indexing</a></span></dt></dl></dd><dt><span class="section"><a href="#lucene-indexing-performance">3.9. Tuning Lucene indexing performance</a></span></dt><dt><span class="section"><a href="#search-configuration-directory-lockfactories">3.10. LockFactory configuration</a></span></dt><dt><span class="section"><a href="#d0e1698">3.11. Exception Handling Configuration</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-directory"/>3.1. Directory configuration</h2></div></div></div><p>Apache Lucene has a notion of <code class="literal">Directory</code> to store
    the index files. The <code class="classname">Directory</code> implementation can
    be customized, but Lucene comes bundled with a file system
    (<code class="literal">FSDirectoryProvider</code>) and an in memory
    (<code class="literal">RAMDirectoryProvider</code>) implementation.
    <code class="literal">DirectoryProvider</code>s are the Hibernate Search abstraction
    around a Lucene <code class="classname">Directory</code> and handle the
    configuration and the initialization of the underlying Lucene resources.
    <a class="xref" href="#directory-provider-table" title="Table 3.1. List of built-in Directory Providers">Table 3.1, “List of built-in Directory Providers”</a> shows the list of the
    directory providers bundled with Hibernate Search.</p><div class="table"><a id="directory-provider-table"/><p class="title"><b>Table 3.1. List of built-in Directory Providers</b></p><div class="table-contents"><table summary="List of built-in Directory Providers" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">Class</th><th align="center">Description</th><th align="center">Properties</th></tr></thead><tbody><tr><td>org.hibernate.search.store.RAMDirectoryProvider</td><td>Memory based directory, the directory will be uniquely
            identified (in the same deployment unit) by the
            <code class="literal">@Indexed.index</code> element</td><td>none</td></tr><tr><td>org.hibernate.search.store.FSDirectoryProvider</td><td>File system based directory. The directory used will be
            &lt;indexBase&gt;/&lt; indexName &gt;</td><td><p><code class="literal">indexBase</code> : Base
            directory</p><p><code class="literal">indexName</code>: override
            @Indexed.index (useful for sharded indexes)</p><p><code class="literal">
            locking_strategy</code> : optional, see <a class="xref" href="#search-configuration-directory-lockfactories" title="3.10. LockFactory configuration">Section 3.10, “LockFactory configuration”</a>
            </p></td></tr><tr><td>org.hibernate.search.store.FSMasterDirectoryProvider</td><td><p>File system based directory. Like
            FSDirectoryProvider. It also copies the index to a source
            directory (aka copy directory) on a regular basis.
            </p><p>The recommended value for the refresh period is (at
            least) 50% higher that the time to copy the information (default
            3600 seconds - 60 minutes).</p><p>Note that the copy is
            based on an incremental copy mechanism reducing the average copy
            time.</p><p>DirectoryProvider typically used on the master
            node in a JMS back end cluster.</p><p>The <code class="literal">
            buffer_size_on_copy</code> optimum depends on your operating
            system and available RAM; most people reported good results using
            values between 16 and 64MB.</p></td><td><p><code class="literal">indexBase</code>: Base
            directory</p><p><code class="literal">indexName</code>: override
            @Indexed.index (useful for sharded
            indexes)</p><p><code class="literal">sourceBase</code>: Source (copy)
            base directory.</p><p><code class="literal">source</code>: Source
            directory suffix (default to <code class="literal">@Indexed.index</code>).
            The actual source directory name being
            <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
            </p><p><code class="literal">refresh</code>: refresh period in second
            (the copy will take place every refresh seconds).</p><p>
            <code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to
            move in a single low level copy instruction; defaults to
            16MB.</p><p><code class="literal"> locking_strategy</code> : optional,
            see <a class="xref" href="#search-configuration-directory-lockfactories" title="3.10. LockFactory configuration">Section 3.10, “LockFactory configuration”</a>
            </p></td></tr><tr><td>org.hibernate.search.store.FSSlaveDirectoryProvider</td><td><p>File system based directory. Like
            FSDirectoryProvider, but retrieves a master version (source) on a
            regular basis. To avoid locking and inconsistent search results, 2
            local copies are kept. </p><p>The recommended value for the
            refresh period is (at least) 50% higher that the time to copy the
            information (default 3600 seconds - 60 minutes).</p><p>Note
            that the copy is based on an incremental copy mechanism reducing
            the average copy time.</p><p>DirectoryProvider typically
            used on slave nodes using a JMS back end.</p><p>The
            <code class="literal"> buffer_size_on_copy</code> optimum depends on your
            operating system and available RAM; most people reported good
            results using values between 16 and 64MB.</p></td><td><p><code class="literal">indexBase</code>: Base
            directory</p><p><code class="literal">indexName</code>: override
            @Indexed.index (useful for sharded
            indexes)</p><p><code class="literal">sourceBase</code>: Source (copy)
            base directory.</p><p><code class="literal">source</code>: Source
            directory suffix (default to <code class="literal">@Indexed.index</code>).
            The actual source directory name being
            <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
            </p><p><code class="literal">refresh</code>: refresh period in second
            (the copy will take place every refresh seconds).</p><p>
            <code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to
            move in a single low level copy instruction; defaults to
            16MB.</p><p><code class="literal"> locking_strategy</code> : optional,
            see <a class="xref" href="#search-configuration-directory-lockfactories" title="3.10. LockFactory configuration">Section 3.10, “LockFactory configuration”</a>
            </p></td></tr></tbody></table></div></div><br class="table-break"/><p>If the built-in directory providers do not fit your needs, you can
    write your own directory provider by implementing the
    <code class="classname">org.hibernate.store.DirectoryProvider</code>
    interface.</p><p>Each indexed entity is associated to a Lucene index (an index can be
    shared by several entities but this is not usually the case). You can
    configure the index through properties prefixed by
    <code class="constant">hibernate.search.</code><em class="replaceable"><code>indexname</code></em>
    . Default properties inherited to all indexes can be defined using the
    prefix <code class="constant">hibernate.search.default.</code></p><p>To define the directory provider of a given index, you use the
    <code class="constant">hibernate.search.<em class="replaceable"><code>indexname</code></em>.directory_provider
    </code></p><div class="example"><a id="d0e862"/><p class="title"><b>Example 3.1. Configuring directory providers</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.directory_provider org.hibernate.search.store.FSDirectoryProvider
hibernate.search.default.indexBase=/usr/lucene/indexes
hibernate.search.Rules.directory_provider org.hibernate.search.store.RAMDirectoryProvider</pre></div></div><br class="example-break"/><p>applied on</p><div class="example"><a id="d0e869"/><p class="title"><b>Example 3.2. Specifying the index name using the <code class="literal">index</code>
      parameter of <code class="classname">@Indexed</code></b></p><div class="example-contents"><pre class="programlisting">@Indexed(index="Status")
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }</pre></div></div><br class="example-break"/><p>will create a file system directory in
    <code class="filename">/usr/lucene/indexes/Status</code> where the Status entities
    will be indexed, and use an in memory directory named
    <code class="literal">Rules</code> where Rule entities will be indexed.</p><p>You can easily define common rules like the directory provider and
    base directory, and override those defaults later on on a per index
    basis.</p><p>Writing your own <code class="classname">DirectoryProvider</code>, you can
    utilize this configuration mechanism as well.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-directory-sharding"/>3.2. Sharding indexes</h2></div></div></div><p>In some cases, it is necessary to split (shard) the indexing data of
    a given entity type into several Lucene indexes. This solution is not
    recommended unless there is a pressing need because by default, searches
    will be slower as all shards have to be opened for a single search. In
    other words don't do it until you have problems :)</p><p>For example, sharding may be desirable if:</p><div class="itemizedlist"><ul><li><p>A single index is so huge that index update times are slowing
        the application down.</p></li><li><p>A typical search will only hit a sub-set of the index, such as
        when data is naturally segmented by customer, region or
        application.</p></li></ul></div><p>Hibernate Search allows you to index a given entity type into
    several sub indexes. Data is sharded into the different sub indexes thanks
    to an <code class="classname">IndexShardingStrategy</code>. By default, no
    sharding strategy is enabled, unless the number of shards is configured.
    To configure the number of shards use the following property</p><div class="example"><a id="d0e913"/><p class="title"><b>Example 3.3. Enabling index sharding by specifying nbr_of_shards for a
      specific index</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards 5</pre></div></div><br class="example-break"/><p>This will use 5 different shards.</p><p>The default sharding strategy, when shards are set up, splits the
    data according to the hash value of the id string representation
    (generated by the Field Bridge). This ensures a fairly balanced sharding.
    You can replace the strategy by implementing
    <code class="literal">IndexShardingStrategy</code> and by setting the following
    property</p><div class="example"><a id="d0e925"/><p class="title"><b>Example 3.4. Specifying a custom sharding strategy</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy my.shardingstrategy.Implementation</pre></div></div><br class="example-break"/><p>Using a custom <code class="classname">IndexShardingStrategy</code>
    implementation, it's possible to define what shard a given entity is
    indexed to. </p><p>It also allows for optimizing searches by selecting which shard to
    run the query onto. By activating a filter (see <a class="xref" href="#query-filter-shard" title="5.3.1. Using filters in a sharded environment">Section 5.3.1, “Using filters in a sharded environment”</a>), a sharding strategy can select a subset
    of the shards used to answer a query
    (<code class="classname">IndexShardingStrategy.getDirectoryProvidersForQuery</code>)
    and thus speed up the query execution.</p><p>Each shard has an independent directory provider configuration as
    described in <a class="xref" href="#search-configuration-directory" title="3.1. Directory configuration">Section 3.1, “Directory configuration”</a>. The
    <code class="classname">DirectoryProvider</code> default name for the previous
    example are <code class="literal">&lt;indexName&gt;.0</code> to
    <code class="literal">&lt;indexName&gt;.4</code>. In other words, each shard has the
    name of it's owning index followed by <code class="constant">.</code> (dot) and its
    index number.</p><div class="example"><a id="d0e958"/><p class="title"><b>Example 3.5. Configuring the sharding configuration for an example entity
      <code class="classname">Animal</code></b></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.indexBase /usr/lucene/indexes

hibernate.search.Animal.sharding_strategy.nbr_of_shards 5
hibernate.search.Animal.directory_provider org.hibernate.search.store.FSDirectoryProvider
hibernate.search.Animal.0.indexName Animal00
hibernate.search.Animal.3.indexBase /usr/lucene/sharded
hibernate.search.Animal.3.indexName Animal03</pre></div></div><br class="example-break"/><p>This configuration uses the default id string hashing strategy and
    shards the Animal index into 5 subindexes. All subindexes are
    <code class="classname">FSDirectoryProvider</code> instances and the directory
    where each subindex is stored is as followed:</p><div class="itemizedlist"><ul><li><p>for subindex 0: /usr/lucene/indexes/Animal00 (shared indexBase
        but overridden indexName)</p></li><li><p>for subindex 1: /usr/lucene/indexes/Animal.1 (shared indexBase,
        default indexName)</p></li><li><p>for subindex 2: /usr/lucene/indexes/Animal.2 (shared indexBase,
        default indexName)</p></li><li><p>for subindex 3: /usr/lucene/shared/Animal03 (overridden
        indexBase, overridden indexName)</p></li><li><p>for subindex 4: /usr/lucene/indexes/Animal.4 (shared indexBase,
        default indexName)</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e986"/>3.3. Sharing indexes (two entities into the same directory)</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>This is only presented here so that you know the option is
      available. There is really not much benefit in sharing indexes.</p></div><p>It is technically possible to store the information of more than one
    entity into a single Lucene index. There are two ways to accomplish
    this:</p><div class="itemizedlist"><ul><li><p>Configuring the underlying directory providers to point to the
        same physical index directory. In practice, you set the property
        <code class="literal">hibernate.search.[fully qualified entity
        name].indexName</code> to the same value. As an example let’s use
        the same index (directory) for the <code class="classname">Furniture</code>
        and <code class="classname">Animal</code> entity. We just set
        <code class="literal">indexName</code> for both entities to for example
        “Animal”. Both entities will then be stored in the Animal
        directory</p><pre class="programlisting"><code class="code">hibernate.search.org.hibernate.search.test.shards.Furniture.indexName = Animal
hibernate.search.org.hibernate.search.test.shards.Animal.indexName = Animal</code></pre></li><li><p>Setting the <code class="code">@Indexed</code> annotation’s
        <code class="methodname">index</code> attribute of the entities you want to
        merge to the same value. If we again wanted all
        <code class="classname">Furniture</code> instances to be indexed in the
        <code class="classname">Animal</code> index along with all instances of
        <code class="classname">Animal</code> we would specify
        <code class="code">@Indexed(index=”Animal”)</code> on both
        <code class="classname">Animal</code> and <code class="classname">Furniture</code>
        classes.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1041"/>3.4. Worker configuration</h2></div></div></div><p>It is possible to refine how Hibernate Search interacts with Lucene
    through the worker configuration. The work can be executed to the Lucene
    directory or sent to a JMS queue for later processing. When processed to
    the Lucene directory, the work can be processed synchronously or
    asynchronously to the transaction commit.</p><p>You can define the worker configuration using the following
    properties</p><div class="table"><a id="d0e1048"/><p class="title"><b>Table 3.2. worker configuration</b></p><div class="table-contents"><table summary="worker configuration" border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>Property</td><td>Description</td></tr><tr><td><code class="literal">hibernate.search.worker.backend</code></td><td>Out of the box support for the Apache Lucene back end and
            the JMS back end. Default to <code class="literal">lucene</code>. Supports
            also <code class="literal">jms</code>, <code class="literal">blackhole</code>,
            <code class="literal">jgroupsMaster</code> and <code class="literal">jgroupsSlave</code>.</td></tr><tr><td><code class="literal">hibernate.search.worker.execution</code></td><td>Supports synchronous and asynchronous execution. Default to
            <code class="literal"><code class="literal">sync</code></code>. Supports also
            <code class="literal">async</code>.</td></tr><tr><td><code class="literal">hibernate.search.worker.thread_pool.size</code></td><td>Defines the number of threads in the pool. useful only for
            asynchronous execution. Default to 1.</td></tr><tr><td><code class="literal">hibernate.search.worker.buffer_queue.max</code></td><td>Defines the maximal number of work queue if the thread poll
            is starved. Useful only for asynchronous execution. Default to
            infinite. If the limit is reached, the work is done by the main
            thread.</td></tr><tr><td><code class="literal">hibernate.search.worker.jndi.*</code></td><td>Defines the JNDI properties to initiate the InitialContext
            (if needed). JNDI is only used by the JMS back end.</td></tr><tr><td><code class="literal">
            hibernate.search.worker.jms.connection_factory</code></td><td>Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS connection factory from
            (<code class="literal">/ConnectionFactory</code> by default in JBoss
            AS)</td></tr><tr><td><code class="literal">hibernate.search.worker.jms.queue</code></td><td>Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS queue from. The queue will be used to post work
            messages.</td></tr><tr><td><code class="literal">hibernate.search.worker.jgroups.clusterName</code></td><td>Optional for JGroups back end. Defines the name of JGroups channel.</td></tr><tr><td><code class="literal">hibernate.search.worker.jgroups.configurationFile</code></td><td>Optional JGroups network stack configuration. Defines the name of a JGroups
           configuration file, which must exist on classpath.</td></tr><tr><td><code class="literal">hibernate.search.worker.jgroups.configurationXml</code></td><td>Optional JGroups network stack configuration.
           Defines a String representing JGroups configuration as XML.</td></tr><tr><td><code class="literal">hibernate.search.worker.jgroups.configurationString</code></td><td>Optional JGroups network stack configuration.
            Provides JGroups configuration in plain text.</td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="jms-backend"/>3.5. JMS Master/Slave configuration</h2></div></div></div><p>This section describes in greater detail how to configure the Master
    / Slaves Hibernate Search architecture.</p><div class="mediaobject" align="center"><img src="jms-backend.png" align="middle"/><div class="caption"><p>JMS back end configuration.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1162"/>3.5.1. Slave nodes</h3></div></div></div><p>Every index update operation is sent to a JMS queue. Index
      querying operations are executed on a local index copy.</p><div class="example"><a id="d0e1167"/><p class="title"><b>Example 3.6. JMS Slave configuration</b></p><div class="example-contents"><pre class="programlisting">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSSlaveDirectoryProvider

## Backend configuration
hibernate.search.worker.backend = jms
hibernate.search.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.worker.jms.queue = queue/hibernatesearch
#optional jndi configuration (check your JMS provider for more information)

## Optional asynchronous execution strategy
# hibernate.search.worker.execution = async
# hibernate.search.worker.thread_pool.size = 2
# hibernate.search.worker.buffer_queue.max = 50</pre></div></div><br class="example-break"/><p>A file system local copy is recommended for faster search
      results.</p><p>The refresh period should be higher that the expected time
      copy.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1176"/>3.5.2. Master node</h3></div></div></div><p>Every index update operation is taken from a JMS queue and
      executed. The master index is copied on a regular basis.</p><div class="example"><a id="d0e1181"/><p class="title"><b>Example 3.7. JMS Master configuration</b></p><div class="example-contents"><pre class="programlisting">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = org.hibernate.search.store.FSMasterDirectoryProvider

## Backend configuration
#Backend is the default lucene one</pre></div></div><br class="example-break"/><p>The refresh period should be higher that the expected time
      copy.</p><p>In addition to the Hibernate Search framework configuration, a
      Message Driven Bean should be written and set up to process the index
      works queue through JMS.</p><div class="example"><a id="d0e1190"/><p class="title"><b>Example 3.8. Message Driven Bean processing the indexing queue</b></p><div class="example-contents"><pre class="programlisting">@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType", propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination", propertyValue="queue/hibernatesearch"),
      @ActivationConfigProperty(propertyName="DLQMaxResent", propertyValue="1")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController implements MessageListener {
    @PersistenceContext EntityManager em;
    
    //method retrieving the appropriate session
    protected Session getSession() {
        return (Session) em.getDelegate();
    }

    //potentially close the session opened in #getSession(), not needed here
    protected void cleanSessionIfNeeded(Session session) 
    }
}</pre></div></div><br class="example-break"/><p>This example inherits from the abstract JMS controller class
      available in the Hibernate Search source code and implements a JavaEE 5
      MDB. This implementation is given as an example and, while most likely
      be more complex, can be adjusted to make use of non Java EE Message
      Driven Beans. For more information about the
      <code class="methodname">getSession()</code> and
      <code class="methodname">cleanSessionIfNeeded()</code>, please check
      <code class="classname">AbstractJMSHibernateSearchController</code>'s
      javadoc.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="jgroups-backend"/>3.6. JGroups Master/Slave configuration</h2></div></div></div><p>Describes how to configure JGroups Master/Slave back end.
            Configuration examples illustrated in JMS Master/Slave configuration
            section (<a class="xref" href="#jms-backend" title="3.5. JMS Master/Slave configuration">Section 3.5, “JMS Master/Slave configuration”</a>) also apply here, only
            a different backend needs to be set.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1213"/>3.6.1. Slave nodes</h3></div></div></div><p>Every index update operation is sent through a JGroups channel to the master node. Index
                querying operations are executed on a local index copy.
            </p><div class="example"><a id="d0e1218"/><p class="title"><b>Example 3.9. JGroups Slave configuration</b></p><div class="example-contents"><pre class="programlisting">
### slave configuration
## Backend configuration
hibernate.search.worker.backend = jgroupsSlave
       </pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1223"/>3.6.2. Master node</h3></div></div></div><p>Every index update operation is taken from a JGroups channel and
                executed. The master index is copied on a regular basis.
            </p><div class="example"><a id="d0e1228"/><p class="title"><b>Example 3.10. JGroups Master configuration</b></p><div class="example-contents"><pre class="programlisting">
### master configuration
## Backend configuration
hibernate.search.worker.backend = jgroupsMaster
     </pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1233"/>3.6.3. JGroups channel configuration</h3></div></div></div><p>Optionally configuration for JGroups transport protocols
            (UDP, TCP) and channel name can be defined. It can be applied to both master and slave nodes.
            There are several ways to configure JGroups transport details.
            If it is not defined explicity, configuration found in the <code class="literal">
            flush-udp.xml</code> file is used.</p><div class="example"><a id="d0e1241"/><p class="title"><b>Example 3.11. JGroups transport protocols configuration</b></p><div class="example-contents"><pre class="programlisting">
## configuration
#udp.xml file needs to be located in the classpath
hibernate.search.worker.backend.jgroups.configurationFile = udp.xml

#protocol stack configuration provided in XML format
hibernate.search.worker.backend.jgroups.configurationXml =

&lt;config xmlns="urn:org:jgroups"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="urn:org:jgroups file:schema/JGroups-2.8.xsd"&gt;
&lt;UDP
mcast_addr="${jgroups.udp.mcast_addr:228.10.10.10}"
mcast_port="${jgroups.udp.mcast_port:45588}"
tos="8"
thread_naming_pattern="pl"
thread_pool.enabled="true"
thread_pool.min_threads="2"
thread_pool.max_threads="8"
thread_pool.keep_alive_time="5000"
thread_pool.queue_enabled="false"
thread_pool.queue_max_size="100"
thread_pool.rejection_policy="Run"/&gt;
&lt;PING timeout="1000" num_initial_members="3"/&gt;
&lt;MERGE2 max_interval="30000" min_interval="10000"/&gt;
&lt;FD_SOCK/&gt;
&lt;FD timeout="3000" max_tries="3"/&gt;
&lt;VERIFY_SUSPECT timeout="1500"/&gt;
&lt;pbcast.STREAMING_STATE_TRANSFER/&gt;
&lt;pbcast.FLUSH timeout="0"/&gt;
&lt;/config&gt;

#protocol stack configuration provided in "old style" jgroups format
hibernate.search.worker.backend.jgroups.configurationString =

UDP(mcast_addr=228.1.2.3;mcast_port=45566;ip_ttl=32):PING(timeout=3000;
num_initial_members=6):FD(timeout=5000):VERIFY_SUSPECT(timeout=1500):
pbcast.NAKACK(gc_lag=10;retransmit_timeout=3000):UNICAST(timeout=5000):
FRAG:pbcast.GMS(join_timeout=3000;shun=false;print_local_addr=true)

    </pre></div></div><br class="example-break"/><p>Master and slave nodes communicate over JGroups channel
                  that is identified by this same name. Name of the channel can be defined
                  explicity, if not default <code class="literal">HSearchCluster</code> is used.</p><div class="example"><a id="d0e1251"/><p class="title"><b>Example 3.12. JGroups channel name configuration</b></p><div class="example-contents"><pre class="programlisting">
## Backend configuration
hibernate.search.worker.backend.jgroups.clusterName = Hibernate-Search-Cluster
                </pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-reader-strategy"/>3.7. Reader strategy configuration</h2></div></div></div><p>The different reader strategies are described in <a class="xref" href="#search-architecture-readerstrategy" title="2.3. Reader strategy">Reader strategy</a>. Out of the box strategies
    are:</p><div class="itemizedlist"><ul><li><p><code class="literal">shared</code>: share index readers across several
        queries. This strategy is the most efficient.</p></li><li><p><code class="literal">not-shared</code>: create an index reader for each
        individual query</p></li></ul></div><p>The default reader strategy is <code class="literal">shared</code>. This can
    be adjusted:</p><pre class="programlisting">hibernate.search.reader.strategy = not-shared</pre><p>Adding this property switches to the <code class="literal">not-shared</code>
    strategy.</p><p>Or if you have a custom reader strategy:</p><pre class="programlisting">hibernate.search.reader.strategy = my.corp.myapp.CustomReaderProvider</pre><p>where <code class="classname">my.corp.myapp.CustomReaderProvider</code> is
    the custom strategy implementation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-event"/>3.8. Enabling Hibernate Search and automatic indexing</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1298"/>3.8.1. Enabling Hibernate Search</h3></div></div></div><p>Hibernate Search is enabled out of the box when using Hibernate
      Annotations or Hibernate EntityManager. If, for some reason you need to
      disable it, set
      <code class="literal">hibernate.search.autoregister_listeners</code> to false.
      Note that there is no performance penalty when the listeners are enabled
      but no entities are annotated as indexed.</p><p>To enable Hibernate Search in Hibernate Core (ie. if you don't use
      Hibernate Annotations), add the
      <code class="literal">FullTextIndexEventListener</code> for the following six
      Hibernate events and also add it after the default
      <code class="literal">DefaultFlushEventListener</code>, as in the following
      example.</p><div class="example"><a id="d0e1314"/><p class="title"><b>Example 3.13. Explicitly enabling Hibernate Search by configuring the
        <code class="classname">FullTextIndexEventListener</code></b></p><div class="example-contents"><pre class="programlisting">&lt;hibernate-configuration&gt;
     &lt;session-factory&gt;
        ...
        &lt;event type="post-update"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-insert"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-delete"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-recreate"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-remove"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="post-collection-update"&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="flush"&gt;
            &lt;listener class="org.hibernate.event.def.DefaultFlushEventListener"/&gt;
            &lt;listener class="org.hibernate.search.event.FullTextIndexEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1321"/>3.8.2. Automatic indexing</h3></div></div></div><p>By default, every time an object is inserted, updated or deleted
      through Hibernate, Hibernate Search updates the according Lucene index.
      It is sometimes desirable to disable that features if either your index
      is read-only or if index updates are done in a batch way (see <a class="xref" href="#search-batchindex" title="6.3. Rebuilding the whole Index">Section 6.3, “Rebuilding the whole Index”</a>).</p><p>To disable event based indexing, set</p><pre class="programlisting">hibernate.search.indexing_strategy manual</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>In most case, the JMS backend provides the best of both world, a
        lightweight event based system keeps track of all changes in the
        system, and the heavyweight indexing process is done by a separate
        process or machine.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="lucene-indexing-performance"/>3.9. Tuning Lucene indexing performance</h2></div></div></div><p>Hibernate Search allows you to tune the Lucene indexing performance
    by specifying a set of parameters which are passed through to underlying
    Lucene <code class="literal">IndexWriter</code> such as
    <code class="literal">mergeFactor</code>, <code class="literal">maxMergeDocs</code> and
    <code class="literal">maxBufferedDocs</code>. You can specify these parameters
    either as default values applying for all indexes, on a per index basis,
    or even per shard.</p><p>There are two sets of parameters allowing for different performance
    settings depending on the use case. During indexing operations triggered
    by database modifications, the parameters are grouped by the
    <code class="literal">transaction</code> keyword: </p><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.transaction.&lt;parameter_name&gt;</pre><p>
    When indexing occurs via <code class="literal">FullTextSession.index()</code> or
    via a <code class="classname">MassIndexer</code> (see
    <a class="xref" href="#search-batchindex" title="6.3. Rebuilding the whole Index">Section 6.3, “Rebuilding the whole Index”</a>), the used properties are those
    grouped under the <code class="literal">batch</code> keyword: </p><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.&lt;parameter_name&gt;</pre><p>If no value is set for a
    <code class="literal">.batch</code> value in a specific shard configuration,
    Hibernate Search will look at the index section, then at the default
    section: </p><pre class="programlisting">hibernate.search.Animals.2.indexwriter.transaction.max_merge_docs 10
hibernate.search.Animals.2.indexwriter.transaction.merge_factor 20
hibernate.search.default.indexwriter.batch.max_merge_docs 100</pre><p>
    This configuration will result in these settings applied to the second
    shard of Animals index:</p><div class="itemizedlist"><ul><li><p><code class="literal">transaction.max_merge_docs</code> = 10</p></li><li><p><code class="literal">batch.max_merge_docs</code> = 100</p></li><li><p><code class="literal">transaction.merge_factor</code> = 20</p></li><li><p><code class="literal">batch.merge_factor</code> = Lucene default</p></li></ul></div><p>All other values will use the defaults defined in Lucene.</p><p>The default for all values is to leave them at Lucene's own default,
    so the listed values in the following table actually depend on the version
    of Lucene you are using; values shown are relative to version
    <code class="literal">2.4</code>. For more information about Lucene indexing
    performances, please refer to the Lucene documentation.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Previous versions had the <code class="literal">batch</code>
    parameters inherit from <code class="literal">transaction</code> properties.
    This needs now to be explicitly set.</p></div><div class="table"><a id="d0e1418"/><p class="title"><b>Table 3.3. List of indexing performance and behavior properties</b></p><div class="table-contents"><table summary="List of indexing performance and behavior properties" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">Property</th><th align="center">Description</th><th align="center">Default Value</th></tr></thead><tbody><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</code></td><td><p>Set to <code class="literal">true</code> when no other
            process will need to write to the same index: this will enable
            Hibernate Search to work in exlusive mode on the index and
            improve performance in writing changes to the index.</p></td><td><code class="literal">false</code> (releases locks as soon as possible)</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_delete_terms</code></td><td><p>Determines the minimal number of delete terms
            required before the buffered in-memory delete terms are applied
            and flushed. If there are documents buffered in memory at the
            time, they are merged and a new segment is created.</p></td><td>Disabled (flushes by RAM usage)</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_docs</code></td><td><p>Controls the amount of documents buffered in memory
            during indexing. The bigger the more RAM is
            consumed.</p></td><td>Disabled (flushes by RAM usage)</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_field_length</code></td><td><p>The maximum number of terms that will be indexed for
            a single field. This limits the amount of memory required for
            indexing so that very large data will not crash the indexing
            process by running out of memory. This setting refers to the
            number of running terms, not to the number of different
            terms.</p> <p>This silently truncates large documents,
            excluding from the index all terms that occur further in the
            document. If you know your source documents are large, be sure to
            set this value high enough to accommodate the expected size. If
            you set it to Integer.MAX_VALUE, then the only limit is your
            memory, but you should anticipate an OutOfMemoryError. </p>
            <p>If setting this value in <code class="literal">batch</code>
            differently than in <code class="literal">transaction</code> you may get
            different data (and results) in your index depending on the
            indexing mode.</p></td><td>10000</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_merge_docs</code></td><td><p>Defines the largest number of documents allowed in a
            segment. Larger values are best for batched indexing and speedier
            searches. Small values are best for transaction
            indexing.</p></td><td>Unlimited (Integer.MAX_VALUE)</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].merge_factor</code></td><td><p>Controls segment merge frequency and size. </p>
            <p>Determines how often segment indexes are merged when
            insertion occurs. With smaller values, less RAM is used while
            indexing, and searches on unoptimized indexes are faster, but
            indexing speed is slower. With larger values, more RAM is used
            during indexing, and while searches on unoptimized indexes are
            slower, indexing is faster. Thus larger values (&gt; 10) are best
            for batch index creation, and smaller values (&lt; 10) for indexes
            that are interactively maintained. The value must no be lower than
            2.</p></td><td>10</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].ram_buffer_size</code></td><td><p>Controls the amount of RAM in MB dedicated to
            document buffers. When used together max_buffered_docs a flush
            occurs for whichever event happens first.</p> <p>Generally
            for faster indexing performance it's best to flush by RAM usage
            instead of document count and use as large a RAM buffer as you
            can.</p></td><td>16 MB</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].term_index_interval</code></td><td><p>Expert: Set the interval between indexed
            terms.</p> <p>Large values cause less memory to be used by
            IndexReader, but slow random-access to terms. Small values cause
            more memory to be used by an IndexReader, and speed random-access
            to terms. See Lucene documentation for more
            details.</p></td><td>128</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].use_compound_file</code></td><td>The advantage of using the compound file format is that
            less file descriptors are used. The disadvantage is that indexing
            takes more time and temporary disk space. You can set this
            parameter to <code class="literal">false</code> in an attempt to improve the
            indexing time, but you could run out of file descriptors if
            <code class="literal">mergeFactor</code> is also
            large.<p/><p>Boolean parameter, use
            "<code class="literal">true</code>" or "<code class="literal">false</code>". The
            default value for this option is
            <code class="literal">true</code>.</p></td><td>true</td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>When your architecture permits it, always set
    <code class="literal">hibernate.search.default.exclusive_index_use=true</code>
    as it greatly improves efficiency in index writing.</p></div><p>To tune the indexing speed it might be useful to time the object
    loading from database in isolation from the writes to the index. To
    achieve this set the <code class="literal">blackhole</code> as worker backend and
    start you indexing routines. This backend does not disable Hibernate
    Search: it will still generate the needed changesets to the index, but
    will discard them instead of flushing them to the index. As opposite to
    setting the <code class="literal">hibernate.search.indexing_strategy</code> to
    <code class="literal">manual</code> when using <code class="literal">blackhole</code> it will
    possibly load more data to rebuild the index from associated
    entities.</p><pre class="programlisting">hibernate.search.worker.backend blackhole</pre><p>The recommended approach is to focus first on optimizing the object
    loading, and then use the timings you achieve as a baseline to tune the
    indexing process.</p><p>The <code class="literal">blackhole</code> backend is not meant to be used in
    production, only as a tool to identify indexing bottlenecks.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-directory-lockfactories"/>3.10. LockFactory configuration</h2></div></div></div><p>Lucene Directories have default locking strategies which work well
    for most cases, but it's possible to specify for each index managed by
    Hibernate Search which LockingFactory you want to use.</p><p>Some of these locking strategies require a filesystem level lock and
    may be used even on RAM based indexes, but this is not recommended and of
    no practical use.</p><p>To select a locking factory, set the
    <code class="literal">hibernate.search.&lt;index&gt;.locking_strategy</code> option
    to one of <code class="literal">simple</code>, <code class="literal">native</code>,
    <code class="literal">single</code> or <code class="literal">none</code>, or set it to the
    fully qualified name of an implementation of
    <code class="literal">org.hibernate.search.store.LockFactoryFactory</code>;
    Implementing this interface you can provide a custom
    <code class="literal">org.apache.lucene.store.LockFactory</code>. </p><div class="table"><a id="search-configuration-directory-lockfactories-table"/><p class="title"><b>Table 3.4. List of available LockFactory implementations</b></p><div class="table-contents"><table summary="List of available LockFactory implementations" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">name</th><th align="center">Class</th><th align="center">Description</th></tr></thead><tbody><tr><td>simple</td><td>org.apache.lucene.store.SimpleFSLockFactory</td><td>
                <p>Safe implementation based on Java's File API, it marks
                the usage of the index by creating a marker file.</p>

                <p>If for some reason you had to kill your application, you
                will need to remove this file before restarting it.</p>

                <p>This is the default implementation for
                <code class="literal">FSDirectoryProvider</code>,<code class="literal">FSMasterDirectoryProvider</code>
                and <code class="literal">FSSlaveDirectoryProvider</code>.</p>
              </td></tr><tr><td>native</td><td>org.apache.lucene.store.NativeFSLockFactory</td><td>
                <p>As does <code class="literal">simple</code> this also marks the
                usage of the index by creating a marker file, but this one is
                using native OS file locks so that even if your application
                crashes the locks will be cleaned up.</p>

                <p>This implementation has known problems on NFS.</p>
              </td></tr><tr><td>single</td><td>org.apache.lucene.store.SingleInstanceLockFactory</td><td>
                <p>This LockFactory doesn't use a file marker but is a Java
                object lock held in memory; therefore it's possible to use it
                only when you are sure the index is not going to be shared by
                any other process.</p>

                <p>This is the default implementation for
                <code class="literal">RAMDirectoryProvider</code>.</p>
              </td></tr><tr><td>none</td><td>org.apache.lucene.store.NoLockFactory</td><td>
                <p>All changes to this index are not coordinated by any
                lock; test your application carefully and make sure you know
                what it means.</p>
              </td></tr></tbody></table></div></div><p><br class="table-break"/></p>

     Configuration example: 

    <pre class="programlisting">hibernate.search.default.locking_strategy simple
hibernate.search.Animals.locking_strategy native
hibernate.search.Books.locking_strategy org.custom.components.MyLockingFactory</pre><p/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1698"/>3.11. Exception Handling Configuration</h2></div></div></div><p>Hibernate Search allows you to configure how exceptions are handled
    during the indexing process. If no configuration is provided then
    exceptions are logged to the log output by default. It is possible to
    explicitly declare the exception logging mechanism as seen below:</p><pre class="programlisting">hibernate.search.error_handler log</pre><p>The
    default exception handling occurs for both synchronous and asynchronous
    indexing. Hibernate Search provides an easy mechanism to override the
    default error handling implementation.</p><p>In order to provide your own implementation you must implement the
    <code class="code">ErrorHandler</code> interface, which provides <code class="code">handle (
    ErrorContext context )</code> method. The <code class="code">ErrorContext</code>
    provides a reference to the primary <code class="code">LuceneWork</code> that failed, the
    underlying exception and any subsequent <code class="code">LuceneWork</code> that could
    not be processed due to the primary exception.</p><pre class="programlisting">public interface ErrorContext  {
   List&lt;LuceneWork&gt; getFailingOperations();
   LuceneWork getOperationAtFault();
   Throwable getThrowable();
   boolean hasErrors();
}</pre><p>The following provides an example implementation of
    <code class="code">ErrorHandler</code>:</p><pre class="programlisting">public class CustomErrorHandler implements ErrorHandler {
   public void handle ( ErrorContext context ) {
      ...
      //publish error context to some internal error handling system
      ...
   }
}</pre><p>To register this error handler with Hibernate Search you
    must declare the <code class="code">CustomErrorHandler</code> fully qualified classname
    in the configuration properties:</p><pre class="programlisting">hibernate.search.error_handler CustomerErrorHandler</pre></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-mapping"/>Chapter 4. Mapping entities to the index structure</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#search-mapping-entity">4.1. Mapping an entity</a></span></dt><dd><dl><dt><span class="section"><a href="#basic-mapping">4.1.1. Basic mapping</a></span></dt><dt><span class="section"><a href="#d0e1924">4.1.2. Mapping properties multiple times</a></span></dt><dt><span class="section"><a href="#search-mapping-associated">4.1.3. Embedded and associated objects</a></span></dt><dt><span class="section"><a href="#section-boost-annotation">4.1.4. Boost factor</a></span></dt><dt><span class="section"><a href="#d0e2218">4.1.5. Dynamic boost factor</a></span></dt><dt><span class="section"><a href="#analyzer">4.1.6. Analyzer</a></span></dt></dl></dd><dt><span class="section"><a href="#search-mapping-bridge">4.2. Property/Field Bridge</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2656">4.2.1. Built-in bridges</a></span></dt><dt><span class="section"><a href="#d0e2727">4.2.2. Custom Bridge</a></span></dt></dl></dd><dt><span class="section"><a href="#provided-id">4.3. Providing your own id</a></span></dt><dd><dl><dt><span class="section"><a href="#ProvidedId">4.3.1. The ProvidedId annotation</a></span></dt></dl></dd><dt><span class="section"><a href="#hsearch-mapping-programmaticapi">4.4. Programmatic API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3009">4.4.1. Mapping an entity as indexable</a></span></dt><dt><span class="section"><a href="#d0e3046">4.4.2. Adding DocumentId to indexed entity</a></span></dt><dt><span class="section"><a href="#d0e3069">4.4.3. Defining analyzers</a></span></dt><dt><span class="section"><a href="#d0e3099">4.4.4. Defining full text filter definitions</a></span></dt><dt><span class="section"><a href="#d0e3132">4.4.5. Defining fields for indexing</a></span></dt><dt><span class="section"><a href="#d0e3178">4.4.6. Programmatically defining embedded entities</a></span></dt><dt><span class="section"><a href="#d0e3211">4.4.7. Contained In definition</a></span></dt><dt><span class="section"><a href="#d0e3237">4.4.8. Date/Calendar Bridge</a></span></dt><dt><span class="section"><a href="#d0e3279">4.4.9. Defining bridges</a></span></dt><dt><span class="section"><a href="#d0e3310">4.4.10. Mapping class bridge</a></span></dt><dt><span class="section"><a href="#d0e3333">4.4.11. Mapping dynamic boost</a></span></dt></dl></dd></dl></div><p>All the metadata information needed to index entities is described
  through annotations. There is no need for xml mapping files. In fact there
  is currently no xml configuration option available (see <a class="ulink" href="http://opensource.atlassian.com/projects/hibernate/browse/HSEARCH-210">HSEARCH-210</a>).
  You can still use Hibernate mapping files for the basic Hibernate
  configuration, but the Hibernate Search specific configuration has to be
  expressed via annotations.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-mapping-entity"/>4.1. Mapping an entity</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="basic-mapping"/>4.1.1. Basic mapping</h3></div></div></div><p>First, we must declare a persistent class as indexable. This is
      done by annotating the class with <code class="literal">@Indexed</code> (all
      entities not annotated with <code class="literal">@Indexed</code> will be ignored
      by the indexing process):</p><div class="example"><a id="d0e1766"/><p class="title"><b>Example 4.1. Making a class indexable using the
        <code class="classname">@Indexed</code> annotation</b></p><div class="example-contents"><pre class="programlisting">@Entity
<span class="bold"><strong>@Indexed(index="indexes/essays")</strong></span>
public class Essay {
    ...
}</pre></div></div><br class="example-break"/><p>The <code class="literal">index</code> attribute tells Hibernate what the
      Lucene directory name is (usually a directory on your file system). It
      is recommended to define a base directory for all Lucene indexes using
      the <code class="literal">hibernate.search.default.indexBase</code> property in
      your configuration file. Alternatively you can specify a base directory
      per indexed entity by specifying
      <code class="literal">hibernate.search.&lt;index&gt;.indexBase, </code>where
      <code class="literal">&lt;index&gt;</code> is the fully qualified classname of the
      indexed entity. Each entity instance will be represented by a Lucene
      <code class="classname">Document</code> inside the given index (aka
      Directory).</p><p>For each property (or attribute) of your entity, you have the
      ability to describe how it will be indexed. The default (no annotation
      present) means that the property is ignored by the indexing process.
      <code class="literal">@Field</code> does declare a property as indexed. When
      indexing an element to a Lucene document you can specify how it is
      indexed:</p><div class="itemizedlist"><ul><li><p><code class="literal">name</code> : describe under which name, the
          property should be stored in the Lucene Document. The default value
          is the property name (following the JavaBeans convention)</p></li><li><p><code class="literal">store</code> : describe whether or not the
          property is stored in the Lucene index. You can store the value
          <code class="literal">Store.YES</code> (consuming more space in the index but
          allowing projection, see <a class="xref" href="#projections" title="5.1.2.5. Projection">Section 5.1.2.5, “Projection”</a> for more
          information), store it in a compressed way
          <code class="literal">Store.COMPRESS</code> (this does consume more CPU), or
          avoid any storage <code class="literal">Store.NO</code> (this is the default
          value). When a property is stored, you can retrieve its original
          value from the Lucene Document. This is not related to whether the
          element is indexed or not.</p></li><li><p>index: describe how the element is indexed and the type of
          information store. The different values are
          <code class="literal">Index.NO</code> (no indexing, ie cannot be found by a
          query), <code class="literal">Index.TOKENIZED</code> (use an analyzer to
          process the property), <code class="literal">Index.UN_TOKENIZED</code> (no
          analyzer pre-processing), <code class="literal">Index.NO_NORMS</code> (do not
          store the normalization data). The default value is
          <code class="literal">TOKENIZED</code>.</p></li><li><p>termVector: describes collections of term-frequency pairs.
          This attribute enables term vectors being stored during indexing so
          they are available within documents. The default value is
          TermVector.NO.</p><p>The different values of this attribute are:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th align="center">Value</th><th align="center">Definition</th></tr></thead><tbody><tr><td align="left">TermVector.YES</td><td align="left">Store the term vectors of each document. This
                  produces two synchronized arrays, one contains document
                  terms and the other contains the term's frequency.</td></tr><tr><td align="left">TermVector.NO</td><td align="left">Do not store term vectors.</td></tr><tr><td align="left">TermVector.WITH_OFFSETS</td><td align="left">Store the term vector and token offset information.
                  This is the same as TermVector.YES plus it contains the
                  starting and ending offset position information for the
                  terms.</td></tr><tr><td align="left">TermVector.WITH_POSITIONS</td><td align="left">Store the term vector and token position information.
                  This is the same as TermVector.YES plus it contains the
                  ordinal positions of each occurrence of a term in a
                  document.</td></tr><tr><td align="left">TermVector.WITH_POSITION_OFFSETS</td><td align="left">Store the term vector, token position and offset
                  information. This is a combination of the YES, WITH_OFFSETS
                  and WITH_POSITIONS.</td></tr></tbody></table></div></li></ul></div><p>Whether or not you want to store the original data in the index
      depends on how you wish to use the index query result. For a regular
      Hibernate Search usage storing is not necessary. However you might want
      to store some fields to subsequently project them (see <a class="xref" href="#projections" title="5.1.2.5. Projection">Section 5.1.2.5, “Projection”</a> for more information).</p><p>Whether or not you want to tokenize a property depends on whether
      you wish to search the element as is, or by the words it contains. It
      make sense to tokenize a text field, but probably not a date field.
      </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Fields used for sorting must not be tokenized.</p></div><p>Finally, the id property of an entity is a special property used
      by Hibernate Search to ensure index unicity of a given entity. By
      design, an id has to be stored and must not be tokenized. To mark a
      property as index id, use the <code class="literal">@DocumentId</code> annotation.
      If you are using Hibernate Annotations and you have specified @Id you
      can omit @DocumentId. The chosen entity id will also be used as document
      id.</p><div class="example"><a id="example-annotated-entity"/><p class="title"><b>Example 4.2. Adding <code class="classname">@DocumentId</code> ad
        <code class="classname">@Field</code> annotations to an indexed entity</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
public class Essay {
    ...

    @Id
    <span class="bold"><strong>@DocumentId</strong></span>
    public Long getId() { return id; }

    <span class="bold"><strong>@Field(name="Abstract", index=Index.TOKENIZED, store=Store.YES)</strong></span>
    public String getSummary() { return summary; }

    @Lob
    <span class="bold"><strong>@Field(index=Index.TOKENIZED)</strong></span>
    public String getText() { return text; }
}</pre></div></div><br class="example-break"/><p><a class="xref" href="#example-annotated-entity" title="Example 4.2. Adding @DocumentId ad @Field annotations to an indexed entity">Example 4.2, “Adding @DocumentId ad
        @Field annotations to an indexed entity”</a> define an index with
      three fields: <code class="literal">id</code> , <code class="literal">Abstract</code> and
      <code class="literal">text</code> . Note that by default the field name is
      decapitalized, following the JavaBean specification</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1924"/>4.1.2. Mapping properties multiple times</h3></div></div></div><p>Sometimes one has to map a property multiple times per index, with
      slightly different indexing strategies. For example, sorting a query by
      field requires the field to be <code class="literal">UN_TOKENIZED</code>. If one
      wants to search by words in this property and still sort it, one need to
      index it twice - once tokenized and once untokenized. @Fields allows to
      achieve this goal.</p><div class="example"><a id="example-fields-annotation"/><p class="title"><b>Example 4.3. Using @Fields to map a property multiple times</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index = "Book" )
public class Book {
    <span class="bold"><strong>@Fields( {</strong></span>
            @Field(index = Index.TOKENIZED),
            @Field(name = "summary_forSort", index = Index.UN_TOKENIZED, store = Store.YES)
            <span class="bold"><strong>} )</strong></span>
    public String getSummary() {
        return summary;
    }

    ...
}</pre></div></div><br class="example-break"/><p>In <a class="xref" href="#example-fields-annotation" title="Example 4.3. Using @Fields to map a property multiple times">Example 4.3, “Using @Fields to map a property multiple times”</a> the field
      <code class="literal">summary</code> is indexed twice, once as
      <code class="literal">summary</code> in a tokenized way, and once as
      <code class="literal">summary_forSort</code> in an untokenized way. @Field
      supports 2 attributes useful when @Fields is used:</p><div class="itemizedlist"><ul><li><p>analyzer: defines a @Analyzer annotation per field rather than
          per property</p></li><li><p>bridge: defines a @FieldBridge annotation per field rather
          than per property</p></li></ul></div><p>See below for more information about analyzers and field
      bridges.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="search-mapping-associated"/>4.1.3. Embedded and associated objects</h3></div></div></div><p>Associated objects as well as embedded objects can be indexed as
      part of the root entity index. This is useful if you expect to search a
      given entity based on properties of associated objects. In the following
      example the aim is to return places where the associated city is Atlanta
      (In the Lucene query parser language, it would translate into
      <code class="code">address.city:Atlanta</code>).</p><div class="example"><a id="d0e1973"/><p class="title"><b>Example 4.4. Using @IndexedEmbedded to index associations</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field( index = Index.TOKENIZED )
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <span class="bold"><strong>@IndexedEmbedded</strong></span>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field(index=Index.TOKENIZED)
    private String street;

    @Field(index=Index.TOKENIZED)
    private String city;

    <span class="bold"><strong>@ContainedIn</strong></span>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</pre></div></div><br class="example-break"/><p>In this example, the place fields will be indexed in the
      <code class="literal">Place</code> index. The <code class="literal">Place</code> index
      documents will also contain the fields <code class="literal">address.id</code>,
      <code class="literal">address.street</code>, and <code class="literal">address.city</code>
      which you will be able to query. This is enabled by the
      <code class="literal">@IndexedEmbedded</code> annotation.</p><p>Be careful. Because the data is denormalized in the Lucene index
      when using the <code class="classname">@IndexedEmbedded</code> technique,
      Hibernate Search needs to be aware of any change in the
      <code class="classname">Place</code> object and any change in the
      <code class="classname">Address</code> object to keep the index up to date. To
      make sure the <code class="literal"><code class="classname">Place</code></code> Lucene
      document is updated when it's <code class="classname">Address</code> changes,
      you need to mark the other side of the bidirectional relationship with
      <code class="classname">@ContainedIn</code>.</p><p><code class="literal">@ContainedIn</code> is only useful on associations
      pointing to entities as opposed to embedded (collection of)
      objects.</p><p>Let's make our example a bit more complex:</p><div class="example"><a id="d0e2031"/><p class="title"><b>Example 4.5. Nested usage of <code class="classname">@IndexedEmbedded</code> and
        <code class="classname">@ContainedIn</code></b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field( index = Index.TOKENIZED )
    private String name;

    @OneToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
    <span class="bold"><strong>@IndexedEmbedded</strong></span>
    private Address address;
    ....
}

@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field(index=Index.TOKENIZED)
    private String street;

    @Field(index=Index.TOKENIZED)
    private String city;

    <span class="bold"><strong>@IndexedEmbedded(depth = 1, prefix = "ownedBy_")</strong></span>
    private Owner ownedBy;

    <span class="bold"><strong>@ContainedIn</strong></span>
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}

@Embeddable
public class Owner {
    @Field(index = Index.TOKENIZED)
    private String name;
   ...
}</pre></div></div><br class="example-break"/><p>Any <code class="literal">@*ToMany, @*ToOne</code> and
      <code class="literal">@Embedded</code> attribute can be annotated with
      <code class="literal">@IndexedEmbedded</code>. The attributes of the associated
      class will then be added to the main entity index. In the previous
      example, the index will contain the following fields</p><div class="itemizedlist"><ul><li><p>id</p></li><li><p>name</p></li><li><p>address.street</p></li><li><p>address.city</p></li><li><p>address.ownedBy_name</p></li></ul></div><p>The default prefix is <code class="literal">propertyName.</code>, following
      the traditional object navigation convention. You can override it using
      the <code class="literal">prefix</code> attribute as it is shown on the
      <code class="literal">ownedBy</code> property.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The prefix cannot be set to the empty string.</p></div><p>The<code class="literal"> depth</code> property is necessary when the object
      graph contains a cyclic dependency of classes (not instances). For
      example, if <code class="classname">Owner</code> points to
      <code class="classname">Place</code>. Hibernate Search will stop including
      Indexed embedded attributes after reaching the expected depth (or the
      object graph boundaries are reached). A class having a self reference is
      an example of cyclic dependency. In our example, because
      <code class="literal">depth</code> is set to 1, any
      <code class="literal">@IndexedEmbedded</code> attribute in Owner (if any) will be
      ignored.</p><p>Using <code class="literal">@IndexedEmbedded</code> for object associations
      allows you to express queries such as:</p><div class="itemizedlist"><ul><li><p>Return places where name contains JBoss and where address city
          is Atlanta. In Lucene query this would be</p><pre class="programlisting">+name:jboss +address.city:atlanta  </pre></li><li><p>Return places where name contains JBoss and where owner's name
          contain Joe. In Lucene query this would be</p><pre class="programlisting">+name:jboss +address.orderBy_name:joe  </pre></li></ul></div><p>In a way it mimics the relational join operation in a more
      efficient way (at the cost of data duplication). Remember that, out of
      the box, Lucene indexes have no notion of association, the join
      operation is simply non-existent. It might help to keep the relational
      model normalized while benefiting from the full text index speed and
      feature richness.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>An associated object can itself (but does not have to) be
          <code class="literal">@Indexed</code></p></div><p>When @IndexedEmbedded points to an entity, the association has to
      be directional and the other side has to be annotated
      <code class="literal">@ContainedIn</code> (as seen in the previous example). If
      not, Hibernate Search has no way to update the root index when the
      associated entity is updated (in our example, a <code class="literal">Place</code>
      index document has to be updated when the associated
      <code class="classname">Address</code> instance is updated).</p><p>Sometimes, the object type annotated by
      <code class="classname">@IndexedEmbedded</code> is not the object type targeted
      by Hibernate and Hibernate Search. This is especially the case when
      interfaces are used in lieu of their implementation. For this reason you
      can override the object type targeted by Hibernate Search using the
      <code class="methodname">targetElement</code> parameter.</p><div class="example"><a id="d0e2151"/><p class="title"><b>Example 4.6. Using the <code class="literal">targetElement</code> property of
        <code class="classname">@IndexedEmbedded</code></b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    @DocumentId
    private Long id;

    @Field(index= Index.TOKENIZED)
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", <span class="bold"><strong>targetElement = Owner.class</strong></span>)
    @Target(Owner.class)
    private Person ownedBy;


    ...
}

@Embeddable
public class Owner implements Person { ... }</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="section-boost-annotation"/>4.1.4. Boost factor</h3></div></div></div><p>Lucene has the notion of <span class="emphasis"><em>boost factor</em></span>. It's a
      way to give more weight to a field or to an indexed element over others
      during the indexation process. You can use <code class="literal">@Boost</code> at
      the @Field, method or class level.</p><div class="example"><a id="d0e2175"/><p class="title"><b>Example 4.7. Using different ways of increasing the weight of an indexed
        element using a boost factor</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index="indexes/essays")
<span class="bold"><strong>@Boost(1.7f)</strong></span>
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", index=Index.TOKENIZED, store=Store.YES, boost=<span class="bold"><strong>@Boost(2f)</strong></span>)
    <span class="bold"><strong>@Boost(1.5f)</strong></span>
    public String getSummary() { return summary; }

    @Lob
    @Field(index=Index.TOKENIZED, boost=<span class="bold"><strong>@Boost(1.2f)</strong></span>)
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }

}        </pre></div></div><br class="example-break"/><p>In our example, <code class="classname">Essay</code>'s probability to
      reach the top of the search list will be multiplied by 1.7. The
      <code class="methodname">summary</code> field will be 3.0 (2 * 1.5 -
      <code class="methodname">@Field.boost</code> and <code class="classname">@Boost</code>
      on a property are cumulative) more important than the
      <code class="methodname">isbn</code> field. The <code class="methodname">text</code>
      field will be 1.2 times more important than the
      <code class="methodname">isbn</code> field. Note that this explanation in
      strictest terms is actually wrong, but it is simple and close enough to
      reality for all practical purposes. Please check the Lucene
      documentation or the excellent <em class="citetitle">Lucene In Action </em>
      from Otis Gospodnetic and Erik Hatcher.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2218"/>4.1.5. Dynamic boost factor</h3></div></div></div><p>The <code class="literal">@Boost </code>annotation used in <a class="xref" href="#section-boost-annotation" title="4.1.4. Boost factor">Section 4.1.4, “Boost factor”</a> defines a static boost factor
      which is is independent of the state of of the indexed entity at
      runtime. However, there are usecases in which the boost factor may
      depends on the actual state of the entity. In this case you can use the
      <code class="literal">@DynamicBoost </code>annotation together with an
      accompanying custom <code class="classname">BoostStrategy</code>.</p><div class="example"><a id="example-dynamic-boosting"/><p class="title"><b>Example 4.8. Dynamic boost examle</b></p><div class="example-contents"><pre class="programlisting">public enum PersonType {
    NORMAL,
    VIP
}

@Entity
@Indexed
<span class="bold"><strong>@DynamicBoost(impl = VIPBoostStrategy.class)</strong></span>
public class Person {
    private PersonType type;   
    
    // ....
}

public class VIPBoostStrategy implements BoostStrategy {
    <span class="bold"><strong>public float defineBoost(Object value)</strong></span> {
        Person person = ( Person ) value;
        if ( person.getType().equals( PersonType.VIP ) ) {
            return 2.0f;
        }
        else {
            return 1.0f;
        }
    }
}</pre></div></div><p><br class="example-break"/>In <a class="xref" href="#example-dynamic-boosting" title="Example 4.8. Dynamic boost examle">Example 4.8, “Dynamic boost examle”</a> a dynamic
      boost is defined on class level specifying
      <code class="classname">VIPBoostStrategy</code> as implementation of the
      <code class="classname">BoostStrategy</code> interface to be used at indexing
      time. You can place the <code class="literal">@DynamicBoost</code> either at class
      or field level. Depending on the placement of the annotation either the
      whole entity is passed to the <code class="methodname">defineBoost</code>
      method or just the annotated field/property value. It's up to you to
      cast the passed object to the correct type. In the example all indexed
      values of a VIP person would be double as important as the values of a
      normal person.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The specified <code class="classname">BoostStrategy</code>
          implementation must define a public no-arg constructor.</p></div><p>Of course you can mix and match <code class="literal">@Boost</code> and
      <code class="literal">@DynamicBoost</code> annotations in your entity. All defined
      boost factors are cummulative as described in <a class="xref" href="#section-boost-annotation" title="4.1.4. Boost factor">Section 4.1.4, “Boost factor”</a>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="analyzer"/>4.1.6. Analyzer</h3></div></div></div><p>The default analyzer class used to index tokenized fields is
      configurable through the <code class="literal">hibernate.search.analyzer</code>
      property. The default value for this property is
      <code class="classname">org.apache.lucene.analysis.standard.StandardAnalyzer</code>.</p><p>You can also define the analyzer class per entity, property and
      even per @Field (useful when multiple fields are indexed from a single
      property).</p><div class="example"><a id="d0e2288"/><p class="title"><b>Example 4.9. Different ways of specifying an analyzer</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
<span class="bold"><strong>@Analyzer(impl = EntityAnalyzer.class)</strong></span>
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field(index = Index.TOKENIZED)
    private String name;

    @Field(index = Index.TOKENIZED)
    <span class="bold"><strong>@Analyzer(impl = PropertyAnalyzer.class)</strong></span>
    private String summary;

    @Field(index = Index.TOKENIZED, <span class="emphasis"><em><span class="bold"><strong>analyzer = @Analyzer(impl = FieldAnalyzer.class</strong></span>)</em></span>
    private String body;

    ...
}</pre></div></div><br class="example-break"/><p>In this example, <code class="classname">EntityAnalyzer</code> is used to
      index all tokenized properties (eg. <code class="literal">name</code>), except
      <code class="literal">summary</code> and <code class="literal">body</code> which are indexed
      with <code class="classname">PropertyAnalyzer</code> and
      <code class="classname">FieldAnalyzer</code> respectively.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="caution"><h2>Caution</h2><p>Mixing different analyzers in the same entity is most of the
        time a bad practice. It makes query building more complex and results
        less predictable (for the novice), especially if you are using a
        QueryParser (which uses the same analyzer for the whole query). As a
        rule of thumb, for any given field the same analyzer should be used
        for indexing and querying.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2327"/>4.1.6.1. Analyzer definitions</h4></div></div></div><p>Analyzers can become quite complex to deal with for which reason
        Hibernate Search introduces the notion of analyzer definitions. An
        analyzer definition can be reused by many
        <code class="classname">@Analyzer</code> declarations. An analyzer definition
        is composed of:</p><div class="itemizedlist"><ul><li><p>a name: the unique string used to refer to the
            definition</p></li><li><p>a list of char filters: each char filter is responsible to
              pre-process input characters before the tokenization. Char filters can add,
              change or remove characters; one common usage is for characters normalization</p></li><li><p>a tokenizer: responsible for tokenizing the input stream
            into individual words</p></li><li><p>a list of filters: each filter is responsible to remove,
            modify or sometimes even add words into the stream provided by the
            tokenizer</p></li></ul></div><p>This separation of tasks - a list of char filters, and a tokenizer followed by a list of
        filters - allows for easy reuse of each individual component and let
        you build your customized analyzer in a very flexible way (just like
        Lego). Generally speaking the <code class="classname">char filters</code> do some
        pre-processing in the character input, then the <code class="classname">Tokenizer</code> starts
        the tokenizing process by turning the character input into tokens which
        are then further processed by the <code class="classname">TokenFilter</code>s.
        Hibernate Search supports this infrastructure by utilizing the Solr
        analyzer framework. Make sure to add<code class="filename"> solr-core.jar and
        </code><code class="filename">solr-solrj.jar</code> to your classpath to
        use analyzer definitions. In case you also want to use the
        snowball stemmer also include the
        <code class="filename">lucene-snowball.jar.</code> Other Solr analyzers might
        depend on more libraries. For example, the
        <code class="classname">PhoneticFilterFactory</code> depends on <a class="ulink" href="http://commons.apache.org/codec">commons-codec</a>. Your
        distribution of Hibernate Search provides these dependencies in its
        <code class="filename">lib</code> directory.</p><div class="example"><a id="d0e2376"/><p class="title"><b>Example 4.10. <code class="classname">@AnalyzerDef</code> and the Solr
          framework</b></p><div class="example-contents"><pre class="programlisting">@AnalyzerDef(name="customanalyzer",
        charFilters = {
                @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
                    @Parameter(name = "mapping", value = "org/hibernate/search/test/analyzer/solr/mapping-chars.properties")
                })
        },
        tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
        filters = {
                @TokenFilterDef(factory = ISOLatin1AccentFilterFactory.class),
                @TokenFilterDef(factory = LowerCaseFilterFactory.class),
                @TokenFilterDef(factory = StopFilterFactory.class, params = {
                    @Parameter(name="words", value= "org/hibernate/search/test/analyzer/solr/stoplist.properties" ),
                    @Parameter(name="ignoreCase", value="true")
                })
})
public class Team {
    ...
}</pre></div></div><br class="example-break"/><p>A char filter is defined by its factory which is responsible for
        building the char filter and using the optional list of parameters.
        In our example, a mapping char filter is used, and will replace
        characters in the input based on the rules specified in the mapping
        file. A tokenizer is also defined by its factory.
        This example use the standard tokenizer. A filter is defined by its factory
        which is responsible for creating the filter instance using the
        optional parameters. In our example, the StopFilter filter is built
        reading the dedicated words property file and is expected to ignore
        case. The list of parameters is dependent on the tokenizer or filter
        factory.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Filters and char filters are applied in the order they are defined in the
          <code class="classname">@AnalyzerDef</code> annotation. Make sure to think
          twice about this order.</p></div><p>Once defined, an analyzer definition can be reused by an
        <code class="classname">@Analyzer</code> declaration using the definition name
        rather than declaring an implementation class.</p><div class="example"><a id="d0e2396"/><p class="title"><b>Example 4.11. Referencing an analyzer by name</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field <span class="bold"><strong>@Analyzer(definition = "customanalyzer")</strong></span>
    private String description;
}</pre></div></div><br class="example-break"/><p>Analyzer instances declared by
        <code class="classname">@AnalyzerDef</code> are available by their name in the
        <code class="classname">SearchFactory</code>.</p><pre class="programlisting">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</pre><p>This is quite useful wen building queries. Fields in queries
        should be analyzed with the same analyzer used to index the field so
        that they speak a common "language": the same tokens are reused
        between the query and the indexing process. This rule has some
        exceptions but is true most of the time. Respect it unless you know
        what you are doing.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2416"/>4.1.6.2. Available analyzers</h4></div></div></div><p>Solr and Lucene come with a lot of useful default char filters, tokenizers and
        filters. You can find a complete list of char filter factories, tokenizer factories and
        filter factories at <a class="ulink" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</a>.
        Let check a few of them.</p><div class="table"><a id="d0e2424"/><p class="title"><b>Table 4.1. Some of the available char filters</b></p><div class="table-contents"><table summary="Some of the available char filters" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">Factory</th><th align="center">Description</th><th align="center">parameters</th></tr></thead><tbody><tr><td>MappingCharFilterFactory</td><td>Replaces one or more characters with one or more characters, based on mappings
                specified in the resource file</td><td><p><code class="literal">mapping</code>: points to a resource file containing the mappings
                using the format:
                </p><div class="literallayout"><p><br/>
                    "á" =&gt; "a"<br/>
                    "ñ" =&gt; "n"<br/>
                    "ø" =&gt; "o"<br/>
                </p></div><p>
                </p></td></tr><tr><td>HTMLStripCharFilterFactory</td><td>Remove HTML standard tags, keeping the text</td><td>none</td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="d0e2457"/><p class="title"><b>Table 4.2. Some of the available tokenizers</b></p><div class="table-contents"><table summary="Some of the available tokenizers" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">Factory</th><th align="center">Description</th><th align="center">parameters</th></tr></thead><tbody><tr><td>StandardTokenizerFactory</td><td>Use the Lucene StandardTokenizer</td><td>none</td></tr><tr><td>HTMLStripStandardTokenizerFactory</td><td>Remove HTML tags, keep the text and pass it to a
                StandardTokenizer. @Deprecated, use the HTMLStripCharFilterFactory instead</td><td>none</td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="d0e2484"/><p class="title"><b>Table 4.3. Some of the available filters</b></p><div class="table-contents"><table summary="Some of the available filters" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">Factory</th><th align="center">Description</th><th align="center">parameters</th></tr></thead><tbody><tr><td>StandardFilterFactory</td><td>Remove dots from acronyms and 's from words</td><td>none</td></tr><tr><td>LowerCaseFilterFactory</td><td>Lowercase words</td><td>none</td></tr><tr><td>StopFilterFactory</td><td>remove words (tokens) matching a list of stop
                words</td><td><p><code class="literal">words</code>: points to a resource
                file containing the stop words</p><p>ignoreCase: true if
                <code class="literal">case</code> should be ignore when comparing stop
                words, <code class="literal">false</code> otherwise </p></td></tr><tr><td>SnowballPorterFilterFactory</td><td>Reduces a word to it's root in a given language. (eg.
                protect, protects, protection share the same root). Using such
                a filter allows searches matching related words.</td><td><code class="literal">language</code>: Danish, Dutch, English,
                Finnish, French, German, Italian, Norwegian, Portuguese,
                Russian, Spanish, Swedish and a few more</td></tr><tr><td>ISOLatin1AccentFilterFactory</td><td>remove accents for languages like French</td><td>none</td></tr></tbody></table></div></div><br class="table-break"/><p>We recommend to check all the implementations of
        <code class="classname">org.apache.solr.analysis.TokenizerFactory</code> and
        <code class="classname">org.apache.solr.analysis.TokenFilterFactory</code> in
        your IDE to see the implementations available.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2553"/>4.1.6.3. Analyzer discriminator (experimental)</h4></div></div></div><p>So far all the introduced ways to specify an analyzer were
        static. However, there are use cases where it is useful to select an
        analyzer depending on the current state of the entity to be indexed,
        for example in multilingual applications. For an
        <code class="classname">BlogEntry</code> class for example the analyzer could
        depend on the language property of the entry. Depending on this
        property the correct language specific stemmer should be chosen to
        index the actual text.</p><p>To enable this dynamic analyzer selection Hibernate Search
        introduces the <code class="classname">AnalyzerDiscriminator</code>
        annotation. The following example demonstrates the usage of this
        annotation:</p><div class="example"><a id="d0e2567"/><p class="title"><b>Example 4.12. Usage of @AnalyzerDiscriminator in order to select an
            analyzer depending on the entity state</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class
      )
    }),
  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
    })
})
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;
    
    @Field
    private String text;
    
    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    ...
}</pre><pre class="programlisting">public class LanguageDiscriminator implements Discriminator {

    public String getAnalyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof Article ) ) {
            return null;
        }
        return (String) value;
    }
}</pre></div></div><p><br class="example-break"/></p><p>The prerequisite for using
        <code class="classname">@AnalyzerDiscriminator</code> is that all analyzers
        which are going to be used are predefined via
        <code class="classname">@AnalyzerDef</code> definitions. If this is the case
        one can place the <code class="classname">@AnalyzerDiscriminator</code>
        annotation either on the class or on a specific property of the entity
        for which to dynamically select an analyzer. Via the
        <code class="literal">impl</code> parameter of the
        <code class="classname">AnalyzerDiscriminator</code> you specify a concrete
        implementation of the <code class="classname">Discriminator</code> interface.
        It is up to you to provide an implementation for this interface. The
        only method you have to implement is
        <code class="classname">getAnalyzerDefinitionName()</code> which gets called
        for each field added to the Lucene document. The entity which is
        getting indexed is also passed to the interface method. The
        <code class="literal">value</code> parameter is only set if the
        <code class="classname">AnalyzerDiscriminator</code> is placed on property
        level instead of class level. In this case the value represents the
        current value of this property.</p><p>An implemention of the <code class="classname">Discriminator</code>
        interface has to return the name of an existing analyzer definition if
        the analyzer should be set dynamically or <code class="classname">null</code>
        if the default analyzer should not be overridden. The given example
        assumes that the language parameter is either 'de' or 'en' which
        matches the specified names in the
        <code class="classname">@AnalyzerDef</code>s.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The <code class="classname">@AnalyzerDiscriminator</code> is currently
          still experimental and the API might still change. We are hoping for
          some feedback from the community about the usefulness and usability
          of this feature.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="analyzer-retrievinganalyzer"/>4.1.6.4. Retrieving an analyzer</h4></div></div></div><p>During indexing time, Hibernate Search is using analyzers under
        the hood for you. In some situations, retrieving analyzers can be
        handy. If your domain model makes use of multiple analyzers (maybe to
        benefit from stemming, use phonetic approximation and so on), you need
        to make sure to use the same analyzers when you build your
        query.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>This rule can be broken but you need a good reason for it. If
          you are unsure, use the same analyzers.</p></div><p>You can retrieve the scoped analyzer for a given entity used at
        indexing time by Hibernate Search. A scoped analyzer is an analyzer
        which applies the right analyzers depending on the field indexed:
        multiple analyzers can be defined on a given entity each one working
        on an individual field, a scoped analyzer unify all these analyzers
        into a context-aware analyzer. While the theory seems a bit complex,
        using the right analyzer in a query is very easy.</p><div class="example"><a id="d0e2630"/><p class="title"><b>Example 4.13. Using the scoped analyzer when building a full-text
          query</b></p><div class="example-contents"><pre class="programlisting">org.apache.lucene.queryParser.QueryParser parser = new QueryParser(
    "title", 
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery = 
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery = 
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects    </pre></div></div><br class="example-break"/><p>In the example above, the song title is indexed in two fields:
        the standard analyzer is used in the field <code class="literal">title</code>
        and a stemming analyzer is used in the field
        <code class="literal">title_stemmed</code>. By using the analyzer provided by
        the search factory, the query uses the appropriate analyzer depending
        on the field targeted.</p><p>If your query targets more that one query and you wish to use
        your standard analyzer, make sure to describe it using an analyzer
        definition. You can retrieve analyzers by their definition name using
        <code class="code">searchFactory.getAnalyzer(String)</code>.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-mapping-bridge"/>4.2. Property/Field Bridge</h2></div></div></div><p>In Lucene all index fields have to be represented as Strings. For
    this reason all entity properties annotated with <code class="literal">@Field</code>
    have to be indexed in a String form. For most of your properties,
    Hibernate Search does the translation job for you thanks to a built-in set
    of bridges. In some cases, though you need a more fine grain control over
    the translation process.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2656"/>4.2.1. Built-in bridges</h3></div></div></div><p>Hibernate Search comes bundled with a set of built-in bridges
      between a Java property type and its full text representation.</p><div class="variablelist"><dl><dt><span class="term">null</span></dt><dd><p>null elements are not indexed. Lucene does not support null
            elements and this does not make much sense either.</p></dd><dt><span class="term">java.lang.String</span></dt><dd><p>String are indexed as is</p></dd><dt><span class="term">short, Short, integer, Integer, long, Long, float, Float,
          double, Double, BigInteger, BigDecimal</span></dt><dd><p>Numbers are converted in their String representation. Note
            that numbers cannot be compared by Lucene (ie used in ranged
            queries) out of the box: they have to be padded </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Using a Range query is debatable and has drawbacks, an
                alternative approach is to use a Filter query which will
                filter the result query to the appropriate range.</p><p>Hibernate Search will support a padding mechanism</p></div></dd><dt><span class="term">java.util.Date</span></dt><dd><p>Dates are stored as yyyyMMddHHmmssSSS in GMT time
            (200611072203012 for Nov 7th of 2006 4:03PM and 12ms EST). You
            shouldn't really bother with the internal format. What is
            important is that when using a DateRange Query, you should know
            that the dates have to be expressed in GMT time.</p><p>Usually, storing the date up to the millisecond is not
            necessary. <code class="literal">@DateBridge</code> defines the appropriate
            resolution you are willing to store in the index ( <code class="literal">
            <code class="literal">@DateBridge(resolution=Resolution.DAY)</code>
            </code> ). The date pattern will then be truncated
            accordingly.</p><pre class="programlisting">@Entity 
@Indexed
public class Meeting {
    @Field(index=Index.UN_TOKENIZED)
    <span class="bold"><strong>@DateBridge(resolution=Resolution.MINUTE)</strong></span>
    private Date date;
    ...                 </pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>A Date whose resolution is lower than
              <code class="literal">MILLISECOND</code> cannot be a
              <code class="literal">@DocumentId</code></p></div></dd><dt><span class="term">java.net.URI, java.net.URL</span></dt><dd><p>URI and URL are converted to their string
            representation</p></dd><dt><span class="term">java.lang.Class</span></dt><dd><p>Class are converted to their fully qualified class name. The
            thread context classloader is used when the class is
            rehydrated</p></dd></dl></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2727"/>4.2.2. Custom Bridge</h3></div></div></div><p>Sometimes, the built-in bridges of Hibernate Search do not cover
      some of your property types, or the String representation used by the
      bridge does not meet your requirements. The following paragraphs
      describe several solutions to this problem.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2732"/>4.2.2.1. StringBridge</h4></div></div></div><p>The simplest custom solution is to give Hibernate Search an
        implementation of your expected
        <span class="emphasis"><em><code class="classname">Object</code> </em></span>to
        <code class="classname">String</code> bridge. To do so you need to implements
        the <code class="literal">org.hibernate.search.bridge.StringBridge</code>
        interface. All implementations have to be thread-safe as they are used
        concurrently.</p><div class="example"><a id="d0e2748"/><p class="title"><b>Example 4.14. Implementing your own
          <code class="classname">StringBridge</code></b></p><div class="example-contents"><pre class="programlisting">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements <span class="bold"><strong>StringBridge</strong></span> {

    private int PADDING = 5;

    <span class="bold"><strong>public String objectToString(Object object)</strong></span> {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; PADDING) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; PADDING ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}                </pre></div></div><br class="example-break"/><p>Then any property or field can use this bridge thanks to the
        <code class="literal">@FieldBridge</code> annotation</p><pre class="programlisting"><span class="bold"><strong>@FieldBridge(impl = PaddedIntegerBridge.class)</strong></span>
private Integer length;                </pre><p>Parameters can be passed to the Bridge implementation making it
        more flexible. The Bridge implementation implements a
        <code class="classname">ParameterizedBridge</code> interface, and the
        parameters are passed through the <code class="literal">@FieldBridge</code>
        annotation.</p><div class="example"><a id="d0e2778"/><p class="title"><b>Example 4.15. Passing parameters to your bridge implementation</b></p><div class="example-contents"><pre class="programlisting">public class PaddedIntegerBridge implements StringBridge, <span class="bold"><strong>ParameterizedBridge</strong></span> {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    <span class="bold"><strong>public void setParameterValues(Map parameters)</strong></span> {
        Object padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}


//property
@FieldBridge(impl = PaddedIntegerBridge.class,
             <span class="bold"><strong>params = @Parameter(name="padding", value="10")</strong></span>
            )
private Integer length;                </pre></div></div><br class="example-break"/><p>The <code class="classname">ParameterizedBridge</code> interface can be
        implemented by <code class="classname">StringBridge</code>,
        <code class="classname">TwoWayStringBridge</code>,
        <code class="classname">FieldBridge</code> implementations.</p><p>All implementations have to be thread-safe, but the parameters
        are set during initialization and no special care is required at this
        stage.</p><p>If you expect to use your bridge implementation on an id
        property (ie annotated with <code class="literal">@DocumentId</code> ), you need
        to use a slightly extended version of <code class="literal">StringBridge</code>
        named <code class="classname">TwoWayStringBridge</code>. Hibernate Search
        needs to read the string representation of the identifier and generate
        the object out of it. There is no difference in the way the
        <code class="literal">@FieldBridge</code> annotation is used.</p><div class="example"><a id="d0e2822"/><p class="title"><b>Example 4.16. Implementing a TwoWayStringBridge which can for example be
          used for id properties</b></p><div class="example-contents"><pre class="programlisting">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ( (Integer) object ).toString();
        if (rawInteger.length() &gt; padding) 
            throw new IllegalArgumentException( "Try to pad on a number too big" );
        StringBuilder paddedInteger = new StringBuilder( );
        for ( int padIndex = rawInteger.length() ; padIndex &lt; padding ; padIndex++ ) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }

    <span class="bold"><strong>public Object stringToObject(String stringValue)</strong></span> {
        return new Integer(stringValue);
    }
}


//id property
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10") 
private Integer id;
                </pre></div></div><br class="example-break"/><p>It is critically important for the two-way process to be
        idempotent (ie object = stringToObject( objectToString( object ) )
        ).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2832"/>4.2.2.2. FieldBridge</h4></div></div></div><p>Some use cases require more than a simple object to string
        translation when mapping a property to a Lucene index. To give you the
        greatest possible flexibility you can also implement a bridge as a
        <code class="classname">FieldBridge</code>. This interface gives you a
        property value and let you map it the way you want in your Lucene
        <code class="classname">Document</code>. The interface is very similar in its
        concept to the Hibernate <code class="classname">UserType</code>s.</p><p>You can for example store a given property in two different
        document fields:</p><div class="example"><a id="d0e2848"/><p class="title"><b>Example 4.17. Implementing the FieldBridge interface in order to a given
          property into multiple document fields</b></p><div class="example-contents"><pre class="programlisting">/**
 * Store the date in 3 different fields - year, month, day - to ease Range Query per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    <span class="bold"><strong>public void set(String name, Object value, Document document, 
                    LuceneOptions luceneOptions)</strong></span> {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);
  
        // set year
        luceneOptions.addFieldToDocument(
            name + ".year",
            String.valueOf( year ),
            document );
  
        // set month and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".month",
            month &lt; 10 ? "0" : "" + String.valueOf( month ),
            document );
  
        // set day and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".day",
            day &lt; 10 ? "0" : "" + String.valueOf( day ),
            document );
    }
}

//property
<span class="bold"><strong>@FieldBridge(impl = DateSplitBridge.class)</strong></span>
private Date date;                </pre></div></div><br class="example-break"/><p>In the previous example the fields where not added directly to Document
        but we where delegating this task to the <code class="classname">LuceneOptions</code> helper; this will apply the
        options you have selected on <code class="literal">@Field</code>, like <code class="literal">Store</code>
        or <code class="literal">TermVector</code> options, or apply the choosen <code class="classname">@Boost</code>
        value. It is especially useful to encapsulate the complexity of <code class="literal">COMPRESS</code>
        implementations so it's recommended to delegate to <code class="classname">LuceneOptions</code> to add fields to the
        <code class="classname">Document</code>, but nothing stops you from editing
        the <code class="classname">Document</code> directly and ignore the <code class="classname">LuceneOptions</code> in case you need to.
        </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>Classes like <code class="classname">LuceneOptions</code> are created to shield your application from
        changes in Lucene API and simplify your code. Use them if you can, but if you need more flexibility
        you're not required to.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2897"/>4.2.2.3. ClassBridge</h4></div></div></div><p>It is sometimes useful to combine more than one property of a
        given entity and index this combination in a specific way into the
        Lucene index. The <code class="classname">@ClassBridge</code> and
        <code class="classname">@ClassBridge</code> annotations can be defined at the
        class level (as opposed to the property level). In this case the
        custom field bridge implementation receives the entity instance as the
        value parameter instead of a particular property. Though not shown in
        this example, <code class="classname">@ClassBridge</code> supports the
        <code class="methodname">termVector</code> attribute discussed in section
        <a class="xref" href="#basic-mapping" title="4.1.1. Basic mapping">Section 4.1.1, “Basic mapping”</a>.</p><div class="example"><a id="d0e2916"/><p class="title"><b>Example 4.18. Implementing a class bridge</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
<span class="bold"><strong>@ClassBridge</strong></span>(name="branchnetwork",
             index=Index.TOKENIZED,
             store=Store.YES,
             impl = <span class="bold"><strong>CatFieldsClassBridge.class</strong></span>,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees
    ...
}

public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    <span class="bold"><strong>public void set(String name, Object value, Document document, LuceneOptions luceneOptions)</strong></span> {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        Field field = new Field( name, fieldValue, luceneOptions.getStore(), luceneOptions.getIndex(), luceneOptions.getTermVector() );
        field.setBoost( luceneOptions.getBoost() );
        document.add( field );
   }
}</pre></div></div><br class="example-break"/><p>In this example, the particular
        <code class="classname">CatFieldsClassBridge</code> is applied to the
        <code class="literal">department</code> instance, the field bridge then
        concatenate both branch and network and index the
        concatenation.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="provided-id"/>4.3. Providing your own id</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>This part of the documentation is a work in progress.</p></div><p>You can provide your own id for Hibernate Search if you are
    extending the internals. You will have to generate a unique value so it
    can be given to Lucene to be indexed. This will have to be given to
    Hibernate Search when you create an org.hibernate.search.Work object - the
    document id is required in the constructor.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="ProvidedId"/>4.3.1. The ProvidedId annotation</h3></div></div></div><p>Unlike conventional Hibernate Search API and @DocumentId, this
      annotation is used on the class and not a field. You also can provide
      your own bridge implementation when you put in this annotation by
      calling the bridge() which is on @ProvidedId. Also, if you annotate a
      class with @ProvidedId, your subclasses will also get the annotation -
      but it is not done by using the java.lang.annotations.@Inherited. Be
      sure however, to <span class="emphasis"><em>not</em></span> use this annotation with
      @DocumentId as your system will break.</p><div class="example"><a id="d0e2954"/><p class="title"><b>Example 4.19. Providing your own id</b></p><div class="example-contents"><pre class="programlisting">@ProvidedId (bridge = org.my.own.package.MyCustomBridge)
@Indexed
public class MyClass{
    @Field
    String MyString;
    ...
}</pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="hsearch-mapping-programmaticapi"/>4.4. Programmatic API</h2></div></div></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>This feature is considered experimental. While stable code-wise,
        the API is subject to change in the future.</p></div><p>Although the recommended approach for mapping indexed entities
    is to use annotations, it is sometimes more convenient to use a different
    approach:</p><div class="itemizedlist"><ul><li><p>the same entity is mapped differently depending on deployment
        needs (customization for clients)</p></li><li><p>some automatization process requires the dynamic mapping of many
        entities sharing a common traits</p></li></ul></div><p>While it has been a popular demand in the past, the Hibernate team
    never found the idea of an XML alternative to annotations appealing due to
    it's heavy duplication, lack of code refactoring safety, because it did
    not cover all the use case spectrum and because we are in the 21st century
    :)</p><p>Th idea of a programmatic API was much more appealing and has now
    become a reality. You can programmatically and safely define your mapping
    using a programmatic API: you define entities and fields as indexable by
    using mapping classes which effectively mirror the annotation concepts in
    Hibernate Search. Note that fan(s) of XML approach can design their own
    schema and use the programmatic API to create the mapping while parsing
    the XML stream.</p><p>In order to use the programmatic model you must first construct a
    <code class="classname">SearchMapping</code> object. This object is passed to
    Hibernate Search via a property set to the <code class="classname">Configuration
    </code>object. The property key is
    <code class="literal">hibernate.search.model_mapping</code> or it's type-safe
    representation <code class="classname">Environment.MODEL_MAPPING</code>.</p><pre class="programlisting">SearchMapping mapping = new SearchMapping();
[...]
configuration.setProperty( Environment.MODEL_MAPPING, mapping );

//or in JPA
SearchMapping mapping = new SearchMapping();
[...]
Map&lt;String,String&gt; properties = new HashMap&lt;String,String)(1);
properties.put( Environment.MODEL_MAPPING, mapping );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", properties );</pre><p>The <code class="classname">SearchMapping</code> is the root object which
    contains all the necessary indexable entities and fields. From there, the
    <code class="classname">SearchMapping</code> object exposes a fluent (and thus
    intuitive) API to express your mappings: it contextually exposes the
    relevant mapping options in a type-safe way, just let your IDE
    autocompletion feature guide you through.</p><p>Today, the programmatic API cannot be used on a class annotated with
    Hibernate Search annotations, chose one approach or the other. Also note
    that the same default values apply in annotations and the programmatic
    API. For example, the <code class="methodname">@Field.name</code> is defaulted to
    the property name and does not have to be set.</p><p>Each core concept of the programmatic API has a corresponding
    example to depict how the same definition would look using annotation.
    Therefore seeing an annotation example of the programmatic approach should
    give you a clear picture of what Hibernate Search will build with the
    marked entities and associated properties.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3009"/>4.4.1. Mapping an entity as indexable</h3></div></div></div><p>The first concept of the programmatic API is to define an entity
      as indexable. Using the annotation approach a user would mark the entity
      as <code class="classname">@Indexed</code>, the following example demonstrates
      how to programmatically achieve this.</p><div class="example"><a id="d0e3018"/><p class="title"><b>Example 4.20. Marking an entity indexable</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class)
           .indexed()
               .indexName("Address_Index"); //optional

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</pre><p>As you can see you must first create a
          <code class="classname">SearchMapping</code> object which is the root object
          that is then passed to the <code class="classname">Configuration</code>
          object as property. You must declare an entity and if you wish to
          make that entity as indexable then you must call the
          <code class="methodname">indexed()</code> method. The <code class="methodname">indexed()
          </code>method has an optional <code class="methodname">indexName(String
          indexName)</code> which can be used to change the default
          index name that is created by Hibernate Search. Using the annotation
          model the above can be achieved as:</p><div class="example"><a id="d0e3041"/><p class="title"><b>Example 4.21. Annotation example of indexing entity</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed(index="Address_Index")
public class Address {
....
}</pre></div></div><p><br class="example-break"/></p></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3046"/>4.4.2. Adding DocumentId to indexed entity</h3></div></div></div><p>To set a property as a document id:</p><div class="example"><a id="d0e3052"/><p class="title"><b>Example 4.22. Enabling document id with programmatic model</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class).indexed()
           .property("addressId", ElementType.FIELD) //field access
               .documentId()
                   .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping);</pre><p>The above is equivalent to annotating a property in the entity
          as <code class="classname">@DocumentId</code> as seen in the following
          example:</p><div class="example"><a id="d0e3063"/><p class="title"><b>Example 4.23. DocumentId annotation definition</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Address {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 ....
}</pre></div></div><p><br class="example-break"/></p></div></div><p><br class="example-break"/>The next section demonstrates how to programmatically define
      analyzers.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3069"/>4.4.3. Defining analyzers</h3></div></div></div><p>Analyzers can be programmatically defined using the
      <code class="methodname">analyzerDef(String analyzerDef, Class&lt;? extends
      TokenizerFactory&gt; tokenizerFactory) </code>method. This method
      also enables you to define filters for the analyzer definition. Each
      filter that you define can optionally take in parameters as seen in the
      following example :</p><div class="example"><a id="d0e3078"/><p class="title"><b>Example 4.24. Defining analyzers using programmatic model</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mapping
    <span class="bold"><strong>.analyzerDef( "ngram", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( NGramFilterFactory.class )
            .param( "minGramSize", "3" )
            .param( "maxGramSize", "3" )
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .analyzerDef( "de", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( GermanStemFilterFactory.class )</strong></span>
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD) //getter access
            .documentId()
                .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</pre><p>The analyzer mapping defined above is equivalent to the
          annotation model using <code class="classname">@AnalyzerDef</code> in
          conjunction with <code class="classname">@AnalyzerDefs</code>:</p></div></div><p><br class="example-break"/></p><div class="example"><a id="d0e3094"/><p class="title"><b>Example 4.25. Analyzer definition using annotation</b></p><div class="example-contents"><pre class="programlisting">@Indexed
@Entity
@AnalyzerDefs({
  @AnalyzerDef(name = "ngram",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = NGramFilterFactory.class, 
        params = {
          @Parameter(name = "minGramSize",value = "3"),
          @Parameter(name = "maxGramSize",value = "3") 
       })
   }),
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   }),

  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
  })

})
public class Address {
...
}</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3099"/>4.4.4. Defining full text filter definitions</h3></div></div></div><p>The programmatic API provides easy mechanism for defining full
      text filter definitions which is available via
      <code class="classname">@FullTextFilterDef</code> and
      <code class="classname">@FullTextFilterDefs</code>. Note that contrary to the
      annotation equivalent, full text filter definitions are a global
      construct and are not tied to an entity. The next example depicts the
      creation of full text filter definition using the
      <code class="methodname">fullTextFilterDef </code>method.</p><div class="example"><a id="d0e3114"/><p class="title"><b>Example 4.26. Defining full text definition programmatically</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    <span class="bold"><strong>.fullTextFilterDef("security", SecurityFilterFactory.class)
            .cache(FilterCacheModeType.INSTANCE_ONLY)</strong></span>
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            .field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en")
                .store(Store.NO);

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</pre><p>The previous example can effectively been seen as annotating
          your entity with <code class="classname">@FullTextFilterDef</code> like
          below:</p></div></div><p><br class="example-break"/></p><div class="example"><a id="d0e3127"/><p class="title"><b>Example 4.27. Using annotation to define full text filter
          definition</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   })
})
@FullTextFilterDefs({
 @FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class, cache = FilterCacheModeType.INSTANCE_ONLY)
})
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 pubblic Long getAddressId() {...};

 @Fields({
      @Field(index=Index.TOKENIZED, store=Store.YES, 
             analyzer=@Analyzer(definition="en")),
      @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 })
 public String getAddress1() {...};

 ......
 
}</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3132"/>4.4.5. Defining fields for indexing</h3></div></div></div><p>When defining fields for indexing using the programmatic API, call
      <code class="methodname">field()</code> on the <code class="methodname">property(String
      propertyName, ElementType elementType)</code> method. From
      <code class="methodname">field()</code> you can specify the <code class="methodname">name,
      index</code>, <code class="methodname">store</code>,
      <code class="methodname">bridge</code> and <code class="methodname">analyzer</code>
      definitions.</p><div class="example"><a id="d0e3159"/><p class="title"><b>Example 4.28. Indexing fields using programmatic API</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            <span class="bold"><strong>.field()
                .analyzer("en")
                .store(Store.YES)
                .index(Index.TOKENIZED) //no useful here as it's the default
            .field()
                .name("address_data")
                .analyzer("en");</strong></span>

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</pre><p>The above example of marking fields as indexable is equivalent
          to defining fields using <code class="classname">@Field</code> as seen
          below:</p></div></div><p><br class="example-break"/></p><div class="example"><a id="d0e3172"/><p class="title"><b>Example 4.29. Indexing fields using annotation</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   })
})
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long getAddressId() {...};

 @Fields({
      @Field(index=Index.TOKENIZED, store=Store.YES, 
             analyzer=@Analyzer(definition="en")),
      @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 })
 public String getAddress1() {...}

 ......
}</pre><p/></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3178"/>4.4.6. Programmatically defining embedded entities</h3></div></div></div><p>In this section you will see how to programmatically define
      entities to be embedded into the indexed entity similar to using the
      <code class="classname">@IndexEmbedded</code> model. In order to define this you
      must mark the property as <code class="methodname">indexEmbedded. </code>The is
      the option to add a prefix to the embedded entity definition and this
      can be done by calling <code class="methodname">prefix</code> as seen in the
      example below:</p><div class="example"><a id="d0e3193"/><p class="title"><b>Example 4.30. Programmatically defining embedded entites</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mappping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("title", ElementType.METHOD)
            .field()
                .index(Index.TOKENIZED)
                .store(Store.NO)
        .property("description", ElementType.METHOD)
             .field()
                 .index(Index.TOKENIZED)
                 .store(Store.NO)
        .property("items", ElementType.METHOD)
            <span class="bold"><strong>.indexEmbedded()
                .prefix("catalog.items"); //optional</strong></span>

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</pre><p>The next example shows the same definition using annotation
          (<code class="classname">@IndexEmbedded</code>):</p></div></div><p><br class="example-break"/></p><div class="example"><a id="d0e3206"/><p class="title"><b>Example 4.31. Using @IndexEmbedded</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class ProductCatalog {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 public Long getCatalogId() {...}
 
 @Field(store=Store.NO, index=Index.TOKENIZED)
 public String getTitle() {...}

 @Field(store=Store.NO, index=Index.TOKENIZED)
 public String getDescription();
 
 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexEmbedded(prefix="catalog.items")
 public List&lt;Item&gt; getItems() {...}

 ...

}</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3211"/>4.4.7. Contained In definition</h3></div></div></div><p><code class="classname">@ContainedIn</code> can be define as seen in the
      example below:</p><div class="example"><a id="d0e3218"/><p class="title"><b>Example 4.32. Programmatically defining ContainedIn</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mappping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
        .property("title", ElementType.METHOD)
            .field()
        .property("description", ElementType.METHOD)
            .field()
        .property("items", ElementType.METHOD)
            .indexEmbedded()

    .entity(Item.class)
        .property("description", ElementType.METHOD)
            .field()
        .property("productCatalog", ElementType.METHOD)
            <span class="bold"><strong>.containedIn()</strong></span>;

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</pre><p>This is equivalent to defining
          <code class="classname">@ContainedIn</code> in your entity:</p><div class="example"><a id="d0e3232"/><p class="title"><b>Example 4.33. Annotation approach for ContainedIn</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class ProductCatalog {
 
 @Id
 @GeneratedValue
 @DocumentId
 public Long getCatalogId() {...}
 
 @Field
 public String getTitle() {...}

 @Field
 public String getDescription() {...}
 
 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexEmbedded
 private List&lt;Item&gt; getItems() {...}

 ...

}


@Entity
public class Item {
 
 @Id
 @GeneratedValue
 private Long itemId;

 @Field
 public String getDescription() {...}
 
 @ManyToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
 @ContainedIn
 public ProductCatalog getProductCatalog() {...}

 ...
}</pre></div></div><p><br class="example-break"/></p></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3237"/>4.4.8. Date/Calendar Bridge</h3></div></div></div><p>In order to define a calendar or date bridge mapping, call the
      <code class="methodname">dateBridge(Resolution resolution) </code>or
      <code class="methodname">calendarBridge(Resolution resolution)</code> methods
      after you have defined a <code class="methodname">field()</code> in the
      <code class="classname">SearchMapping </code>hierarchy.</p><div class="example"><a id="d0e3255"/><p class="title"><b>Example 4.34. Programmatic model for defining calendar/date bridge</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
    .property("street1", ElementType.FIELD()
        .field()
    .property("createdOn", ElementType.FIELD)
        .field()
        <span class="bold"><strong>.dateBridge(Resolution.DAY)</strong></span>
    .property("lastUpdated", ElementType.FIELD)
        <span class="bold"><strong>.calendarBridge(Resolution.DAY)</strong></span>;

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</pre><p>See below for defining the above using
          <code class="classname">@CalendarBridge</code> and
          <code class="classname">@DateBridge</code>:</p></div></div><p><br class="example-break"/></p><div class="example"><a id="d0e3274"/><p class="title"><b>Example 4.35. @CalendarBridge and @DateBridge definition</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId
 private Long addressId;

 @Field
 private String address1;

 @Field
 @DateBridge(resolution=Resolution.DAY)
 private Date createdOn;

 @CalendarBridge(resolution=Resolution.DAY)
 private Calendar lastUpdated;

 ...
}</pre></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3279"/>4.4.9. Defining bridges</h3></div></div></div><p>It is possible to associate bridges to programmatically defined
      fields. When you define a <code class="methodname">field()</code>
      programmatically you can use the <code class="methodname">bridge(Class&lt;?&gt;
      impl)</code> to associate a <code class="classname">FieldBridge
      </code>implementation class. The bridge method also provides
      optional methods to include any parameters required for the bridge
      class. The below shows an example of programmatically defining a
      bridge:</p><div class="example"><a id="d0e3294"/><p class="title"><b>Example 4.36. Defining field bridges programmatically</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
        .property("street1", ElementType.FIELD)
            .field()
            .field()
                .name("street1_abridged")
                <span class="bold"><strong>.bridge( ConcatStringBridge.class )
                    .param( "size", "4" )</strong></span>;
 
cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</pre><p>The above can equally be defined using annotations, as seen in
          the next example.</p><div class="example"><a id="d0e3305"/><p class="title"><b>Example 4.37. Defining field bridges using annotation</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed

public class Address {
 
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 @Fields({
      @Field,
      @Field(name="street1_abridged", 
             bridge = @FieldBridge( impl = ConcatStringBridge.class, 
             params = @Parameter( name="size", value="4" ))
 })
 private String address1;

 ...
}</pre></div></div><p><br class="example-break"/></p></div></div><p><br class="example-break"/></p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3310"/>4.4.10. Mapping class bridge</h3></div></div></div><p>You can define class bridges on entities programmatically. This is
      shown in the next example:</p><div class="example"><a id="d0e3315"/><p class="title"><b>Example 4.38. Defining class briges using API</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Departments.class)
<span class="emphasis"><em>       .classBridge(CatDeptsFieldsClassBridge.class)
         .name("branchnetwork")
         .index(Index.TOKENIZED)
         .store(Store.YES)
         .param("sepChar", " ")
      .classBridge(EquipmentType.class)
         .name("equiptype")
         .index(Index.TOKENIZED)
         .store(Store.YES)
         .param("C", "Cisco")
         .param("D", "D-Link")
         .param("K", "Kingston")
         .param("3", "3Com")</em></span>
      .indexed();

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );

</pre><p>The above is similar to using <code class="classname">@ClassBridge
        </code>as seen in the next example:</p><div class="example"><a id="d0e3328"/><p class="title"><b>Example 4.39. Using @ClassBridge</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@ClassBridges ( {
  @ClassBridge(name="branchnetwork",
     index= Index.TOKENIZED,
     store= Store.YES,
     impl = CatDeptsFieldsClassBridge.class,
     params = @Parameter( name="sepChar", value=" " ) ),
  @ClassBridge(name="equiptype",
     index= Index.TOKENIZED,
     store= Store.YES,
     impl = EquipmentType.class,
     params = {@Parameter( name="C", value="Cisco" ),
        @Parameter( name="D", value="D-Link" ),
        @Parameter( name="K", value="Kingston" ),
        @Parameter( name="3", value="3Com" )
   })
})
public class Departments {

....

}</pre></div></div><p><br class="example-break"/></p></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3333"/>4.4.11. Mapping dynamic boost</h3></div></div></div><p>You can apply a dynamic boost factor on either a field or a whole
      entity:</p><div class="example"><a id="d0e3338"/><p class="title"><b>Example 4.40. DynamicBoost mapping using programmatic model</b></p><div class="example-contents"><pre class="programlisting">SearchMapping mapping = new SearchMapping();

mapping
  .entity(DynamicBoostedDescLibrary.class)
   .indexed()
   <span class="emphasis"><em>.dynamicBoost(CustomBoostStrategy.class)</em></span>
  .property("libraryId", ElementType.FIELD)
    .documentId().name("id")
  .property("name", ElementType.FIELD)
    <span class="emphasis"><em>.dynamicBoost(CustomFieldBoostStrategy.class)</em></span>;
    .field()
      .store(Store.YES)

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</pre><p>The next example shows the equivalent mapping using the
        <code class="classname">@DynamicBoost</code> annotation: </p><div class="example"><a id="d0e3354"/><p class="title"><b>Example 4.41. Using the @DynamicBoost</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@DynamicBoost(impl = CustomBoostStrategy.class)
public class DynamicBoostedDescriptionLibrary {

 @Id
 @GeneratedValue
 @DocumentId
 private int id;

 private float dynScore;
 
 @Field(store = Store.YES)
 @DynamicBoost(impl = CustomFieldBoostStrategy.class)
 private String name;

 public DynamicBoostedDescriptionLibrary() {
  dynScore = 1.0f;
 }
  
 .......

}</pre></div></div><p><br class="example-break"/></p></div></div><br class="example-break"/></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-query"/>Chapter 5. Querying</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e3443">5.1. Building queries</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3451">5.1.1. Building a Lucene query</a></span></dt><dt><span class="section"><a href="#d0e3456">5.1.2. Building a Hibernate Search query</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e3643">5.2. Retrieving the results</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e3660">5.2.1. Performance considerations</a></span></dt><dt><span class="section"><a href="#d0e3705">5.2.2. Result size</a></span></dt><dt><span class="section"><a href="#d0e3736">5.2.3. ResultTransformer</a></span></dt><dt><span class="section"><a href="#d0e3757">5.2.4. Understanding results</a></span></dt></dl></dd><dt><span class="section"><a href="#query-filter">5.3. Filters</a></span></dt><dd><dl><dt><span class="section"><a href="#query-filter-shard">5.3.1. Using filters in a sharded environment</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e4109">5.4. Optimizing the query process</a></span></dt><dt><span class="section"><a href="#d0e4126">5.5. Native Lucene Queries</a></span></dt></dl></div><p>The second most important capability of Hibernate Search is the
  ability to execute a Lucene query and retrieve entities managed by an
  Hibernate session, providing the power of Lucene without leaving the
  Hibernate paradigm, and giving another dimension to the Hibernate classic
  search mechanisms (HQL, Criteria query, native SQL query). Preparing and
  executing a query consists of four simple steps:</p><div class="itemizedlist"><ul><li><p>Creating a <code class="classname">FullTextSession</code></p></li><li><p>Creating a Lucene query</p></li><li><p>Wrapping the Lucene query using a
      <code class="classname">org.hibernate.Query</code></p></li><li><p>Executing the search by calling for example
      <code class="methodname">list()</code> or
      <code class="methodname">scroll()</code></p></li></ul></div><p>To access the querying facilities, you have to use an
  <code class="classname">FullTextSession</code>. This Search specific session wraps a
  regular <code class="classname">org.hibernate.Session</code> to provide query and
  indexing capabilities.</p><div class="example"><a id="d0e3396"/><p class="title"><b>Example 5.1. Creating a FullTextSession</b></p><div class="example-contents"><pre class="programlisting">Session session = sessionFactory.openSession();
...
FullTextSession fullTextSession = Search.getFullTextSession(session);    </pre></div></div><br class="example-break"/><p>The actual search facility is built on native Lucene queries which the
  following example illustrates.</p><div class="example"><a id="d0e3403"/><p class="title"><b>Example 5.2. Creating a Lucene query</b></p><div class="example-contents"><pre class="programlisting">org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", new StopAnalyzer() );

org.apache.lucene.search.Query luceneQuery = parser.parse( "summary:Festina Or brand:Seiko" );
<span class="bold"><strong>org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );
        </strong></span>
List result = fullTextQuery.list(); //return a list of managed objects    </pre></div></div><br class="example-break"/><p>The Hibernate query built on top of the Lucene query is a regular
  <code class="literal">org.hibernate.Query</code>, which means you are in the same
  paradigm as the other Hibernate query facilities (HQL, Native or Criteria).
  The regular <code class="literal">list()</code> , <code class="literal">uniqueResult()</code>,
  <code class="literal">iterate()</code> and <code class="literal">scroll()</code> methods can be
  used.</p><p>In case you are using the Java Persistence APIs of Hibernate (aka EJB
  3.0 Persistence), the same extensions exist:</p><div class="example"><a id="d0e3430"/><p class="title"><b>Example 5.3. Creating a Search query using the JPA API</b></p><div class="example-contents"><pre class="programlisting">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager = 
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);

...
org.apache.lucene.queryParser.QueryParser parser = 
    new QueryParser("title", new StopAnalyzer() );

org.apache.lucene.search.Query luceneQuery = parser.parse( "summary:Festina Or brand:Seiko" );
<span class="bold"><strong>javax.persistence.Query fullTextQuery = fullTextEntityManager.createFullTextQuery( luceneQuery );</strong></span>

List result = fullTextQuery.getResultList(); //return a list of managed objects  </pre></div></div><br class="example-break"/><p>The following examples we will use the Hibernate APIs but the same
  example can be easily rewritten with the Java Persistence API by just
  adjusting the way the <code class="classname">FullTextQuery</code> is
  retrieved.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3443"/>5.1. Building queries</h2></div></div></div><p>Hibernate Search queries are built on top of Lucene queries which
    gives you total freedom on the type of Lucene query you want to execute.
    However, once built, Hibernate Search wraps further query processing using
    <code class="classname">org.hibernate.Query</code> as your primary query
    manipulation API.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3451"/>5.1.1. Building a Lucene query</h3></div></div></div><p>It is out of the scope of this documentation on how to exactly
      build a Lucene query. Please refer to the online Lucene documentation or
      get hold of a copy of either Lucene In Action or Hibernate Search in
      Action.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3456"/>5.1.2. Building a Hibernate Search query</h3></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3459"/>5.1.2.1. Generality</h4></div></div></div><p>Once the Lucene query is built, it needs to be wrapped into an
        Hibernate Query.</p><div class="example"><a id="d0e3464"/><p class="title"><b>Example 5.4. Wrapping a Lucene query into a Hibernate Query</b></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</pre></div></div><br class="example-break"/><p>If not specified otherwise, the query will be executed against
        all indexed entities, potentially returning all types of indexed
        classes. It is advised, from a performance point of view, to restrict
        the returned types:</p><div class="example"><a id="d0e3471"/><p class="title"><b>Example 5.5. Filtering the search result by entity type</b></p><div class="example-contents"><pre class="programlisting">org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
// or
fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Item.class, Actor.class );</pre></div></div><br class="example-break"/><p>The first example returns only matching
        <code class="classname">Customer</code>s, the second returns matching
        <code class="classname">Actor</code>s and <code class="classname">Item</code>s. The
        type restriction is fully polymorphic which means that if there are
        two indexed subclasses <code class="classname">Salesman</code> and
        <code class="classname">Customer</code> of the baseclass
        <code class="classname">Person</code>, it is possible to just specify
        <code class="classname">Person.class</code> in order to filter on result
        types.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3499"/>5.1.2.2. Pagination</h4></div></div></div><p>Out of performance reasons it is recommended to restrict the
        number of returned objects per query. In fact is a very common use
        case anyway that the user navigates from one page to an other. The way
        to define pagination is exactly the way you would define pagination in
        a plain HQL or Criteria query.</p><div class="example"><a id="d0e3504"/><p class="title"><b>Example 5.6. Defining pagination for a search query</b></p><div class="example-contents"><pre class="programlisting">org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, Customer.class );
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>It is still possible to get the total number of matching
          elements regardless of the pagination via
          <code class="methodname">fulltextQuery.</code><code class="methodname">getResultSize()</code></p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3516"/>5.1.2.3. Sorting</h4></div></div></div><p>Apache Lucene provides a very flexible and powerful way to sort
        results. While the default sorting (by relevance) is appropriate most
        of the time, it can be interesting to sort by one or several other
        properties. In order to do so set the Lucene Sort object to apply a
        Lucene sorting strategy.</p><div class="example"><a id="d0e3521"/><p class="title"><b>Example 5.7. Specifying a Lucene <code class="classname">Sort</code> in order to
          sort the results</b></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( query, Book.class );
org.apache.lucene.search.Sort sort = new Sort(new SortField("title"));
<span class="bold"><strong>query.setSort(sort);</strong></span>
List results = query.list();</pre></div></div><br class="example-break"/><p>One can notice the <code class="classname">FullTextQuery</code>
        interface which is a sub interface of
        <code class="classname">org.hibernate.Query</code>. Be aware that fields used
        for sorting must not be tokenized.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e3540"/>5.1.2.4. Fetching strategy</h4></div></div></div><p>When you restrict the return types to one class, Hibernate
        Search loads the objects using a single query. It also respects the
        static fetching strategy defined in your domain model.</p><p>It is often useful, however, to refine the fetching strategy for
        a specific use case.</p><div class="example"><a id="d0e3547"/><p class="title"><b>Example 5.8. Specifying <code class="classname">FetchMode</code> on a
          query</b></p><div class="example-contents"><pre class="programlisting">Criteria criteria = s.createCriteria( Book.class ).setFetchMode( "authors", FetchMode.JOIN );
s.createFullTextQuery( luceneQuery ).setCriteriaQuery( criteria );</pre></div></div><br class="example-break"/><p>In this example, the query will return all Books matching the
        luceneQuery. The authors collection will be loaded from the same query
        using an SQL outer join.</p><p>When defining a criteria query, it is not needed to restrict the
        entity types returned while creating the Hibernate Search query from
        the full text session: the type is guessed from the criteria query
        itself. Only fetch mode can be adjusted, refrain from applying any
        other restriction.</p><p>One cannot use <code class="methodname">setCriteriaQuery</code> if more
        than one entity type is expected to be returned.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="projections"/>5.1.2.5. Projection</h4></div></div></div><p>For some use cases, returning the domain object (graph) is
        overkill. Only a small subset of the properties is necessary.
        Hibernate Search allows you to return a subset of properties:</p><div class="example"><a id="d0e3569"/><p class="title"><b>Example 5.9. Using projection instead of returning the full domain
          object</b></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.<span class="bold"><strong>setProjection( "id", "summary", "body", "mainAuthor.name" )</strong></span>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
Integer id = firstResult[0];
String summary = firstResult[1];
String body = firstResult[2];
String authorName = firstResult[3];</pre></div></div><br class="example-break"/><p>Hibernate Search extracts the properties from the Lucene index
        and convert them back to their object representation, returning a list
        of <code class="classname">Object[]</code>. Projections avoid a potential
        database round trip (useful if the query response time is critical),
        but has some constraints:</p><div class="itemizedlist"><ul><li><p>the properties projected must be stored in the index
            (<code class="literal">@Field(store=Store.YES)</code>), which increase the
            index size</p></li><li><p>the properties projected must use a
            <code class="literal">FieldBridge</code> implementing
            <code class="classname">org.hibernate.search.bridge.TwoWayFieldBridge</code>
            or
            <code class="literal">org.hibernate.search.bridge.TwoWayStringBridge</code>,
            the latter being the simpler version. All Hibernate Search
            built-in types are two-way.</p></li><li><p>you can only project simple properties of the indexed entity
            or its embedded associations. This means you cannot project a
            whole embedded entity.</p></li><li><p>projection does not work on collections or maps which are
            indexed via <code class="classname">@IndexedEmbedded</code></p></li></ul></div><p>Projection is useful for another kind of use cases. Lucene
        provides some metadata information to the user about the results. By
        using some special placeholders, the projection mechanism can retrieve
        them:</p><div class="example"><a id="d0e3611"/><p class="title"><b>Example 5.10. Using projection in order to retrieve meta data</b></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.<span class="bold"><strong>setProjection( FullTextQuery.SCORE, FullTextQuery.THIS, "mainAuthor.name" )</strong></span>;
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
float score = firstResult[0];
Book book = firstResult[1];
String authorName = firstResult[2];</pre></div></div><br class="example-break"/><p>You can mix and match regular fields and special placeholders.
        Here is the list of available placeholders:</p><div class="itemizedlist"><ul><li><p>FullTextQuery.THIS: returns the initialized and managed
            entity (as a non projected query would have done).</p></li><li><p>FullTextQuery.DOCUMENT: returns the Lucene Document related
            to the object projected.</p></li><li><p>FullTextQuery.OBJECT_CLASS: returns the class of the indexed
            entity.</p></li><li><p>FullTextQuery.SCORE: returns the document score in the
            query. Scores are handy to compare one result against an other for
            a given query but are useless when comparing the result of
            different queries.</p></li><li><p>FullTextQuery.ID: the id property value of the projected
            object.</p></li><li><p>FullTextQuery.DOCUMENT_ID: the Lucene document id. Careful,
            Lucene document id can change overtime between two different
            IndexReader opening (this feature is experimental).</p></li><li><p>FullTextQuery.EXPLANATION: returns the Lucene Explanation
            object for the matching object/document in the given query. Do not
            use if you retrieve a lot of data. Running explanation typically
            is as costly as running the whole Lucene query per matching
            element. Make sure you use projection!</p></li></ul></div></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e3643"/>5.2. Retrieving the results</h2></div></div></div><p>Once the Hibernate Search query is built, executing it is in no way
    different than executing a HQL or Criteria query. The same paradigm and
    object semantic applies. All the common operations are available:
    <code class="methodname">list()</code>, <code class="methodname">uniqueResult()</code>,
    <code class="methodname">iterate()</code>,
    <code class="methodname">scroll()</code>.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3660"/>5.2.1. Performance considerations</h3></div></div></div><p>If you expect a reasonable number of results (for example using
      pagination) and expect to work on all of them,
      <code class="methodname">list()</code> or
      <code class="methodname">uniqueResult()</code> are recommended.
      <code class="methodname">list()</code> work best if the entity
      <code class="literal">batch-size</code> is set up properly. Note that Hibernate
      Search has to process all Lucene Hits elements (within the pagination)
      when using <code class="methodname">list()</code> ,
      <code class="methodname">uniqueResult()</code> and
      <code class="methodname">iterate()</code>.</p><p>If you wish to minimize Lucene document loading,
      <code class="methodname">scroll()</code> is more appropriate. Don't forget to
      close the <code class="classname">ScrollableResults</code> object when you're
      done, since it keeps Lucene resources. If you expect to use
      <code class="methodname">scroll,</code> but wish to load objects in batch, you
      can use <code class="methodname">query.setFetchSize()</code>. When an object is
      accessed, and if not already loaded, Hibernate Search will load the next
      <code class="literal">fetchSize</code> objects in one pass.</p><p>Pagination is a preferred method over scrolling though.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3705"/>5.2.2. Result size</h3></div></div></div><p>It is sometime useful to know the total number of matching
      documents:</p><div class="itemizedlist"><ul><li><p>for the Google-like feature 1-10 of about 888,000,000</p></li><li><p>to implement a fast pagination navigation</p></li><li><p>to implement a multi step search engine (adding approximation
          if the restricted query return no or not enough results)</p></li></ul></div><p>Of course it would be too costly to retrieve all the matching
      documents. Hibernate Search allows you to retrieve the total number of
      matching documents regardless of the pagination parameters. Even more
      interesting, you can retrieve the number of matching elements without
      triggering a single object load.</p><div class="example"><a id="d0e3722"/><p class="title"><b>Example 5.11. Determining the result size of a query</b></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
assert 3245 == <span class="bold"><strong>query.getResultSize()</strong></span>; //return the number of matching books without loading a single one

org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.setMaxResult(10);
List results = query.list();
assert 3245 == <span class="bold"><strong>query.getResultSize()</strong></span>; //return the total number of matching books regardless of pagination</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Like Google, the number of results is approximative if the index
        is not fully up-to-date with the database (asynchronous cluster for
        example).</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3736"/>5.2.3. ResultTransformer</h3></div></div></div><p>Especially when using projection, the data structure returned by a
      query (an object array in this case), is not always matching the
      application needs. It is possible to apply a
      <code class="classname">ResultTransformer</code> operation post query to match
      the targeted data structure:</p><div class="example"><a id="d0e3744"/><p class="title"><b>Example 5.12. Using ResultTransformer in conjunction with projections</b></p><div class="example-contents"><pre class="programlisting">org.hibernate.search.FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
query.setProjection( "title", "mainAuthor.name" );

<span class="bold"><strong>query.setResultTransformer( 
    new StaticAliasToBeanResultTransformer( BookView.class, "title", "author" ) 
);</strong></span>
List&lt;BookView&gt; results = (List&lt;BookView&gt;) query.list();
for(BookView view : results) {
    log.info( "Book: " + view.getTitle() + ", " + view.getAuthor() );
}</pre></div></div><br class="example-break"/><p>Examples of <code class="classname">ResultTransformer</code>
      implementations can be found in the Hibernate Core codebase.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e3757"/>5.2.4. Understanding results</h3></div></div></div><p>You will find yourself sometimes puzzled by a result showing up in
      a query or a result not showing up in a query. Luke is a great tool to
      understand those mysteries. However, Hibernate Search also gives you
      access to the Lucene <code class="classname">Explanation</code> object for a
      given result (in a given query). This class is considered fairly
      advanced to Lucene users but can provide a good understanding of the
      scoring of an object. You have two ways to access the Explanation object
      for a given result:</p><div class="itemizedlist"><ul><li><p>Use the <code class="methodname">fullTextQuery.explain(int)</code>
          method</p></li><li><p>Use projection</p></li></ul></div><p>The first approach takes a document id as a parameter and return
      the Explanation object. The document id can be retrieved using
      projection and the <code class="literal">FullTextQuery.DOCUMENT_ID</code>
      constant.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>The Document id has nothing to do with the entity id. Do not
        mess up these two notions.</p></div><p>The second approach let's you project the
      <code class="classname">Explanation</code> object using the
      <code class="literal">FullTextQuery.EXPLANATION</code> constant.</p><div class="example"><a id="d0e3791"/><p class="title"><b>Example 5.13. Retrieving the Lucene Explanation object using
        projection</b></p><div class="example-contents"><pre class="programlisting">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection( FullTextQuery.DOCUMENT_ID, <span class="bold"><strong>FullTextQuery.EXPLANATION</strong></span>, FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    display( e.toString() );
}</pre></div></div><br class="example-break"/><p>Be careful, building the explanation object is quite expensive, it
      is roughly as expensive as running the Lucene query again. Don't do it
      if you don't need the object</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="query-filter"/>5.3. Filters</h2></div></div></div><p>Apache Lucene has a powerful feature that allows to filter query
    results according to a custom filtering process. This is a very powerful
    way to apply additional data restrictions, especially since filters can be
    cached and reused. Some interesting use cases are:</p><div class="itemizedlist"><ul><li><p>security</p></li><li><p>temporal data (eg. view only last month's data)</p></li><li><p>population filter (eg. search limited to a given
        category)</p></li><li><p>and many more</p></li></ul></div><p>Hibernate Search pushes the concept further by introducing the
    notion of parameterizable named filters which are transparently cached.
    For people familiar with the notion of Hibernate Core filters, the API is
    very similar:</p><div class="example"><a id="d0e3821"/><p class="title"><b>Example 5.14. Enabling fulltext filters for a given query</b></p><div class="example-contents"><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter( "login", "andre" );
fullTextQuery.list(); //returns only best drivers where andre has credentials</pre></div></div><br class="example-break"/><p>In this example we enabled two filters on top of the query. You can
    enable (or disable) as many filters as you like.</p><p>Declaring filters is done through the
    <code class="classname">@FullTextFilterDef</code> annotation. This annotation can
    be on any <code class="literal">@Indexed</code> entity regardless of the query the
    filter is later applied to. This implies that filter definitions are
    global and their names must be unique. A
    <code class="classname">SearchException</code> is thrown in case two different
    <code class="classname">@FullTextFilterDef</code> annotations with the same name
    are defined. Each named filter has to specify its actual filter
    implementation.</p><div class="example"><a id="d0e3842"/><p class="title"><b>Example 5.15. Defining and implementing a Filter</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@FullTextFilterDefs( {
    <span class="bold"><strong>@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilter.class)</strong></span>, 
    <span class="bold"><strong>@FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)</strong></span> 
})
public class Driver { ... }</pre><pre class="programlisting">public class BestDriversFilter extends <span class="bold"><strong>org.apache.lucene.search.Filter</strong></span> {

    public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
        OpenBitSet bitSet = new OpenBitSet( reader.maxDoc() );
        TermDocs termDocs = reader.termDocs( new Term( "score", "5" ) );
        while ( termDocs.next() ) {
            bitSet.set( termDocs.doc() );
        }
        return bitSet;
    }
}</pre></div></div><br class="example-break"/><p><code class="classname">BestDriversFilter</code> is an example of a simple
    Lucene filter which reduces the result set to drivers whose score is 5. In
    this example the specified filter implements the
    <code class="literal">org.apache.lucene.search.Filter</code> directly and contains a
    no-arg constructor.</p><p>If your Filter creation requires additional steps or if the filter
    you want to use does not have a no-arg constructor, you can use the
    factory pattern:</p><div class="example"><a id="d0e3867"/><p class="title"><b>Example 5.16. Creating a filter using the factory pattern</b></p><div class="example-contents"><pre class="programlisting">@Entity
@Indexed
@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
public class Driver { ... }

public class BestDriversFilterFactory {

    <span class="bold"><strong>@Factory</strong></span>
    public Filter getFilter() {
        //some additional steps to cache the filter results per IndexReader
        Filter bestDriversFilter = new BestDriversFilter();
        return new CachingWrapperFilter(bestDriversFilter);
    }
}</pre></div></div><br class="example-break"/><p>Hibernate Search will look for a <code class="literal">@Factory</code>
    annotated method and use it to build the filter instance. The factory must
    have a no-arg constructor. For people familiar with JBoss Seam, this is
    similar to the component factory pattern, but the annotation is
    different!</p><p>Named filters come in handy where parameters have to be passed to
    the filter. For example a security filter might want to know which
    security level you want to apply:</p><div class="example"><a id="d0e3882"/><p class="title"><b>Example 5.17. Passing parameters to a defined filter</b></p><div class="example-contents"><pre class="programlisting">fullTextQuery = s.createFullTextQuery( query, Driver.class );
fullTextQuery.enableFullTextFilter("security")<span class="bold"><strong>.setParameter( "level", 5 )</strong></span>;</pre></div></div><br class="example-break"/><p>Each parameter name should have an associated setter on either the
    filter or filter factory of the targeted named filter definition.</p><div class="example"><a id="d0e3892"/><p class="title"><b>Example 5.18. Using parameters in the actual filter implementation</b></p><div class="example-contents"><pre class="programlisting">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    <span class="bold"><strong>public void setLevel(Integer level)</strong></span> {
        this.level = level;
    }

    <span class="bold"><strong>@Key
    public FilterKey getKey()</strong></span> {
        StandardFilterKey key = new StandardFilterKey();
        key.addParameter( level );
        return key;
    }

    @Factory
    public Filter getFilter() {
        Query query = new TermQuery( new Term("level", level.toString() ) );
        return new CachingWrapperFilter( new QueryWrapperFilter(query) );
    }
}</pre></div></div><br class="example-break"/><p>Note the method annotated <code class="classname">@Key</code> returning a
    <code class="classname">FilterKey</code> object. The returned object has a special
    contract: the key object must implement <code class="methodname">equals()</code>
    / <code class="methodname">hashCode()</code> so that 2 keys are equal if and only
    if the given <code class="classname">Filter</code> types are the same and the set
    of parameters are the same. In other words, 2 filter keys are equal if and
    only if the filters from which the keys are generated can be interchanged.
    The key object is used as a key in the cache mechanism.</p><p><code class="classname">@Key</code> methods are needed only if:</p><div class="itemizedlist"><ul><li><p>you enabled the filter caching system (enabled by
        default)</p></li><li><p>your filter has parameters</p></li></ul></div><p>In most cases, using the <code class="literal">StandardFilterKey</code>
    implementation will be good enough. It delegates the
    <code class="methodname">equals()</code> / <code class="methodname">hashCode()</code>
    implementation to each of the parameters equals and hashcode
    methods.</p><p>As mentioned before the defined filters are per default cached and
    the cache uses a combination of hard and soft references to allow disposal
    of memory when needed. The hard reference cache keeps track of the most
    recently used filters and transforms the ones least used to
    <code class="classname">SoftReferences</code> when needed. Once the limit of the
    hard reference cache is reached additional filters are cached as
    <code class="classname">SoftReferences</code>. To adjust the size of the hard
    reference cache, use
    <code class="literal">hibernate.search.filter.cache_strategy.size</code> (defaults
    to 128). For advanced use of filter caching, you can implement your own
    <code class="classname">FilterCachingStrategy</code>. The classname is defined by
    <code class="literal">hibernate.search.filter.cache_strategy</code>.</p><p>This filter caching mechanism should not be confused with caching
    the actual filter results. In Lucene it is common practice to wrap filters
    using the <code class="classname">IndexReader</code> around a
    <code class="classname">CachingWrapperFilter.</code> The wrapper will cache the
    <code class="classname">DocIdSet</code> returned from the
    <code class="methodname">getDocIdSet(IndexReader reader)</code> method to avoid
    expensive recomputation. It is important to mention that the computed
    <code class="classname">DocIdSet</code> is only cachable for the same
    <code class="classname">IndexReader</code> instance, because the reader
    effectively represents the state of the index at the moment it was opened.
    The document list cannot change within an opened
    <code class="classname">IndexReader</code>. A different/new<code class="classname">
    IndexReader</code> instance, however, works potentially on a
    different set of <code class="classname">Document</code>s (either from a different
    index or simply because the index has changed), hence the cached
    <code class="classname">DocIdSet</code> has to be recomputed.</p><p>Hibernate Search also helps with this aspect of caching. Per default
    the <code class="literal">cache</code> flag of <code class="classname">@FullTextFilterDef
    </code>is set to
    <code class="literal">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</code> which
    will automatically cache the filter instance as well as wrap the specified
    filter around a Hibernate specific implementation of
    <code class="classname">CachingWrapperFilter</code>
    (<code class="classname">org.hibernate.search.filter.CachingWrapperFilter</code>).
    In contrast to Lucene's version of this class
    <code class="classname">SoftReference</code>s are used together with a hard
    reference count (see discussion about filter cache). The hard reference
    count can be adjusted using
    <code class="literal">hibernate.search.filter.cache_docidresults.size</code>
    (defaults to 5). The wrapping behaviour can be controlled using the
    <code class="literal">@FullTextFilterDef.cache</code> parameter. There are three
    different values for this parameter:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th align="center">Value</th><th align="center">Definition</th></tr></thead><tbody><tr><td align="left">FilterCacheModeType.NONE</td><td align="left">No filter instance and no result is cached by Hibernate
              Search. For every filter call, a new filter instance is created.
              This setting might be useful for rapidly changing data sets or
              heavily memory constrained environments.</td></tr><tr><td align="left">FilterCacheModeType.INSTANCE_ONLY</td><td align="left">The filter instance is cached and reused across
              concurrent <code class="methodname">Filter.getDocIdSet()</code> calls.
              <code class="classname">DocIdSet</code> results are not cached. This
              setting is useful when a filter uses its own specific caching
              mechanism or the filter results change dynamically due to
              application specific events making
              <code class="classname">DocIdSet</code> caching in both cases
              unnecessary.</td></tr><tr><td align="left">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</td><td align="left">Both the filter instance and the
              <code class="classname">DocIdSet</code> results are cached. This is the
              default value.</td></tr></tbody></table></div><p>Last but not least - why should filters be cached? There
    are two areas where filter caching shines:</p><div class="itemizedlist"><ul><li><p>the system does not update the targeted entity index often (in
        other words, the IndexReader is reused a lot)</p></li><li><p>the Filter's DocIdSet is expensive to compute (compared to the
        time spent to execute the query)</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="query-filter-shard"/>5.3.1. Using filters in a sharded environment</h3></div></div></div><p>It is possible, in a sharded environment to execute queries on a
      subset of the available shards. This can be done in two steps:</p><div class="itemizedlist"><ul><li><p>create a sharding strategy that does select a subset of
          <code class="classname">DirectoryProvider</code>s depending on sone filter
          configuration</p></li><li><p>activate the proper filter at query time</p></li></ul></div><p>Let's first look at an example of sharding strategy that query on
      a specific customer shard if the customer filter is activated.</p><pre class="programlisting">public class CustomerShardingStrategy implements IndexShardingStrategy {

	// stored DirectoryProviders in a array indexed by customerID
	private DirectoryProvider&lt;?&gt;[] providers;
	
	public void initialize(Properties properties, DirectoryProvider&lt;?&gt;[] providers) {
		this.providers = providers;
	}

	public DirectoryProvider&lt;?&gt;[] getDirectoryProvidersForAllShards() {
		return providers;
	}

	public DirectoryProvider&lt;?&gt; getDirectoryProviderForAddition(Class&lt;?&gt; entity, Serializable id, String idInString, Document document) {
		Integer customerID = Integer.parseInt(document.getField("customerID").stringValue());
		return providers[customerID];
	}

	public DirectoryProvider&lt;?&gt;[] getDirectoryProvidersForDeletion(Class&lt;?&gt; entity, Serializable id, String idInString) {
		return getDirectoryProvidersForAllShards();
	}

<span class="bold"><strong>	/**
	 * Optimization; don't search ALL shards and union the results; in this case, we 
	 * can be certain that all the data for a particular customer Filter is in a single
	 * shard; simply return that shard by customerID.
	 */
	public DirectoryProvider&lt;?&gt;[] getDirectoryProvidersForQuery(FullTextFilterImplementor[] filters) {
		FFullTextFilter filter = getCustomerFilter(filters, "customer");
		if (filter == null) {
			return getDirectoryProvidersForAllShards();
		}
		else {
			return new DirectoryProvider[] { providers[Integer.parseInt(filter.getParameter("customerID").toString())] };
		}
	}

	private FullTextFilter getFilter(FullTextFilterImplementor[] filters, String name) {
		for (FullTextFilterImplementor filter: filters) {
			if (filter.getName().equals(name)) return filter;
		}
		return null;
	}</strong></span>

}</pre><p>In this example, if the filter named <code class="literal">customer</code>
      is present, we make sure to only use the shard dedicated to this
      customer. Otherwise, we return all shards. A given Sharding strategy can
      react to one or more filters and depends on their parameters.</p><p>The second step is simply to activate the filter at query time.
      While the filter can be a regular filter (as defined in <a class="xref" href="#query-filter" title="5.3. Filters">Section 5.3, “Filters”</a>) which also filters Lucene results after the
      query, you can make use of a special filter that will only be passed to
      the sharding strategy and otherwise ignored for the rest of the query.
      Simply use the <code class="classname">ShardSensitiveOnlyFilter</code> class
      when declaring your filter.</p><pre class="programlisting">@Entity @Indexed
<span class="bold"><strong>@FullTextFilterDef(name="customer", impl=ShardSensitiveOnlyFilter.class)</strong></span>
public class Customer {
   ...
}


FullTextQuery query = ftEm.createFullTextQuery(luceneQuery, Customer.class);
<span class="bold"><strong>query.enableFulltextFilter("customer").setParameter("CustomerID", 5);</strong></span>
@SuppressWarnings("unchecked")
List&lt;Customer&gt; results = query.getResultList();</pre><p>Note that by using the
      <code class="classname">ShardSensitiveOnlyFilter</code>, you do not have to
      implement any Lucene filter. Using filters and sharding strategy
      reacting to these filters is recommended to speed up queries in a
      sharded environment.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4109"/>5.4. Optimizing the query process</h2></div></div></div><p>Query performance depends on several criteria:</p><div class="itemizedlist"><ul><li><p>the Lucene query itself: read the literature on this
        subject</p></li><li><p>the number of object loaded: use pagination (always ;-) ) or
        index projection (if needed)</p></li><li><p>the way Hibernate Search interacts with the Lucene readers:
        defines the appropriate <a class="xref" href="#search-architecture-readerstrategy" title="2.3. Reader strategy">Reader strategy</a>.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4126"/>5.5. Native Lucene Queries</h2></div></div></div><p>If you wish to use some specific features of Lucene, you can always
    run Lucene specific queries. Check <a class="xref" href="#search-lucene-native" title="Chapter 8. Advanced features">Chapter 8, <i>Advanced features</i></a>
    for more information.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="manual-index-changes"/>Chapter 6. Manual index changes</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4142">6.1. Adding instances to the Index</a></span></dt><dt><span class="section"><a href="#d0e4170">6.2. Deleting instances from the Index: Purging</a></span></dt><dt><span class="section"><a href="#search-batchindex">6.3. Rebuilding the whole Index</a></span></dt><dd><dl><dt><span class="section"><a href="#search-batchindex-flushtoindexes">6.3.1. Using flushToIndexes()</a></span></dt><dt><span class="section"><a href="#search-batchindex-massindexer">6.3.2. Using a MassIndexer</a></span></dt></dl></dd></dl></div><p>As Hibernate core applies changes to the Database, Hibernate Search
  detects these changes and will update the index automatically (unless the
  EventListeners are disabled).
  Sometimes changes are made to the database without using Hibernate, as when
  backup is restored or your data is otherwise affected;
  for these cases Hibernate Search exposes the Manual Index APIs to explicitly
  update or remove a single entity from the index, or rebuild the index for
  the whole database, or remove all references to a specific type.</p><p>All these methods affect the Lucene Index only, no changes are applied
  to the Database.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4142"/>6.1. Adding instances to the Index</h2></div></div></div><p>Using <code class="classname">FullTextSession</code>.<code class="methodname">index(T entity)</code>
    you can directly add or update a specific object instance to the index.
    If this entity was already indexed, then the index will be updated.
    Changes to the index are only applied at transaction commit.</p><div class="example"><a id="d0e4153"/><p class="title"><b>Example 6.1. Indexing an entity via
      <code class="methodname">FullTextSession.index(T entity)</code></b></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
Object customer = fullTextSession.load( Customer.class, 8 );
<span class="bold"><strong>fullTextSession.index(customer);</strong></span>
tx.commit(); //index only updated at commit time</pre></div></div><br class="example-break"/><p>In case you want to add all instances for a type, or for all indexed types,
    the recommended approach is to use a <code class="classname">MassIndexer</code>: see
    <a class="xref" href="#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a> for more details.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4170"/>6.2. Deleting instances from the Index: Purging</h2></div></div></div><p>It is equally possible to remove an entity or all entities of a
    given type from a Lucene index without the need to physically remove them
    from the database. This operation is named purging and is also done
    through the <code class="classname">FullTextSession</code>.</p><div class="example"><a id="d0e4178"/><p class="title"><b>Example 6.2. Purging a specific instance of an entity from the index</b></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    <span class="bold"><strong>fullTextSession.purge( Customer.class, customer.getId() );</strong></span>
}
tx.commit(); //index is updated at commit time</pre></div></div><br class="example-break"/><p>Purging will remove the entity with the given id from the Lucene
    index but will not touch the database.</p><p>If you need to remove all entities of a given type, you can use the
    <code class="methodname">purgeAll</code> method. This operation removes all
    entities of the type passed as a parameter as well as all its
    subtypes.</p><div class="example"><a id="d0e4193"/><p class="title"><b>Example 6.3. Purging all instances of an entity from the index</b></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
<span class="bold"><strong>fullTextSession.purgeAll( Customer.class );</strong></span>
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index changes are applied at commit time    </pre></div></div><br class="example-break"/><p>It is recommended to optimize the index after such an
    operation.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>Methods <code class="methodname">index</code>,
      <code class="methodname">purge</code> and <code class="methodname">purgeAll</code> are
      available on <code class="classname">FullTextEntityManager</code> as
      well.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>All manual indexing methods (<code class="methodname">index</code>,
      <code class="methodname">purge</code> and <code class="methodname">purgeAll</code>) only
      affect the index, not the database, nevertheless they are
      transactional and as such they won't be applied until the transaction
      is successfully committed, or you make use of
      <code class="methodname">flushToIndexes</code>.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-batchindex"/>6.3. Rebuilding the whole Index</h2></div></div></div><p>If you change the entity mapping to the index, chances are that
    the whole Index needs to be updated; For example if you decide to index
    a an existing field using a different analyzer you'll need to rebuild the
    index for affected types. Also if the Database is replaced (like restored
    from a backup, imported from a legacy system) you'll want to be able
    to rebuild the index from existing data.
    Hibernate Search provides two main strategies to choose from:</p><div class="itemizedlist"><ul><li><p>Using <code class="classname">FullTextSession</code>.<code class="methodname">flushToIndexes()</code>
      periodically, while using <code class="classname">FullTextSession</code>.<code class="methodname">index()</code>
      on all entities.</p></li><li><p>Use a <code class="classname">MassIndexer</code>.</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="search-batchindex-flushtoindexes"/>6.3.1. Using flushToIndexes()</h3></div></div></div><p>
    This strategy consists in removing the existing index and then adding
    all entities back to the index using <code class="classname">FullTextSession</code>.<code class="methodname">purgeAll()</code>
    and <code class="classname">FullTextSession</code>.<code class="methodname">index()</code>,
    however there are some memory and efficiency contraints.
    For maximum efficiency Hibernate Search batches index operations
    and executes them at commit time. If you expect to index a lot of data
    you need to be careful about memory consumption since all
    documents are kept in a queue until the transaction commit. You can
    potentially face an <code class="classname">OutOfMemoryException</code> if you
    don't empty the queue periodically: to do this you can use
    <code class="methodname">fullTextSession.flushToIndexes()</code>. Every time
    <code class="methodname">fullTextSession.flushToIndexes()</code> is called (or if
    the transaction is committed), the batch queue is processed
    applying all index changes. Be aware that, once flushed, the changes
    cannot be rolled back.</p><div class="example"><a id="d0e4286"/><p class="title"><b>Example 6.4. Index rebuilding using index() and flushToIndexes()</b></p><div class="example-contents"><pre class="programlisting">fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll( ScrollMode.FORWARD_ONLY );
int index = 0;
while( results.next() ) {
    index++;
    fullTextSession.index( results.get(0) ); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //free memory since the queue is processed
    }
}
transaction.commit();</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">hibernate.search.worker.batch_size</code> has been
      deprecated in favor of this explicit API which provides better
      control</p></div><p>Try to use a batch size that guarantees that your application will
    not run out of memory: with a bigger batch size objects are fetched faster
    from database but more memory is needed.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="search-batchindex-massindexer"/>6.3.2. Using a MassIndexer</h3></div></div></div><p>Hibernate Search's <code class="classname">MassIndexer</code> uses several
    parallel threads to rebuild the index; you can optionally select which entities
    need to be reloaded or have it reindex all entities. This approach is optimized
    for best performance but requires to set the application in maintenance mode:
    making queries to the index is not recommended when a MassIndexer is busy.</p><div class="example"><a id="d0e4306"/><p class="title"><b>Example 6.5. Index rebuilding using a MassIndexer</b></p><div class="example-contents"><pre class="programlisting">fullTextSession.createIndexer().startAndWait();</pre><p>This will rebuild the index, deleting it and then reloading all entities
      from the database. Although it's simple to use, some tweaking is recommended
      to speed up the process: there are several parameters configurable.</p></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>During the progress of a MassIndexer the content of the index is undefined,
    make sure that nobody will try to make some query during index rebuilding!
    If somebody should query the index it will not corrupt but most results will
    likely be missing.</p></div><div class="example"><a id="d0e4316"/><p class="title"><b>Example 6.6. Using a tuned MassIndexer</b></p><div class="example-contents"><pre class="programlisting">fullTextSession
	.createIndexer( User.class )
	.batchSizeToLoadObjects( 25 )
	.cacheMode( CacheMode.NORMAL )
	.threadsToLoadObjects( 5 )
	.threadsForSubsequentFetching( 20 )
	.startAndWait();</pre><p>This will rebuild the index of all User instances (and subtypes), and will
	  create 5 parallel threads to load the User instances using batches of 25 objects
	  per query; these loaded User instances are then pipelined to 20 parallel threads
	  to load the attached lazy collections of User containing some information needed
	  for the index.</p><p>It is recommended to leave cacheMode to <code class="literal">CacheMode.IGNORE</code> (the default), as
	  in most reindexing situations the cache will be a useless additional overhead;
	  it might be useful to enable some other <code class="literal">CacheMode</code> depending on your data: it might increase
	  performance if the main entity is relating to enum-like data included in the index.</p></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>The "sweet spot" of number of threads to achieve best performance is
    highly dependent on your overall architecture, database design and even data
    values.
    To find out the best number of threads for your application it is recommended
    to use a profiler: all internal thread groups have meaningful names
    to be easily identified with most tools.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>The MassIndexer was designed for speed and is unaware of transactions,
      so there is no need to begin one or committing. Also because it is not transactional
      it is not recommended to let users use the system during it's processing,
      as it is unlikely people will be able to find results and the system load
      might be too high anyway.</p></div></div><p>Other parameters which also affect indexing time and memory
    consumption are:</p><div class="itemizedlist"><ul><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.max_buffered_docs</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.max_field_length</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.max_merge_docs</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.merge_factor</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.ram_buffer_size</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.term_index_interval</code></li></ul></div><p>All <code class="literal">.indexwriter</code> parameters are Lucene specific and
    Hibernate Search is just passing these parameters through - see <a class="xref" href="#lucene-indexing-performance" title="3.9. Tuning Lucene indexing performance">Section 3.9, “Tuning Lucene indexing performance”</a> for more details.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-optimize"/>Chapter 7. Index Optimization</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4403">7.1. Automatic optimization</a></span></dt><dt><span class="section"><a href="#d0e4442">7.2. Manual optimization</a></span></dt><dt><span class="section"><a href="#d0e4465">7.3. Adjusting optimization</a></span></dt></dl></div><p>From time to time, the Lucene index needs to be optimized. The process
  is essentially a defragmentation. Until an optimization is triggered Lucene
  only marks deleted documents as such, no physical deletions are applied.
  During the optimization process the deletions will be applied which also
  effects the number of files in the Lucene Directory.</p><p>Optimizing the Lucene index speeds up searches but has no effect on
  the indexation (update) performance. During an optimization, searches can be
  performed, but will most likely be slowed down. All index updates will be
  stopped. It is recommended to schedule optimization:</p><div class="itemizedlist"><ul><li><p>on an idle system or when the searches are less frequent</p></li><li><p>after a lot of index modifications</p></li></ul></div><p>When using a <code class="classname">MassIndexer</code> (see
  <a class="xref" href="#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a>) it will optimize involved
  indexes by default at the start and at the end of processing; you can change
  this behavior by using respectively
  <code class="classname">MassIndexer</code>.<code class="methodname">optimizeAfterPurge</code>
  and <code class="classname">MassIndexer</code>.<code class="methodname">optimizeOnFinish</code>.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4403"/>7.1. Automatic optimization</h2></div></div></div><p>Hibernate Search can automatically optimize an index after:</p><div class="itemizedlist"><ul><li><p>a certain amount of operations (insertion, deletion)</p></li><li><p>or a certain amount of transactions </p></li></ul></div><p>The configuration for automatic index optimization can be defined on
    a global level or per index:</p><div class="example"><a id="d0e4417"/><p class="title"><b>Example 7.1. Defining automatic optimization parameters</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre></div></div><br class="example-break"/><p>An optimization will be triggered to the <code class="literal">Animal</code>
    index as soon as either:</p><div class="itemizedlist"><ul><li><p>the number of additions and deletions reaches 1000</p></li><li><p>the number of transactions reaches 50
        (<code class="constant">hibernate.search.Animal.optimizer.transaction_limit.max</code>
        having priority over
        <code class="constant">hibernate.search.default.optimizer.transaction_limit.max</code>)</p></li></ul></div><p>If none of these parameters are defined, no optimization is
    processed automatically.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4442"/>7.2. Manual optimization</h2></div></div></div><p>You can programmatically optimize (defragment) a Lucene index from
    Hibernate Search through the <code class="classname">SearchFactory</code>:</p><div class="example"><a id="d0e4450"/><p class="title"><b>Example 7.2. Programmatic index optimization</b></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();

searchFactory.optimize(Order.class);
// or
searchFactory.optimize();</pre></div></div><br class="example-break"/><p>The first example optimizes the Lucene index holding
    <code class="classname">Order</code>s; the second, optimizes all indexes.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p><code class="literal">searchFactory.optimize()</code> has no effect on a JMS
      backend. You must apply the optimize operation on the Master
      node.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4465"/>7.3. Adjusting optimization</h2></div></div></div><p>Apache Lucene has a few parameters to influence how optimization is
    performed. Hibernate Search exposes those parameters.</p><p>Further index optimization parameters include: </p><div class="itemizedlist"><ul><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_buffered_docs</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_field_length</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].max_merge_docs</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].merge_factor</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].ram_buffer_size</code></li><li><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[batch|transaction].term_index_interval</code></li></ul></div><p> See <a class="xref" href="#lucene-indexing-performance" title="3.9. Tuning Lucene indexing performance">Section 3.9, “Tuning Lucene indexing performance”</a> for
    more details.</p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-lucene-native"/>Chapter 8. Advanced features</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e4499">8.1. SearchFactory</a></span></dt><dt><span class="section"><a href="#d0e4520">8.2. Accessing a Lucene Directory</a></span></dt><dt><span class="section"><a href="#d0e4548">8.3. Using an IndexReader</a></span></dt><dt><span class="section"><a href="#d0e4585">8.4. Customizing Lucene's scoring formula</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4499"/>8.1. SearchFactory</h2></div></div></div><p>The <code class="classname">SearchFactory</code> object keeps track of the
    underlying Lucene resources for Hibernate Search, it's also a convenient
    way to access Lucene natively. The <code class="classname">SearchFactory</code>
    can be accessed from a <code class="classname">FullTextSession</code>:</p><div class="example"><a id="d0e4513"/><p class="title"><b>Example 8.1. Accessing the <code class="classname">SearchFactory</code></b></p><div class="example-contents"><pre class="programlisting">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();</pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4520"/>8.2. Accessing a Lucene Directory</h2></div></div></div><p>You can always access the Lucene directories through plain Lucene,
    the Directory structure is in no way different with or without Hibernate
    Search. However there are some more convenient ways to access a given
    Directory. The <code class="classname">SearchFactory</code> keeps track of the
    <code class="classname">DirectoryProvider</code>s per indexed class. One directory
    provider can be shared amongst several indexed classes if the classes
    share the same underlying index directory. While usually not the case, a
    given entity can have several <code class="classname">DirectoryProvider</code>s if
    the index is sharded (see <a class="xref" href="#search-configuration-directory-sharding" title="3.2. Sharding indexes">Section 3.2, “Sharding indexes”</a>).</p><div class="example"><a id="d0e4536"/><p class="title"><b>Example 8.2. Accessing the Lucene <code class="classname">Directory</code></b></p><div class="example-contents"><pre class="programlisting">DirectoryProvider[] provider = searchFactory.getDirectoryProviders(Order.class);
org.apache.lucene.store.Directory directory = provider[0].getDirectory();</pre></div></div><br class="example-break"/><p>In this example, directory points to the lucene index storing
    <code class="classname">Order</code>s information. Note that the obtained Lucene
    directory must not be closed (this is Hibernate Search
    responsibility).</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4548"/>8.3. Using an IndexReader</h2></div></div></div><p>Queries in Lucene are executed on an <code class="literal">IndexReader</code>.
    Hibernate Search caches all index readers to maximize performance. Your
    code can access this cached resources, but you have to follow some "good
    citizen" rules.</p><div class="example"><a id="d0e4556"/><p class="title"><b>Example 8.3. Accessing an <code class="classname">IndexReader</code></b></p><div class="example-contents"><pre class="programlisting">DirectoryProvider orderProvider = searchFactory.getDirectoryProviders(Order.class)[0];
DirectoryProvider clientProvider = searchFactory.getDirectoryProviders(Client.class)[0];

ReaderProvider readerProvider = searchFactory.getReaderProvider();
IndexReader reader = readerProvider.openReader(orderProvider, clientProvider);

try {
    //do read-only operations on the reader
}
finally {
    readerProvider.closeReader(reader);
}</pre></div></div><br class="example-break"/><p>The ReaderProvider (described in <a class="xref" href="#search-architecture-readerstrategy" title="2.3. Reader strategy">Reader strategy</a>), will open an IndexReader
    on top of the index(es) referenced by the directory providers. Because
    this <code class="classname">IndexReader</code> is shared amongst several clients,
    you must adhere to the following rules:</p><div class="itemizedlist"><ul><li><p>Never call indexReader.close(), but always call
        readerProvider.closeReader(reader), preferably in a finally
        block.</p></li><li><p>Don't use this <code class="classname">IndexReader</code> for
        modification operations (you would get an exception). If you want to
        use a read/write index reader, open one from the Lucene Directory
        object.</p></li></ul></div><p>Aside from those rules, you can use the IndexReader freely,
    especially to do native queries. Using the shared
    <code class="literal">IndexReader</code>s will make most queries more
    efficient.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e4585"/>8.4. Customizing Lucene's scoring formula</h2></div></div></div><p>Lucene allows the user to customize its scoring formula by extending
    <code class="classname">org.apache.lucene.search.Similarity</code>. The abstract
    methods defined in this class match the factors of the following formula
    calculating the score of query q for document d:</p><p><span class="bold"><strong>score(q,d) = coord(q,d) · queryNorm(q) ·
    ∑<sub>t in q</sub> ( tf(t in d) ·
    idf(t)<sup>2</sup> · t.getBoost() · norm(t,d)
    )</strong></span></p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th align="center">Factor</th><th align="center">Description</th></tr></thead><tbody><tr><td align="left">tf(t ind)</td><td align="left">Term frequency factor for the term (t) in the document
              (d).</td></tr><tr><td align="left">idf(t)</td><td align="left">Inverse document frequency of the term.</td></tr><tr><td align="left">coord(q,d)</td><td align="left">Score factor based on how many of the query terms are
              found in the specified document.</td></tr><tr><td align="left">queryNorm(q)</td><td align="left">Normalizing factor used to make scores between queries
              comparable.</td></tr><tr><td align="left">t.getBoost()</td><td align="left">Field boost.</td></tr><tr><td align="left">norm(t,d)</td><td align="left">Encapsulates a few (indexing time) boost and length
              factors.</td></tr></tbody></table></div><p>It is beyond the scope of this manual to explain this
    formula in more detail. Please refer to
    <code class="classname">Similarity</code>'s Javadocs for more information.</p><p>Hibernate Search provides two ways to modify Lucene's similarity
    calculation. First you can set the default similarity by specifying the
    fully specified classname of your <code class="classname">Similarity</code>
    implementation using the property
    <code class="constant">hibernate.search.similarity</code>. The default value is
    <code class="classname">org.apache.lucene.search.DefaultSimilarity</code>.
    Additionally you can override the default similarity on class level using
    the <code class="literal">@Similarity</code> annotation.</p><pre class="programlisting">@Entity
@Indexed
<span class="bold"><strong>@Similarity(impl = DummySimilarity.class)</strong></span>
public class Book {
   ...
}</pre><p>As an example, let's assume it is not important how often a
    term appears in a document. Documents with a single occurrence of the term
    should be scored the same as documents with multiple occurrences. In this
    case your custom implementation of the method <code class="methodname">tf(float
    freq)</code> should return 1.0.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>When two entities share the same index they must declare the
    same <code class="classname">Similarity</code> implementation. Classes in the same
    class hierarchy always share the index, so it's not allowed to override the
    <code class="classname">Similarity</code> implementation in a subtype.</p></div></div></div></div><HR xmlns=""/><a xmlns="" href=""/><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("search"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>