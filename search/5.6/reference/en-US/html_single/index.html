<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Hibernate Search</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate Search, full text search for your entities - Reference Documentation" /><meta name="keywords" content="hibernate, search, hibernate search, full text, lucene, elasticsearch" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" type="text/css" href="docbook.css"/><link rel="stylesheet" type="text/css" href="css/hibernate-single.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div xml:lang="en" class="book" id="d0e3"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title">Hibernate Search</h1></div><div><h2 class="subtitle">Apache <span class="trademark">Lucene</span>™ Integration</h2></div><div><h2 class="subtitle">Reference Guide</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Emmanuel</span> <span class="surname">Bernard</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Hardy</span> <span class="surname">Ferentschik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Gustavo</span> <span class="surname">Fernandes</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Sanne</span> <span class="surname">Grinovero</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Nabeel</span> <span class="othername">Ali</span> <span class="surname">Memon</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Gunnar</span> <span class="surname">Morling</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Yoann</span> <span class="surname">Rodière</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Guillaume</span> <span class="surname">Smet</span></h3></div></div></div><div><p class="releaseinfo">5.6.6.Final</p></div></div><hr/></div><div class="toc"><ul class="toc"><li><span class="preface"><a href="#preface">Preface</a></span></li><li><span class="chapter"><a href="#getting-started">1. Getting started</a></span><ul><li><span class="section"><a href="#_system_requirements">1.1. System Requirements</a></span></li><li><span class="section"><a href="#_migration_notes">1.2. Migration notes</a></span></li><li><span class="section"><a href="#_required_libraries">1.3. Required libraries</a></span><ul><li><span class="section"><a href="#search-download-via-maven">1.3.1. Using Maven</a></span></li><li><span class="section"><a href="#_manual_library_management">1.3.2. Manual library management</a></span></li></ul></li><li><span class="section"><a href="#_deploying_on_wildfly">1.4. Deploying on WildFly</a></span></li><li><span class="section"><a href="#_configuration">1.5. Configuration</a></span></li><li><span class="section"><a href="#_indexing">1.6. Indexing</a></span></li><li><span class="section"><a href="#_searching">1.7. Searching</a></span></li><li><span class="section"><a href="#_analyzer">1.8. Analyzer</a></span></li><li><span class="section"><a href="#_what_s_next">1.9. What’s next</a></span></li></ul></li><li><span class="chapter"><a href="#search-architecture">2. Architecture</a></span><ul><li><span class="section"><a href="#_overview">2.1. Overview</a></span></li><li><span class="section"><a href="#_back_end">2.2. Back end</a></span><ul><li><span class="section"><a href="#_lucene">2.2.1. Lucene</a></span></li><li><span class="section"><a href="#search-architecture-jms">2.2.2. JMS</a></span></li><li><span class="section"><a href="#_jgroups">2.2.3. JGroups</a></span></li></ul></li><li><span class="section"><a href="#search-architecture-readerstrategy">2.3. Reader strategy</a></span><ul><li><span class="section"><a href="#_shared">2.3.1. shared</a></span></li><li><span class="section"><a href="#_not_shared">2.3.2. not-shared</a></span></li><li><span class="section"><a href="#_async">2.3.3. async</a></span></li><li><span class="section"><a href="#_custom">2.3.4. Custom</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#search-configuration">3. Configuration</a></span><ul><li><span class="section"><a href="#search-configuration-event">3.1. Enabling Hibernate Search and automatic indexing</a></span><ul><li><span class="section"><a href="#_enabling_hibernate_search">3.1.1. Enabling Hibernate Search</a></span></li><li><span class="section"><a href="#_automatic_indexing">3.1.2. Automatic indexing</a></span></li></ul></li><li><span class="section"><a href="#configuration-indexmanager">3.2. Configuring the IndexManager</a></span><ul><li><span class="section"><a href="#_directory_based">3.2.1. directory-based</a></span></li><li><span class="section"><a href="#_near_real_time">3.2.2. near-real-time</a></span></li><li><span class="section"><a href="#_custom_2">3.2.3. Custom</a></span></li></ul></li><li><span class="section"><a href="#search-configuration-directory">3.3. Directory configuration</a></span><ul><li><span class="section"><a href="#infinispan-directories">3.3.1. Infinispan Directory configuration</a></span></li></ul></li><li><span class="section"><a href="#configuration-worker">3.4. Worker configuration</a></span><ul><li><span class="section"><a href="#jms-backend">3.4.1. JMS Master/Slave back end</a></span></li><li><span class="section"><a href="#jgroups-backend">3.4.2. JGroups Master/Slave back end</a></span></li></ul></li><li><span class="section"><a href="#configuration-reader-strategy">3.5. Reader strategy configuration</a></span></li><li><span class="section"><a href="#_serialization">3.6. Serialization</a></span></li><li><span class="section"><a href="#exception-handling">3.7. Exception handling</a></span></li><li><span class="section"><a href="#_lucene_configuration">3.8. Lucene configuration</a></span><ul><li><span class="section"><a href="#lucene-indexing-performance">3.8.1. Tuning indexing performance</a></span></li><li><span class="section"><a href="#search-configuration-directory-lockfactories">3.8.2. LockFactory configuration</a></span></li><li><span class="section"><a href="#_index_format_compatibility">3.8.3. Index format compatibility</a></span></li></ul></li><li><span class="section"><a href="#_metadata_api">3.9. Metadata API</a></span></li><li><span class="section"><a href="#search-configuration-deploy-on-wildfly">3.10. Hibernate Search as a WildFly module</a></span><ul><li><span class="section"><a href="#using-wildfly-provided-hibernatesearch-versions">3.10.1. Use the Hibernate Search version included in WildFly</a></span></li><li><span class="section"><a href="#_update_and_activate_latest_hibernate_search_version_in_wildfly">3.10.2. Update and activate latest Hibernate Search version in WildFly</a></span></li><li><span class="section"><a href="#_more_about_modules">3.10.3. More about modules</a></span></li><li><span class="section"><a href="#_using_infinispan_with_hibernate_search_on_wildfly">3.10.4. Using Infinispan with Hibernate Search on WildFly</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#search-mapping">4. Mapping entities to the index structure</a></span><ul><li><span class="section"><a href="#search-mapping-entity">4.1. Mapping an entity</a></span><ul><li><span class="section"><a href="#basic-mapping">4.1.1. Basic mapping</a></span></li><li><span class="section"><a href="#fields-annotation">4.1.2. Mapping properties multiple times</a></span></li><li><span class="section"><a href="#search-mapping-associated">4.1.3. Embedded and associated objects</a></span></li><li><span class="section"><a href="#_associated_objects_building_a_dependency_graph_with_containedin">4.1.4. Associated objects: building a dependency graph with @ContainedIn</a></span></li></ul></li><li><span class="section"><a href="#section-boosting">4.2. Boosting</a></span><ul><li><span class="section"><a href="#section-boost-annotation">4.2.1. Static index time boosting</a></span></li><li><span class="section"><a href="#section-dynamic-boost">4.2.2. Dynamic index time boosting</a></span></li></ul></li><li><span class="section"><a href="#_analysis">4.3. Analysis</a></span><ul><li><span class="section"><a href="#analyzer">4.3.1. Default analyzer and analyzer by class</a></span></li><li><span class="section"><a href="#section-named-analyzers">4.3.2. Named analyzers</a></span></li><li><span class="section"><a href="#_dynamic_analyzer_selection">4.3.3. Dynamic analyzer selection</a></span></li><li><span class="section"><a href="#analyzer-retrievinganalyzer">4.3.4. Retrieving an analyzer</a></span></li></ul></li><li><span class="section"><a href="#search-mapping-bridge">4.4. Bridges</a></span><ul><li><span class="section"><a href="#section-built-in-bridges">4.4.1. Built-in bridges</a></span></li><li><span class="section"><a href="#_tika_bridge">4.4.2. Tika bridge</a></span></li><li><span class="section"><a href="#section-custom-bridges">4.4.3. Custom bridges</a></span></li><li><span class="section"><a href="#_bridgeprovider_associate_a_bridge_to_a_given_return_type">4.4.4. BridgeProvider: associate a bridge to a given return type</a></span></li></ul></li><li><span class="section"><a href="#search-mapping-indexinginterceptor">4.5. Conditional indexing</a></span></li><li><span class="section"><a href="#provided-id">4.6. Providing your own id</a></span><ul><li><span class="section"><a href="#ProvidedId">4.6.1. The ProvidedId annotation</a></span></li></ul></li><li><span class="section"><a href="#hsearch-mapping-programmaticapi">4.7. Programmatic API</a></span><ul><li><span class="section"><a href="#_mapping_an_entity_as_indexable">4.7.1. Mapping an entity as indexable</a></span></li><li><span class="section"><a href="#_adding_documentid_to_indexed_entity">4.7.2. Adding DocumentId to indexed entity</a></span></li><li><span class="section"><a href="#_defining_analyzers">4.7.3. Defining analyzers</a></span></li><li><span class="section"><a href="#_defining_full_text_filter_definitions">4.7.4. Defining full text filter definitions</a></span></li><li><span class="section"><a href="#_defining_fields_for_indexing">4.7.5. Defining fields for indexing</a></span></li><li><span class="section"><a href="#_programmatically_defining_embedded_entities">4.7.6. Programmatically defining embedded entities</a></span></li><li><span class="section"><a href="#_contained_in_definition">4.7.7. Contained In definition</a></span></li><li><span class="section"><a href="#_date_calendar_bridge">4.7.8. Date/Calendar Bridge</a></span></li><li><span class="section"><a href="#_declaring_bridges">4.7.9. Declaring bridges</a></span></li><li><span class="section"><a href="#_mapping_class_bridge">4.7.10. Mapping class bridge</a></span></li><li><span class="section"><a href="#_mapping_dynamic_boost">4.7.11. Mapping dynamic boost</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#search-query">5. Querying</a></span><ul><li><span class="section"><a href="#section-building-lucene-queries">5.1. Building queries</a></span><ul><li><span class="section"><a href="#search-query-lucene-api">5.1.1. Building a Lucene query using the Lucene API</a></span></li><li><span class="section"><a href="#search-query-querydsl">5.1.2. Building a Lucene query with the Hibernate Search query DSL</a></span></li><li><span class="section"><a href="#_building_a_hibernate_search_query">5.1.3. Building a Hibernate Search query</a></span></li></ul></li><li><span class="section"><a href="#_retrieving_the_results">5.2. Retrieving the results</a></span><ul><li><span class="section"><a href="#_performance_considerations">5.2.1. Performance considerations</a></span></li><li><span class="section"><a href="#_result_size">5.2.2. Result size</a></span></li><li><span class="section"><a href="#_resulttransformer">5.2.3. ResultTransformer</a></span></li><li><span class="section"><a href="#_understanding_results">5.2.4. Understanding results</a></span></li></ul></li><li><span class="section"><a href="#query-filter">5.3. Filters</a></span><ul><li><span class="section"><a href="#query-filter-shard">5.3.1. Using filters in a sharded environment</a></span></li></ul></li><li><span class="section"><a href="#query-faceting">5.4. Faceting</a></span><ul><li><span class="section"><a href="#section-creating-faceting-request">5.4.1. Creating a faceting request</a></span></li><li><span class="section"><a href="#section-sorting-faceting-request">5.4.2. Setting the facet sort order</a></span></li><li><span class="section"><a href="#section-applying-faceting-request">5.4.3. Applying a faceting request</a></span></li><li><span class="section"><a href="#section-interpreting-facet-result">5.4.4. Interpreting a Facet result</a></span></li><li><span class="section"><a href="#_restricting_query_results">5.4.5. Restricting query results</a></span></li></ul></li><li><span class="section"><a href="#_optimizing_the_query_process">5.5. Optimizing the query process</a></span><ul><li><span class="section"><a href="#query-logging">5.5.1. Logging executed Lucene queries</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#manual-index-changes">6. Manual index changes</a></span><ul><li><span class="section"><a href="#_adding_instances_to_the_index">6.1. Adding instances to the index</a></span></li><li><span class="section"><a href="#_deleting_instances_from_the_index">6.2. Deleting instances from the index</a></span></li><li><span class="section"><a href="#search-batchindex">6.3. Rebuilding the whole index</a></span><ul><li><span class="section"><a href="#search-batchindex-flushtoindexes">6.3.1. Using flushToIndexes()</a></span></li><li><span class="section"><a href="#search-batchindex-massindexer">6.3.2. Using a MassIndexer</a></span></li><li><span class="section"><a href="#_useful_parameters_for_batch_indexing">6.3.3. Useful parameters for batch indexing</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#search-optimize">7. Index Optimization</a></span><ul><li><span class="section"><a href="#_automatic_optimization">7.1. Automatic optimization</a></span></li><li><span class="section"><a href="#_manual_optimization">7.2. Manual optimization</a></span></li><li><span class="section"><a href="#_adjusting_optimization">7.3. Adjusting optimization</a></span></li></ul></li><li><span class="chapter"><a href="#search-monitoring">8. Monitoring</a></span><ul><li><span class="section"><a href="#_jmx">8.1. JMX</a></span><ul><li><span class="section"><a href="#_statisticsinfombean">8.1.1. StatisticsInfoMBean</a></span></li><li><span class="section"><a href="#_indexcontrolmbean">8.1.2. IndexControlMBean</a></span></li><li><span class="section"><a href="#_indexingprogressmonitormbean">8.1.3. IndexingProgressMonitorMBean</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#spatial">9. Spatial</a></span><ul><li><span class="section"><a href="#spatial-indexing">9.1. Enable indexing of Spatial Coordinates</a></span><ul><li><span class="section"><a href="#spatial-indexing-range">9.1.1. Indexing coordinates for range queries</a></span></li><li><span class="section"><a href="#spatial-indexing-spatialHash">9.1.2. Indexing coordinates in a grid with spatial hashes</a></span></li><li><span class="section"><a href="#spatial-coordinatesinterface">9.1.3. Implementing the Coordinates interface</a></span></li></ul></li><li><span class="section"><a href="#spatial-queries">9.2. Performing Spatial Queries</a></span><ul><li><span class="section"><a href="#spatial-queries-distance">9.2.1. Returning distance to query point in the search results</a></span></li></ul></li><li><span class="section"><a href="#spatial-multiplecoordinates">9.3. Multiple Coordinate pairs</a></span></li><li><span class="section"><a href="#spatial-behind-curtain">9.4. Insight: implementation details of spatial hashes indexing</a></span><ul><li><span class="section"><a href="#_at_indexing_level">9.4.1. At indexing level</a></span></li><li><span class="section"><a href="#_at_search_level">9.4.2. At search level</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#search-lucene-native">10. Advanced features</a></span><ul><li><span class="section"><a href="#AccessingSearchFactory">10.1. Accessing the <code class="literal">SearchFactory</code></a></span></li><li><span class="section"><a href="#AccessingSearchIntegrator">10.2. Accessing the <code class="literal">SearchIntegrator</code></a></span></li><li><span class="section"><a href="#IndexReaders">10.3. Using an <code class="literal">IndexReader</code></a></span></li><li><span class="section"><a href="#_accessing_a_lucene_directory">10.4. Accessing a Lucene Directory</a></span></li><li><span class="section"><a href="#advanced-features-sharding">10.5. Sharding indexes</a></span><ul><li><span class="section"><a href="#_static_sharding">10.5.1. Static sharding</a></span></li><li><span class="section"><a href="#advanced-features-dynamic-sharding">10.5.2. Dynamic sharding</a></span></li></ul></li><li><span class="section"><a href="#section-sharing-indexes">10.6. Sharing indexes</a></span></li><li><span class="section"><a href="#section-services">10.7. Using external services</a></span><ul><li><span class="section"><a href="#_using_a_service">10.7.1. Using a Service</a></span></li><li><span class="section"><a href="#_implementing_a_service">10.7.2. Implementing a Service</a></span></li></ul></li><li><span class="section"><a href="#_customizing_lucene_s_scoring_formula">10.8. Customizing Lucene’s scoring formula</a></span></li><li><span class="section"><a href="#section-multi-tenancy">10.9. Multi-tenancy</a></span><ul><li><span class="section"><a href="#_what_is_multi_tenancy">10.9.1. What is multi-tenancy?</a></span></li><li><span class="section"><a href="#_using_a_tenant_aware_literal_fulltextsession_literal">10.9.2. Using a tenant-aware <code class="literal">FullTextSession</code></a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#elasticsearch-integration">11. Integration with Elasticsearch</a></span><ul><li><span class="section"><a href="#_status">11.1. Status</a></span></li><li><span class="section"><a href="#_goal_of_the_elasticsearch_integration">11.2. Goal of the Elasticsearch integration</a></span></li><li><span class="section"><a href="#_getting_started_and_configuration">11.3. Getting started and configuration</a></span><ul><li><span class="section"><a href="#_dependencies_in_your_java_application">11.3.1. Dependencies in your Java application</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_integration_server_configuration_xreflabel_elasticsearch_integration_server_configuration_elasticsearch_configuration">11.3.2.  Elasticsearch configuration</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_integration_configuration_xreflabel_elasticsearch_integration_configuration_hibernate_search_configuration">11.3.3.  Hibernate Search configuration</a></span></li></ul></li><li><span class="section"><a href="#_mapping_and_indexing">11.4. Mapping and indexing</a></span><ul><li><span class="section"><a href="#_annotation_specificities">11.4.1. Annotation specificities</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_mapping_analyzer_xreflabel_elasticsearch_mapping_analyzer_analyzers">11.4.2.  Analyzers</a></span></li><li><span class="section"><a href="#_custom_field_bridges">11.4.3. Custom field bridges</a></span></li><li><span class="section"><a href="#_tika_bridges">11.4.4. Tika bridges</a></span></li></ul></li><li><span class="section"><a href="#_queries">11.5. Queries</a></span><ul><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_query_spatial_xreflabel_elasticsearch_query_spatial_spatial_queries">11.5.1.  Spatial queries</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_scrolling_xreflabel_elasticsearch_scrolling_paging_and_scrolling">11.5.2.  Paging and scrolling</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_query_sorting_xreflabel_elasticsearch_query_sorting_sorting">11.5.3. Sorting</a></span></li><li><span class="section"><a href="#_projections">11.5.4. Projections</a></span></li><li><span class="section"><a href="#_filters">11.5.5. Filters</a></span></li></ul></li><li><span class="section"><a href="#_index_optimization">11.6. Index optimization</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_limitations_xreflabel_elasticsearch_limitations_limitations">11.7. Limitations</a></span></li><li><span class="section"><a href="#_known_bugs_in_elasticsearch">11.8. Known bugs in Elasticsearch</a></span></li><li><span class="section"><a href="#_acknowledgment">11.9. Acknowledgment</a></span></li></ul></li><li><span class="chapter"><a href="#_further_reading">12. Further reading</a></span></li></ul></div><section class="preface" id="preface"><div class="titlepage"><div><div><h1 class="title">Preface</h1></div></div></div><p>Full text search engines like Apache Lucene are very powerful technologies to add efficient free
text search capabilities to applications. However, Lucene suffers several mismatches when dealing
with object domain models. Amongst other things indexes have to be kept up to date and mismatches
between index structure and domain model as well as query mismatches have to be avoided.</p><p>Hibernate Search addresses these shortcomings - it indexes your domain model with the help of a few
annotations, takes care of database/index synchronization and brings back regular managed objects
from free text queries. To achieve this Hibernate Search is combining the power of
<a class="link" href="http://www.hibernate.org">Hibernate</a> and <a class="link" href="http://lucene.apache.org">Apache Lucene</a>.</p><p>Since version <code class="literal">5.6</code> Hibernate Search sports an experimental integration with <a class="link" href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>.
Elasticsearch is built on Apache Lucene so we can now expose very similar features, making most
of this reference documentation a valid guide to both approaches.
For details specific to Elasticsearch, jump to <a class="xref" href="#elasticsearch-integration" title="Chapter 11. Integration with Elasticsearch">Chapter 11, <em>Integration with Elasticsearch</em></a>.
The other sections of this guide will assume you’re using Lucene without the Elasticsearch indirection.</p></section><section class="chapter" id="getting-started"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Getting started</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#_system_requirements">1.1. System Requirements</a></span></li><li><span class="section"><a href="#_migration_notes">1.2. Migration notes</a></span></li><li><span class="section"><a href="#_required_libraries">1.3. Required libraries</a></span><ul><li><span class="section"><a href="#search-download-via-maven">1.3.1. Using Maven</a></span></li><li><span class="section"><a href="#_manual_library_management">1.3.2. Manual library management</a></span></li></ul></li><li><span class="section"><a href="#_deploying_on_wildfly">1.4. Deploying on WildFly</a></span></li><li><span class="section"><a href="#_configuration">1.5. Configuration</a></span></li><li><span class="section"><a href="#_indexing">1.6. Indexing</a></span></li><li><span class="section"><a href="#_searching">1.7. Searching</a></span></li><li><span class="section"><a href="#_analyzer">1.8. Analyzer</a></span></li><li><span class="section"><a href="#_what_s_next">1.9. What’s next</a></span></li></ul></div><p>Welcome to Hibernate Search. The following chapter will guide you through the initial steps required
to integrate Hibernate Search into an existing Hibernate ORM enabled application. In case you are a
Hibernate new timer we recommend you start <a class="link" href="http://hibernate.org/quick-start.html">here</a>.</p><section class="section" id="_system_requirements"><div class="titlepage"><div><div><h2 class="title">1.1. System Requirements</h2></div></div></div><div class="table" id="d0e128"><div class="table-title">Table 1.1. System requirements</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Java Runtime</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Requires Java version <span class="emphasis"><em>7</em></span> or greater. You
            can download a Java Runtime for Windows/Linux/Solaris <a class="link" href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">here</a>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Hibernate Search</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">hibernate-search-5.6.6.Final.jar</code> and all
            runtime dependencies. You can get the jar artifacts either from
            the <code class="literal">dist/lib</code> directory of the <a class="link" href="http://sourceforge.net/projects/hibernate/files/hibernate-search/">Hibernate Search distribution</a> or you can download them from the
            <a class="link" href="http://repository.jboss.org/nexus/content/groups/public-jboss/org/hibernate/">JBoss maven repository</a>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Hibernate ORM</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>You will need
            <code class="literal">hibernate-core-5.1.15.Final.jar</code> and its
            dependencies (either from the <a class="link" href="http://sourceforge.net/projects/hibernate/files/hibernate-orm/">distribution bundle</a> or the maven repository).</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>JPA 2.1</p></td><td style="text-align: left; vertical-align: top; "><p>Hibernate Search can be used without JPA but the following instructions will use JPA annotations for basic
            entity configuration (<code class="literal">@Entity</code>, <code class="literal">@Id</code>, <code class="literal">@OneToMany</code>,…​).</p></td></tr></tbody></table></div></div><br class="table-break"/></section><section class="section" id="_migration_notes"><div class="titlepage"><div><div><h2 class="title">1.2. Migration notes</h2></div></div></div><p>If you are upgrading an existing application from an earlier version of Hibernate Search to the latest release,
make sure to check the out the <a class="link" href="http://hibernate.org/search/documentation/migrate/">migration guide</a>.</p></section><section class="section" id="_required_libraries"><div class="titlepage"><div><div><h2 class="title">1.3. Required libraries</h2></div></div></div><p>The Hibernate Search library is split in several modules to allow you to pick the minimal set of
dependencies you need.
It requires Apache Lucene, Hibernate ORM and some standard APIs such as the Java Persistence API
and the Java Transactions API. Other dependencies are optional, providing additional integration
points.
To get the correct jar files on your classpath we highly recommend to use a dependency manager such
as <a class="link" href="http://maven.apache.org/">Maven</a>, or similar tools such as <a class="link" href="http://www.gradle.org/">Gradle</a> or
<a class="link" href="http://ant.apache.org/ivy/">Ivy</a>.
These alternatives are also able to consume the artifacts from the <a class="xref" href="#search-download-via-maven" title="1.3.1. Using Maven">Section 1.3.1, “Using Maven”</a> section.</p><section class="section" id="search-download-via-maven"><div class="titlepage"><div><div><h3 class="title">1.3.1. Using Maven</h3></div></div></div><p>The Hibernate Search artifacts can be found in Maven’s <a class="link" href="http://central.sonatype.org/">Central Repository</a>
but are released first in the <a class="link" href="http://repository.jboss.org/nexus/content/groups/public-jboss/">JBoss Maven Repository</a>.
See also the <a class="link" href="https://community.jboss.org/wiki/MavenGettingStarted-Users">Maven Getting Started wiki page</a> to use
the JBoss repository.</p><p>All you have to add to your pom.xml is:</p><div class="example" id="d0e235"><div class="example-title">Example 1.1. Maven artifact identifier for Hibernate Search</div><div class="example-contents"><pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
   &lt;version&gt;5.6.6.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div></div><br class="example-break"/><div class="example" id="d0e240"><div class="example-title">Example 1.2. Optional Maven dependencies for Hibernate Search</div><div class="example-contents"><pre><code class="language-xml">&lt;!-- If using JPA, add: --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;
   &lt;version&gt;5.1.15.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Infinispan integration: --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
   &lt;artifactId&gt;infinispan-directory-provider&lt;/artifactId&gt;
   &lt;version&gt;8.2.4.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div></div><br class="example-break"/><p>Only the <span class="emphasis"><em>hibernate-search-orm</em></span> dependency is mandatory. <span class="emphasis"><em>hibernate-entitymanager</em></span> is only required
if you want to use Hibernate Search in conjunction with JPA.</p></section><section class="section" id="_manual_library_management"><div class="titlepage"><div><div><h3 class="title">1.3.2. Manual library management</h3></div></div></div><p>You can download zip bundles from Sourceforge containing all needed
<a class="link" href="http://sourceforge.net/projects/hibernate/files/hibernate-search/5.6.6.Final/">Hibernate Search</a>
dependencies. This includes - among others - the latest compatible version of Hibernate ORM. However,
only the essential parts you need to start experimenting with are included. You will probably need
to combine this with downloads from the other projects, for example the
<a class="link" href="http://sourceforge.net/projects/hibernate/files/hibernate-orm/5.1.15.Final/">Hibernate ORM distribution on Sourceforge</a>
also provides the modules to enable caching or use a connection pool.</p></section></section><section class="section" id="_deploying_on_wildfly"><div class="titlepage"><div><div><h2 class="title">1.4. Deploying on WildFly</h2></div></div></div><p>If you are creating an application to be deployed on WildFly you’re lucky:
Hibernate Search is included in the application server.
This means that you don’t need to package it along with your application, unless you want to use a different version
than the one included.
The Hibernate Search dependencies are automatically activated since WildFly 10; see <a class="xref" href="#search-configuration-deploy-on-wildfly" title="3.10. Hibernate Search as a WildFly module">Section 3.10, “Hibernate Search as a WildFly module”</a> for details.</p><p>Since this version of Hibernate Search requires Hibernate ORM 5.0, we will assume you’re running at least WildFly 10.</p></section><section class="section" id="_configuration"><div class="titlepage"><div><div><h2 class="title">1.5. Configuration</h2></div></div></div><p>Once you have added all required dependencies to your application you have to add a couple of
properties to your Hibernate configuration file.
If you are using Hibernate directly this can be done in <code class="literal">hibernate.properties</code> or <code class="literal">hibernate.cfg.xml</code>.
If you are using Hibernate via JPA you can also add the properties to <code class="literal">persistence.xml</code>.
The good news is that for standard use most properties offer a sensible default.
An example <code class="literal">persistence.xml</code> configuration could look like this:</p><div class="example" id="d0e290"><div class="example-title">Example 1.3. Basic configuration options to be added to <code class="literal">hibernate.properties</code>, <code class="literal">hibernate.cfg.xml</code> or <code class="literal">persistence.xml</code></div><div class="example-contents"><pre><code class="language-xml">...
&lt;property name="hibernate.search.default.directory_provider"
          value="filesystem"/&gt;

&lt;property name="hibernate.search.default.indexBase"
          value="/var/lucene/indexes"/&gt;
...</code></pre></div></div><br class="example-break"/><p>First you have to tell Hibernate Search which <code class="literal">DirectoryProvider</code> to use. This can be achieved by
setting the <code class="literal">hibernate.search.default.directory_provider</code> property. Apache Lucene has the notion
of a <code class="literal">Directory</code> to store the index files. Hibernate Search handles the initialization and
configuration of a Lucene <code class="literal">Directory</code> instance via a <code class="literal">DirectoryProvider</code>. In this tutorial we will
use a a directory provider which stores the index on the file system. This will give us the ability to
inspect the Lucene indexes created by Hibernate Search (eg via
<a class="link" href="https://github.com/DmitryKey/luke/">Luke</a>). Once you have a working configuration you can start
experimenting with other directory providers (see <a class="xref" href="#search-configuration-directory" title="3.3. Directory configuration">Section 3.3, “Directory configuration”</a>).
You also have to specify the default base directory for all indexes via
<code class="literal">hibernate.search.default.indexBase</code>. This defines the path where indexes are stored.</p><p>Let’s assume that your application contains the Hibernate managed classes <code class="literal">example.Book</code> and
<code class="literal">example.Author</code> and you want to add free text search capabilities to your application in order to
search the books contained in your database.</p><div class="example" id="d0e336"><div class="example-title">Example 1.4. Example entities Book and Author before adding Hibernate Search specific annotations</div><div class="example-contents"><pre><code class="language-java">package example;
...
@Entity
public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  private String title;

  private String subtitle;

  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  private Date publicationDate;

  public Book() {}

  // standard getters/setters follow
  ...
}</code></pre><pre><code class="language-java">package example;
...
@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  private String name;

  public Author() {}

  // standard getters/setters follow
  ...
}</code></pre></div></div><br class="example-break"/><p>To achieve this you have to add a few annotations to the <code class="literal">Book</code> and <code class="literal">Author</code> class. The first annotation
<code class="literal">@Indexed</code> marks <code class="literal">Book</code> as indexable. By design Hibernate Search needs to store an <span class="emphasis"><em>untokenized</em></span> id in
the index to ensure index uniqueness for a given entity (for now don’t worry if you don’t know what
<span class="emphasis"><em>untokenized</em></span> means, it will soon be clear).</p><p>Next you have to mark the fields you want to make searchable. Let’s start with <code class="literal">title</code> and
<code class="literal">subtitle</code> and annotate both with <code class="literal">@Field</code>. The parameter <code class="literal">index=Index.YES</code> will ensure that the
text will be indexed, while <code class="literal">analyze=Analyze.YES</code> ensures that the text will be analyzed using the
default Lucene analyzer. Usually, analyzing or tokenizing means chunking a sentence into individual
words and potentially excluding common words like "a" or "the". We will talk more about analyzers a
little later on.
The third parameter we specify is <code class="literal">store=Store.NO</code>, which ensures that the actual data
will not be stored in the index.
Whether data is stored in the index or not has nothing to do with the ability to search for it.
It is not necessary to store fields in the index to allow Lucene to search for them: the benefit of
storing them is the ability to retrieve them via projections (see <a class="xref" href="#projections" title="5.1.3.5. Projection">Section 5.1.3.5, “Projection”</a>).</p><p>Without projections, Hibernate Search will per default execute a Lucene query in order to find the
database identifiers of the entities matching the query criteria and use these identifiers to
retrieve managed objects from the database. The decision for or against projection has to be made on
a case by case basis.</p><p>Note that <code class="literal">index=Index.YES</code>, <code class="literal">analyze=Analyze.YES</code> and <code class="literal">store=Store.NO</code> are the default values for
these parameters and could be omitted.</p><p>After this short look under the hood let’s go back to annotating the <code class="literal">Book</code> class. Another annotation
we have not yet discussed is <code class="literal">@DateBridge</code>. This annotation is one of the built-in field bridges in
Hibernate Search. The Lucene index is mostly string based, with special support for encoding numbers.
Hibernate Search must convert the data types of the indexed fields to their respective Lucene
encoding and vice versa. A range of predefined bridges is provided for this purpose, including the
<code class="literal">DateBridge</code> which will convert a <code class="literal">java.util.Date</code> into a numeric value (a <code class="literal">long</code>) with the
specified resolution. For more details see <a class="xref" href="#section-built-in-bridges" title="4.4.1. Built-in bridges">Section 4.4.1, “Built-in bridges”</a>.</p><p>This leaves us with <code class="literal">@IndexedEmbedded</code>. This annotation is used to index associated entities
(<code class="literal">@ManyToMany</code>, <code class="literal">@*ToOne</code>, <code class="literal">@Embedded</code> and <code class="literal">@ElementCollection</code>) as part of the owning entity.
This is needed since a Lucene index document is a flat data structure which does not know anything
about object relations.
To ensure that the author names will be searchable you have to make sure that the names are indexed
as part of the book itself. On top of <code class="literal">@IndexedEmbedded</code> you will also have to mark the fields of
the associated entity you want to have included in the index with <code class="literal">@Field</code>.
For more details see <a class="xref" href="#search-mapping-associated" title="4.1.3. Embedded and associated objects">Section 4.1.3, “Embedded and associated objects”</a>.</p><p>These settings should be sufficient for now. For more details on entity mapping refer to
<a class="xref" href="#search-mapping-entity" title="4.1. Mapping an entity">Section 4.1, “Mapping an entity”</a>.</p><div class="example" id="d0e446"><div class="example-title">Example 1.5. Example entities after adding Hibernate Search annotations</div><div class="example-contents"><pre><code class="language-java">package example;
...
@Entity
@Indexed
public class Book {

  @Id
  @GeneratedValue
  private Integer id;

  @Field(index=Index.YES, analyze=Analyze.YES, store=Store.NO)
  private String title;

  @Field(index=Index.YES, analyze=Analyze.YES, store=Store.NO)
  private String subtitle;

  @Field(index = Index.YES, analyze=Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  @IndexedEmbedded
  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();
  public Book() {
  }

  // standard getters/setters follow here
  ...
}</code></pre><pre><code class="language-java">@Entity
public class Author {

  @Id
  @GeneratedValue
  private Integer id;

  @Field
  private String name;

  public Author() {
  }

  // standard getters/setters follow here
  ...
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_indexing"><div class="titlepage"><div><div><h2 class="title">1.6. Indexing</h2></div></div></div><p>Hibernate Search will transparently index every entity persisted, updated or removed through
Hibernate ORM. However, you have to create an initial Lucene index for the data already present in
your database. Once you have added the above properties and annotations it is time to trigger an
initial batch index of your books. You can achieve this by using one of the following code snippets
(see also <a class="xref" href="#search-batchindex" title="6.3. Rebuilding the whole index">Section 6.3, “Rebuilding the whole index”</a>):</p><div class="example" id="d0e460"><div class="example-title">Example 1.6. Using Hibernate Session to index data</div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
fullTextSession.createIndexer().startAndWait();</code></pre></div></div><br class="example-break"/><div class="example" id="d0e465"><div class="example-title">Example 1.7. Using JPA to index data</div><div class="example-contents"><pre><code class="language-java">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(em);
fullTextEntityManager.createIndexer().startAndWait();</code></pre></div></div><br class="example-break"/><p>After executing the above code, you should be able to see a Lucene index under <code class="literal">/var/lucene/indexes/example.Book</code>
(or based on a different path depending how you configured the property <code class="literal">hibernate.search.default.directory_provider</code>).</p><p>Go ahead an inspect this index with <a class="link" href="https://github.com/DmitryKey/luke/">Luke</a>:
it will help you to understand how Hibernate Search works.</p></section><section class="section" id="_searching"><div class="titlepage"><div><div><h2 class="title">1.7. Searching</h2></div></div></div><p>Now it is time to execute a first search. The general approach is to create a Lucene query, either
via the Lucene API (<a class="xref" href="#search-query-lucene-api" title="5.1.1. Building a Lucene query using the Lucene API">Section 5.1.1, “Building a Lucene query using the Lucene API”</a>) or via the Hibernate Search query DSL
(<a class="xref" href="#search-query-querydsl" title="5.1.2. Building a Lucene query with the Hibernate Search query DSL">Section 5.1.2, “Building a Lucene query with the Hibernate Search query DSL”</a>), and then wrap this query into a <code class="literal">org.hibernate.Query</code> in order to get all the
functionality one is used to from the Hibernate API. The following code will prepare a query against
the indexed fields, execute it and return a list of <code class="literal">Book</code> instances.</p><div class="example" id="d0e498"><div class="example-title">Example 1.8. Using Hibernate Session to create and execute a search</div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity(Book.class).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a org.hibernate.Query
org.hibernate.Query hibQuery =
    fullTextSession.createFullTextQuery(query, Book.class);

// execute search
List result = hibQuery.list();

tx.commit();
session.close();</code></pre></div></div><br class="example-break"/><div class="example" id="d0e503"><div class="example-title">Example 1.9. Using JPA to create and execute a search</div><div class="example-contents"><pre><code class="language-java">EntityManager em = entityManagerFactory.createEntityManager();
FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);
em.getTransaction().begin();

// create native Lucene query using the query DSL
// alternatively you can write the Lucene query using the Lucene query parser
// or the Lucene programmatic API. The Hibernate Search DSL is recommended though
QueryBuilder qb = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
org.apache.lucene.search.Query query = qb
  .keyword()
  .onFields("title", "subtitle", "authors.name")
  .matching("Java rocks!")
  .createQuery();

// wrap Lucene query in a javax.persistence.Query
javax.persistence.Query persistenceQuery =
    fullTextEntityManager.createFullTextQuery(query, Book.class);

// execute search
List result = persistenceQuery.getResultList();

em.getTransaction().commit();
em.close();</code></pre></div></div><br class="example-break"/></section><section class="section" id="_analyzer"><div class="titlepage"><div><div><h2 class="title">1.8. Analyzer</h2></div></div></div><p>Let’s make things a little more interesting now. Assume that one of your indexed book entities has
the title "Refactoring: Improving the Design of Existing Code" and you want to get hits for all of
the following queries: "refactor", "refactors", "refactored" and "refactoring". In Lucene this can
be achieved by choosing an analyzer class which applies word stemming during the indexing <span class="strong"><strong>as well
as</strong></span> the search process. Hibernate Search offers several ways to configure the analyzer to be used
(see <a class="xref" href="#analyzer" title="4.3.1. Default analyzer and analyzer by class">Section 4.3.1, “Default analyzer and analyzer by class”</a>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Setting the <code class="literal">hibernate.search.analyzer</code> property in the configuration file.
The specified class will then be the default analyzer.</li><li class="listitem">Setting the <code class="literal">@Analyzer</code> annotation at the entity level.</li><li class="listitem">Setting the <code class="literal">@Analyzer</code> annotation at the field level.</li></ul></div><p>When using the <code class="literal">@Analyzer</code> annotation one can either specify the fully qualified classname of the
analyzer to use or one can refer to an analyzer definition defined by the <code class="literal">@AnalyzerDef</code> annotation.
In the latter case the analyzer framework with its factories approach is utilized.</p><p>To find out more about the factory classes available
you can either browse the Lucene JavaDoc or read the corresponding section on the
<a class="link" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">Solr Wiki</a>.</p><p>You can use <code class="literal">@AnalyzerDef</code> or <code class="literal">@AnalyzerDefs</code> on any:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">@Indexed</code> entity regardless of where the analyzer is applied to;</li><li class="listitem">parent class of an <code class="literal">@Indexed</code> entity;</li><li class="listitem">package-info.java of a package containing an <code class="literal">@Indexed</code> entity.</li></ul></div><p>This implies that analyzer definitions are global and their names must be unique.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Why the reference to the Apache Solr wiki?</p><p>Apache Solr was historically an indepedent sister project of Apache Lucene and the analyzer factory
framework was originally created in Solr.
Since then the Apache Lucene and Solr projects have merged, but the
documentation for these additional analyzers can still be found in the Solr Wiki. You might find
other documentation referring to the "Solr Analyzer Framework" - just remember you don’t need to
depend on Apache Solr anymore to use it. The required classes are part of the core Lucene
distribution.</p></div><p>In the example below a <code class="literal">StandardTokenizerFactory</code> is used followed by two filter factories,
<code class="literal">LowerCaseFilterFactory</code> and <code class="literal">SnowballPorterFilterFactory</code>. The standard tokenizer splits words at
punctuation characters and hyphens.
It is a good general purpose tokenizer.
For indexing email addresses or internet hostnames it is not the best fit as it would split them up.
You may either make use of Lucene’s <code class="literal">ClassicTokenizerFactory</code> in such cases or implement a custom tokenizer and factory.
The lowercase filter converts to lowercase the letters in each token
whereas the snowball filter finally applies language specific stemming.</p><p>Generally, when using the Analyzer Framework you have to start with a tokenizer followed by an
arbitrary number of filters.</p><div class="example" id="d0e599"><div class="example-title">Example 1.10. Using <code class="literal">@AnalyzerDef</code> and the Analyzer Framework to define and use an analyzer</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@AnalyzerDef(name = "customanalyzer",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = SnowballPorterFilterFactory.class, params = {
      @Parameter(name = "language", value = "English")
    })
  })
public class Book {

  @Id
  @GeneratedValue
  @DocumentId
  private Integer id;

  @Field
  @Analyzer(definition = "customanalyzer")
  private String title;

  @Field
  @Analyzer(definition = "customanalyzer")
  private String subtitle;

  @IndexedEmbedded
  @ManyToMany
  private Set&lt;Author&gt; authors = new HashSet&lt;Author&gt;();

  @Field(index = Index.YES, analyze = Analyze.NO, store = Store.YES)
  @DateBridge(resolution = Resolution.DAY)
  private Date publicationDate;

  public Book() {
  }

  // standard getters/setters follow here
  ...
}</code></pre></div></div><br class="example-break"/><p>Using <code class="literal">@AnalyzerDef</code> only defines an Analyzer, you still have to apply it to entities and or
properties using <code class="literal">@Analyzer</code>. Like in the above example the <code class="literal">customanalyzer</code> is defined but not
applied on the entity: it’s applied on the <code class="literal">title</code> and <code class="literal">subtitle</code> properties only. An analyzer
definition is global, so you can define it on any entity and reuse the definition on other entities.</p></section><section class="section" id="_what_s_next"><div class="titlepage"><div><div><h2 class="title">1.9. What’s next</h2></div></div></div><p>The above paragraphs helped you getting an overview of Hibernate Search. The next step after this
tutorial is to get more familiar with the overall architecture of Hibernate Search
(<a class="xref" href="#search-architecture" title="Chapter 2. Architecture">Chapter 2, <em>Architecture</em></a>) and explore the basic features in more detail. Two topics which were only briefly
touched in this tutorial were analyzer configuration (<a class="xref" href="#analyzer" title="4.3.1. Default analyzer and analyzer by class">Section 4.3.1, “Default analyzer and analyzer by class”</a>) and field bridges
(<a class="xref" href="#search-mapping-bridge" title="4.4. Bridges">Section 4.4, “Bridges”</a>). Both are important features required for more fine-grained indexing. More
advanced topics cover clustering (<a class="xref" href="#jms-backend" title="3.4.1. JMS Master/Slave back end">Section 3.4.1, “JMS Master/Slave back end”</a>, <a class="xref" href="#infinispan-directories" title="3.3.1. Infinispan Directory configuration">Section 3.3.1, “Infinispan Directory configuration”</a>) and large index
handling (<a class="xref" href="#advanced-features-sharding" title="10.5. Sharding indexes">Section 10.5, “Sharding indexes”</a>).</p></section></section><section class="chapter" id="search-architecture"><div class="titlepage"><div><div><h1 class="title">Chapter 2. Architecture</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#_overview">2.1. Overview</a></span></li><li><span class="section"><a href="#_back_end">2.2. Back end</a></span><ul><li><span class="section"><a href="#_lucene">2.2.1. Lucene</a></span></li><li><span class="section"><a href="#search-architecture-jms">2.2.2. JMS</a></span></li><li><span class="section"><a href="#_jgroups">2.2.3. JGroups</a></span></li></ul></li><li><span class="section"><a href="#search-architecture-readerstrategy">2.3. Reader strategy</a></span><ul><li><span class="section"><a href="#_shared">2.3.1. shared</a></span></li><li><span class="section"><a href="#_not_shared">2.3.2. not-shared</a></span></li><li><span class="section"><a href="#_async">2.3.3. async</a></span></li><li><span class="section"><a href="#_custom">2.3.4. Custom</a></span></li></ul></li></ul></div><section class="section" id="_overview"><div class="titlepage"><div><div><h2 class="title">2.1. Overview</h2></div></div></div><p>Hibernate Search consists of an indexing component as well as an index search component. Both are
backed by Apache Lucene.</p><p>Each time an entity is inserted, updated or removed in/from the database, Hibernate Search keeps
track of this event (through the Hibernate event system) and schedules an index update. All these
updates are handled without you having to interact with the Apache Lucene APIs directly (see
<a class="xref" href="#search-configuration-event" title="3.1. Enabling Hibernate Search and automatic indexing">Section 3.1, “Enabling Hibernate Search and automatic indexing”</a>). Instead, the interaction with the underlying Lucene indexes is
handled via so called IndexManagers.</p><p>Each Lucene index is managed by one index manager which is uniquely identified by name. In most
cases there is also a one to one relationship between an indexed entity and a single IndexManager.
The exceptions are the use cases of index sharding and index sharing. The former can be applied when
the index for a single entity becomes too big and indexing operations are slowing down the
application. In this case a single entity is indexed into multiple indexes each with its own index
manager (see <a class="xref" href="#advanced-features-sharding" title="10.5. Sharding indexes">Section 10.5, “Sharding indexes”</a>). The latter, index sharing, is the ability to index
multiple entities into the same Lucene index (see <a class="xref" href="#section-sharing-indexes" title="10.6. Sharing indexes">Section 10.6, “Sharing indexes”</a>).</p><p>The index manager abstracts from the specific index configuration. In the case of the default index
manager this includes details about the selected backend, the configured reader strategy and the
chosen DirectoryProvider. These components will be discussed in greater detail later on. It is
recommended that you start with the default index manager which uses different Lucene Directory
types to manage the indexes (see <a class="xref" href="#search-configuration-directory" title="3.3. Directory configuration">Section 3.3, “Directory configuration”</a>). You can, however, also provide
your own IndexManager implementation (see <a class="xref" href="#configuration-indexmanager" title="3.2. Configuring the IndexManager">Section 3.2, “Configuring the IndexManager”</a>).</p><p>Once the index is created, you can search for entities and return lists of managed entities saving
you the tedious object to Lucene Document mapping. The same persistence context is shared between
Hibernate and Hibernate Search. As a matter of fact, the <code class="literal">FullTextSession</code> is built on top of the
Hibernate Session so that the application code can use the unified org.hibernate.Query or
javax.persistence.Query APIs exactly the same way a HQL, JPA-QL or native query would do.</p><p>To be more efficient Hibernate Search batches the write interactions with the Lucene index. This
batching is the responsibility of the Worker. There are currently two types of batching. Outside a
transaction, the index update operation is executed right after the actual database operation. This
is really a no batching setup. In the case of an ongoing transaction, the index update operation is
scheduled for the transaction commit phase and discarded in case of transaction rollback. The
batching scope is the transaction. There are two immediate benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Performance: Lucene indexing works better when operation are executed in batch.</li><li class="listitem">ACIDity: The work executed has the same scoping as the one executed by the database transaction and
is executed if and only if the transaction is committed. This is not ACID in the strict sense of it,
but ACID behavior is rarely useful for full text search indexes since they can be rebuilt from the
source at any time.</li></ul></div><p>You can think of those two batch modes (no scope vs transactional) as the equivalent of the
(infamous) autocommit vs transactional behavior. From a performance perspective, the <span class="emphasis"><em>in
transaction</em></span> mode is recommended. The scoping choice is made transparently. Hibernate Search detects
the presence of a transaction and adjust the scoping (see <a class="xref" href="#configuration-worker" title="3.4. Worker configuration">Section 3.4, “Worker configuration”</a>).</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>It is recommended - for both your database and Hibernate Search - to execute your operations in a transaction, be it JDBC or JTA.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Hibernate Search works perfectly fine in the Hibernate / EntityManager long conversation
pattern aka. atomic conversation.</p></div></section><section class="section" id="_back_end"><div class="titlepage"><div><div><h2 class="title">2.2. Back end</h2></div></div></div><p>Hibernate Search offers the ability to let the batched work being processed by different back ends.
Several back ends are provided out of the box and you have the option to plugin your own. It is
important to understand that in this context back end encompasses more than just the configuration
option <code class="literal">hibernate.search.default.worker.backend</code>. This property just specifies a implementation of
the BackendQueueProcessor interface which is a part of a back end configuration. In most cases,
however, additional configuration settings are needed to successfully configure a specific backend
setup, like for example the JMS back end.</p><section class="section" id="_lucene"><div class="titlepage"><div><div><h3 class="title">2.2.1. Lucene</h3></div></div></div><p>In this mode, all index update operations applied on a given node (JVM) will be executed to the
Lucene directories (through the directory providers) by the same node. This mode is typically used
in non clustered environment or in clustered environments where the directory store is shared.</p><div class="informalfigure"><div class="mediaobject"><img src="images/lucene-backend.png" alt="Lucene back end configuration"/></div></div><p>This mode targets non clustered applications, or clustered applications where the Directory is
taking care of the locking strategy.</p><p>The main advantage is simplicity and immediate visibility of the changes in Lucene queries (a
requirement in some applications).</p><p>An alternative back end viable for non-clustered and non-shared index configurations is the near-
real-time backend.</p></section><section class="section" id="search-architecture-jms"><div class="titlepage"><div><div><h3 class="title">2.2.2. JMS</h3></div></div></div><p>All index update operations applied on a given node are sent to a JMS queue. A unique reader will
then process the queue and update the master index. The master index is then replicated on a regular
basis to the slave copies. This is known as the master/slaves pattern. The master is the sole
responsible for updating the Lucene index. The slaves can accept read as well as write operations.
However, while they process the read operations on their local index copy, they will delegate the
update operations to the master.</p><div class="informalfigure"><div class="mediaobject"><img src="images/jms-backend.png" alt="JMS back end configuration"/></div></div><p>This mode targets clustered environments where throughput is critical, and index update delays are
affordable. Reliability is ensured by the JMS provider and by having the slaves working on a local
copy of the index.</p><p>The JMS integration can be transactional. With this backend (and currently only this backend) you
can have Hibernate Search send the indexing work into the queue within the same transaction
applying changes to the relational database. This options requires you to use an XA transaction.</p><p>By default this backend’s transactional capabilities are disabled: messages will be
enqueued as a post-transaction event, consistently with other backends.
To change this configuration see also <a class="xref" href="#configuration-worker" title="3.4. Worker configuration">Section 3.4, “Worker configuration”</a>.</p></section><section class="section" id="_jgroups"><div class="titlepage"><div><div><h3 class="title">2.2.3. JGroups</h3></div></div></div><p>The JGroups based back end works similar to the JMS one and is designed after the same master/slave
pattern. However, instead of JMS the JGroups toolkit is used as a replication mechanism. This back
end can be used as an alternative to JMS when response time is critical, but i.e. JNDI service is
not available.</p><p>Note that while JMS can usually be configured to use persistent queues, JGroups talks directly to
other nodes over network. Message delivery to other reachable nodes is guaranteed, but if no master
node is available, index operations are silently discarded. This backend can be configured to use
asynchronous messages, or to wait for each indexing operation to be completed on the remote node
before returning.</p><p>The JGroups backend can be configured with static master or slave roles, or can be setup to perform
an auto-election of the master. This mode is particularly useful to have the system automatically
pick a new master in case of failure, but during a reelection process some indexing operations might
be lost. For this reason this mode is not suited for use cases requiring strong consistency
guarantees. When configured to perform an automatic election, the master node is defined as an hash
on the index name: the role is therefore possibly different for each index or shard.</p></section></section><section class="section" id="search-architecture-readerstrategy"><div class="titlepage"><div><div><h2 class="title">2.3. Reader strategy</h2></div></div></div><p>When executing a query, Hibernate Search interacts with the Apache Lucene indexes through a reader
strategy. Choosing a reader strategy will depend on the profile of the application (frequent
updates, read mostly, asynchronous index update etc). See also <a class="xref" href="#configuration-reader-strategy" title="3.5. Reader strategy configuration">Section 3.5, “Reader strategy configuration”</a></p><section class="section" id="_shared"><div class="titlepage"><div><div><h3 class="title">2.3.1. shared</h3></div></div></div><p>With this strategy, Hibernate Search will share the same IndexReader, for a given Lucene index,
across multiple queries and threads provided that the IndexReader is still up-to-date. If the
IndexReader is not up-to-date, a new one is opened and provided. Each IndexReader is made of several
SegmentReaders. This strategy only reopens segments that have been modified or created after last
opening and shares the already loaded segments from the previous instance.
This approach is quite efficient and guarantees that each query is run on the most recent index snapshot; the drawback is that for every query the strategy will have to verify if the IndexReader is still fresh, and if not perform a refresh; such a refresh is typically a cheap operation but if you have a significant amount of writes and queries happening concurrently then one of the other strategies might be preferred.
This strategy is the default.</p><p>The name of this strategy is <code class="literal">shared</code>.</p></section><section class="section" id="_not_shared"><div class="titlepage"><div><div><h3 class="title">2.3.2. not-shared</h3></div></div></div><p>Every time a query is executed, a Lucene IndexReader is opened. This strategy is not efficient since opening and warming up an IndexReader can be a relatively expensive operation, but is very simple code.
Use it as an example implementation if you’re interested to learn about
Hibernate Search internals or want to extend it.</p><p>The name of this strategy is <code class="literal">not-shared</code>.</p></section><section class="section" id="_async"><div class="titlepage"><div><div><h3 class="title">2.3.3. async</h3></div></div></div><p>This implementation keeps an IndexReader open and ready to be used by all
queries, while a background thread periodically verifies if there is need
to open a fresh one, replaces the active one and disposes the outdated one.
The frequency of checks - and refreshing - of this background thread is configurable, but defaults to 5000 milliseconds.
The drawback of this design is that queries are effectively run on an
index snapshot which might be approximately 5 seconds out of date (assuming the refresh period is not reconfigured);
the benefit is that if your application writes frequently to the index,
the query performance will be more consistent.</p><p>The name of this strategy is <code class="literal">async</code>.</p></section><section class="section" id="_custom"><div class="titlepage"><div><div><h3 class="title">2.3.4. Custom</h3></div></div></div><p>You can write your own reader strategy that suits your application needs by implementing
org.hibernate.search.reader.ReaderProvider. The implementation must be thread safe.</p></section></section></section><section class="chapter" id="search-configuration"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Configuration</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#search-configuration-event">3.1. Enabling Hibernate Search and automatic indexing</a></span><ul><li><span class="section"><a href="#_enabling_hibernate_search">3.1.1. Enabling Hibernate Search</a></span></li><li><span class="section"><a href="#_automatic_indexing">3.1.2. Automatic indexing</a></span></li></ul></li><li><span class="section"><a href="#configuration-indexmanager">3.2. Configuring the IndexManager</a></span><ul><li><span class="section"><a href="#_directory_based">3.2.1. directory-based</a></span></li><li><span class="section"><a href="#_near_real_time">3.2.2. near-real-time</a></span></li><li><span class="section"><a href="#_custom_2">3.2.3. Custom</a></span></li></ul></li><li><span class="section"><a href="#search-configuration-directory">3.3. Directory configuration</a></span><ul><li><span class="section"><a href="#infinispan-directories">3.3.1. Infinispan Directory configuration</a></span></li></ul></li><li><span class="section"><a href="#configuration-worker">3.4. Worker configuration</a></span><ul><li><span class="section"><a href="#jms-backend">3.4.1. JMS Master/Slave back end</a></span></li><li><span class="section"><a href="#jgroups-backend">3.4.2. JGroups Master/Slave back end</a></span></li></ul></li><li><span class="section"><a href="#configuration-reader-strategy">3.5. Reader strategy configuration</a></span></li><li><span class="section"><a href="#_serialization">3.6. Serialization</a></span></li><li><span class="section"><a href="#exception-handling">3.7. Exception handling</a></span></li><li><span class="section"><a href="#_lucene_configuration">3.8. Lucene configuration</a></span><ul><li><span class="section"><a href="#lucene-indexing-performance">3.8.1. Tuning indexing performance</a></span></li><li><span class="section"><a href="#search-configuration-directory-lockfactories">3.8.2. LockFactory configuration</a></span></li><li><span class="section"><a href="#_index_format_compatibility">3.8.3. Index format compatibility</a></span></li></ul></li><li><span class="section"><a href="#_metadata_api">3.9. Metadata API</a></span></li><li><span class="section"><a href="#search-configuration-deploy-on-wildfly">3.10. Hibernate Search as a WildFly module</a></span><ul><li><span class="section"><a href="#using-wildfly-provided-hibernatesearch-versions">3.10.1. Use the Hibernate Search version included in WildFly</a></span></li><li><span class="section"><a href="#_update_and_activate_latest_hibernate_search_version_in_wildfly">3.10.2. Update and activate latest Hibernate Search version in WildFly</a></span></li><li><span class="section"><a href="#_more_about_modules">3.10.3. More about modules</a></span></li><li><span class="section"><a href="#_using_infinispan_with_hibernate_search_on_wildfly">3.10.4. Using Infinispan with Hibernate Search on WildFly</a></span></li></ul></li></ul></div><section class="section" id="search-configuration-event"><div class="titlepage"><div><div><h2 class="title">3.1. Enabling Hibernate Search and automatic indexing</h2></div></div></div><p>Let’s start with the most basic configuration question - how do I enable Hibernate Search?</p><section class="section" id="_enabling_hibernate_search"><div class="titlepage"><div><div><h3 class="title">3.1.1. Enabling Hibernate Search</h3></div></div></div><p>The good news is that Hibernate Search is enabled out of the box when detected on the classpath by
Hibernate ORM. If, for some reason you need to disable it, set
<code class="literal">hibernate.search.autoregister_listeners</code> to false. Note that there is no performance penalty
when the listeners are enabled but no entities are annotated as indexed.</p></section><section class="section" id="_automatic_indexing"><div class="titlepage"><div><div><h3 class="title">3.1.2. Automatic indexing</h3></div></div></div><p>By default, every time an object is inserted, updated or deleted through Hibernate, Hibernate Search
updates the according Lucene index. It is sometimes desirable to disable that features if either
your index is read-only or if index updates are done in a batch way (see <a class="xref" href="#search-batchindex" title="6.3. Rebuilding the whole index">Section 6.3, “Rebuilding the whole index”</a>).</p><p>To disable event based indexing, set</p><div class="informalexample"><pre class="screen">hibernate.search.indexing_strategy = manual</pre></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>In most case, the JMS backend provides the best of both world, a lightweight event based system
keeps track of all changes in the system, and the heavyweight indexing process is done by a separate
process or machine.</p></div></section></section><section class="section" id="configuration-indexmanager"><div class="titlepage"><div><div><h2 class="title">3.2. Configuring the IndexManager</h2></div></div></div><p>The role of the index manager component is described in <a class="xref" href="#search-architecture" title="Chapter 2. Architecture">Chapter 2, <em>Architecture</em></a>. Hibernate Search
provides two possible implementations for this interface to choose from.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">directory-based</code>: the default implementation which uses the Lucene Directory abstraction to
manage index files.</li><li class="listitem"><code class="literal">near-real-time</code>: avoid flushing writes to disk at each commit. This index manager is also
Directory based, but also makes uses of Lucene’s NRT functionality.</li></ul></div><p>To select an alternative you specify the property:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexmanager = near-real-time</pre></div><section class="section" id="_directory_based"><div class="titlepage"><div><div><h3 class="title">3.2.1. directory-based</h3></div></div></div><p>The default IndexManager implementation. This is the one mostly referred to in this documentation.
It is highly configurable and allows you to select different settings for the reader strategy, back
ends and directory providers. Refer to <a class="xref" href="#search-configuration-directory" title="3.3. Directory configuration">Section 3.3, “Directory configuration”</a>, <a class="xref" href="#configuration-worker" title="3.4. Worker configuration">Section 3.4, “Worker configuration”</a>
and <a class="xref" href="#configuration-reader-strategy" title="3.5. Reader strategy configuration">Section 3.5, “Reader strategy configuration”</a> for more details.</p></section><section class="section" id="_near_real_time"><div class="titlepage"><div><div><h3 class="title">3.2.2. near-real-time</h3></div></div></div><p>The NRTIndexManager is an extension of the default IndexManager, leveraging the Lucene NRT (Near
Real Time) features for extreme low latency index writes. As a trade-off it requires a non-clustered
and non-shared index. In other words, it will ignore configuration settings for alternative back
ends other than <code class="literal">lucene</code> and will acquire exclusive write locks on the Directory.</p><p>To achieve this low latency writes, the IndexWriter will not flush every change to disk. Queries
will be allowed to read updated state from the unflushed index writer buffers; the downside of this
strategy is that if the application crashes or the IndexWriter is otherwise killed you’ll have to
rebuild the indexes as some updates might be lost.</p><p>Because of these downsides, and because a master node in cluster can be configured for good
performance as well, the NRT configuration is only recommended for non clustered websites with a
limited amount of data.</p></section><section class="section" id="_custom_2"><div class="titlepage"><div><div><h3 class="title">3.2.3. Custom</h3></div></div></div><p>It is also possible to configure a custom IndexManager implementation by specifying the fully
qualified class name of your custom implementation. This implementation must have a no-argument
constructor:</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexmanager = my.corp.myapp.CustomIndexManager</pre><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Your custom index manager implementation doesn’t need to use the same components as the default
implementations. For example, you can delegate to a remote indexing service which doesn’t expose a
Directory interface.</p></div></section></section><section class="section" id="search-configuration-directory"><div class="titlepage"><div><div><h2 class="title">3.3. Directory configuration</h2></div></div></div><p>As we have seen in <a class="xref" href="#configuration-indexmanager" title="3.2. Configuring the IndexManager">Section 3.2, “Configuring the IndexManager”</a> the default index manager uses Lucene’s notion of
a Directory to store the index files. The Directory implementation can be customized and Lucene
comes bundled with a file system and an in-memory implementation. DirectoryProvider is the Hibernate
Search abstraction around a Lucene Directory and handles the configuration and the initialization of
the underlying Lucene resources. <a class="xref" href="#directory-provider-table" title="Table 3.1. List of built-in DirectoryProvider">Table 3.1, “List of built-in DirectoryProvider”</a> shows the list of the directory
providers available in Hibernate Search together with their corresponding options.</p><p>To configure your DirectoryProvider you have to understand that each indexed entity is associated to
a Lucene index (except of the case where multiple entities share the same index -
<a class="xref" href="#section-sharing-indexes" title="10.6. Sharing indexes">Section 10.6, “Sharing indexes”</a>). The name of the index is given by the index property of the @Indexed
annotation. If the index property is not specified the fully qualified name of the indexed class
will be used as name (recommended).</p><p>Knowing the index name, you can configure the directory provider and any additional options by using
the prefix <code class="literal">hibernate.search.&lt;indexname&gt;</code>. The name default (<code class="literal">hibernate.search.default</code>) is
reserved and can be used to define properties which apply to all indexes.
<a class="xref" href="#example-configuring-directory-providers" title="Example 3.2. Configuring directory providers">Example 3.2, “Configuring directory providers”</a> shows how <code class="literal">hibernate.search.default.directory_provider</code>
is used to set the default directory provider to be the filesystem one. <code class="literal">hibernate.search.default.indexBase</code>
sets then the default base directory for the indexes. As a result the index for the entity Status is
created in <code class="literal">/usr/lucene/indexes/org.hibernate.example.Status</code>.</p><p>The index for the Rule entity, however, is using an in-memory directory, because the default
directory provider for this entity is overridden by the property
<code class="literal">hibernate.search.Rules.directory_provider</code>.</p><p>Finally the Action entity uses a custom directory provider <code class="literal">CustomDirectoryProvider</code> specified via
<code class="literal">hibernate.search.Actions.directory_provider</code>.</p><div class="example" id="d0e920"><div class="example-title">Example 3.1. Specifying the index name</div><div class="example-contents"><pre><code class="language-java">package org.hibernate.example;

@Indexed
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }

@Indexed(index="Actions")
public class Action { ... }</code></pre></div></div><br class="example-break"/><div class="example" id="example-configuring-directory-providers"><div class="example-title">Example 3.2. Configuring directory providers</div><div class="example-contents"><pre class="screen">hibernate.search.default.directory_provider = filesystem
hibernate.search.default.indexBase = /usr/lucene/indexes
hibernate.search.Rules.directory_provider = ram
hibernate.search.Actions.directory_provider = com.acme.hibernate.CustomDirectoryProvider</pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Using the described configuration scheme you can easily define common rules like the directory
provider and base directory, and override those defaults later on on a per index basis.</p></div><div class="table" id="directory-provider-table"><div class="table-title">Table 3.1. List of built-in DirectoryProvider</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Name and description</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Properties</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>ram: Memory based directory.
</p><p>The directory will be uniquely identified (in the same deployment unit) by the <code class="literal">@Indexed.index</code> element</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>none</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>filesystem: File system based directory.
</p><p>The directory used will be &lt;indexBase&gt;/&lt;indexName&gt;</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">indexBase</code> : base directory
<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
<code class="literal">locking_strategy</code> : optional, see <a class="xref" href="#search-configuration-directory-lockfactories" title="3.8.2. LockFactory configuration">Section 3.8.2, “LockFactory configuration”</a>
<code class="literal">filesystem_access_type</code>: allows to determine the exact type of FSDirectory implementation used
by this DirectoryProvider. Allowed values are <code class="literal">auto</code> (the default value, selects NIOFSDirectory on
non Windows systems, SimpleFSDirectory on Windows), <code class="literal">simple</code> (SimpleFSDirectory),
<code class="literal">nio</code> (NIOFSDirectory), <code class="literal">mmap</code> (MMapDirectory). Make sure to refer to Javadocs of these Directory
implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory can bring
substantial performance boosts they also have their issues.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>filesystem-master: File system based directory.
</p><p>Like <code class="literal">filesystem</code>. It also copies the index to a source directory (aka copy directory) on a regular
basis.
</p><p>The recommended value for the refresh period is (at least) 50% higher that the time to copy the
information (default 3600 seconds - 60 minutes).
</p><p>Note that the copy is based on an incremental copy mechanism reducing the average copy time.
</p><p>DirectoryProvider typically used on the master node in a JMS back end cluster.
</p><p>The <code class="literal">buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most
people reported good results using values between 16 and 64MB.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">indexBase</code>: base directory
<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
<code class="literal">sourceBase</code>: source (copy) base directory.
<code class="literal">source</code>: source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name
being <span class="emphasis"><em>&lt;sourceBase&gt;/&lt;source&gt;</em></span>
<code class="literal">refresh</code>: refresh period in seconds (the copy will take place every refresh seconds). If a copy
is still in progress when the following refresh period elapses, the second copy operation will be
skipped.
<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction;
defaults to 16MB.
<code class="literal">locking_strategy</code> : optional, see <a class="xref" href="#search-configuration-directory-lockfactories" title="3.8.2. LockFactory configuration">Section 3.8.2, “LockFactory configuration”</a>
<code class="literal">filesystem_access_type</code>: allows to determine the exact type of FSDirectory implementation used by
this DirectoryProvider. Allowed values are <code class="literal">auto</code> (the default value, selects NIOFSDirectory on non
Windows systems, SimpleFSDirectory on Windows), <code class="literal">simple</code> (SimpleFSDirectory),
<code class="literal">nio</code> (NIOFSDirectory), <code class="literal">mmap</code> (MMapDirectory). Make sure to refer to Javadocs of these
Directory implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory
can bring substantial performance boosts they also have their issues.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>filesystem-slave: File system based directory.
</p><p>Like <code class="literal">filesystem</code>, but retrieves a master version
(source) on a regular basis. To avoid locking and inconsistent search results, 2 local copies are kept.
</p><p>The recommended value for the refresh period is (at least) 50% higher that the time to copy the
information (default 3600 seconds - 60 minutes).
</p><p>Note that the copy is based on an incremental copy mechanism reducing the average copy time.
If a copy is still in progress when refresh period elapses, the second copy operation will be skipped.
</p><p>DirectoryProvider typically used on slave nodes using a JMS back end.
</p><p>The <code class="literal">buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most
people reported good results using values between 16 and 64MB.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">indexBase</code>: Base directory
<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
<code class="literal">sourceBase</code>: Source (copy) base directory.
<code class="literal">source</code>: Source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory
name being <span class="emphasis"><em>&lt;sourceBase&gt;/&lt;source&gt;</em></span>
<code class="literal">refresh</code>: refresh period in second (the copy will take place every refresh seconds).
<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction;
defaults to 16MB.
<code class="literal">locking_strategy</code> : optional, see <a class="xref" href="#search-configuration-directory-lockfactories" title="3.8.2. LockFactory configuration">Section 3.8.2, “LockFactory configuration”</a>
<code class="literal">retry_marker_lookup</code> : optional, default to 0. Defines how many times we look for the marker files
in the source directory before failing. Waiting 5 seconds between each try.
<code class="literal">retry_initialize_period</code> : optional, set an integer value in seconds to enable the retry initialize
feature: if the slave can’t find the master index it will try again until it’s found in background,
without preventing the application to start: full-text queries performed before the index is
initialized are not blocked but will return empty results. When not enabling the option or
explicitly setting it to zero it will fail with an exception instead of scheduling a retry timer.
To prevent the application from starting without an invalid index but still control an
initialization timeout, see <code class="literal">retry_marker_lookup</code> instead.
<code class="literal">filesystem_access_type</code>: allows to determine the exact type of FSDirectory implementation
used by this DirectoryProvider. Allowed values are <code class="literal">auto</code> (the default value, selects NIOFSDirectory
on non Windows systems, SimpleFSDirectory on Windows), <code class="literal">simple</code> (SimpleFSDirectory), <code class="literal">nio</code>
(NIOFSDirectory), <code class="literal">mmap</code> (MMapDirectory). Make sure to refer to Javadocs of these Directory
implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory can bring
substantial performance boosts they also have their issues.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>infinispan: Infinispan based directory.
</p><p>Use it to store the index in a distributed grid, making
index changes visible to all elements of the cluster very quickly. Also see
<a class="xref" href="#infinispan-directories" title="3.3.1. Infinispan Directory configuration">Section 3.3.1, “Infinispan Directory configuration”</a> for additional requirements and configuration settings.
Infinispan needs a global configuration and additional dependencies; the
settings defined here apply to each different index.</p></td><td style="text-align: left; vertical-align: top; "><p><code class="literal">locking_cachename</code>: name of the Infinispan cache to use to store locks. `
<code class="literal">data_cachename</code> : name of the Infinispan cache to use to store the largest data chunks; this area
will contain the largest objects, use replication if you have enough memory or switch to
distribution.
<code class="literal">metadata_cachename</code>: name of the Infinispan cache to use to store the metadata relating to the
index; this data is rather small and read very often, it’s recommended to have this cache setup
using replication.
<code class="literal">chunk_size</code>: large files of the index are split in smaller chunks, you might want to set the
highest value efficiently handled by your network. Networking tuning might be useful.</p></td></tr></tbody></table></div></div><br class="table-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>If the built-in directory providers do not fit your needs, you can write your own directory provider
by implementing the org.hibernate.store.DirectoryProvider interface. In this case, pass the fully
qualified class name of your provider into the <code class="literal">directory_provider</code> property. You can pass any
additional properties using the prefix <code class="literal">hibernate.search.&lt;indexname&gt;</code>.</p></div><section class="section" id="infinispan-directories"><div class="titlepage"><div><div><h3 class="title">3.3.1. Infinispan Directory configuration</h3></div></div></div><p>Infinispan is a distributed, scalable, cloud friendly data grid platform, which
Hibernate Search can use to store the Lucene index. Your application can benefits in this case
from Infinispan’s distribution capabilities making index updates available on all nodes with short
latency.</p><p>This section describes how to configure Hibernate Search to use an Infinispan Lucene Directory.</p><p>When using an Infinispan Directory the index is stored in memory and shared across multiple nodes.
It is considered a single directory distributed across all participating nodes: if a node updates
the index, all other nodes are updated as well. Updates on one node can be immediately searched
for in the whole cluster.</p><p>The default configuration replicates all data which defines the index across all nodes, thus
consuming a significant amount of memory but providing the best query performance.
For large indexes it’s suggested to enable data distribution, so that each piece of information is
replicated to a subset of all cluster members. The distribution option will reduce the amount of memory
required for each node but is less efficient as it will cause high network usage among the nodes.</p><p>It is also possible to offload part or most information to a <code class="literal">CacheStore</code>, such as plain filesystem,
Amazon S3, Cassandra, MongoDB or standard relational databases. You can configure it to have a
<code class="literal">CacheStore</code> on each node or have a single centralized one shared by each node.</p><p>A popular choice is to use a replicated index aiming to keep the whole index in memory, combined with
a <code class="literal">CacheStore</code> as safety valve in case the index gets larger than expected.</p><p>See the <a class="link" href="http://infinispan.org/documentation/">Infinispan documentation</a> for all Infinispan
configuration options.</p><section class="section" id="_requirements"><div class="titlepage"><div><div><h4 class="title">3.3.1.1. Requirements</h4></div></div></div><p>To use the Infinispan directory via Maven, add the following dependencies:</p><div class="example" id="d0e1198"><div class="example-title">Example 3.3. Maven dependencies for Hibernate Search using Infinispan</div><div class="example-contents"><pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
   &lt;version&gt;5.6.6.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
   &lt;artifactId&gt;infinispan-directory-provider&lt;/artifactId&gt;
   &lt;version&gt;8.2.4.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>This dependency changed in Hibernate Search version 5.2.</p><p>Previously the DirectoryProvider was provided by the Hibernate Search project and had Maven coordinates
'org.hibernate:hibernate-search-infinispan', but the Infinispan team is now maintaining this extension point
so since this version please use the Maven definition as in the previous example.</p><p>The version printed above was the latest compatible at the time of publishing this Hibernate Search version:
it’s possible that more recently improved versions of Infinispan have been published which
are compatible with this same Hibernate Search version.</p></div></section><section class="section" id="_architecture"><div class="titlepage"><div><div><h4 class="title">3.3.1.2. Architecture</h4></div></div></div><p>Even when using an Infinispan directory it’s still recommended to use the JMS Master/Slave or
JGroups backend, because in Infinispan all nodes will share the same index and it is likely that
<code class="literal">IndexWriter</code> instances being active on different nodes will try to acquire the lock on the same
index. So instead of sending updates directly to the index, send it to a JMS queue or JGroups
channel and have a single node apply all changes on behalf of all other nodes.</p><p>Configuring a non-default backend is not a requirement but a performance optimization as locks are
enabled to have a single node writing.</p><p>To configure a JMS slave only the backend must be replaced, the directory provider must be set to
<code class="literal">infinispan</code>; set the same directory provider on the master, they will connect without the need to
setup the copy job across nodes. Using the JGroups backend is very similar - just combine the
backend configuration with the <code class="literal">infinispan</code> directory provider.</p></section><section class="section" id="_infinispan_configuration"><div class="titlepage"><div><div><h4 class="title">3.3.1.3. Infinispan Configuration</h4></div></div></div><p>The most simple configuration only requires to enable the backend:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].directory_provider = infinispan</pre></div><p>That’s all what is needed to get a cluster-replicated index, but the default configuration does not
enable any form of permanent persistence for the index; to enable such a feature an Infinispan
configuration file should be provided.</p><p>To use Infinispan, Hibernate Search requires a CacheManager; it can lookup and reuse an existing
CacheManager, via JNDI, or start and manage a new one. In the latter case Hibernate Search will
start and stop it ( closing occurs when the Hibernate SessionFactory is closed).</p><p>To use and existing CacheManager via JNDI (optional parameter):</p><div class="informalexample"><pre class="screen">hibernate.search.infinispan.cachemanager_jndiname = [jndiname]</pre></div><p>To start a new CacheManager from a configuration file (optional parameter):</p><div class="informalexample"><pre class="screen">hibernate.search.infinispan.configuration_resourcename = [infinispan configuration filename]</pre></div><p>If both parameters are defined, JNDI will have priority. If none of these is defined, Hibernate
Search will use the default Infinispan configuration included in <code class="literal">infinispan-directory-provider.jar</code>.
This configuration should work fine in most cases but does not store the index in a persistent cache
store.</p><p>As mentioned in <a class="xref" href="#directory-provider-table" title="Table 3.1. List of built-in DirectoryProvider">Table 3.1, “List of built-in DirectoryProvider”</a>, each index makes use of three caches, so three
different caches should be configured as shown in the <code class="literal">default-hibernatesearch-infinispan.xml</code>
provided in the <code class="literal">infinispan-directory-provider.jar</code>. Several indexes can share the same caches.</p><p>Infinispan relies on JGroups for its networking functionality, so unless you are using Infinispan on
a single node, an Infinispan configuration file will refer to a JGroups configuration file. This
coupling is not always practical and we provide a property to override the used JGroups
configuration file:</p><div class="informalexample"><pre class="screen">hibernate.search.infinispan.configuration.transport_override_resourcename = jgroups-ec2.xml</pre></div><p>This allows to just switch the JGroups configuration while keeping the rest of the Infinispan
configuration.</p><p>The file <code class="literal">jgroups-ec2.xml</code> used in the example above is one of the several JGroups configurations
included in Infinispan. It is a good starting point to run on Amazon EC2 networks. For more details
and examples see <a class="link" href="http://infinispan.org/docs/8.0.x/user_guide/user_guide.html#_use_one_of_the_pre_configured_jgroups_files">usage of pre-configured JGroups stacks</a>
in the Infinispan configuration guide.</p></section></section></section><section class="section" id="configuration-worker"><div class="titlepage"><div><div><h2 class="title">3.4. Worker configuration</h2></div></div></div><p>It is possible to refine how Hibernate Search interacts with Lucene through the worker
configuration. There exist several architectural components and possible extension points. Let’s
have a closer look.</p><p>First there is a Worker. An implementation of the Worker interface is responsible for receiving all
entity changes, queuing them by context and applying them once a context ends. The most intuitive
context, especially in connection with ORM, is the transaction. For this reason Hibernate Search
will per default use the TransactionalWorker to scope all changes per transaction. One can, however,
imagine a scenario where the context depends for example on the number of entity changes or some
other application (lifecycle) events. For this reason the Worker implementation is configurable as
shown in <a class="xref" href="#table-worker-configuration" title="Table 3.2. Scope configuration">Table 3.2, “Scope configuration”</a>.</p><div class="table" id="table-worker-configuration"><div class="table-title">Table 3.2. Scope configuration</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><span class="strong"><strong>Property</strong></span></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.worker.scope</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>The fully qualified class name of the
            Worker implementation to use. If this
            property is not set, empty or <code class="literal">transaction</code> the
            default TransactionalWorker is
            used.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.default.worker.*</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>All configuration properties prefixed with
            <code class="literal">hibernate.search.default.worker</code> are passed to the
            Worker during initialization. This allows adding custom, worker
            specific parameters.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>hibernate.search.worker.enlist_in_transaction</p></td><td style="text-align: left; vertical-align: top; "><p>Defaults to <code class="literal">false</code>. Set it to <code class="literal">true</code>
            to have all indexing work sent to the queue within the same transaction
            as the Hibernate ORM Session. This options should only be enabled when all
            backends use JMS and the queues are configured to be transactional, XA enabled.</p></td></tr></tbody></table></div></div><br class="table-break"/><p>Once a context ends it is time to prepare and apply the index changes. This can be done
synchronously or asynchronously from within a new thread. Synchronous updates have the advantage
that the index is at all times in sync with the databases. Asynchronous updates, on the other hand,
can help to minimize the user response time. The drawback is potential discrepancies between
database and index states. Lets look at the configuration options shown in
<a class="xref" href="#table-work-execution-configuration" title="Table 3.3. Execution configuration">Table 3.3, “Execution configuration”</a>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The following options can be different on each index; in fact they need the indexName prefix or use
<code class="literal">default</code> to set the default value for all indexes.</p></div><div class="table" id="table-work-execution-configuration"><div class="table-title">Table 3.3. Execution configuration</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><span class="strong"><strong>Property</strong></span></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.worker.execution</p></td><td style="text-align: left; vertical-align: top; "><p><code class="literal">sync</code>: synchronous execution (default)
</p><p><code class="literal">async</code>: asynchronous execution</p></td></tr></tbody></table></div></div><br class="table-break"/><p>So far all work is done within the same Virtual Machine (VM), no matter which execution mode. The
total amount of work has not changed for the single VM. Luckily there is a better approach, namely
delegation. It is possible to send the indexing work to a different server by configuring
hibernate.search.default.worker.backend - see <a class="xref" href="#table-backend-configuration" title="Table 3.4. Backend configuration">Table 3.4, “Backend configuration”</a>. Again this option can be
configured differently for each index.</p><div class="table" id="table-backend-configuration"><div class="table-title">Table 3.4. Backend configuration</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><span class="strong"><strong>Property</strong></span></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.worker.backend</p></td><td style="text-align: left; vertical-align: top; "><p><code class="literal">local</code>: The default backend which runs index updates in the same JVM. Also used when the property is undefined or empty.
</p><p><code class="literal">jms</code>: JMS backend. Index updates are send to a JMS queue to be processed by an indexing master. See <a class="xref" href="#table-jms-backend-configuration" title="Table 3.5. JMS backend configuration">Table 3.5, “JMS backend configuration”</a> for additional configuration options and <a class="xref" href="#jms-backend" title="3.4.1. JMS Master/Slave back end">Section 3.4.1, “JMS Master/Slave back end”</a> for a more detailed description of this setup.
</p><p><code class="literal">jgroupsMaster</code>, <code class="literal">jgroupsSlave</code> or <code class="literal">jgroups</code>: Backend using <a class="link" href="http://www.jgroups.org/">JGroups</a> as communication layer. See <a class="xref" href="#jgroups-backend" title="3.4.2. JGroups Master/Slave back end">Section 3.4.2, “JGroups Master/Slave back end”</a> for a more detailed description of this setup.
</p><p><code class="literal">blackhole</code>: Mainly a test/developer setting which ignores all indexing work
</p><p>You can also specify the fully qualified name of a class implementing BackendQueueProcessor. This way you can implement your own communication layer. The implementation is responsible for returning a Runnable instance which on execution will process the index work.</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="table" id="table-jms-backend-configuration"><div class="table-title">Table 3.5. JMS backend configuration</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><span class="strong"><strong>Property</strong></span></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.worker.jndi.*</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Defines the JNDI properties to initiate the InitialContext
            (if needed). JNDI is only used by the JMS back end.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.worker.jms.connection_factory</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS connection factory from
            (<code class="literal">/ConnectionFactory</code> by default in JBoss
            AS)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.worker.jms.queue</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS queue from. The queue will be used to post work
            messages.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.worker.jms.login</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Optional for the JMS slaves. Use it when your queue
            requires login credentials to define your login.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.worker.jms.login</p></td><td style="text-align: left; vertical-align: top; "><p>Optional for the JMS slaves. Use it when your queue
            requires login credentials to define your password.</p></td></tr></tbody></table></div></div><br class="table-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>As you probably noticed, some of the shown properties are correlated which means that not all
combinations of property values make sense. In fact you can end up with a non-functional
configuration. This is especially true for the case that you provide your own implementations of
some of the shown interfaces. Make sure to study the existing code before you write your own Worker
or BackendQueueProcessor implementation.</p></div><section class="section" id="jms-backend"><div class="titlepage"><div><div><h3 class="title">3.4.1. JMS Master/Slave back end</h3></div></div></div><p>This section describes in greater detail how to configure the Master/Slave Hibernate Search
architecture.</p><p>JMS back end configuration.</p><section class="section" id="_slave_nodes"><div class="titlepage"><div><div><h4 class="title">3.4.1.1. Slave nodes</h4></div></div></div><p>Every index update operation is sent to a JMS queue. Index querying operations are executed on a
local index copy.</p><div class="example" id="d0e1504"><div class="example-title">Example 3.4. JMS Slave configuration</div><div class="example-contents"><pre class="screen">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-slave

## Backend configuration
hibernate.search.default.worker.backend = jms
hibernate.search.default.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.default.worker.jms.queue = queue/hibernatesearch
#optionally authentication credentials:
hibernate.search.default.worker.jms.login = myname
hibernate.search.default.worker.jms.password = wonttellyou
#optional jndi configuration (check your JMS provider for more information)

## Enqueue indexing tasks within an XA transaction with the database (optional)
hibernate.search.worker.enlist_in_transaction = true</pre></div></div><br class="example-break"/><p>The <code class="literal">enlist_in_transaction</code> option can be enabled if you need strict guarantees of
indexing work to be stored in the queue within the same transaction of the database
changes, however this will require both the RDBMs datasource and the JMS queue to be XA enabled.</p><p>Make sure to use a XA JMS queue
and that your database supports XA as we are talking about coordinated transactional systems.</p><p>The default for <code class="literal">enlist_in_transaction</code> is <code class="literal">false</code> as often it is desirable to not have
the database transaction fail in case there are issues with indexing.</p><p>It is possible to apply compensating operations to the index by implementing a custom
<code class="literal">ErrorHandler</code> (see <a class="xref" href="#exception-handling" title="3.7. Exception handling">Section 3.7, “Exception handling”</a>), or simply re-synchronize the whole index
state by starting the MassIndexer (see <a class="xref" href="#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>A file system local copy is recommended for faster search results.</p></div></section><section class="section" id="_master_node"><div class="titlepage"><div><div><h4 class="title">3.4.1.2. Master node</h4></div></div></div><p>Every index update operation is taken from a JMS queue and executed. The master index is copied on a
regular basis.</p><div class="example" id="d0e1541"><div class="example-title">Example 3.5. JMS Master configuration</div><div class="example-contents"><pre class="screen">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-master

## Backend configuration
#The backend is not set: use the default one which is 'local'</pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>It is recommended that the refresh period be higher than the expected copy time; if a copy operation
is still being performed when the next refresh triggers, the second refresh is skipped: it’s safe to
set this value low even when the copy time is not known.</p></div><p>In addition to the Hibernate Search framework configuration, a Message Driven Bean has to be written
and set up to process the index works queue through JMS.</p><div class="example" id="d0e1551"><div class="example-title">Example 3.6. Message Driven Bean processing the indexing queue</div><div class="example-contents"><pre><code class="language-java">@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType",
                                propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination",
                                propertyValue="queue/hibernatesearch")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController
                                 implements MessageListener {

    @PersistenceContext EntityManager em;

    @Override
    protected SearchIntegrator getSearchIntegrator() {
        FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(em);
        return fullTextEntityManager.getSearchFactory().unwrap(SearchIntegrator.class);
    }
}</code></pre></div></div><br class="example-break"/><p>This example inherits from the abstract JMS controller class available in the Hibernate Search
source code and implements a JavaEE MDB. This implementation is given as an example and can be
adjusted to make use of non Java EE Message Driven Beans.
Essentially what you need to do is to connect the specific JMS Queue with the <code class="literal">SearchFactory</code>
instance of the EntityManager.
As an advanced alternative, you can implement your own logic by not extending <code class="literal">AbstractJMSHibernateSearchController</code>
but rather to use it as an implementation example.</p></section></section><section class="section" id="jgroups-backend"><div class="titlepage"><div><div><h3 class="title">3.4.2. JGroups Master/Slave back end</h3></div></div></div><p>This section describes how to configure the JGroups Master/Slave back end. The master and slave
roles are similar to what is illustrated in <a class="xref" href="#jms-backend" title="3.4.1. JMS Master/Slave back end">Section 3.4.1, “JMS Master/Slave back end”</a>, only a different backend
(hibernate.search.default.worker.backend) needs to be set.</p><p>A specific backend can be configured to act either as a slave using <code class="literal">jgroupsSlave</code>, as a master
using <code class="literal">jgroupsMaster</code>, or can automatically switch between the roles as needed by using <code class="literal">jgroups</code>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Either you specify a single <code class="literal">jgroupsMaster</code> and a set of <code class="literal">jgroupsSlave</code> instances, or you specify
all instances as <code class="literal">jgroups</code>. Never mix the two approaches!</p></div><p>All backends configured to use JGroups share the same channel. The JGroups JChannel is the main
communication link across all nodes participating in the same cluster group; since it is convenient
to have just one channel shared across all backends, the Channel configuration properties are not
defined on a per-worker section but are defined globally. See <a class="xref" href="#jgroups-channel-configuration" title="3.4.2.4. JGroups channel configuration">Section 3.4.2.4, “JGroups channel configuration”</a>.</p><p>Table <a class="xref" href="#table-jgroups-backend-configuration" title="Table 3.6. JGroups backend configuration properties">Table 3.6, “JGroups backend configuration properties”</a> contains all configuration options which can be set
independently on each index backend. These apply to all three variants of the backend:
<code class="literal">jgroupsSlave</code>, <code class="literal">jgroupsMaster</code>, <code class="literal">jgroups</code>. It is very unlikely that you need to change any of these
from their defaults.</p><div class="table" id="table-jgroups-backend-configuration"><div class="table-title">Table 3.6. JGroups backend configuration properties</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><span class="strong"><strong>Property</strong></span></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.jgroups.block_waiting_ack</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Set to either <code class="literal">true</code> or
              <code class="literal">false</code>. False is more efficient but will not
              wait for the operation to be delivered to the peers. Defaults to
              <code class="literal">true</code> when the backend is synchronous, to
              <code class="literal">false</code> when the backend is
              <code class="literal">async</code>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.jgroups.messages_timeout</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>The timeout of waiting for a single command to be
              acknowledged and executed when
              <code class="literal">block_waiting_ack</code> is <code class="literal">true</code>,
              or just acknowledged otherwise. Value in milliseconds, defaults
              to <code class="literal">20000</code>.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>hibernate.search.&lt;indexName&gt;.jgroups.delegate_backend</p></td><td style="text-align: left; vertical-align: top; "><p>The master node receiving indexing operations forwards
              them to a standard backend to be performed. Defaults to
              <code class="literal">lucene</code>. See also <a class="xref" href="#table-backend-configuration" title="Table 3.4. Backend configuration">Table 3.4, “Backend configuration”</a> for other options, but
              probably the only useful option is <code class="literal">blackhole</code>,
              or a custom implementation, to help isolating network latency
              problems.</p></td></tr></tbody></table></div></div><br class="table-break"/><section class="section" id="_slave_nodes_2"><div class="titlepage"><div><div><h4 class="title">3.4.2.1. Slave nodes</h4></div></div></div><p>Every index update operation is sent through a JGroups channel to the master node. Index querying
operations are executed on a local index copy. Enabling the JGroups worker only makes sure the index
operations are sent to the master, you still have to synchronize configuring an appropriate
directory (See <code class="literal">filesystem-master</code>, <code class="literal">filesystem-slave</code> or <code class="literal">infinispan</code> options in <a class="xref" href="#search-configuration-directory" title="3.3. Directory configuration">Section 3.3, “Directory configuration”</a>).</p><div class="example" id="d0e1696"><div class="example-title">Example 3.7. JGroups Slave configuration</div><div class="example-contents"><pre class="screen">### slave configuration
hibernate.search.default.worker.backend = jgroupsSlave</pre></div></div><br class="example-break"/></section><section class="section" id="_master_node_2"><div class="titlepage"><div><div><h4 class="title">3.4.2.2. Master node</h4></div></div></div><p>Every index update operation is taken from a JGroups channel and executed. The master index is
copied on a regular basis.</p><div class="example" id="d0e1706"><div class="example-title">Example 3.8. JGroups Master configuration</div><div class="example-contents"><pre class="screen">### master configuration
hibernate.search.default.worker.backend = jgroupsMaster</pre></div></div><br class="example-break"/></section><section class="section" id="_automatic_master_election"><div class="titlepage"><div><div><h4 class="title">3.4.2.3. Automatic master election</h4></div></div></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>This feature is considered experimental. In particular during a re-election process there is a small
window of time in which indexing requests could be lost.</p></div><p>In this mode the different nodes will autonomously elect a master node. When a master fails, a new
node is elected automatically.</p><p>When setting this backend it is expected that all Hibernate Search instances in the same cluster use
the same backend for each specific index: this configuration is an alternative to the static
<code class="literal">jgroupsMaster</code> and <code class="literal">jgroupsSlave</code> approach so make sure to not mix them.</p><p>To synchronize the indexes in this configuration avoid <code class="literal">filesystem-master</code> and <code class="literal">filesystem-slave</code>
directory providers as their behaviour can not be switched dynamically; use the Infinispan
<code class="literal">Directory</code> instead, which has no need for different configurations on each instance and allows
dynamic switching of writers; see also <a class="xref" href="#infinispan-directories" title="3.3.1. Infinispan Directory configuration">Section 3.3.1, “Infinispan Directory configuration”</a>.</p><div class="example" id="d0e1740"><div class="example-title">Example 3.9. JGroups configuration for automatic master configuration</div><div class="example-contents"><pre class="screen">### automatic configuration
hibernate.search.default.worker.backend = jgroups</pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Should you use <code class="literal">jgroups</code> or the couple <code class="literal">jgroupsMaster</code>, <code class="literal">jgroupsSlave</code>?</p><p>The dynamic <code class="literal">jgroups</code> backend is better suited for environments in which your master is more likely
to need to failover to a different machine, as in clouds. The static configuration has the benefit
of keeping the master at a well known location: your architecture might take advantage of it by
sending most write requests to the known master. Also optimisation and MassIndexer operations need
to be triggered on the master node.</p></div></section><section class="section" id="jgroups-channel-configuration"><div class="titlepage"><div><div><h4 class="title">3.4.2.4. JGroups channel configuration</h4></div></div></div><p>Configuring the JGroups channel essentially entails specifying the transport in terms of a network
protocol stack. To configure the JGroups transport, point the configuration property
hibernate.search.services.jgroups.configurationFile to a JGroups configuration file; this can be
either a file path or a Java resource name.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>If no property is explicitly specified it is assumed that the JGroups default configuration file
<code class="literal">flush-udp.xml</code> is used. This example configuration is known to work in most scenarios, with the
notable exception of Amazon AWS; refer to the
<a class="link" href="http://www.jgroups.org/manual-3.x/html/">JGroups manual</a> for more examples and protocol
configuration details.</p></div><p>The default cluster name is <code class="literal">Hibernate Search Cluster</code> which can be configured as seen in <a class="xref" href="#example-jgroups-cluster-name" title="Example 3.10. JGroups cluster name configuration">Example 3.10, “JGroups cluster name configuration”</a>.</p><div class="example" id="example-jgroups-cluster-name"><div class="example-title">Example 3.10. JGroups cluster name configuration</div><div class="example-contents"><pre class="screen">hibernate.search.services.jgroups.clusterName = My-Custom-Cluster-Id</pre></div></div><br class="example-break"/><p>The cluster name is what identifies a group: by changing the name you can run different clusters in
the same network in isolation.</p><section class="section" id="_jgroups_channel_instance_injection"><div class="titlepage"><div><div><h5 class="title">3.4.2.4.1. JGroups channel instance injection</h5></div></div></div><p>For programmatic configurations, one additional option is available to configure the JGroups
channel: to pass an existing channel instance to Hibernate Search directly using the property
<code class="literal">hibernate.search.services.jgroups.providedChannel</code>, as shown in the following example.</p><div class="informalexample"><pre><code class="language-java">import org.hibernate.search.backend.impl.jgroups.JGroupsChannelProvider;

org.jgroups.JChannel channel = ...
Map&lt;String,String&gt; properties = new HashMap&lt;String,String)(1);
properties.put( JGroupsChannelProvider.CHANNEL_INJECT, channel );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", properties );</code></pre></div></section></section></section></section><section class="section" id="configuration-reader-strategy"><div class="titlepage"><div><div><h2 class="title">3.5. Reader strategy configuration</h2></div></div></div><p>The different reader strategies are described in <a class="xref" href="#search-architecture-readerstrategy" title="2.3. Reader strategy">Section 2.3, “Reader strategy”</a>. Out of the
box strategies are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">shared</code>: share index readers across several queries. This strategy is very efficient.</li><li class="listitem"><code class="literal">not-shared</code>: create an index reader for each individual query. Very simple implementation.</li><li class="listitem"><code class="literal">async</code>: only opens a new index reader periodically. This is the most efficient implementation, but queries might return out of date values.</li></ul></div><p>The default reader strategy is <code class="literal">shared</code>.</p><p>You can pick the reader strategy by changing the <code class="literal">.reader.strategy</code> configuration property,
scoped to the "default" index or to a specific index.</p><p>For example:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].reader.strategy = async
hibernate.search.[default|&lt;indexname&gt;].reader.async_refresh_period_ms = 8000</pre></div><p>Adding the above properties switches to the <code class="literal">async</code> strategy, and configures it to refresh
the index reader each 8 seconds.</p><p>Alternatively you can use a custom implementation of a <code class="literal">org.hibernate.search.indexes.spi.ReaderProvider</code>:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].reader.strategy = my.corp.myapp.CustomReaderProvider</pre></div><p>where my.corp.myapp.CustomReaderProvider is the custom strategy implementation.</p></section><section class="section" id="_serialization"><div class="titlepage"><div><div><h2 class="title">3.6. Serialization</h2></div></div></div><p>When using clustering features, Hibernate Search needs to find an implementation of the
<code class="literal">SerializationProvider</code> service on the classpath.</p><p>An implementation of the service based on <a class="link" href="https://avro.apache.org">Apache Avro</a> can be found
using the following GAV coordinates:</p><p><code class="literal">org.hibernate:hibernate-search-serialization-avro:5.6.6.Final</code></p><p>You can add the coordinates to your pom file or download all the required dependecies and add them
to your classpath. Hibernate Search will find the service implementation without any additional
configuration.</p><p>Alternatively, you can create a custom service implementation:</p><div class="example" id="example-serialization-provider"><div class="example-title">Example 3.11. Serialization strategy definition</div><div class="example-contents"><pre><code class="language-java">package example.provider.serializer

import org.hibernate.search.indexes.serialization.spi.Deserializer;
import org.hibernate.search.indexes.serialization.spi.SerializationProvider;
import org.hibernate.search.indexes.serialization.spi.Serializer;

public class ExampleOfSerializationProvider implements SerializationProvider {

   @Override
    public Serializer getSerializer() {
        Serializer serializer = ...
        return serializer;
    }

    @Override
    public Deserializer getDeserializer() {
        Deserializer deserializer = ...
        return deserializer;
    }
}</code></pre></div></div><br class="example-break"/><p>Hibernate Search uses the Java ServiceLoader mechanism to transparently discover services.
In this case you will add the following file in your classpath:</p><div class="example" id="d0e1881"><div class="example-title">Example 3.12. Service file for the SerializationProvider service</div><div class="example-contents"><pre class="screen">/META-INF/services/org.hibernate.search.indexes.serialization.spi.SerializationProvider</pre></div></div><br class="example-break"/><div class="example" id="d0e1886"><div class="example-title">Example 3.13. Content of /META-INF/services/org.hibernate.search.indexes.serialization.spi.SerializationProvider</div><div class="example-contents"><pre class="screen">example.provider.serializer.ExampleOfSerializationProvider</pre></div></div><br class="example-break"/><p>You will find more details about services in the section <a class="xref" href="#section-services" title="10.7. Using external services">Section 10.7, “Using external services”</a>.</p></section><section class="section" id="exception-handling"><div class="titlepage"><div><div><h2 class="title">3.7. Exception handling</h2></div></div></div><p>Hibernate Search allows you to configure how exceptions are handled during the indexing process. If
no configuration is provided then exceptions are logged to the log output by default. It is possible
to explicitly declare the exception logging mechanism as seen below:</p><div class="informalexample"><pre class="screen">hibernate.search.error_handler = log</pre></div><p>The default exception handling occurs for both synchronous and asynchronous indexing. Hibernate
Search provides an easy mechanism to override the default error handling implementation.</p><p>In order to provide your own implementation you must implement the ErrorHandler interface, which
provides the handle(ErrorContext context) method. ErrorContext provides a reference to the primary
LuceneWork instance, the underlying exception and any subsequent LuceneWork instances that could not
be processed due to the primary exception.</p><div class="informalexample"><pre><code class="language-java">public interface ErrorContext {
   List&lt;LuceneWork&gt; getFailingOperations();
   LuceneWork getOperationAtFault();
   Throwable getThrowable();
   boolean hasErrors();
}</code></pre></div><p>To register this error handler with Hibernate Search you must declare the fully qualified classname
of your ErrorHandler implementation in the configuration properties:</p><div class="informalexample"><pre class="screen">hibernate.search.error_handler = CustomerErrorHandler</pre></div><p>Alternatively, an ErrorHandler instance may be passed via the configuration value map used when bootstrapping Hibernate Search programmatically.</p></section><section class="section" id="_lucene_configuration"><div class="titlepage"><div><div><h2 class="title">3.8. Lucene configuration</h2></div></div></div><p>Even though Hibernate Search will try to shield you as much as possible from Lucene specifics, there
are several Lucene specifics which can be directly configured, either for performance reasons or for
satisfying a specific use case. The following sections discuss these configuration options.</p><section class="section" id="lucene-indexing-performance"><div class="titlepage"><div><div><h3 class="title">3.8.1. Tuning indexing performance</h3></div></div></div><p>Hibernate Search allows you to tune the Lucene indexing performance by specifying a set of
parameters which are passed through to underlying Lucene <code class="literal">IndexWriter</code> such as <code class="literal">mergeFactor</code>,
<code class="literal">maxMergeDocs</code> and <code class="literal">maxBufferedDocs</code>. You can specify these parameters either as default values
applying for all indexes, on a per index basis, or even per shard.</p><p>There are several low level <code class="literal">IndexWriter</code> settings which can be tuned for different use cases.
These parameters are grouped by the <code class="literal">indexwriter</code> keyword:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexwriter.&lt;parameter_name&gt;</pre></div><p>If no value is set for an <code class="literal">indexwriter</code> value in a specific shard configuration, Hibernate Search
will look at the index section, then at the default section.</p><div class="example" id="example-performance-option-configuration"><div class="example-title">Example 3.14. Example performance option configuration</div><div class="example-contents"><pre class="screen">hibernate.search.Animals.2.indexwriter.max_merge_docs = 10
hibernate.search.Animals.2.indexwriter.merge_factor = 20
hibernate.search.Animals.2.indexwriter.max_buffered_docs = default
hibernate.search.default.indexwriter.max_merge_docs = 100
hibernate.search.default.indexwriter.ram_buffer_size = 64</pre></div></div><br class="example-break"/><p>The configuration in <a class="xref" href="#example-performance-option-configuration" title="Example 3.14. Example performance option configuration">Example 3.14, “Example performance option configuration”</a> will result in these settings
applied on the second shard of the Animal index:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">max_merge_docs</code> = 10</li><li class="listitem"><code class="literal">merge_factor</code> = 20</li><li class="listitem"><code class="literal">ram_buffer_size</code> = 64MB</li><li class="listitem"><code class="literal">max_buffered_docs</code> = Lucene default</li></ul></div><p>All other values will use the defaults defined in Lucene.</p><p>The default for all values is to leave them at Lucene’s own default. The values listed in
<a class="xref" href="#table-performance-parameters" title="Table 3.7. List of indexing performance and behavior properties">Table 3.7, “List of indexing performance and behavior properties”</a> depend for this reason on the version of Lucene you are using.
The values shown are relative to version <code class="literal">2.4</code>. For more information about Lucene indexing performance,
please refer to the Lucene documentation.</p><div class="table" id="table-performance-parameters"><div class="table-title">Table 3.7. List of indexing performance and behavior properties</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 40*; " class="col_1"/><col style="width: 40*; " class="col_2"/><col style="width: 20*; " class="col_3"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Property</th><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Description</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Default Value</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Set to <code class="literal">true</code> when no other process will need to write to the same index. This will enable
Hibernate Search to work in exclusive mode on the index and improve performance when writing changes
to the index.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">true</code> (improved performance, releases locks only at shutdown)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].max_queue_length</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Each index has a separate "pipeline" which contains the updates to be applied to the index.
When this queue is full adding more operations to the queue becomes a blocking operation. Configuring
this setting doesn’t make much sense unless the <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">1000</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].index_flush_interval</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>The interval in milliseconds between flushes
of write operations to the index storage. Ignored unless <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">1000</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_delete_terms</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Determines the minimal number of delete terms required before the buffered in-memory delete terms
are applied and flushed. If there are documents buffered in memory at the time, they are merged and
a new segment is created.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Disabled (flushes by RAM usage)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is
consumed.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Disabled (flushes by RAM usage)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Defines the largest number of documents allowed in a segment. Smaller values perform better on
frequently changing indexes, larger values provide better search performance if the index does not
change often.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Unlimited (Integer.MAX_VALUE)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Controls segment merge frequency and size. Determines how often segment indexes are merged when
insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized
indexes are faster, but indexing speed is slower. With larger values, more RAM is used during
indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger
values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are
interactively maintained. The value must not be lower than 2.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>10</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Controls segment merge frequency and size. Segments smaller than this size (in MB) are always
considered for the next segment merge operation.
Setting this too large might result in expensive merge operations, even tough they are less frequent.
See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.minMergeSize</code>.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>0 MB (actually ~1K)</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_size</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Controls segment merge frequency and size. Segments larger than this size (in MB) are never merged
in bigger segments. This helps reduce memory requirements and avoids some merging operations at the
cost of optimal search speed. When optimizing an index this value is ignored.
See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSize</code>.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Unlimited</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Controls segment merge frequency and size. Segments larger than this size (in MB) are not merged
in bigger segments even when optimizing the index (see <code class="literal">merge_max_size</code> setting as well).
Applied to <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSizeForOptimize</code>.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Unlimited</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Controls segment merge frequency and size. Set to <code class="literal">false</code> to not consider deleted documents when
estimating the merge policy. Applied to <code class="literal">org.apache.lucene.index.LogMergePolicy.calibrateSizeByDeletes</code>.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">true</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs
a flush occurs for whichever event happens first.
Generally for faster indexing performance it’s best to flush by RAM usage instead of document count
and use as large a RAM buffer as you can.</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>16 MB</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>hibernate.search.enable_dirty_check</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Not all entity changes require an update of the Lucene index. If all of the updated entity
properties (dirty properties) are not indexed Hibernate Search will skip the re-indexing work.
Disable this option if you use a custom <code class="literal">FieldBridge</code> which need to be invoked at each update
event (even though the property for which the field bridge is configured has not changed).
This optimization will not be applied on classes using a <code class="literal">@ClassBridge</code> or a <code class="literal">@DynamicBoost</code>.
Boolean parameter, use "true" or "false".</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>true</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.infostream</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>Enable low level trace information about Lucene’s internal components.
Will cause significant performance degradation: should only be used for troubleshooting purposes.</p></td><td style="text-align: left; vertical-align: top; "><p>false</p></td></tr></tbody></table></div></div><br class="table-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>When your architecture permits it, always keep
<code class="literal">hibernate.search.default.exclusive_index_use=true</code> as it greatly improves efficiency in index
writing. This is the default since Hibernate Search version 4.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>To tune the indexing speed it might be useful to time the object loading from database in isolation
from the writes to the index. To achieve this set the <code class="literal">blackhole</code> as worker backend and start your
indexing routines. This backend does not disable Hibernate Search: it will still generate the needed
changesets to the index, but will discard them instead of flushing them to the index. In contrast to
setting the <code class="literal">hibernate.search.indexing_strategy</code> to <code class="literal">manual</code>, using <code class="literal">blackhole</code> will possibly
load more data from the database because associated entities are re-indexed as well.</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].worker.backend blackhole</pre><p>The recommended approach is to focus first on optimizing the object loading by enabling the <code class="literal">blackhole</code> backend,
and then use the timings you achieve as a baseline to tune the indexing process.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>The <code class="literal">blackhole</code> backend is not meant to be used in production, only as a tool to identify indexing
bottlenecks.</p></div><section class="section" id="lucene-segment-size"><div class="titlepage"><div><div><h4 class="title">3.8.1.1. Control segment size</h4></div></div></div><p>The options <code class="literal">merge_max_size</code>, <code class="literal">merge_max_optimize_size</code>, <code class="literal">merge_calibrate_by_deletes</code>
give you control on the maximum size of the segments being created, but you need to understand how
they affect file sizes. If you need to hard limit the size, consider that merging a segment is about
adding it together with another existing segment to form a larger one, so you might want to set the
<code class="literal">max_size</code> for merge operations to less than half of your hard limit. Also segments might
initially be generated larger than your expected size at first creation time: before they are ever
merged. A segment is never created much larger than <code class="literal">ram_buffer_size</code>, but the threshold is
checked as an estimate.</p><p>Example:</p><div class="informalexample"><pre class="screen">//to be fairly confident no files grow above 15MB, use:
hibernate.search.default.indexwriter.ram_buffer_size = 10
hibernate.search.default.indexwriter.merge_max_optimize_size = 7
hibernate.search.default.indexwriter.merge_max_size = 7</pre></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>When using the Infinispan Directory to cluster indexes make sure that your segments are smaller than
the <code class="literal">chunk_size</code> so that you avoid fragmenting segments in the grid. Note that the
<code class="literal">chunk_size</code> of the Infinispan Directory is expressed in bytes, while the index tuning options
are in MB.</p></div></section><section class="section" id="lucene-infostream"><div class="titlepage"><div><div><h4 class="title">3.8.1.2. Troubleshooting: enable Lucene’s Infostream</h4></div></div></div><p>Apache Lucene allows to log a very detailed trace log from its internals using a feature called "infostream".
To access these details, Hibernate Search can be configured to capture this internal trace from Apache Lucene and redirect it to your logger.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Enable <code class="literal">TRACE</code> level logging for the category <code class="literal">org.hibernate.search.backend.lucene.infostream</code></li><li class="listitem">Activate the feature on the index you want to inspect: <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.infostream=true</code></li></ul></div><p>Keep in mind that this feature has a performance cost, and although most logger frameworks allow the <code class="literal">TRACE</code> level to be reconfigured at runtime,
enabling the <code class="literal">infostream</code> property will slow you down even if the logger is disabled.</p></section></section><section class="section" id="search-configuration-directory-lockfactories"><div class="titlepage"><div><div><h3 class="title">3.8.2. LockFactory configuration</h3></div></div></div><p>Lucene Directorys have default locking strategies which work generally good enough for most cases,
but it’s possible to specify for each index managed by Hibernate Search a specific LockingFactory
you want to use. This is generally not needed but could be useful.</p><p>Some of these locking strategies require a filesystem level lock and may be used even on RAM based
indexes, this combination is valid but in this case the <code class="literal">indexBase</code> configuration option usually
needed only for filesystem based Directory instances must be specified to point to a filesystem
location where to store the lock marker files.</p><p>To select a locking factory, set the <code class="literal">hibernate.search.&lt;index&gt;.locking_strategy</code> option to
one of <code class="literal">simple</code>, <code class="literal">native</code>, <code class="literal">single</code> or <code class="literal">none</code>. Alternatively set it to the fully qualified name of
an implementation of <code class="literal">org.hibernate.search.store.LockFactoryProvider</code>.</p><div class="table" id="search-configuration-directory-lockfactories-table"><div class="table-title">Table 3.8. List of available LockFactory implementations</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 33*; " class="col_1"/><col style="width: 33*; " class="col_2"/><col style="width: 33*; " class="col_3"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">name</th><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Class</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Description</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>simple</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>org.apache.lucene.store.SimpleFSLockFactory</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Safe implementation based on Java’s File API, it marks the usage of the index by creating a marker file.
</p><p>If for some reason you had to kill your application, you will need to remove this file before restarting it.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>native</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>org.apache.lucene.store.NativeFSLockFactory</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>As does <code class="literal">simple</code> this also marks the usage of the index by creating a marker file, but this one is using native OS file locks so that even if the JVM is terminated the locks will be cleaned up.
</p><p>This implementation has known problems on NFS, avoid it on network shares.
</p><p><code class="literal">native</code> is the default implementation for the <code class="literal">filesystem</code>, <code class="literal">filesystem-master</code> and <code class="literal">filesystem-slave</code> directory providers.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>single</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>org.apache.lucene.store.SingleInstanceLockFactory</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>This LockFactory doesn’t use a file marker but is a Java object lock held in memory; therefore it’s possible to use it only when you are sure the index is not going to be shared by any other process.
</p><p>This is the default implementation for the <code class="literal">ram</code> directory provider.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>none</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>org.apache.lucene.store.NoLockFactory</p></td><td style="text-align: left; vertical-align: top; "><p>All changes to this index are not coordinated by any lock; test your application carefully and make sure you know what it means.</p></td></tr></tbody></table></div></div><br class="table-break"/><p>Configuration example:</p><div class="informalexample"><pre class="screen">hibernate.search.default.locking_strategy = simple
hibernate.search.Animals.locking_strategy = native
hibernate.search.Books.locking_strategy = org.custom.components.MyLockingFactory</pre></div><p>The Infinispan Directory uses a custom implementation; it’s still possible to override it but make
sure you understand how that will work, especially with clustered indexes.</p></section><section class="section" id="_index_format_compatibility"><div class="titlepage"><div><div><h3 class="title">3.8.3. Index format compatibility</h3></div></div></div><p>While Hibernate Search strives to offer a backwards compatible API making it easy to port your
application to newer versions, it still delegates to Apache Lucene to handle the index writing and
searching. This creates a dependency to the Lucene index format. The Lucene developers of course
attempt to keep a stable index format, but sometimes a change in the format can not be avoided. In
those cases you either have to re-index all your data or use an index upgrade tool. Sometimes Lucene
is also able to read the old format so you don’t need to take specific actions (besides making
backup of your index).</p><p>While an index format incompatibility is a rare event, it can happen more often that Lucene’s
Analyzer implementations might slightly change its behavior. This can lead to a poor recall score,
possibly missing many hits from the results.</p><p>Hibernate Search exposes a configuration property <code class="literal">hibernate.search.lucene_version</code> which
instructs the analyzers and other Lucene classes to conform to their behavior as defined in an
(older) specific version of Lucene. See also <code class="literal">org.apache.lucene.util.Version</code> contained in the
<span class="emphasis"><em>lucene-core.jar</em></span>. Depending on the specific version of Lucene you’re using you might have different
options available. When this option is not specified, Hibernate Search will instruct Lucene to use
the default version, which is usually the best option for new projects. Still it’s recommended to
define the version you’re using explicitly in the configuration so that when you happen to upgrade
Lucene the analyzers will not change behavior. You can then choose to update this value at a later
time, when you for example have the chance to rebuild the index from scratch.</p><div class="example" id="d0e2428"><div class="example-title">Example 3.15. Force Analyzers to be compatible with a Lucene 4.7 created index</div><div class="example-contents"><pre class="screen">hibernate.search.lucene_version = LUCENE_47</pre></div></div><br class="example-break"/><p>This option is global for the configured SearchFactory and affects all Lucene APIs having such a
parameter, as this should be applied consistently. So if you are also making use of Lucene bypassing
Hibernate Search, make sure to apply the same value too.</p></section></section><section class="section" id="_metadata_api"><div class="titlepage"><div><div><h2 class="title">3.9. Metadata API</h2></div></div></div><p>After looking at all these different configuration options, it is time to have a look at an API
which allows you to programmatically access parts of the configuration. Via the metadata API you can
determine the indexed types and also how they are mapped (see <a class="xref" href="#search-mapping" title="Chapter 4. Mapping entities to the index structure">Chapter 4, <em>Mapping entities to the index structure</em></a>) to the index
structure. The entry point into this API is the SearchFactory. It offers two methods, namely
<code class="literal">getIndexedTypes()</code> and <code class="literal">getIndexedTypeDescriptor(Class&lt;?&gt;)</code>. The former returns a set of all
indexed type, where as the latter allows to retrieve a so called IndexedTypeDescriptorfor a given
type. This descriptor allows you determine whether the type is indexed at all and, if so, whether
the index is for example sharded or not (see <a class="xref" href="#advanced-features-sharding" title="10.5. Sharding indexes">Section 10.5, “Sharding indexes”</a>). It also allows you to
determine the static boost of the type (see <a class="xref" href="#section-boost-annotation" title="4.2.1. Static index time boosting">Section 4.2.1, “Static index time boosting”</a>) as well as its dynamic
boost strategy (see <a class="xref" href="#section-dynamic-boost" title="4.2.2. Dynamic index time boosting">Section 4.2.2, “Dynamic index time boosting”</a>). Most importantly, however, you get information about
the indexed properties and generated Lucene Document fields. This is exposed via PropertyDescriptors
respectively FieldDescriptors. The easiest way to get to know the API is to explore it via the IDE
or its javadocs.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>All descriptor instances of the metadata API are read only. They do not allow to change any runtime
configuration.</p></div></section><section class="section" id="search-configuration-deploy-on-wildfly"><div class="titlepage"><div><div><h2 class="title">3.10. Hibernate Search as a WildFly module</h2></div></div></div><p>Hibernate Search is included in the WildFly application server, and since WildFly 10 the module
is automatically activated (added to the classpath of your deployment) if you have any indexed entities.</p><p>Alternatively you can opt to use a different version of the module by downloading and unzipping a different
moduleset and setting the <code class="literal">wildfly.jpa.hibernate.search.module</code> property in your <code class="literal">persistence.xml</code>.</p><p>The modules system in WildFly allows to safely run multiple versions of Hibernate ORM and
Hibernate Search in parallel, but if you download an alternative version make sure the Hibernate Search version you choose
is compatible with the Hibernate ORM version you choose.</p><section class="section" id="using-wildfly-provided-hibernatesearch-versions"><div class="titlepage"><div><div><h3 class="title">3.10.1. Use the Hibernate Search version included in WildFly</h3></div></div></div><p>The activation of the Hibernate Search modules in wildfly is automatic, provided you’re having at least one
entity annotated with <code class="literal">org.hibernate.search.annotations.Indexed</code>.</p><p>You can control this behaviour of the JPA deployer explicitly; for example to make sure Hibernate Search
and Apache Lucene classes are available to your application even though you haven’t annotated any entity,
set the following property in your <code class="literal">persistence.xml</code>:</p><div class="informalexample"><pre class="screen">wildfly.jpa.hibernate.search.module=org.hibernate.search.orm:main</pre></div></section><section class="section" id="_update_and_activate_latest_hibernate_search_version_in_wildfly"><div class="titlepage"><div><div><h3 class="title">3.10.2. Update and activate latest Hibernate Search version in WildFly</h3></div></div></div><p>You can also download the latest Hibernate Search provided module and install it. This is often the
best approach as you will benefit from all the latest improvements of
Hibernate Search. Because of the modular design in WildFly, these additional modules can
coexist with the embedded modules and won’t affect any other application, unless you
explicitly reconfigure it to use the newer module.</p><p>You can download the latest pre-packaged Hibernate Search modules from
<a class="link" href="http://sourceforge.net/projects/hibernate/files/hibernate-search/5.6.6.Final/hibernate-search-modules-5.6.6.Final-wildfly-10-dist.zip/download">Sourceforge</a>.
As a convenience these zip files are also distributed as Maven artifacts:
<a class="link" href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-modules~{hibernateSearchVersion}~~">org.hibernate:hibernate-search-modules-5.6.6.Final-wildfly-10-dist:zip</a>.</p><p>Unpack the modules in your WildFly <code class="literal">modules</code> directory: this will create modules for Hibernate Search and Apache Lucene.
The Hibernate Search modules are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="emphasis"><em>org.hibernate.search.orm</em></span>, for users of Hibernate Search with Hibernate; this will transitively include Hibernate ORM.</li><li class="listitem"><span class="emphasis"><em>org.hibernate.search.engine</em></span>, for projects depending on the internal indexing engine that don’t require other dependencies to Hibernate.</li><li class="listitem"><span class="emphasis"><em>org.hibernate.search.backend-jms</em></span>, in case you want to use the JMS backend described in <a class="link" href="#search-architecture-jms" title="2.2.2. JMS">JMS Architecture</a>.</li></ul></div><p>Next you will need to make sure the JPA deployer of WildFly provides you with the version you have chosen, instead of the default version
bundled with the application server.
Set the following property in your <code class="literal">persistence.xml</code>:</p><div class="informalexample"><pre class="screen">wildfly.jpa.hibernate.search.module=org.hibernate.search.orm:5.6.6.Final</pre></div><p>See also <a class="link" href="https://docs.jboss.org/author/display/WFLY10/JPA+Reference+Guide#JPAReferenceGuide-UsingHibernateSearch">the WildFly JPA configuration</a></p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>This version of Hibernate Search <code class="literal">5.6.6.Final</code> requires Hibernate ORM 5.
At the time of writing this paragraph the only version of WildFly compatible with Hibernate ORM 5 is WildFly version 10.</p><p>If you need an Hibernate Search version for WildFly versions 9 or earlier, you can either include
a version of Hibernate ORM 5 in custom modules, but this requires some expertise with the modules system;
In such a scenario it might be easier to use a previous version of Hibernate Search, or simply use the
Hibernate Search version included in each WildFly release (see <a class="xref" href="#using-wildfly-provided-hibernatesearch-versions" title="3.10.1. Use the Hibernate Search version included in WildFly">Section 3.10.1, “Use the Hibernate Search version included in WildFly”</a>).</p></div></section><section class="section" id="_more_about_modules"><div class="titlepage"><div><div><h3 class="title">3.10.3. More about modules</h3></div></div></div><p>More information about the modules configuration in WildFly can be found in the
<a class="link" href="https://docs.jboss.org/author/display/WFLY10/Class+Loading+in+WildFly">Class Loading in WildFly 10</a> wiki.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Modular classloading is a feature of JBoss EAP 6 as well, but if you are using JBoss EAP, you’re
reading the wrong version of the user guide! JBoss EAP subscriptions include official support for
Hibernate Search and come with a different edition of this guide specifically tailored for EAP users.</p></div></section><section class="section" id="_using_infinispan_with_hibernate_search_on_wildfly"><div class="titlepage"><div><div><h3 class="title">3.10.4. Using Infinispan with Hibernate Search on WildFly</h3></div></div></div><p>The Infinispan project is also included in WildFly so you can use the feature without
additional downloads.</p><p>If you are updating the version of Hibernate Search in WildFly as described in the previous paragraph,
you might need to update Infinispan as well.
The process is very similar: download the modules from
<a class="link" href="http://infinispan.org/download/">Infinispan project downloads</a>, picking a compatible version,
and decompress the modules into the <code class="literal">modules</code> directory of your WildFly installation.</p><p>Hibernate Search version <code class="literal">5.6.6.Final</code> was compiled and tested with Infinispan version
<code class="literal">8.2.4.Final</code>; generally a more recent version of either project is expected to be backwards
compatible for cross-project integration purposes as long as they have the same "major.minor" family
version.</p><p>For example for a version of Hibernate Search depending on Infinispan <code class="literal">7.0.3.Final</code> it should be
safe to upgrade Infinispan to <code class="literal">7.0.6.Final</code>, but an upgrade to <code class="literal">7.1.0.Final</code> might not work.</p></section></section></section><section class="chapter" id="search-mapping"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Mapping entities to the index structure</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#search-mapping-entity">4.1. Mapping an entity</a></span><ul><li><span class="section"><a href="#basic-mapping">4.1.1. Basic mapping</a></span></li><li><span class="section"><a href="#fields-annotation">4.1.2. Mapping properties multiple times</a></span></li><li><span class="section"><a href="#search-mapping-associated">4.1.3. Embedded and associated objects</a></span></li><li><span class="section"><a href="#_associated_objects_building_a_dependency_graph_with_containedin">4.1.4. Associated objects: building a dependency graph with @ContainedIn</a></span></li></ul></li><li><span class="section"><a href="#section-boosting">4.2. Boosting</a></span><ul><li><span class="section"><a href="#section-boost-annotation">4.2.1. Static index time boosting</a></span></li><li><span class="section"><a href="#section-dynamic-boost">4.2.2. Dynamic index time boosting</a></span></li></ul></li><li><span class="section"><a href="#_analysis">4.3. Analysis</a></span><ul><li><span class="section"><a href="#analyzer">4.3.1. Default analyzer and analyzer by class</a></span></li><li><span class="section"><a href="#section-named-analyzers">4.3.2. Named analyzers</a></span></li><li><span class="section"><a href="#_dynamic_analyzer_selection">4.3.3. Dynamic analyzer selection</a></span></li><li><span class="section"><a href="#analyzer-retrievinganalyzer">4.3.4. Retrieving an analyzer</a></span></li></ul></li><li><span class="section"><a href="#search-mapping-bridge">4.4. Bridges</a></span><ul><li><span class="section"><a href="#section-built-in-bridges">4.4.1. Built-in bridges</a></span></li><li><span class="section"><a href="#_tika_bridge">4.4.2. Tika bridge</a></span></li><li><span class="section"><a href="#section-custom-bridges">4.4.3. Custom bridges</a></span></li><li><span class="section"><a href="#_bridgeprovider_associate_a_bridge_to_a_given_return_type">4.4.4. BridgeProvider: associate a bridge to a given return type</a></span></li></ul></li><li><span class="section"><a href="#search-mapping-indexinginterceptor">4.5. Conditional indexing</a></span></li><li><span class="section"><a href="#provided-id">4.6. Providing your own id</a></span><ul><li><span class="section"><a href="#ProvidedId">4.6.1. The ProvidedId annotation</a></span></li></ul></li><li><span class="section"><a href="#hsearch-mapping-programmaticapi">4.7. Programmatic API</a></span><ul><li><span class="section"><a href="#_mapping_an_entity_as_indexable">4.7.1. Mapping an entity as indexable</a></span></li><li><span class="section"><a href="#_adding_documentid_to_indexed_entity">4.7.2. Adding DocumentId to indexed entity</a></span></li><li><span class="section"><a href="#_defining_analyzers">4.7.3. Defining analyzers</a></span></li><li><span class="section"><a href="#_defining_full_text_filter_definitions">4.7.4. Defining full text filter definitions</a></span></li><li><span class="section"><a href="#_defining_fields_for_indexing">4.7.5. Defining fields for indexing</a></span></li><li><span class="section"><a href="#_programmatically_defining_embedded_entities">4.7.6. Programmatically defining embedded entities</a></span></li><li><span class="section"><a href="#_contained_in_definition">4.7.7. Contained In definition</a></span></li><li><span class="section"><a href="#_date_calendar_bridge">4.7.8. Date/Calendar Bridge</a></span></li><li><span class="section"><a href="#_declaring_bridges">4.7.9. Declaring bridges</a></span></li><li><span class="section"><a href="#_mapping_class_bridge">4.7.10. Mapping class bridge</a></span></li><li><span class="section"><a href="#_mapping_dynamic_boost">4.7.11. Mapping dynamic boost</a></span></li></ul></li></ul></div><section class="section" id="search-mapping-entity"><div class="titlepage"><div><div><h2 class="title">4.1. Mapping an entity</h2></div></div></div><p>In <a class="xref" href="#getting-started" title="Chapter 1. Getting started">Chapter 1, <em>Getting started</em></a> you have already seen that all the metadata information needed to index
entities is described through annotations. There is no need for XML mapping files. You can still use
Hibernate mapping files for the basic Hibernate configuration, but the Hibernate Search specific
configuration has to be expressed via annotations.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>There is no XML configuration available for Hibernate Search but we provide a programmatic
mapping API that elegantly replaces this kind of deployment form (see
<a class="xref" href="#hsearch-mapping-programmaticapi" title="4.7. Programmatic API">Section 4.7, “Programmatic API”</a> for more information).</p><p>If you want to contribute the XML mapping implementation, see
<a class="link" href="https://hibernate.onjira.com/browse/HSEARCH-210">HSEARCH-210</a>.</p></div><section class="section" id="basic-mapping"><div class="titlepage"><div><div><h3 class="title">4.1.1. Basic mapping</h3></div></div></div><p>Lets start with the most commonly used annotations when mapping an entity.</p><section class="section" id="indexed-annotation"><div class="titlepage"><div><div><h4 class="title">4.1.1.1. @Indexed</h4></div></div></div><p>Foremost you must declare a persistent class as indexable by annotating the class with <code class="literal">@Indexed.</code>
All entities not annotated with <code class="literal">@Indexed</code> will be ignored by the indexing process.</p><div class="example" id="d0e2626"><div class="example-title">Example 4.1. Making a class indexable with <code class="literal">@Indexed</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Essay {
    ...
}</code></pre></div></div><br class="example-break"/><p>You can optionally specify the <code class="literal">Indexed.index</code> attribute to change the default name of the index.
For more information regarding index naming see <a class="xref" href="#search-configuration-directory" title="3.3. Directory configuration">Section 3.3, “Directory configuration”</a>.</p><p>You can also specify an optional indexing interceptor. For more information see
<a class="link" href="#search-mapping-indexinginterceptor" title="4.5. Conditional indexing">conditional indexing</a>.</p></section><section class="section" id="field-annotation"><div class="titlepage"><div><div><h4 class="title">4.1.1.2. @Field</h4></div></div></div><p>For each property of your entity, you have the ability to describe whether and how it
will be indexed. Adding the <code class="literal">@Field</code> annotation declares a property as indexed and allows you to
configure various aspects of the indexing process. Without <code class="literal">@Field</code> the property is ignored by
the indexing process.</p><p>Hibernate Search tries to determine the best way to index your property. In most
cases this will be as string, but for the types int, long, double and float (and their respective
Java wrapper types) Lucene’s numeric field encoding (see <a class="xref" href="#numeric-field-annotation" title="4.1.1.3. @NumericField">Section 4.1.1.3, “@NumericField”</a>) is used.
This numeric encoding uses a so called <a class="link" href="http://en.wikipedia.org/wiki/Trie">Trie structure</a> which
allows for efficient range queries and sorting, resulting in query response times
being orders of magnitude faster than with the plain string encoding. Byte and short properties
will only be encoded in numeric fields if explicitly marked with the <code class="literal">@NumericField</code> annotation.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="caution"><h2>Caution</h2><p>Prior to Search 5, numeric field encoding was only chosen if explicitly requested via <code class="literal">@NumericField</code>.
As of Search 5 this encoding is automatically chosen for numeric types. To avoid numeric encoding
you can explicitly specify a non numeric field bridge via <code class="literal">@Field.bridge</code> or <code class="literal">@FieldBridge</code>. The
package <code class="literal">org.hibernate.search.bridge.builtin</code> contains a set of bridges which encode numbers as strings,
for example <code class="literal">org.hibernate.search.bridge.builtin.IntegerBridge</code>.</p></div><p>The following attributes of the <code class="literal">@Field</code> annotation help you control the indexing outcome:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">name</code>: describes under which name the property should be stored in the Lucene Document. The
default value is the property name (following the JavaBeans convention)</li><li class="listitem"><code class="literal">store</code>: describes whether or not the property is stored in the Lucene index. You can store the
value <code class="literal">Store.YES</code> (consuming more space in the index but allowing <a class="link" href="#projections" title="5.1.3.5. Projection">projection</a>),
store it in a compressed way <code class="literal">Store.COMPRESS</code> (this does consume more CPU), or avoid any storage
<code class="literal">Store.NO</code> (this is the default value). When a property is stored, you can retrieve its original
value from the Lucene Document. Storing the property has no impact on whether the value is
searchable or not.</li><li class="listitem"><p class="simpara"><code class="literal">index</code>: describes whether the property is indexed or not. The different values are <code class="literal">Index.NO</code>
(no indexing, meaning the value cannot be found by a query), <code class="literal">Index.YES</code> (the element gets indexed
and is searchable). The default value is <code class="literal">Index.YES</code>. <code class="literal">Index.NO</code> can be useful for cases where a
property is not required to be searchable, but needed for projection.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p><code class="literal">Index.NO</code> in combination with <code class="literal">Analyze.YES</code> or <code class="literal">Norms.YES</code> is not useful, since analyze and norms
require the property to be indexed</p></div></li><li class="listitem"><p class="simpara"><code class="literal">analyze</code>: determines whether the property is analyzed (<code class="literal">Analyze.YES</code>) or not (<code class="literal">Analyze.NO</code>).
The default value is <code class="literal">Analyze.YES</code>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Whether or not you want to analyze a property depends on whether you wish to search the element as
is, or by the words it contains. It make sense to analyze a text field, but probably not a date
field.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Fields used for sorting or faceting <span class="emphasis"><em>must not</em></span> be analyzed.</p></div></li><li class="listitem"><code class="literal">norms</code>: describes whether index time boosting information should be stored (<code class="literal">Norms.YES</code>) or
not (<code class="literal">Norms.NO</code>). Not storing the norms can save a considerable amount of memory, but index time
boosting will not be available in this case. The default value is <code class="literal">Norms.YES</code>.</li><li class="listitem"><p class="simpara"><code class="literal">termVector</code>: describes collections of term-frequency pairs. This attribute enables the storing
of the term vectors within the documents during indexing. The default value is <code class="literal">TermVector.NO</code>.</p><p class="simpara">The different values of this attribute are:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Value</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Definition</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">TermVector.YES</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Store the term vectors of each document. This
                    produces two synchronized arrays, one contains document
                    terms and the other contains the term’s frequency.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">TermVector.NO</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Do not store term vectors.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">TermVector.WITH_OFFSETS</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Store the term vector and token offset information.
                    This is the same as <code class="literal">TermVector.YES</code> plus it contains the
                    starting and ending offset position information for the
                    terms.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">TermVector.WITH_POSITIONS</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Store the term vector and token position
                    information. This is the same as <code class="literal">TermVector.YES</code> plus it
                    contains the ordinal positions of each occurrence of a
                    term in a document.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p><code class="literal">TermVector.WITH_POSITION_OFFSETS</code></p></td><td style="text-align: left; vertical-align: top; "><p>Store the term vector, token position and offset
                    information. This is a combination of the <code class="literal">YES</code>,
                    <code class="literal">WITH_OFFSETS</code> and <code class="literal">WITH_POSITIONS</code>.</p></td></tr></tbody></table></div></li><li class="listitem"><p class="simpara"><code class="literal">indexNullAs</code>: Per default null values are ignored and not indexed. However, using <code class="literal">indexNullAs</code>
you can specify a string which will be inserted as token for the null value. Per default this value
is set to <code class="literal">org.hibernate.search.annotations.Field.DO_NOT_INDEX_NULL</code> indicating that null values
should not be indexed. You can set this value to <code class="literal">DEFAULT_NULL_TOKEN</code> to indicate that a default null
token should be used. This default null token can be specified in the configuration using
<code class="literal">hibernate.search.default_null_token</code>. If this property is not set the string <code class="literal">_null_</code> will
be used as default.
When the field is of a Numeric Type (see <a class="xref" href="#numeric-field-annotation" title="4.1.1.3. @NumericField">Section 4.1.1.3, “@NumericField”</a>), the token will be encoded as the
respective numeric type: the <code class="literal">indexNullAs</code> value needs to be set to a value which can be parsed into
a number of the matching type, for example "-1".</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>When <code class="literal">indexNullAs</code> is used, it is important to use the chosen null token in search queries (see
<a class="xref" href="#search-query" title="Chapter 5. Querying">Chapter 5, <em>Querying</em></a>) in order to find null values. It is also advisable to use this feature only with
un-analyzed fields (<code class="literal">analyze=Analyze.NO</code>).</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>When implementing a custom <code class="literal">FieldBridge</code> or <code class="literal">TwoWayFieldBridge</code> it is up to the developer to handle the
indexing of null values (see JavaDocs of <code class="literal">LuceneOptions.indexNullAs()</code>).</p></div></li><li class="listitem"><code class="literal">boost</code>: Refer to section about <a class="link" href="#section-boosting" title="4.2. Boosting">boosting</a></li><li class="listitem"><code class="literal">bridge</code>: Refer to section about <a class="link" href="#section-custom-bridges" title="4.4.3. Custom bridges">field bridges</a></li></ul></div></section><section class="section" id="numeric-field-annotation"><div class="titlepage"><div><div><h4 class="title">4.1.1.3. @NumericField</h4></div></div></div><p><code class="literal">@NumericField</code> is a companion annotation to <code class="literal">@Field</code>. It can be specified in the
same scope as <code class="literal">@Field</code>, but only on properties of numeric type like byte, short, int, long, double and float
(and their respective Java wrapper types). It allows to define a custom <code class="literal">precisionStep</code> for the
numeric encoding of the property value.</p><p><code class="literal">@NumericField</code> accepts the following parameters:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Value</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Definition</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">forField</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>(Optional) Specify the name of of the related <code class="literal">@Field</code>
                  that will be indexed numerically. It’s only mandatory when
                  the property contains more than a <code class="literal">@Field</code> declaration</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p><code class="literal">precisionStep</code></p></td><td style="text-align: left; vertical-align: top; "><p>(Optional) Change the way that the Trie structure is
                  stored in the index. Smaller <code class="literal">precisionSteps</code> lead to more
                  disk space usage and faster range and sort queries. Larger
                  values lead to less space used and range query performance
                  more close to the range query using string encoding. Default
                  value is 4.</p></td></tr></tbody></table></div><p>Lucene supports the numeric types: <code class="literal">Double</code>, <code class="literal">Long</code>, <code class="literal">Integer</code> and <code class="literal">Float</code>. For properties of types
<code class="literal">Byte</code> and <code class="literal">Short</code>, an <code class="literal">Integer</code> field will be used in the index. Other numeric types
should use the default string encoding (via <code class="literal">@Field</code>), unless the application can deal with a
potential loss in precision, in which case a custom <code class="literal">NumericFieldBridge</code> can be used. See
<a class="xref" href="#example-custom-numericfieldbridge" title="Example 4.2. Defining a custom NumericFieldBridge for BigDecimal">Example 4.2, “Defining a custom NumericFieldBridge for <code class="literal">BigDecimal</code>”</a>.</p><div class="example" id="example-custom-numericfieldbridge"><div class="example-title">Example 4.2. Defining a custom NumericFieldBridge for <code class="literal">BigDecimal</code></div><div class="example-contents"><pre><code class="language-java">public class BigDecimalNumericFieldBridge extends NumericFieldBridge {
    private static final BigDecimal storeFactor = BigDecimal.valueOf(100);

    @Override
    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        if ( value != null ) {
            BigDecimal decimalValue = (BigDecimal) value;
            long tmpLong = decimalValue.multiply( storeFactor ).longValue();
            Long indexedValue = Long.valueOf( tmpLong );
            luceneOptions.addNumericFieldToDocument( name, indexedValue, document );
        }
    }

    @Override
    public Object get(String name, Document document) {
        String fromLucene = document.get( name );
        BigDecimal storedBigDecimal = new BigDecimal( fromLucene );
        return storedBigDecimal.divide( storeFactor );
    }
}</code></pre></div></div><br class="example-break"/><p>You would use this custom bridge like seen in <a class="xref" href="#example-useof-custom-numericfieldbridge" title="Example 4.3. Use of BigDecimalNumericFieldBridge">Example 4.3, “Use of <code class="literal">BigDecimalNumericFieldBridge</code>”</a>. In this
case three annotations are used - <code class="literal">@Field</code>, <code class="literal">@NumericField</code> and <code class="literal">@FieldBridge</code>. <code class="literal">@Field</code> is required
to mark the property for being indexed (a standalone <code class="literal">@NumericField</code> is never allowed).
<code class="literal">@NumericField</code> might be omitted in this specific case, because the used <code class="literal">@FieldBridge</code> annotation
refers already to a <code class="literal">NumericFieldBridge</code> instance. However, the use of <code class="literal">@NumericField</code> makes the
use of the property as numeric value explicit.</p><div class="example" id="example-useof-custom-numericfieldbridge"><div class="example-title">Example 4.3. Use of <code class="literal">BigDecimalNumericFieldBridge</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Item {
    @Id
    @GeneratedValue
    private int id;

    @Field
    @NumericField
    @FieldBridge(impl = BigDecimalNumericFieldBridge.class)
    private BigDecimal price;

    public int getId() {
        return id;
    }

    public BigDecimal getPrice() {
       return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="sortablefield-annotation"><div class="titlepage"><div><div><h4 class="title">4.1.1.4. @SortableField</h4></div></div></div><p>As of Lucene 5 (and thus Hibernate Search 5.5) it is highly recommended to create a so-called "doc value field"
for each field to sort on. Hibernate Search provides the <code class="literal">@SortableField</code> annotation for that purpose.
This is an extension annotation to <code class="literal">@Field</code> and marks a field as sortable (internally, the required doc value
field will be added to the index).</p><div class="example" id="example-useof-sortablefield"><div class="example-title">Example 4.4. Use of <code class="literal">@SortableField</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Book {

    @Id
    @GeneratedValue
    private int id;

    @Field(name="Abstract", analyze=Analyze.NO)
    @SortableField
    private String summary;

    // ...
}</code></pre></div></div><br class="example-break"/><p>If there is a single <code class="literal">@Field</code> declared for a given property, <code class="literal">@SortableField</code> implicitly applies to this field.
In case several fields exist for a single property, the <code class="literal">@Field</code> to be marked as sortable can be specified
via <code class="literal">@SortableField#forField()</code>. Several sortable fields can be defined with help of the <code class="literal">@SortableFields</code> annotation.</p><p>The field to be marked as sortable must not be analyzed.</p><p>Note that sorting also works if a property is not explicitly marked with <code class="literal">@SortableField</code>. This has negative runtime
performance and memory consumption implications, though. Therefore it is highly recommended to explicitly mark each
field to be used for sorting.</p><p>Should you want to make a property sortable but not searchable, still an <code class="literal">@Field</code> needs to be declared (so its field
bridge configuration can be inherited). It can be marked with <code class="literal">store = Store.NO</code> and <code class="literal">index = Index.NO</code>, causing
only the doc value field required for sorting to be added, but not a regular index field.</p><p><span id="metadata-providing-field-bridge"/> Fields added through class-level bridges or custom field-level bridges (when not using the default field name) cannot
be marked as sortable by means of the <code class="literal">@SortableField</code> annotation. Instead the field bridge itself has to add the
required doc value fields, in addition to the document fields it adds. Furthermore such bridge needs to implement the
<code class="literal">MetadataProvidingFieldBridge</code> interface which defines a method <code class="literal">configureFieldMetadata()</code> for marking the fields
created by this bridge as sortable:</p><div class="example" id="example-adding-docvaluefield"><div class="example-title">Example 4.5. Marking fields as sortable via a custom field bridge</div><div class="example-contents"><pre><code class="language-java">/***
  * Custom field bridge for a Map property which creates sortable fields
  * with the values of two keys from the map.
  */
public class MyClassBridge implements MetadataProvidingFieldBridge {

  @Override
  public void set(String name, Object value,
          Document document, LuceneOptions luceneOps) {

      Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) value;

      String firstName = map.get( "firstName" );
      String lastName = map.get( "lastName" );

      // add regular document fields
      luceneOps.addFieldToDocument( name + "_firstName", lastName, document );
      luceneOps.addFieldToDocument( name + "_lastName", lastName, document );

      // add doc value fields to allow for sorting
      document.add( new SortedDocValuesField(
                        name + "_firstName", new BytesRef( firstName ) ) );
      document.add( new SortedDocValuesField(
                        name + "_lastName", new BytesRef( lastName ) ) );
  }

  @Override
  public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
      builder
          .field( name + "_firstName", FieldType.STRING )
              .sortable( true )
          .field( name + "_lastName", FieldType.STRING )
              .sortable( true );
  }
}</code></pre></div></div><br class="example-break"/><p>The meta-data configured through <code class="literal">configureFieldMetadata()</code> will be used for sort validation upon query execution. The
name passed to the method is the default field name also passed to <code class="literal">set()</code>. It needs to be used consistently with
<code class="literal">set()</code>, e.g. as a prefix for all custom fields added.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The <code class="literal">MetadataProvidingFieldBridge</code> contract is under active development and considered experimental at this time. It
may be altered in future revisions, e.g. by adding further methods, thus breaking existing implementations.</p></div><section class="section" id="flagging-uncovered-sorts"><div class="titlepage"><div><div><h5 class="title">4.1.1.4.1. Flagging uncovered sorts</h5></div></div></div><p>By default Hibernate Search will transparently create an uninverting index reader when running a query with sorts not
covered by the sortable fields configured as described above. While this allows to execute the query, relying on index
uninverting negatively impacts performance.</p><p>You thus can optionally advice Hibernate Search to raise an exception when detecting uncovered sorts. To do so, specify
the following option:</p><div class="example" id="d0e3141"><div class="example-title">Example 4.6. Disabling automatic index uninverting for uncovered sorts</div><div class="example-contents"><pre class="screen">hibernate.search.index_uninverting_allowed = false</pre></div></div><br class="example-break"/><p>You e.g. may set this to <code class="literal">false</code> during testing to identify the sortable fields required for your queries and set it to
<code class="literal">true</code> in production environments to fall back to index uninverting for uncovered sorts accidentally left over.</p></section></section><section class="section" id="id-annotation"><div class="titlepage"><div><div><h4 class="title">4.1.1.5. @Id</h4></div></div></div><p>Finally, the id property of an entity is a special property used by Hibernate Search to ensure index
unicity of a given entity. By design, an id has to be stored and must not be tokenized. It is also
always string encoded, even if the id is a number. To mark a property as index id, use the
<code class="literal">@DocumentId</code> annotation. If you are using JPA and you are using <code class="literal">@Id</code> you can omit <code class="literal">@DocumentId</code>.
The chosen entity id will also be used as document id.</p><div class="example" id="example-annotated-entity"><div class="example-title">Example 4.7. Specifying indexed properties</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES)
    public String getSummary() { return summary; }

    @Lob
    @Field
    public String getText() { return text; }

    @Field
    @NumericField(precisionStep = 6)
    public float getGrade() { return grade; }
}</code></pre></div></div><br class="example-break"/><p><a class="xref" href="#example-annotated-entity" title="Example 4.7. Specifying indexed properties">Example 4.7, “Specifying indexed properties”</a> defines an index with four fields: <code class="literal">id</code>, <code class="literal">Abstract</code>, <code class="literal">text</code> and
<code class="literal">grade</code>. Note that by default the field name is de-capitalized, following the JavaBean
specification. The <code class="literal">grade</code> field is annotated as numeric with a slightly larger <code class="literal">precisionStep</code> than
the default.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>It is not recommended to sort on the id field as it will lead to erratic behaviors. If you want to sort on your
document id, it is recommended to declare another field specifically for sorting using the <code class="literal">@Field</code> annotation.</p></div></section></section><section class="section" id="fields-annotation"><div class="titlepage"><div><div><h3 class="title">4.1.2. Mapping properties multiple times</h3></div></div></div><p>Sometimes one has to map a property multiple times per index, with slightly different indexing
strategies. For example, sorting a query by field requires the field to be un-analyzed. If one wants
to search by words in this property and still sort it, one need to index it twice - once analyzed
and once un-analyzed. <code class="literal">@Fields</code> allows to achieve this goal.</p><div class="example" id="example-fields-annotation"><div class="example-title">Example 4.8. Using <code class="literal">@Fields</code> to map a property multiple times</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed(index = "Book")
public class Book {
    @Fields( {
            @Field,
            @Field(name = "summary_forSort", analyze = Analyze.NO, store = Store.YES)
    } )
    @SortableField(forField = "summary_forSort")
    public String getSummary() {
        return summary;
    }

    // ...
}</code></pre></div></div><br class="example-break"/><p>In <a class="xref" href="#example-fields-annotation" title="Example 4.8. Using @Fields to map a property multiple times">Example 4.8, “Using <code class="literal">@Fields</code> to map a property multiple times”</a> the field <code class="literal">summary</code> is indexed twice, once as <code class="literal">summary</code> in a
tokenized way, and once as <code class="literal">summary_forSort</code> in an un-tokenized way. <code class="literal">@Field</code> supports 2 attributes
useful when <code class="literal">@Fields</code> is used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">analyzer</code>: defines a <code class="literal">@Analyzer</code> annotation per field rather than per property</li><li class="listitem"><code class="literal">bridge</code>: defines a <code class="literal">@FieldBridge</code> annotation per field rather than per property</li></ul></div><p>See below for more information about analyzers and field bridges.</p></section><section class="section" id="search-mapping-associated"><div class="titlepage"><div><div><h3 class="title">4.1.3. Embedded and associated objects</h3></div></div></div><p>Associated objects as well as embedded objects can be indexed as part of the root entity index. This
is useful if you expect to search a given entity based on properties of the associated objects.</p><p>In the example <a class="xref" href="#example-indexing-associations" title="Example 4.9. Indexing associations">Example 4.9, “Indexing associations”</a> the aim is to return places where the associated
city is Atlanta (in Lucene query parser language, it would translate into <code class="literal">address.city:Atlanta</code>).
All place fields are added to the <code class="literal">Place</code> index, but also the address related fields <code class="literal">address.street</code>,
and <code class="literal">address.city</code> will be added and made queryable. The embedded object id,
<code class="literal">address.id</code>, is not added per default. To include it you need to also set
<code class="literal">@IndexedEmbedded(includeEmbeddedObjectId=true, …​)</code>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Only actual indexed fields (properties annotated with <code class="literal">@Field</code>) are added to the root entity index
when embedded objects are indexed. The embedded object identifiers are treated differently and need to
be included explicitly.</p></div><div class="example" id="example-indexing-associations"><div class="example-title">Example 4.9. Indexing associations</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String name;

    @OneToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
    @IndexedEmbedded
    private Address address;
    ....
}</code></pre><pre><code class="language-java">@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;
    ...
}</code></pre></div></div><br class="example-break"/><p>Be careful. Because the data is de-normalized in the Lucene index when using the <code class="literal">@IndexedEmbedded</code>
technique, Hibernate Search needs to be aware of any change in the <code class="literal">Place</code> object and any change in
the <code class="literal">Address</code> object to keep the index up to date. To make sure the <code class="literal">Place</code> Lucene document is updated
when it’s <code class="literal">Address</code> changes, you need to mark the other side of the bidirectional relationship with
<code class="literal">@ContainedIn</code>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p><code class="literal">@ContainedIn</code> is useful on both associations pointing to entities and on embedded (collection of)
objects.</p></div><p>Let’s make <a class="xref" href="#example-indexing-associations" title="Example 4.9. Indexing associations">Example 4.9, “Indexing associations”</a> a bit more complex by nesting <code class="literal">@IndexedEmbedded</code> as seen
in <a class="xref" href="#example-nested-index-embedded" title="Example 4.10. Nested usage of @IndexedEmbedded and @ContainedIn">Example 4.10, “Nested usage of <code class="literal">@IndexedEmbedded</code> and <code class="literal">@ContainedIn</code>”</a>.</p><div class="example" id="example-nested-index-embedded"><div class="example-title">Example 4.10. Nested usage of <code class="literal">@IndexedEmbedded</code> and <code class="literal">@ContainedIn</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Place {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String name;

    @OneToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
    @IndexedEmbedded
    private Address address;

    // ...
}</code></pre><pre><code class="language-java">@Entity
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @Field
    private String city;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_")
    private Owner ownedBy;

    @ContainedIn
    @OneToMany(mappedBy="address")
    private Set&lt;Place&gt; places;

    // ...
}</code></pre><pre><code class="language-java">@Embeddable
public class Owner {
    @Field
    private String name;
    // ...
}</code></pre></div></div><br class="example-break"/><p>As you can see, any <code class="literal">@*ToMany</code>, <code class="literal">@*ToOne</code> or <code class="literal">@Embedded</code> attribute can be annotated with
<code class="literal">@IndexedEmbedded</code>. The attributes of the associated class will then be added to the main entity
index. In <a class="xref" href="#example-nested-index-embedded" title="Example 4.10. Nested usage of @IndexedEmbedded and @ContainedIn">Example 4.10, “Nested usage of <code class="literal">@IndexedEmbedded</code> and <code class="literal">@ContainedIn</code>”</a> the index will contain the following fields</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">id</code></li><li class="listitem"><code class="literal">name</code></li><li class="listitem"><code class="literal">address.street</code></li><li class="listitem"><code class="literal">address.city</code></li><li class="listitem"><code class="literal">address.ownedBy_name</code></li></ul></div><p>The default prefix is <code class="literal">propertyName.</code>, following the traditional object navigation convention. You
can override it using the <code class="literal">prefix</code> attribute as it is shown on the <code class="literal">ownedBy</code> property.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The prefix cannot be set to the empty string.</p></div><p>The <code class="literal">depth</code> property is necessary when the object graph contains a cyclic dependency of classes (not
instances). For example, if <code class="literal">Owner</code> points to <code class="literal">Place</code>. Hibernate Search will stop including indexed
embedded attributes after reaching the expected depth (or the object graph boundaries are reached).
A class having a self reference is an example of cyclic dependency. In our example, because <code class="literal">depth</code>
is set to 1, any <code class="literal">@IndexedEmbedded</code> attribute in <code class="literal">Owner</code> (if any) will be ignored.</p><p>Using <code class="literal">@IndexedEmbedded</code> for object associations allows you to express queries (using Lucene’s query
syntax) such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Return places where name contains JBoss and where address city is Atlanta. In Lucene query this would be</li></ul></div><pre class="screen">+name:jboss +address.city:atlanta</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Return places where name contains JBoss and where owner’s name contain Joe. In Lucene query this would be</li></ul></div><pre class="screen">+name:jboss +address.ownedBy_name:joe</pre><p>In a way it mimics the relational join operation in a more efficient way (at the cost of data
duplication). Remember that, out of the box, Lucene indexes have no notion of association, the join
operation is simply non-existent. It might help to keep the relational model normalized while
benefiting from the full text index speed and feature richness.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>An associated object can itself (but does not have to) be <code class="literal">@Indexed</code></p></div><p>When <code class="literal">@IndexedEmbedded</code> points to an entity, the association has to be directional and the other side
has to be annotated with <code class="literal">@ContainedIn</code>. If not, Hibernate Search has
no way to update the root index when the associated entity is updated (in our example, a <code class="literal">Place</code>
index document has to be updated when the associated <code class="literal">Address</code> instance is updated).</p><p>Sometimes, the object type annotated by <code class="literal">@IndexedEmbedded</code> is not the object type targeted by
Hibernate and Hibernate Search. This is especially the case when interfaces are used in lieu of
their implementation. For this reason you can override the object type targeted by Hibernate Search
using the <code class="literal">targetElement</code> parameter.</p><div class="example" id="d0e3459"><div class="example-title">Example 4.11. Using the <code class="literal">targetElement</code> property of <code class="literal">@IndexedEmbedded</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Address {
    @Id
    @GeneratedValue
    private Long id;

    @Field
    private String street;

    @IndexedEmbedded(depth = 1, prefix = "ownedBy_", targetElement = Owner.class)
    @Target(Owner.class)
    private Person ownedBy;

    // ...
}</code></pre><pre><code class="language-java">@Embeddable
public class Owner implements Person { ... }</code></pre></div></div><br class="example-break"/><section class="section" id="search-mapping-associated-viapaths"><div class="titlepage"><div><div><h4 class="title">4.1.3.1. Limiting object embedding to specific paths</h4></div></div></div><p>The <code class="literal">@IndexedEmbedded</code> annotation provides also an attribute <code class="literal">includePaths</code> which can be used as an
alternative to <code class="literal">depth</code>, or in combination with it.</p><p>When using only <code class="literal">depth</code> all indexed fields of the embedded type will be added recursively at the same
depth; this makes it harder to pick only a specific path without adding all other fields as well,
which might not be needed.</p><p>To avoid unnecessarily loading and indexing entities you can specify exactly which paths are needed.
A typical application might need different depths for different paths, or in other words it might
need to specify paths explicitly, as shown in <a class="xref" href="#indexedembedded-includePath" title="Example 4.12. Using the includePaths property of @IndexedEmbedded">Example 4.12, “Using the <code class="literal">includePaths</code> property of <code class="literal">@IndexedEmbedded</code>”</a></p><div class="example" id="indexedembedded-includePath"><div class="example-title">Example 4.12. Using the <code class="literal">includePaths</code> property of <code class="literal">@IndexedEmbedded</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Person {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(includePaths = { "name" })
   public Set&lt;Person&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

   // ... other fields omitted</code></pre></div></div><br class="example-break"/><p>Using a mapping as in <a class="xref" href="#indexedembedded-includePath" title="Example 4.12. Using the includePaths property of @IndexedEmbedded">Example 4.12, “Using the <code class="literal">includePaths</code> property of <code class="literal">@IndexedEmbedded</code>”</a>, you would be able to search on a <code class="literal">Person</code> by
<code class="literal">name</code> and/or <code class="literal">surname</code>, and/or the <code class="literal">name</code> of the parent. It will not index the <code class="literal">surname</code> of the
parent, so searching on parent’s surnames will not be possible but speeds up indexing, saves space
and improve overall performance.</p><p>The <code class="literal">@IndexedEmbedded.includePaths</code> will include the specified paths <span class="emphasis"><em>in addition to</em></span> what you would
index normally specifying a limited value for depth. Using <code class="literal">includePaths</code> with a undefined (default)
value for <code class="literal">depth</code> is equivalent to setting <code class="literal">depth=0</code>: only the included paths are indexed.</p><div class="example" id="indexedembedded-includePathsAndDepth"><div class="example-title">Example 4.13. Using the <code class="literal">includePaths</code> property of <code class="literal">@IndexedEmbedded</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Human {

   @Id
   public int getId() {
      return id;
   }

   @Field
   public String getName() {
      return name;
   }

   @Field
   public String getSurname() {
      return surname;
   }

   @OneToMany
   @IndexedEmbedded(depth = 2, includePaths = { "parents.parents.name" })
   public Set&lt;Human&gt; getParents() {
      return parents;
   }

   @ContainedIn
   @ManyToOne
   public Human getChild() {
      return child;
   }

    // ... other fields omitted</code></pre></div></div><br class="example-break"/><p>In <a class="xref" href="#indexedembedded-includePathsAndDepth" title="Example 4.13. Using the includePaths property of @IndexedEmbedded">Example 4.13, “Using the <code class="literal">includePaths</code> property of <code class="literal">@IndexedEmbedded</code>”</a>, every human will have it’s name and surname attributes
indexed. The name and surname of parents will be indexed too, recursively up to second line because
of the <code class="literal">depth</code> attribute. It will be possible to search by name or surname, of the person directly,
his parents or of his grand parents. Beyond the second level, we will in addition index one more
level but only the name, not the surname.</p><p>This results in the following fields in the index:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">id</code> - as primary key</li><li class="listitem"><code class="literal">_hibernate_class</code> - stores entity type</li><li class="listitem"><code class="literal">name</code> - as direct field</li><li class="listitem"><code class="literal">surname</code> - as direct field</li><li class="listitem"><code class="literal">parents.name</code> - as embedded field at depth 1</li><li class="listitem"><code class="literal">parents.surname</code> - as embedded field at depth 1</li><li class="listitem"><code class="literal">parents.parents.name</code> - as embedded field at depth 2</li><li class="listitem"><code class="literal">parents.parents.surname</code> - as embedded field at depth 2</li><li class="listitem"><code class="literal">parents.parents.parents.name</code> - as additional path as specified by includePaths. The first
<code class="literal">parents.</code> is inferred from the field name, the remaining path is the attribute of includePaths</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>You can explicitly include the id of the embedded object using <code class="literal">includePath</code>, for example
<code class="literal">@IndexedEmbedded(includePaths = { "parents.id" })</code>. This will work regardless of the
<code class="literal">includeEmbeddedObjectId</code> attribute. However, it is recommended to just set
<code class="literal">includeEmbeddedObjectId=true</code>.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Having explicit control of the indexed paths might be easier if you’re designing your application by
defining the needed queries first, as at that point you might know exactly which fields you need,
and which other fields are unnecessary to implement your use case.</p></div></section><section class="section" id="_indexing_null_embeddeds"><div class="titlepage"><div><div><h4 class="title">4.1.3.2. Indexing null embeddeds</h4></div></div></div><p>Per default null values are ignored and not indexed. However, using <code class="literal">indexNullAs</code> you can specify that a field should be added when the embedded is null, with a value of your choice.</p><p>Per default <code class="literal">indexNullAs</code> is set to <code class="literal">org.hibernate.search.annotations.IndexedEmbedded.DO_NOT_INDEX_NULL</code>, indicating that null values should not be indexed. You can set this value to <code class="literal">IndexedEmbedded.DEFAULT_NULL_TOKEN</code> to indicate that a default null token should be used. This default null token can be specified in the configuration using <code class="literal">hibernate.search.default_null_token</code>. If this property is not set the string <code class="literal">_null_</code> will be used as default.</p><p>The field name used when indexing null values depend on the <code class="literal">prefix</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">if the <code class="literal">prefix</code> is not set, the field name will be the Java property name</li><li class="listitem">if the <code class="literal">prefix</code> is set, the field name will be the prefix with the trailing dot (if any) removed.
For instance with the prefix <code class="literal">my_embedded.</code>, the null field name will be <code class="literal">my_embedded</code> (without dot).</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>When <code class="literal">indexNullAs</code> is used, it is important to use the chosen null token in search queries (see
<a class="xref" href="#search-query" title="Chapter 5. Querying">Chapter 5, <em>Querying</em></a>) in order to find null values.</p></div></section></section><section class="section" id="_associated_objects_building_a_dependency_graph_with_containedin"><div class="titlepage"><div><div><h3 class="title">4.1.4. Associated objects: building a dependency graph with @ContainedIn</h3></div></div></div><p>While <code class="literal">@ContainedIn</code> is often seen as the counterpart of <code class="literal">@IndexedEmbedded</code>, it can also be used
on its own to build an indexing dependency graph.</p><p>When an entity is reindexed, all the entities pointed by <code class="literal">@ContainedIn</code> are also going to be
reindexed.</p></section></section><section class="section" id="section-boosting"><div class="titlepage"><div><div><h2 class="title">4.2. Boosting</h2></div></div></div><p>Lucene has the notion of <span class="emphasis"><em>boosting</em></span> which allows you to give certain documents or fields more or
less importance than others. Lucene differentiates between index and search time boosting. The
following sections show you how you can achieve index time boosting using Hibernate Search.</p><section class="section" id="section-boost-annotation"><div class="titlepage"><div><div><h3 class="title">4.2.1. Static index time boosting</h3></div></div></div><p>To define a static boost value for an indexed class or property you can use the <code class="literal">@Boost</code> annotation.
You can use this annotation within <code class="literal">@Field</code> or specify it directly on method or class level.</p><div class="example" id="example-boost"><div class="example-title">Example 4.14. Different ways of using <code class="literal">@Boost</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@Boost(1.7f)
public class Essay {
    ...

    @Id
    @DocumentId
    public Long getId() { return id; }

    @Field(name="Abstract", store=Store.YES, boost=@Boost(2f))
    @Boost(1.5f)
    public String getSummary() { return summary; }

    @Lob
    @Field(boost=@Boost(1.2f))
    public String getText() { return text; }

    @Field
    public String getISBN() { return isbn; }

}</code></pre></div></div><br class="example-break"/><p>In <a class="xref" href="#example-boost" title="Example 4.14. Different ways of using @Boost">Example 4.14, “Different ways of using <code class="literal">@Boost</code>”</a>, Essay’s probability to reach the top of the search list will be multiplied by
1.7. The summary field will be 3.0 (2 * 1.5, because <code class="literal">@Field.boost</code> and <code class="literal">@Boost</code> on a property are
cumulative) more important than the <code class="literal">isbn</code> field. The text field will be 1.2 times more important than
the <code class="literal">isbn</code> field. Note that this explanation is wrong in strictest terms, but it is simple and close
enough to reality for all practical purposes. Please check the Lucene documentation or the excellent
Lucene In Action from Otis Gospodnetic and Erik Hatcher.</p></section><section class="section" id="section-dynamic-boost"><div class="titlepage"><div><div><h3 class="title">4.2.2. Dynamic index time boosting</h3></div></div></div><p>The <code class="literal">@Boost</code> annotation used in <a class="xref" href="#section-boost-annotation" title="4.2.1. Static index time boosting">Section 4.2.1, “Static index time boosting”</a> defines a static boost factor which
is independent of the state of of the indexed entity at runtime. However, there are use cases in
which the boost factor may depend on the actual state of the entity. In this case you can use the
<code class="literal">@DynamicBoost</code> annotation together with an accompanying custom <code class="literal">BoostStrategy</code>.</p><div class="example" id="example-dynamic-boosting"><div class="example-title">Example 4.15. Dynamic boost example</div><div class="example-contents"><pre><code class="language-java">public enum PersonType {
    NORMAL,
    VIP
}</code></pre><pre><code class="language-java">@Entity
@Indexed
@DynamicBoost(impl = VIPBoostStrategy.class)
public class Person {
    private PersonType type;

    // ...
}</code></pre><pre><code class="language-java">public class VIPBoostStrategy implements BoostStrategy {
    public float defineBoost(Object value) {
        Person person = ( Person ) value;
        if ( person.getType().equals( PersonType.VIP ) ) {
            return 2.0f;
        }
        else {
            return 1.0f;
        }
    }
}</code></pre></div></div><br class="example-break"/><p>In <a class="xref" href="#example-dynamic-boosting" title="Example 4.15. Dynamic boost example">Example 4.15, “Dynamic boost example”</a> a dynamic boost is defined on class level specifying
<code class="literal">VIPBoostStrategy</code> as implementation of the <code class="literal">BoostStrategy</code> interface to be used at indexing time. You
can place the <code class="literal">@DynamicBoost</code> either at class or field level. Depending on the placement of the
annotation either the whole entity is passed to the <code class="literal">defineBoost</code> method or just the annotated
field/property value. It’s up to you to cast the passed object to the correct type. In the example
all indexed values of a VIP person would be double as important as the values of a normal person.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The specified <code class="literal">BoostStrategy</code> implementation must define a public no-arg constructor.</p></div><p>Of course you can mix and match <code class="literal">@Boost</code> and <code class="literal">@DynamicBoost</code> annotations in your entity. All
defined boost factors are cumulative.</p></section></section><section class="section" id="_analysis"><div class="titlepage"><div><div><h2 class="title">4.3. Analysis</h2></div></div></div><p>Analysis is the process of converting text into single terms (words) and can be considered as one
of the key features of a fulltext search engine. Lucene uses the concept of Analyzers to control
this process. In the following section we cover the multiple ways Hibernate Search offers to
configure the analyzers.</p><section class="section" id="analyzer"><div class="titlepage"><div><div><h3 class="title">4.3.1. Default analyzer and analyzer by class</h3></div></div></div><p>The default analyzer class used to index tokenized fields is configurable through the
<code class="literal">hibernate.search.analyzer</code> property. The default value for this property is
<code class="literal">org.apache.lucene.analysis.standard.StandardAnalyzer</code>.</p><p>You can also define the analyzer class per entity, property and even per <code class="literal">@Field</code> (useful when
multiple fields are indexed from a single property).</p><div class="example" id="d0e3816"><div class="example-title">Example 4.16. Different ways of using @Analyzer</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@Analyzer(impl = EntityAnalyzer.class)
public class MyEntity {
    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    private String name;

    @Field
    @Analyzer(impl = PropertyAnalyzer.class)
    private String summary;

    @Field(analyzer = @Analyzer(impl = FieldAnalyzer.class)
    private String body;

    ...
}</code></pre></div></div><br class="example-break"/><p>In this example, <code class="literal">EntityAnalyzer</code> is used to index all tokenized properties (eg. <code class="literal">name</code>), except
<code class="literal">summary</code> and <code class="literal">body</code> which are indexed with <code class="literal">PropertyAnalyzer</code> and <code class="literal">FieldAnalyzer</code> respectively.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="caution"><h2>Caution</h2><p>Mixing different analyzers in the same entity is most of the time a bad practice. It makes query
building more complex and results less predictable (for the novice), especially if you are using a
<code class="literal">QueryParser</code> (which uses the same analyzer for the whole query). As a rule of thumb, for any given
field the same analyzer should be used for indexing and querying.</p></div></section><section class="section" id="section-named-analyzers"><div class="titlepage"><div><div><h3 class="title">4.3.2. Named analyzers</h3></div></div></div><p>Analyzers can become quite complex to deal with. For this reason introduces Hibernate Search the
notion of analyzer definitions. An analyzer definition can be reused by many <code class="literal">@Analyzer</code> declarations
and is composed of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">a name: the unique string used to refer to the definition</li><li class="listitem">a list of char filters: each char filter is responsible to pre-process input characters before the
tokenization. Char filters can add, change or remove characters; one common usage is for characters
normalization</li><li class="listitem">a tokenizer: responsible for tokenizing the input stream into individual words</li><li class="listitem">a list of filters: each filter is responsible to remove, modify or sometimes even add words into
the stream provided by the tokenizer</li></ul></div><p>This separation of tasks - a list of char filters, and a tokenizer followed by a list of filters -
allows for easy reuse of each individual component and let you build your customized analyzer in a
very flexible way (just like Lego). Generally speaking the char filters do some pre-processing in
the character input, then the Tokenizer starts the tokenizing process by turning the character input
into tokens which are then further processed by the TokenFilters. Hibernate Search supports this
infrastructure by utilizing the advanced analyzers provided by Lucene; this is often referred to as
the Analyzer Framework.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Some of the analyzers and filters will require additional dependencies. For example to use the
snowball stemmer you have to also include the <code class="literal">lucene-snowball</code> jar and for the
<code class="literal">PhoneticFilterFactory</code> you need the <a class="link" href="http://commons.apache.org/codec">commons-codec</a> jar. Your
distribution of Hibernate Search provides these dependencies in its <span class="emphasis"><em>lib/optional</em></span> directory. Have a
look at <a class="xref" href="#table-available-tokenizers" title="Table 4.2. Example of available tokenizers">Table 4.2, “Example of available tokenizers”</a> and <a class="xref" href="#table-available-filters" title="Table 4.3. Examples of available filters">Table 4.3, “Examples of available filters”</a> to see which analyzers and
filters have additional dependencies</p><p>Prior to Hibernate Search 5 it was required to add the Apache Solr dependency to your project as
well; this is no longer required.</p></div><p>Let’s have a look at a concrete example now - <a class="xref" href="#example-analyzer-def" title="Example 4.17. @AnalyzerDef and the Analyzer Framework">Example 4.17, “@AnalyzerDef and the Analyzer Framework”</a>. First a char filter is
defined by its factory. In our example, a mapping char filter is used, and will replace characters
in the input based on the rules specified in the mapping file. Next a tokenizer is defined. This
example uses the standard tokenizer. Last but not least, a list of filters is defined by their
factories. In our example, the StopFilter filter is built reading the dedicated words property file.
The filter is also expected to ignore case.</p><div class="example" id="example-analyzer-def"><div class="example-title">Example 4.17. @AnalyzerDef and the Analyzer Framework</div><div class="example-contents"><pre><code class="language-java">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ASCIIFoldingFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/stoplist.properties" ),
      @Parameter(name="ignoreCase", value="true")
    })
})
public class Team {
    // ...
}</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Filters and char filters are applied in the order they are defined in the <code class="literal">@AnalyzerDef</code> annotation.
Order matters!</p></div><p>Some tokenizers, token filters or char filters load resources like a configuration or metadata file.
This is the case for the stop filter and the synonym filter.</p><div class="example" id="example-analyzer-def-charset"><div class="example-title">Example 4.18. Use a specific charset to load the property file</div><div class="example-contents"><pre><code class="language-java">@AnalyzerDef(name="customanalyzer",
  charFilters = {
    @CharFilterDef(factory = MappingCharFilterFactory.class, params = {
      @Parameter(name = "mapping",
        value = "org/hibernate/search/test/analyzer/mapping-chars.properties")
    })
  },
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
  filters = {
    @TokenFilterDef(factory = ASCIIFoldingFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class, params = {
      @Parameter(name="words",
        value= "org/hibernate/search/test/analyzer/stoplist.properties" ),
      @Parameter(name="ignoreCase", value="true")
  })
})
public class Team {
    // ...
}</code></pre></div></div><br class="example-break"/><p>Once defined, an analyzer definition can be reused by an <code class="literal">@Analyzer</code> declaration as seen in
<a class="xref" href="#example-referencing-analyzer-def" title="Example 4.19. Referencing an analyzer by name">Example 4.19, “Referencing an analyzer by name”</a>.</p><div class="example" id="example-referencing-analyzer-def"><div class="example-title">Example 4.19. Referencing an analyzer by name</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@AnalyzerDef(name="customanalyzer", ... )
public class Team {
    @Id
    @DocumentId
    @GeneratedValue
    private Integer id;

    @Field
    private String name;

    @Field
    private String location;

    @Field
    @Analyzer(definition = "customanalyzer")
    private String description;
}</code></pre></div></div><br class="example-break"/><p>Analyzer instances declared by <code class="literal">@AnalyzerDef</code> are also available by their name in the <code class="literal">SearchFactory</code>
which is quite useful wen building queries.</p><div class="informalexample"><pre><code class="language-java">Analyzer analyzer = fullTextSession.getSearchFactory().getAnalyzer("customanalyzer");</code></pre></div><p>Fields in queries should be analyzed with the same analyzer used to index the field so that they
speak a common "language": the same tokens are reused between the query and the indexing process.
This rule has some exceptions but is true most of the time. Respect it unless you know what you are
doing.</p><section class="section" id="_available_analyzers"><div class="titlepage"><div><div><h4 class="title">4.3.2.1. Available analyzers</h4></div></div></div><p>Apache Lucene comes with a lot of useful default char filters, tokenizers and filters.
You can find a complete list of char filter factories, tokenizer factories and filter factories at
<a class="link" href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters">http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters</a>.
Let’s check a few of them.</p><div class="table" id="table-available-char-filters"><div class="table-title">Table 4.1. Example of available char filters</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 25*; " class="col_1"/><col style="width: 25*; " class="col_2"/><col style="width: 25*; " class="col_3"/><col style="width: 25*; " class="col_4"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Factory</th><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Description</th><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Parameters</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Additional dependencies</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">MappingCharFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Replaces one or more characters with one or more characters, based on
mappings specified in the resource file</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">mapping</code>: points to a resource file containing the mappings
using the format:
"á" ⇒ "a"<br/>
"ñ" ⇒ "n"<br/>
"ø" ⇒ "o"</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p><code class="literal">HTMLStripCharFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>Remove HTML standard tags, keeping the text</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>none</p></td><td style="text-align: left; vertical-align: top; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr></tbody></table></div></div><br class="table-break"/><div class="table" id="table-available-tokenizers"><div class="table-title">Table 4.2. Example of available tokenizers</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 25*; " class="col_1"/><col style="width: 25*; " class="col_2"/><col style="width: 25*; " class="col_3"/><col style="width: 25*; " class="col_4"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Factory</th><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Description</th><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Parameters</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Additional dependencies</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">StandardTokenizerFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Use the Lucene StandardTokenizer</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>none</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">HTMLStripCharFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Remove HTML tags, keep the text and pass it to a
                <code class="literal">StandardTokenizer</code>.</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>none</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p><code class="literal">PatternTokenizerFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>Breaks text at the specified regular expression
                pattern.</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p><code class="literal">pattern</code>: the regular expression to use for tokenizing
</p><p>group: says which pattern group to extract into tokens</p></td><td style="text-align: left; vertical-align: top; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr></tbody></table></div></div><br class="table-break"/><div class="table" id="table-available-filters"><div class="table-title">Table 4.3. Examples of available filters</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 25*; " class="col_1"/><col style="width: 25*; " class="col_2"/><col style="width: 25*; " class="col_3"/><col style="width: 25*; " class="col_4"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Factory</th><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Description</th><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Parameters</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Additional dependencies</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">StandardFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Remove dots from acronyms and 's from words</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>none</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">LowerCaseFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Lowercases all words</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>none</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">StopFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Remove words (tokens) matching a list of stop
                words</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">words</code>: points to a resource file containing the stop words
</p><p><code class="literal">ignoreCase</code>: true if <code class="literal">case</code> should be ignore when comparing stop words, <code class="literal">false</code> otherwise</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">SnowballPorterFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Reduces a word to it’s root in a given language. (eg.
                protect, protects, protection share the same root). Using such
                a filter allows searches matching related words.</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">language</code>: Danish, Dutch, English,
                Finnish, French, German, Italian, Norwegian, Portuguese,
                Russian, Spanish, Swedish and a few more</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">ASCIIFoldingFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Remove accents for languages like French</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>none</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">lucene-analyzers-common</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">PhoneticFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>Inserts phonetically similar tokens into the token
                stream</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">encoder</code>: One of <code class="literal">DoubleMetaphone</code>, <code class="literal">Metaphone</code>, <code class="literal">Soundex</code> or <code class="literal">RefinedSoundex</code>
</p><p><code class="literal">inject</code>: true will add tokens to the stream, false will replace the existing token
</p><p><code class="literal">maxCodeLength</code>: sets the maximum length of the code to be generated. Supported only for Metaphone and DoubleMetaphone encodings</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><code class="literal">lucene-analyzers-phonetic</code> and
                <code class="literal">commons-codec</code></p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p><code class="literal">CollationKeyFilterFactory</code></p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>Converts each token into its
                <code class="literal">java.text.CollationKey</code>, and then
                encodes the <code class="literal">CollationKey</code> with
                <code class="literal">IndexableBinaryStringTools</code>, to allow it
                to be stored as an index term.</p></td><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p><code class="literal">custom</code>, <code class="literal">language</code>,
                <code class="literal">country</code>, <code class="literal">variant</code>,
                <code class="literal">strength</code>, `decomposition
                `see Lucene’s
                CollationKeyFilter javadocs for more
                info</p></td><td style="text-align: left; vertical-align: top; "><p><code class="literal">lucene-analyzers-common</code> and
                <code class="literal">commons-io</code></p></td></tr></tbody></table></div></div><br class="table-break"/><p>We recommend to check out the implementations of <code class="literal">org.apache.lucene.analysis.util.TokenizerFactory</code>
and <code class="literal">org.apache.lucene.analysis.util.TokenFilterFactory</code> in your IDE to see the implementations
available.</p></section></section><section class="section" id="_dynamic_analyzer_selection"><div class="titlepage"><div><div><h3 class="title">4.3.3. Dynamic analyzer selection</h3></div></div></div><p>So far all the introduced ways to specify an analyzer were static. However, there are use cases
where it is useful to select an analyzer depending on the current state of the entity to be indexed,
for example in a multilingual applications. For an <code class="literal">BlogEntry</code> class for example the analyzer could
depend on the language property of the entry. Depending on this property the correct language
specific stemmer should be chosen to index the actual text.</p><p>To enable this dynamic analyzer selection Hibernate Search introduces the <code class="literal">@AnalyzerDiscriminator</code>
annotation. <a class="xref" href="#example-analyzer-discriminator" title="Example 4.20. Usage of @AnalyzerDiscriminator">Example 4.20, “Usage of <code class="literal">@AnalyzerDiscriminator</code>”</a> demonstrates the usage of this annotation.</p><div class="example" id="example-analyzer-discriminator"><div class="example-title">Example 4.20. Usage of <code class="literal">@AnalyzerDiscriminator</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class
      )
    }),
  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
    })
})
public class BlogEntry {

    @Id
    @GeneratedValue
    @DocumentId
    private Integer id;

    @Field
    @AnalyzerDiscriminator(impl = LanguageDiscriminator.class)
    private String language;

    @Field
    private String text;

    private Set&lt;BlogEntry&gt; references;

    // standard getter/setter
    // ...
}</code></pre><pre><code class="language-java">public class LanguageDiscriminator implements Discriminator {

    public String getAnalyzerDefinitionName(Object value, Object entity, String field) {
        if ( value == null || !( entity instanceof Article ) ) {
            return null;
        }
        return (String) value;

    }
}</code></pre></div></div><br class="example-break"/><p>The prerequisite for using <code class="literal">@AnalyzerDiscriminator</code> is that all analyzers which are going to be used
dynamically are predefined via <code class="literal">@AnalyzerDef</code> definitions. If this is the case, one can place the
<code class="literal">@AnalyzerDiscriminator</code> annotation either on the class or on a specific property of the entity for
which to dynamically select an analyzer. Via the <code class="literal">impl</code> parameter of the <code class="literal">@AnalyzerDiscriminator</code> you
specify a concrete implementation of the <code class="literal">Discriminator</code> interface. It is up to you to provide an
implementation for this interface. The only method you have to implement is
<code class="literal">getAnalyzerDefinitionName()</code> which gets called for each field added to the Lucene document. The
entity which is getting indexed is also passed to the interface method. The <code class="literal">value</code> parameter is
only set if the <code class="literal">AnalyzerDiscriminator</code> is placed on property level instead of class level. In this
case the value represents the current value of this property.</p><p>An implementation of the <code class="literal">Discriminator</code> interface has to return the name of an existing analyzer
definition or null if the default analyzer should not be overridden.
<a class="xref" href="#example-analyzer-discriminator" title="Example 4.20. Usage of @AnalyzerDiscriminator">Example 4.20, “Usage of <code class="literal">@AnalyzerDiscriminator</code>”</a> assumes that the language parameter is either 'de' or 'en' which matches the
specified names in the @AnalyzerDefs.</p></section><section class="section" id="analyzer-retrievinganalyzer"><div class="titlepage"><div><div><h3 class="title">4.3.4. Retrieving an analyzer</h3></div></div></div><p>In some situations retrieving analyzers can be handy. For example, if your domain model makes use of
multiple analyzers (maybe to benefit from stemming, use phonetic approximation and so on), you need
to make sure to use the same analyzers when you build your query.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>This rule can be broken but you need a good reason for it. If you are unsure, use the same
analyzers. If you use the Hibernate Search query DSL (see <a class="xref" href="#search-query-querydsl" title="5.1.2. Building a Lucene query with the Hibernate Search query DSL">Section 5.1.2, “Building a Lucene query with the Hibernate Search query DSL”</a>), you don’t have
to think about it. The query DSL does use the right analyzer transparently for you.</p></div><p>Whether you are using the Lucene programmatic API or the Lucene query parser, you can retrieve the
scoped analyzer for a given entity. A scoped analyzer is an analyzer which applies the right
analyzers depending on the field indexed. Remember, multiple analyzers can be defined on a given
entity each one working on an individual field. A scoped analyzer unifies all these analyzers into a
context-aware analyzer. While the theory seems a bit complex, using the right analyzer in a query is
very easy.</p><div class="example" id="d0e4341"><div class="example-title">Example 4.21. Using the scoped analyzer when building a full-text query</div><div class="example-contents"><pre><code class="language-java">org.apache.lucene.queryparser.classic.QueryParser parser = new QueryParser(
    "title",
    fullTextSession.getSearchFactory().getAnalyzer( Song.class )
);

org.apache.lucene.search.Query luceneQuery =
    parser.parse( "title:sky Or title_stemmed:diamond" );

org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery( luceneQuery, Song.class );

List result = fullTextQuery.list(); //return a list of managed objects</code></pre></div></div><br class="example-break"/><p>In the example above, the song title is indexed in two fields: the standard analyzer is used in the
field <code class="literal">title</code> and a stemming analyzer is used in the field <code class="literal">title_stemmed</code>. By using the
analyzer provided by the search factory, the query uses the appropriate analyzer depending on the
field targeted.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>You can also retrieve analyzers defined via <code class="literal">@AnalyzerDef</code> by their definition name using
<code class="literal">searchFactory.getAnalyzer(String)</code>.</p></div></section></section><section class="section" id="search-mapping-bridge"><div class="titlepage"><div><div><h2 class="title">4.4. Bridges</h2></div></div></div><p>When discussing the basic mapping for an entity one important fact was so far disregarded. In Lucene
all index fields have to be represented as strings. All entity properties annotated with <code class="literal">@Field</code>
have to be converted to strings to be indexed. The reason we have not mentioned it so far is, that
for most of your properties Hibernate Search does the translation job for you thanks to a set of
built-in bridges. However, in some cases you need a more fine grained control over the translation
process.</p><section class="section" id="section-built-in-bridges"><div class="titlepage"><div><div><h3 class="title">4.4.1. Built-in bridges</h3></div></div></div><p>Hibernate Search comes bundled with a set of built-in bridges between a Java property type and its
full text representation.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">null</code></span></dt><dd>Per default <code class="literal">null</code> elements are not indexed. Lucene does not support <code class="literal">null</code> elements.
However, in some situation it can be useful to insert a custom token representing the <code class="literal">null</code> value.
See <a class="xref" href="#field-annotation" title="4.1.1.2. @Field">Section 4.1.1.2, “@Field”</a> for more information.</dd><dt><span class="term"><code class="literal">java.lang.String</code></span></dt><dd>Strings are indexed as are</dd><dt><span class="term"><code class="literal">short</code>, <code class="literal">Short</code>, <code class="literal">integer</code>, <code class="literal">Integer</code>, <code class="literal">long</code>, <code class="literal">Long</code>, <code class="literal">float</code>, <code class="literal">Float</code>, <code class="literal">double</code>, <code class="literal">Double</code></span></dt><dd>Are
per default indexed numerically using a <a class="link" href="http://en.wikipedia.org/wiki/Trie">Trie structure</a>. You
need to use a <code class="literal">NumericRangeQuery</code> to search for values. See also <a class="xref" href="#field-annotation" title="4.1.1.2. @Field">Section 4.1.1.2, “@Field”</a> and
<a class="xref" href="#numeric-field-annotation" title="4.1.1.3. @NumericField">Section 4.1.1.3, “@NumericField”</a></dd><dt><span class="term"><code class="literal">BigInteger</code>, <code class="literal">BigDecimal</code></span></dt><dd><code class="literal">BigInteger</code> and <code class="literal">BigDecimal</code> are converted into their string representation and indexed. Note that
in this form the values cannot be compared by Lucene using for example a <code class="literal">TermRangeQuery</code>.
For that the string representation would need to be padded. An alternative using numeric encoding
with a potential loss in precision can be seen in <a class="xref" href="#example-custom-numericfieldbridge" title="Example 4.2. Defining a custom NumericFieldBridge for BigDecimal">Example 4.2, “Defining a custom NumericFieldBridge for <code class="literal">BigDecimal</code>”</a>.</dd><dt><span class="term"><code class="literal">java.util.Date</code>, <code class="literal">java.util.Calendar</code></span></dt><dd><p class="simpara">Dates are indexed as <code class="literal">long</code> value representing the number
of milliseconds since <span class="emphasis"><em>January 1, 1970, 00:00:00 GMT</em></span>. You shouldn’t really bother with the
internal format. It is important, however, to query a numerically indexed date via a <code class="literal">NumericRangeQuery</code>.</p><p class="simpara">Usually, storing the date up to the millisecond is not necessary. <code class="literal">@DateBridge</code> defines the
appropriate resolution you are willing to store in the index.</p></dd><dt><span class="term"><code class="literal">java.time.Year</code></span></dt><dd>converts the year to the integer representation.</dd><dt><span class="term"><code class="literal">java.time.Duration</code></span></dt><dd>converts the duration to the total length in nanoseconds.</dd><dt><span class="term"><code class="literal">java.time.Instant</code></span></dt><dd>converts the instant to the number of milliseconds from Epoch.
Note that these values are indexed with a precision to the millisecond.</dd></dl></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>Note that it must be possible to convert the <code class="literal">Instant</code> or the <code class="literal">Duration</code> to a <code class="literal">Long</code>.
If these values are too big or too small an exception is thrown.</p></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">LocalDate</code>, <code class="literal">LocalTime</code>, <code class="literal">LocalDateTime</code>, <code class="literal">LocalTime</code>, <code class="literal">MonthDay</code>, <code class="literal">OffsetDateTime</code>, <code class="literal">OffsetTime</code>, <code class="literal">Period</code>, <code class="literal">YearMonth</code>, <code class="literal">ZoneDateTime</code>, <code class="literal">ZoneId</code>, <code class="literal">ZoneOffset</code></span></dt><dd>the bridges
for these classes in the <code class="literal">java.time</code> package store the values as string padded with 0 when required to allow sorting.</dd></dl></div><div class="informalexample"><pre><code class="language-java">@Entity
@Indexed
public class Meeting {
    @Field(analyze=Analyze.NO)
    @DateBridge(resolution=Resolution.MINUTE)
    private Date date;
    // ...</code></pre></div><p>You can also choose to encode the date as string using the <code class="literal">encoding=EncodingType.STRING</code> of
<code class="literal">DateBridge</code>. In this case the dates are stored in the format <span class="emphasis"><em>yyyyMMddHHmmssSSS</em></span> (using GMT time).</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>A Date whose resolution is lower than <code class="literal">MILLISECOND</code> cannot be a <code class="literal">@DocumentId</code></p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>The default date bridge uses Lucene’s <code class="literal">DateTools</code> to convert from <code class="literal">Date</code> or <code class="literal">Calendar</code> to its indexed
value. This means that all dates are expressed in GMT time. If your requirements are to store dates
in a fixed time zone you have to implement a custom date bridge.</p></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">java.net.URI</code>, <code class="literal">java.net.URL</code></span></dt><dd><code class="literal">URI</code> and <code class="literal">URL</code> are converted to their string representation</dd><dt><span class="term"><code class="literal">java.lang.Class</code></span></dt><dd>Classes are converted to their fully qualified class name. The thread context
classloader is used when the class is rehydrated</dd></dl></div></section><section class="section" id="_tika_bridge"><div class="titlepage"><div><div><h3 class="title">4.4.2. Tika bridge</h3></div></div></div><p>Hibernate Search allows you to extract text from various document types using the built-in
<code class="literal">TikaBridge</code> which utilizes <a class="link" href="http://tika.apache.org">Apache Tika</a> to extract text and metadata
from the provided documents. The <code class="literal">@TikaBridge</code> annotation can be used with <code class="literal">String</code>, <code class="literal">URI</code>, <code class="literal">byte[]</code> or
<code class="literal">java.sql.Blob</code> properties. In the case of <code class="literal">String</code> and <code class="literal">URI</code> the bridge interprets the values are file
paths and tries to open a file to parse the document. In the case of <code class="literal">byte[]</code> and <code class="literal">Blob</code> the values are
directly passed to Tika for parsing.</p><p>Tika uses metadata as in- and output of the parsing process and it also allows to provide additional
context information. This process is described in
<a class="link" href="http://tika.apache.org/1.1/parser.html#apiorgapachetikametadataMetadata.html">Parser interface</a>.
The Hibernate Search Tika bridge allows you to make use of these additional
configuration options by providing two interfaces in conjunction with <code class="literal">TikaBridge</code>. The first
interface is the <code class="literal">TikaParseContextProvider</code>. It allows you to create a custom <code class="literal">ParseContext</code> for the
document parsing. The second interface is <code class="literal">TikaMetadataProcessor</code> which has two methods -
<code class="literal">prepareMetadata()</code> and <code class="literal">set(String, Object, Document, LuceneOptions, Metadata metadata)</code>. The former
allows to add additional metadata to the parsing process (for example the file name) and the latter
allows you to index metadata discovered during the parsing process.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Sortable fields with Tika</h2><p>If you want to add multiple fields in your <code class="literal">TikaMetadataProcessor</code>, and also want to make those
fields sortable, you should make your processor implement the <code class="literal">MetadataProvidingTikaMetadataProcessor</code>.
This is similar to implementing <code class="literal">MetadataProvidingFieldBridge</code> on a regular field bridge: see <a class="xref" href="#sortablefield-annotation" title="4.1.1.4. @SortableField">Section 4.1.1.4, “@SortableField”</a>.</p><p>Like <code class="literal">MetadataProvidingFieldBridge</code>, the <code class="literal">MetadataProvidingTikaMetadataProcessor</code> contract is under active development and considered experimental at this time. It may be altered in future revisions, e.g. by adding further methods, thus breaking existing implementations.</p></div><p><code class="literal">TikaParseContextProvider</code> as well as <code class="literal">TikaMetadataProcessor</code> implementation classes can both be
specified as parameters on the <code class="literal">TikaBridge</code> annotation.</p><div class="example" id="example-tika-mapping"><div class="example-title">Example 4.22. Example mapping with Apache Tika</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Song {
    @Id
    @GeneratedValue
    long id;

    @Field
    @TikaBridge(metadataProcessor = Mp3TikaMetadataProcessor.class)
    String mp3FileName;

    // ...
}</code></pre><pre><code class="language-java">QueryBuilder queryBuilder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
    .forEntity( Song.class )
    .get();
Query query = queryBuilder.keyword()
    .onField( "mp3FileName" )
    .ignoreFieldBridge() //mandatory
    .matching( "Apes" )
    .createQuery();
List result = fullTextSession.createFullTextQuery( query ).list();</code></pre></div></div><br class="example-break"/><p>In the <a class="xref" href="#example-tika-mapping" title="Example 4.22. Example mapping with Apache Tika">Example 4.22, “Example mapping with Apache Tika”</a> the property <code class="literal">mp3FileName</code> represents a path to an MP3 file; the
headers of this file will be indexed and so the performed query will be able to match the MP3
metadata.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p><code class="literal">TikaBridge</code> does not implement <code class="literal">TwoWayFieldBridge</code>: queries built using the DSL (as in the
<a class="xref" href="#example-tika-mapping" title="Example 4.22. Example mapping with Apache Tika">Example 4.22, “Example mapping with Apache Tika”</a>) need to explicitly enable the option ignoreFieldBridge().</p></div></section><section class="section" id="section-custom-bridges"><div class="titlepage"><div><div><h3 class="title">4.4.3. Custom bridges</h3></div></div></div><p>Sometimes, the built-in bridges of Hibernate Search do not cover some of your property types, or the
<code class="literal">String</code> representation used by the bridge does not meet your requirements. The following paragraphs
describe several solutions to this problem.</p><section class="section" id="_stringbridge"><div class="titlepage"><div><div><h4 class="title">4.4.3.1. StringBridge</h4></div></div></div><p>The simplest custom solution is to give Hibernate Search an implementation of your expected <code class="literal">Object</code>
to <code class="literal">String</code> bridge. To do so you need to implement the <code class="literal">org.hibernate.search.bridge.StringBridge</code>
interface. All implementations have to be thread-safe as they are used concurrently.</p><div class="example" id="example-custom-string-bridge"><div class="example-title">Example 4.23. Custom <code class="literal">StringBridge</code> implementation</div><div class="example-contents"><pre><code class="language-java">/**
 * Padding Integer bridge.
 * All numbers will be padded with 0 to match 5 digits
 *
 * @author Emmanuel Bernard
 */
public class PaddedIntegerBridge implements StringBridge {

    private int padding = 5;

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder();
        for (int padIndex = rawInteger.length(); padIndex &lt; padding; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append( rawInteger ).toString();
    }
}</code></pre></div></div><br class="example-break"/><p>Given the string bridge defined in <a class="xref" href="#example-custom-string-bridge" title="Example 4.23. Custom StringBridge implementation">Example 4.23, “Custom <code class="literal">StringBridge</code> implementation”</a>, any property or field can use
this bridge thanks to the <code class="literal">@FieldBridge</code> annotation:</p><div class="informalexample"><pre><code class="language-java">@FieldBridge(impl = PaddedIntegerBridge.class)
private Integer length;</code></pre></div><section class="section" id="_parameterized_bridge"><div class="titlepage"><div><div><h5 class="title">4.4.3.1.1. Parameterized bridge</h5></div></div></div><p>Parameters can also be passed to the bridge implementation making it more flexible.
<a class="xref" href="#example-passing-bridge-parameters" title="Example 4.24. Passing parameters to your bridge implementation">Example 4.24, “Passing parameters to your bridge implementation”</a> implements a <code class="literal">ParameterizedBridge</code> interface and parameters are
passed through the <code class="literal">@FieldBridge</code> annotation.</p><div class="example" id="example-passing-bridge-parameters"><div class="example-title">Example 4.24. Passing parameters to your bridge implementation</div><div class="example-contents"><pre><code class="language-java">public class PaddedIntegerBridge implements StringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map&lt;String,String&gt; parameters) {
        String padding = parameters.get( PADDING_PROPERTY );
        if (padding != null) this.padding = Integer.parseInt( padding );
    }

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder( );
        for (int padIndex = rawInteger.length(); padIndex &lt; padding; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append(rawInteger).toString();
    }
}</code></pre><pre><code class="language-java">//on the property:
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
            )
private Integer length;</code></pre></div></div><br class="example-break"/><p>The <code class="literal">ParameterizedBridge</code> interface can be implemented by <code class="literal">StringBridge</code>, <code class="literal">TwoWayStringBridge</code>,
<code class="literal">FieldBridge</code> implementations.</p><p>All implementations have to be thread-safe, but the parameters are set during initialization and no
special care is required at this stage.</p></section><section class="section" id="_type_aware_bridge"><div class="titlepage"><div><div><h5 class="title">4.4.3.1.2. Type aware bridge</h5></div></div></div><p>It is sometimes useful to get the type the bridge is applied on:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the return type of the property for field/getter-level bridges</li><li class="listitem">the class type for class-level bridges</li></ul></div><p>An example is a bridge that deals with enums in a custom fashion but needs to access the actual enum
type. Any bridge implementing <code class="literal">AppliedOnTypeAwareBridge</code> will get the type the bridge is applied on
injected. Like parameters, the type injected needs no particular care with regard to thread-safety.</p></section><section class="section" id="_two_way_bridge"><div class="titlepage"><div><div><h5 class="title">4.4.3.1.3. Two-way bridge</h5></div></div></div><p>If you expect to use your bridge implementation on an id property (ie annotated with <code class="literal">@DocumentId</code>
), you need to use a slightly extended version of <code class="literal">StringBridge</code> named <code class="literal">TwoWayStringBridge</code>. Hibernate
Search needs to read the string representation of the identifier and generate the object out of it.
There is no difference in the way the <code class="literal">@FieldBridge</code> annotation is used.</p><div class="example" id="d0e4852"><div class="example-title">Example 4.25. Implementing a <code class="literal">TwoWayStringBridge</code> usable for id properties</div><div class="example-contents"><pre><code class="language-java">public class PaddedIntegerBridge implements TwoWayStringBridge, ParameterizedBridge {

    public static String PADDING_PROPERTY = "padding";
    private int padding = 5; //default

    public void setParameterValues(Map parameters) {
        Object padding = parameters.get(PADDING_PROPERTY);
        if (padding != null) this.padding = (Integer) padding;
    }

    public String objectToString(Object object) {
        String rawInteger = ((Integer) object).toString();
        if (rawInteger.length() &gt; padding)
            throw new IllegalArgumentException("Number too big to be padded");
        StringBuilder paddedInteger = new StringBuilder();
        for (int padIndex = rawInteger.length(); padIndex &lt; padding ; padIndex++) {
            paddedInteger.append('0');
        }
        return paddedInteger.append(rawInteger).toString();
    }

    public Object stringToObject(String stringValue) {
        return new Integer(stringValue);
    }
}</code></pre><pre><code class="language-java">//On an id property:
@DocumentId
@FieldBridge(impl = PaddedIntegerBridge.class,
             params = @Parameter(name="padding", value="10")
private Integer id;</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>It is important for the two-way process to be idempotent
(ie <code class="literal">object = stringToObject(objectToString( object ) )</code> ).</p></div></section></section><section class="section" id="section-filed-bridge"><div class="titlepage"><div><div><h4 class="title">4.4.3.2. FieldBridge</h4></div></div></div><p>Some use cases require more than a simple object to string translation when mapping a property to a
Lucene index. To give you the greatest possible flexibility you can also implement a bridge as a
<code class="literal">FieldBridge</code>. This interface gives you a property value and let you map it the way you want in your
Lucene <code class="literal">Document</code>. You can for example store a property in two different document fields. The
interface is very similar in its concept to the Hibernate ORM <code class="literal">UserTypes</code>.</p><div class="example" id="example-field-bridge"><div class="example-title">Example 4.26. Implementing the FieldBridge interface</div><div class="example-contents"><pre><code class="language-java">/**
 * Store the date in 3 different fields - year, month, day - to ease the creation of RangeQuery per
 * year, month or day (eg get all the elements of December for the last 5 years).
 * @author Emmanuel Bernard
 */
public class DateSplitBridge implements FieldBridge {
    private final static TimeZone GMT = TimeZone.getTimeZone("GMT");

    public void set(String name, Object value, Document document,
                    LuceneOptions luceneOptions) {
        Date date = (Date) value;
        Calendar cal = GregorianCalendar.getInstance(GMT);
        cal.setTime(date);
        int year = cal.get(Calendar.YEAR);
        int month = cal.get(Calendar.MONTH) + 1;
        int day = cal.get(Calendar.DAY_OF_MONTH);

        // set year
        luceneOptions.addFieldToDocument(
            name + ".year",
            String.valueOf( year ),
            document );

        // set month and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".month",
            month &lt; 10 ? "0" : "" + String.valueOf( month ),
            document );

        // set day and pad it if needed
        luceneOptions.addFieldToDocument(
            name + ".day",
            day &lt; 10 ? "0" : "" + String.valueOf( day ),
            document );
    }
}</code></pre><pre><code class="language-java">//property
@FieldBridge(impl = DateSplitBridge.class)
private Date date;</code></pre></div></div><br class="example-break"/><p>In <a class="xref" href="#example-field-bridge" title="Example 4.26. Implementing the FieldBridge interface">Example 4.26, “Implementing the FieldBridge interface”</a> the fields are not added directly to <code class="literal">Document</code>. Instead the addition is
delegated to the <code class="literal">LuceneOptions</code> helper; this helper will apply the options you have selected on
<code class="literal">@Field</code>, like <code class="literal">Store</code> or <code class="literal">TermVector</code>, or apply the chosen <code class="literal">@Boost</code> value. It is especially useful
to encapsulate the complexity of <code class="literal">COMPRESS</code> implementations. Even though it is recommended to
delegate to <code class="literal">LuceneOptions</code> to add fields to the <code class="literal">Document</code>, nothing stops you from editing the
<code class="literal">Document</code> directly and ignore the LuceneOptions in case you need to.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Classes like <code class="literal">LuceneOptions</code> are created to shield your application from changes in Lucene API and
simplify your code. Use them if you can, but if you need more flexibility you’re not required to.</p></div></section><section class="section" id="_classbridge"><div class="titlepage"><div><div><h4 class="title">4.4.3.3. ClassBridge</h4></div></div></div><p>It is sometimes useful to combine more than one property of a given entity and index this
combination in a specific way into the Lucene index. The <code class="literal">@ClassBridge</code> and <code class="literal">@ClassBridges</code>
annotations can be defined at class level (as opposed to the property level). In this case the
custom field bridge implementation receives the entity instance as the value parameter instead of a
particular property. Though not shown in <a class="xref" href="#example-class-bridge" title="Example 4.27. Implementing a class bridge">Example 4.27, “Implementing a class bridge”</a>, <code class="literal">@ClassBridge</code> supports the
<code class="literal">termVector</code> attribute discussed in section <a class="xref" href="#basic-mapping" title="4.1.1. Basic mapping">Section 4.1.1, “Basic mapping”</a>.</p><div class="example" id="example-class-bridge"><div class="example-title">Example 4.27. Implementing a class bridge</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@ClassBridge(name="branchnetwork",
             store=Store.YES,
             impl = CatFieldsClassBridge.class,
             params = @Parameter( name="sepChar", value=" " ) )
public class Department {
    private int id;
    private String network;
    private String branchHead;
    private String branch;
    private Integer maxEmployees
    // ...
}</code></pre><pre><code class="language-java">public class CatFieldsClassBridge implements FieldBridge, ParameterizedBridge {
    private String sepChar;

    public void setParameterValues(Map parameters) {
        this.sepChar = (String) parameters.get( "sepChar" );
    }

    public void set(
        String name, Object value, Document document, LuceneOptions luceneOptions) {
        // In this particular class the name of the new field was passed
        // from the name field of the ClassBridge Annotation. This is not
        // a requirement. It just works that way in this instance. The
        // actual name could be supplied by hard coding it below.
        Department dep = (Department) value;
        String fieldValue1 = dep.getBranch();
        if ( fieldValue1 == null ) {
            fieldValue1 = "";
        }
        String fieldValue2 = dep.getNetwork();
        if ( fieldValue2 == null ) {
            fieldValue2 = "";
        }
        String fieldValue = fieldValue1 + sepChar + fieldValue2;
        Field field = new Field( name, fieldValue, luceneOptions.getStore(),
            luceneOptions.getIndex(), luceneOptions.getTermVector() );
        field.setBoost( luceneOptions.getBoost() );
        document.add( field );
   }
}</code></pre></div></div><br class="example-break"/><p>In this example, the particular <code class="literal">CatFieldsClassBridge</code> is applied to the <code class="literal">department</code> instance, the
field bridge then concatenate both branch and network and index the concatenation.</p></section></section><section class="section" id="_bridgeprovider_associate_a_bridge_to_a_given_return_type"><div class="titlepage"><div><div><h3 class="title">4.4.4. BridgeProvider: associate a bridge to a given return type</h3></div></div></div><p>Custom field bridges are very flexible, but it can be tedious and error prone to apply the same
custom <code class="literal">@FieldBridge</code> annotation every time a property of a given type is present in your domain
model. That is what BridgeProviders are for.</p><p>Let’s imagine that you have a type <code class="literal">Currency</code> in your application and that you want to apply your very
own <code class="literal">CurrencyFieldBridge</code> every time an indexed property returns <code class="literal">Currency</code>. You can do it the hard way:</p><div class="example" id="d0e4984"><div class="example-title">Example 4.28. Applying the same <code class="literal">@FieldBridge</code> for a type the hard way</div><div class="example-contents"><pre><code class="language-java">@Entity @Indexed
public class User {
    @FieldBridge(impl=CurrencyFieldBridge.class)
    public Currency getDefaultCurrency();

    // ...
}

@Entity @Indexed
public class Account {
    @FieldBridge(impl=CurrencyFieldBridge.class)
    public Currency getCurrency();

    // ...
}

// continue to add @FieldBridge(impl=CurrencyFieldBridge.class) everywhere Currency is</code></pre></div></div><br class="example-break"/><p>Or you can write your own <code class="literal">BridgeProvider</code> implementation for <code class="literal">Currency</code>.</p><div class="example" id="d0e5000"><div class="example-title">Example 4.29. Writing a <code class="literal">BridgeProvider</code></div><div class="example-contents"><pre><code class="language-java">public class CurrencyBridgeProvider implements BridgeProvider {

    //needs a default no-arg constructor

    @Override
    public FieldBridge provideFieldBridge(BridgeContext bridgeProviderContext) {
        if ( bridgeProviderContext.getReturnType().equals( Currency.class ) ) {
            return CurrencyFieldBridge.INSTANCE;
        }
        return null;
    }
}</code></pre><pre class="screen"># service file named META-INF/services/org.hibernate.search.bridge.spi.BridgeProvider
com.acme.myapps.hibernatesearch.CurrencyBridgeProvider</pre></div></div><br class="example-break"/><p>You need to implement <code class="literal">BridgeProvider</code> and create a service file named
<span class="emphasis"><em>META-INF/services/org.hibernate.search.bridge.spi.BridgeProvider</em></span>. This file must contain the fully
qualified class name(s) of the <code class="literal">BridgeProvider</code> implementations. This is the classic Service Loader
discovery mechanism.</p><p>Now, any indexed property of type <code class="literal">Currency</code> will use <code class="literal">CurrencyFieldBridge</code> automatically.</p><div class="example" id="d0e5028"><div class="example-title">Example 4.30. An explicit <code class="literal">@FieldBrige</code> is no longer needed</div><div class="example-contents"><pre><code class="language-java">@Entity @Indexed
public class User {

    @Field
    public Currency getDefaultCurrency();

    // ...
}

@Entity @Indexed
public class Account {

    @Field
    public Currency getCurrency();

    // ...
}

//CurrencyFieldBridge is applied automatically everywhere Currency is found on an indexed property</code></pre></div></div><br class="example-break"/><p>A few more things you need to know:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">a <code class="literal">BridgeProvider</code> must have a no-arg constructor</li><li class="listitem">if a <code class="literal">BridgeProvider</code> only returns <code class="literal">FieldBridge</code> instances if it is meaningful for the calling context.
Null otherwise. In our example, the return type must be <code class="literal">Currency</code> to be meaningful to our provider.</li><li class="listitem">if two or more bridge providers return a <code class="literal">FieldBridge</code> instance for a given return type, an exception
will be raised.</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>What is a calling context</h2><p>A calling context is represented by the <code class="literal">BridgeProviderContext</code> object and represents the environment for
which we are looking for a bridge. <code class="literal">BridgeProviderContext</code> gives access to the return type of the indexed
property as well as the <code class="literal">ServiceManager</code> which gives access to the <code class="literal">ClassLoaderService</code> for everything
class loader related.</p><pre><code class="language-java">ClassLoaderService classLoaderService = serviceManager.getClassLoaderService();
CustomBridge cb = classLoaderService.classForName( "com.package.CustomBridge" );</code></pre></div></section></section><section class="section" id="search-mapping-indexinginterceptor"><div class="titlepage"><div><div><h2 class="title">4.5. Conditional indexing</h2></div></div></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>This feature is considered experimental. More operation types might be added in the future depending
on user feedback.</p></div><p>In some situations, you want to index an entity only when it is in a given state, for example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">only index blog entries marked as published</li><li class="listitem">no longer index invoices when they are marked archived</li></ul></div><p>This serves both functional and technical needs. You don’t want your blog readers to find your draft
entries and filtering them off the query is a bit annoying. Very few of your entities are actually
required to be indexed and you want to limit indexing overhead and keep indexes small and fast.</p><p>Hibernate Search lets you intercept entity indexing operations and override them. It is quite
simple:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Write an <code class="literal">EntityIndexingInterceptor</code> class with your entity state based logic</li><li class="listitem">Mark the entity as intercepted by this implementation</li></ul></div><p>Let’s look at the blog example at <a class="xref" href="#example-search-mapping-indexinginterceptor-blog" title="Example 4.31. Index blog entries only when they are published and remove them when they are in a different state">Example 4.31, “Index blog entries only when they are published and remove them when they are in a different state”</a></p><div class="example" id="example-search-mapping-indexinginterceptor-blog"><div class="example-title">Example 4.31. Index blog entries only when they are published and remove them when they are in a different state</div><div class="example-contents"><pre><code class="language-java">/**
 * Only index blog when it is in published state
 *
 * @author Emmanuel Bernard &lt;emmanuel@hibernate.org&gt;
 */
public class IndexWhenPublishedInterceptor implements EntityIndexingInterceptor&lt;Blog&gt; {
    @Override
    public IndexingOverride onAdd(Blog entity) {
        if (entity.getStatus() == BlogStatus.PUBLISHED) {
            return IndexingOverride.APPLY_DEFAULT;
        }
        return IndexingOverride.SKIP;
    }

    @Override
    public IndexingOverride onUpdate(Blog entity) {
        if (entity.getStatus() == BlogStatus.PUBLISHED) {
            return IndexingOverride.UPDATE;
        }
        return IndexingOverride.REMOVE;
    }

    @Override
    public IndexingOverride onDelete(Blog entity) {
        return IndexingOverride.APPLY_DEFAULT;
    }

    @Override
    public IndexingOverride onCollectionUpdate(Blog entity) {
        return onUpdate(entity);
    }
}</code></pre><pre><code class="language-java">@Entity
@Indexed(interceptor=IndexWhenPublishedInterceptor.class)
public class Blog {
    @Id
    @GeneratedValue
    public Integer getId() { return id; }
    public void setId(Integer id) {  this.id = id; }
    private Integer id;

    @Field
    public String getTitle() { return title; }
    public void setTitle(String title) {  this.title = title; }
    private String title;

    public BlogStatus getStatus() { return status; }
    public void setStatus(BlogStatus status) {  this.status = status; }
    private BlogStatus status;

    // ...
}</code></pre></div></div><br class="example-break"/><p>We mark the <code class="literal">Blog</code> entity with <code class="literal">@Indexed.interceptor</code>. As you can see, <code class="literal">IndexWhenPublishedInterceptor</code>
implements <code class="literal">EntityIndexingInterceptor</code> and accepts <code class="literal">Blog</code> entities (it could have accepted super classes
as well - for example <code class="literal">Object</code> if you create a generic interceptor.</p><p>You can react to several planned indexing events:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">when an entity is added to your datastore</li><li class="listitem">when an entity is updated in your datastore</li><li class="listitem">when an entity is deleted from your datastore</li><li class="listitem">when a collection own by this entity is updated in your datastore</li></ul></div><p>For each occurring event you can respond with one of the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">APPLY_DEFAULT</code>: that’s the basic operation that lets Hibernate Search update the index as
expected - creating, updating or removing the document</li><li class="listitem"><code class="literal">SKIP</code>: ask Hibernate Search to not do anything to the index for this event - data will not be
created, updated or removed from the index in any way</li><li class="listitem"><code class="literal">REMOVE</code>: ask Hibernate Search to remove indexing data about this entity - you can safely ask
for <code class="literal">REMOVE</code> even if the entity has not yet been indexed</li><li class="listitem"><code class="literal">UPDATE</code>: ask Hibernate Search to either index or update the index for this entity - it is safe
to ask for <code class="literal">UPDATE</code> even if the entity has never been indexed</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Be careful, not every combination makes sense: for example, asking to <code class="literal">UPDATE</code> the index upon
onDelete. Note that you could ask for <code class="literal">SKIP</code> in this situation if saving indexing time is critical
for you. That’s rarely the case though.</p></div><p>By default, no interceptor is applied on an entity. You have to explicitly define an interceptor via
the <code class="literal">@Indexed</code> annotation (see <a class="xref" href="#indexed-annotation" title="4.1.1.1. @Indexed">Section 4.1.1.1, “@Indexed”</a>) or programmatically (see
<a class="xref" href="#hsearch-mapping-programmaticapi" title="4.7. Programmatic API">Section 4.7, “Programmatic API”</a>). This class and all its subclasses will then be intercepted.
You can stop or change the interceptor used in a subclass by overriding <code class="literal">@Indexed.interceptor</code>.
Hibernate Search provides <code class="literal">DontInterceptEntityInterceptor</code> which will explicitly not intercept any call.
This is useful to reset interception within a class hierarchy.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Dirty checking optimization is disabled when interceptors are used. Dirty checking optimization does
check what has changed in an entity and only triggers an index update if indexed properties are
changed. The reason is simple, your interceptor might depend on a non indexed property which would
be ignored by this optimization.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>An <code class="literal">EntityIndexingInterceptor</code> can never override an explicit indexing operation such as <code class="literal">index(T)</code>,
<code class="literal">purge(T, id)</code> or <code class="literal">purgeAll(class)</code>.</p></div></section><section class="section" id="provided-id"><div class="titlepage"><div><div><h2 class="title">4.6. Providing your own id</h2></div></div></div><p>You can provide your own id for Hibernate Search if you are extending the internals. You will have
to generate a unique value so it can be given to Lucene to be indexed. This will have to be given to
Hibernate Search when you create an <code class="literal">org.hibernate.search.Work</code> object - the document id is required
in the constructor.</p><section class="section" id="ProvidedId"><div class="titlepage"><div><div><h3 class="title">4.6.1. The ProvidedId annotation</h3></div></div></div><p>Unlike <code class="literal">@DocumentId</code> which is applied on field level, <code class="literal">@ProvidedId</code> is used on the class level.
Optionally you can specify your own bridge implementation using the bridge property. Also, if you
annotate a class with <code class="literal">@ProvidedId</code>, your subclasses will also get the annotation - but it is not done
by using the <code class="literal">java.lang.annotations.@Inherited</code>. Be sure however, to <span class="emphasis"><em>not</em></span> use this annotation with
<code class="literal">@DocumentId</code> as your system will break.</p><div class="example" id="d0e5258"><div class="example-title">Example 4.32. Providing your own id</div><div class="example-contents"><pre><code class="language-java">@ProvidedId(bridge = org.my.own.package.MyCustomBridge)
@Indexed
public class MyClass{
    @Field
    String MyString;
    ...
}</code></pre></div></div><br class="example-break"/></section></section><section class="section" id="hsearch-mapping-programmaticapi"><div class="titlepage"><div><div><h2 class="title">4.7. Programmatic API</h2></div></div></div><p>Although the recommended approach for mapping indexed entities is to use annotations, it is
sometimes more convenient to use a different approach:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the same entity is mapped differently depending on deployment needs (customization for clients)</li><li class="listitem">some automation process requires the dynamic mapping of many entities sharing common traits</li></ul></div><p>While it has been a popular demand in the past, the Hibernate team never found the idea of an XML
alternative to annotations appealing due to its heavy duplication, lack of code refactoring safety,
because it did not cover all the use case spectrum and because we are in the 21st century :)</p><p>The idea of a programmatic API was much more appealing and has now become a reality. You can
programmatically define your mapping using a programmatic API: you define entities and fields as
indexable by using mapping classes which effectively mirror the annotation concepts in Hibernate
Search. Note that fan(s) of XML approach can design their own schema and use the programmatic API to
create the mapping while parsing the XML stream.</p><p>In order to use the programmatic model you must first construct a <code class="literal">SearchMapping</code> object which you can
do in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">directly</li><li class="listitem">via a factory</li></ul></div><p>You can pass the SearchMapping object directly via the property key
<code class="literal">hibernate.search.model_mapping</code> or the constant <code class="literal">Environment.MODEL_MAPPING</code>. Use the
Configuration API or the <code class="literal">Map</code> passed to the JPA Persistence bootstrap methods.</p><div class="example" id="d0e5302"><div class="example-title">Example 4.33. Programmatic mapping</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();
// ... configure mapping
Configuration config = new Configuration();
config.getProperties().put( Environment.MODEL_MAPPING, mapping );
SessionFactory sf = config.buildSessionFactory();</code></pre></div></div><br class="example-break"/><div class="example" id="d0e5307"><div class="example-title">Example 4.34. Programmatic mapping with JPA</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();
// ... configure mapping
Map props = new HashMap();
props.put( Environment.MODEL_MAPPING, mapping );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", props );</code></pre></div></div><br class="example-break"/><p>Alternatively, you can create a factory class (ie hosting a method annotated with <code class="literal">@Factory</code>) whose
factory method returns the <code class="literal">SearchMapping</code> object. The factory class must have a no-arg constructor
and its fully qualified class name is passed to the property key
<code class="literal">hibernate.search.model_mapping</code> or its type-safe representation <code class="literal">Environment.MODEL_MAPPING</code>. This
approach is useful when you do not necessarily control the bootstrap process like in a Java EE, CDI
or Spring Framework container.</p><div class="example" id="d0e5326"><div class="example-title">Example 4.35. Use a mapping factory</div><div class="example-contents"><pre><code class="language-java">public class MyAppSearchMappingFactory {
    @Factory
    public SearchMapping getSearchMapping() {
        SearchMapping mapping = new SearchMapping();
        mapping
                .analyzerDef( "ngram", StandardTokenizerFactory.class )
                    .filter( LowerCaseFilterFactory.class )
                    .filter( NGramFilterFactory.class )
                        .param( "minGramSize", "3" )
                        .param( "maxGramSize", "3" );
        return mapping;
    }
}</code></pre><pre><code class="language-xml">&lt;persistence ...&gt;
    &lt;persistence-unit name="users"&gt;
        ...
        &lt;properties&gt;
            &lt;property name="hibernate.search.model_mapping"
                      value="com.acme.MyAppSearchMappingFactory"/&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</code></pre></div></div><br class="example-break"/><p>The <code class="literal">SearchMapping</code> is the root object which contains all the necessary indexable entities and fields.
From there, the <code class="literal">SearchMapping</code> object exposes a fluent (and thus intuitive) API to express your
mappings: it contextually exposes the relevant mapping options in a type-safe way. Just let your IDE
auto-completion feature guide you through.</p><p>Today, the programmatic API cannot be used on a class annotated with Hibernate Search annotations,
chose one approach or the other. Also note that the same default values apply in annotations and the
programmatic API. For example, the <code class="literal">@Field.name</code> is defaulted to the property name and does not have
to be set.</p><p>Each core concept of the programmatic API has a corresponding example to depict how the same
definition would look using annotation. Therefore seeing an annotation example of the programmatic
approach should give you a clear picture of what Hibernate Search will build with the marked
entities and associated properties.</p><section class="section" id="_mapping_an_entity_as_indexable"><div class="titlepage"><div><div><h3 class="title">4.7.1. Mapping an entity as indexable</h3></div></div></div><p>The first concept of the programmatic API is to define an entity as indexable. Using the annotation
approach a user would mark the entity as <code class="literal">@Indexed</code>, the following example demonstrates how to
programmatically achieve this.</p><div class="example" id="d0e5356"><div class="example-title">Example 4.36. Marking an entity indexable</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class)
           .indexed()
               .indexName("Address_Index") //optional
               .interceptor(IndexWhenPublishedInterceptor.class); //optional

cfg.getProperties().put("hibernate.search.model_mapping", mapping);</code></pre></div></div><br class="example-break"/><p>As you can see you must first create a <code class="literal">SearchMapping</code> object which is the root object that is then
passed to the Configuration object as property. You must declare an entity and if you wish to make
that entity as indexable then you must call the <code class="literal">indexed()</code> method. The <code class="literal">indexed()</code> method has an
optional <code class="literal">indexName(String indexName)</code> which can be used to change the default index name that is
created by Hibernate Search. Likewise, an <code class="literal">interceptor(Class&lt;? extends EntityIndexedInterceptor&gt;)</code>
is available. Using the annotation model the above can be achieved as:</p><div class="example" id="d0e5378"><div class="example-title">Example 4.37. Annotation example of indexing entity</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed(index="Address_Index", interceptor=IndexWhenPublishedInterceptor.class)
public class Address {
   // ...
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_adding_documentid_to_indexed_entity"><div class="titlepage"><div><div><h3 class="title">4.7.2. Adding DocumentId to indexed entity</h3></div></div></div><p>To set a property as a document id:</p><div class="example" id="d0e5388"><div class="example-title">Example 4.38. Enabling document id with programmatic model</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping.entity(Address.class).indexed()
           .property("addressId", ElementType.FIELD) //field access
               .documentId()
                   .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping);</code></pre></div></div><br class="example-break"/><p>The above is equivalent to annotating a property in the entity as <code class="literal">@DocumentId</code> as seen in the
following example:</p><div class="example" id="d0e5398"><div class="example-title">Example 4.39. <code class="literal">@DocumentId</code> annotation definition</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Address {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 // ...
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_defining_analyzers"><div class="titlepage"><div><div><h3 class="title">4.7.3. Defining analyzers</h3></div></div></div><p>Analyzers can be programmatically defined using the
<code class="literal">analyzerDef(String analyzerDef, Class&lt;? extends TokenizerFactory&gt; tokenizerFactory)</code> method. This
method also enables you to define filters for the analyzer definition. Each filter that you define
can optionally take in parameters as seen in the following example :</p><div class="example" id="d0e5413"><div class="example-title">Example 4.40. Defining analyzers using programmatic model</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "ngram", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( NGramFilterFactory.class )
            .param( "minGramSize", "3" )
            .param( "maxGramSize", "3" )
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .analyzerDef( "de", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( GermanStemFilterFactory.class )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD) //getter access
            .documentId()
                .name("id");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre></div></div><br class="example-break"/><p>The analyzer mapping defined above is equivalent to the annotation model using <code class="literal">@AnalyzerDef</code> in
conjunction with <code class="literal">@AnalyzerDefs</code>:</p><div class="example" id="d0e5426"><div class="example-title">Example 4.41. Analyzer definition using annotation</div><div class="example-contents"><pre><code class="language-java">@Indexed
@Entity
@AnalyzerDefs({
  @AnalyzerDef(name = "ngram",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = NGramFilterFactory.class,
        params = {
          @Parameter(name = "minGramSize",value = "3"),
          @Parameter(name = "maxGramSize",value = "3")
       })
   }),
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   }),

  @AnalyzerDef(name = "de",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = GermanStemFilterFactory.class)
  })

})
public class Address {
   // ...
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_defining_full_text_filter_definitions"><div class="titlepage"><div><div><h3 class="title">4.7.4. Defining full text filter definitions</h3></div></div></div><p>The programmatic API provides easy mechanism for defining full text filter definitions which is
available via <code class="literal">@FullTextFilterDef</code> and <code class="literal">@FullTextFilterDefs</code> (see <a class="xref" href="#query-filter" title="5.3. Filters">Section 5.3, “Filters”</a>). The next example
depicts the creation of full text filter definition using the <code class="literal">fullTextFilterDef</code> method.</p><div class="example" id="d0e5447"><div class="example-title">Example 4.42. Defining full text definition programmatically</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .fullTextFilterDef("security", SecurityFilterFactory.class)
            .cache(FilterCacheModeType.INSTANCE_ONLY)
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            .field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en")
                .store(Store.NO);

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre></div></div><br class="example-break"/><p>The previous example can effectively been seen as annotating your entity with <code class="literal">@FullTextFilterDef</code>
like below:</p><div class="example" id="d0e5457"><div class="example-title">Example 4.43. Using annotation to define full text filter definition</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   })
})
@FullTextFilterDefs({
 @FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class, cache = FilterCacheModeType.INSTANCE_ONLY)
})
public class Address {

 @Id
 @GeneratedValue
 @DocumentId(name="id")
 public Long getAddressId() {...};

 @Fields({
      @Field(store=Store.YES, analyzer=@Analyzer(definition="en")),
      @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 })
 public String getAddress1() {...};

 // ...

}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_defining_fields_for_indexing"><div class="titlepage"><div><div><h3 class="title">4.7.5. Defining fields for indexing</h3></div></div></div><p>When defining fields for indexing using the programmatic API, call <code class="literal">field()</code> on the
<code class="literal">property(String propertyName, ElementType elementType)</code> method. From <code class="literal">field()</code> you can specify
the <code class="literal">name</code>, <code class="literal">index</code>, <code class="literal">store</code>, <code class="literal">bridge</code> and <code class="literal">analyzer</code> definitions.</p><div class="example" id="d0e5491"><div class="example-title">Example 4.44. Indexing fields using programmatic API</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping
    .analyzerDef( "en", StandardTokenizerFactory.class )
        .filter( LowerCaseFilterFactory.class )
        .filter( EnglishPorterFilterFactory.class )
    .entity(Address.class).indexed()
        .property("addressId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("street1", ElementType.METHOD)
            .field()
                .analyzer("en")
                .store(Store.YES)
            .field()
                .name("address_data")
                .analyzer("en");

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre></div></div><br class="example-break"/><p>The above example of marking fields as indexable is equivalent to defining fields using <code class="literal">@Field</code> as
seen below:</p><div class="example" id="d0e5501"><div class="example-title">Example 4.45. Indexing fields using annotation</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@AnalyzerDefs({
  @AnalyzerDef(name = "en",
    tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class),
    filters = {
      @TokenFilterDef(factory = LowerCaseFilterFactory.class),
      @TokenFilterDef(factory = EnglishPorterFilterFactory.class)
   })
})
public class Address {

 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long getAddressId() {...};

 @Fields({
      @Field(store=Store.YES, analyzer=@Analyzer(definition="en")),
      @Field(name="address_data", analyzer=@Analyzer(definition="en"))
 })
 public String getAddress1() {...}

 // ...
}</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>When using a programmatic mapping for a given type <code class="literal">X</code>, you can only refer to fields defined on <code class="literal">X</code>.
Fields or methods inherited from a super type are not configurable. In case you need to configure a
super class property, you need to either override the property in <code class="literal">X</code> or create a programmatic mapping
for the super class. This mimics the usage of annotations where you cannot annotate a field or
method of a super class either, unless it is redefined in the given type.</p></div></section><section class="section" id="_programmatically_defining_embedded_entities"><div class="titlepage"><div><div><h3 class="title">4.7.6. Programmatically defining embedded entities</h3></div></div></div><p>In this section you will see how to programmatically define entities to be embedded into the indexed
entity similar to using the <code class="literal">@IndexedEmbedded</code> model. In order to define this you must mark the
property as <code class="literal">indexEmbedded</code>. There is the option to add a prefix to the embedded entity definition
which can be done by calling prefix as seen in the example below:</p><div class="example" id="d0e5529"><div class="example-title">Example 4.46. Programmatically defining embedded entities</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
                .name("id")
        .property("title", ElementType.METHOD)
            .field()
                .index(Index.YES)
                .store(Store.NO)
        .property("description", ElementType.METHOD)
             .field()
                 .index(Index.YES)
                 .store(Store.NO)
        .property("items", ElementType.METHOD)
            .indexEmbedded()
                .prefix("catalog.items"); //optional

cfg.getProperties().put( "hibernate.search.model_mapping", mapping )</code></pre></div></div><br class="example-break"/><p>The next example shows the same definition using annotation (<code class="literal">@IndexedEmbedded</code>):</p><div class="example" id="d0e5539"><div class="example-title">Example 4.47. Using <code class="literal">@IndexedEmbedded</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class ProductCatalog {
 @Id
 @GeneratedValue
 @DocumentId(name="id")
 public Long getCatalogId() {...}

 @Field
 public String getTitle() {...}

 @Field
 public String getDescription();

 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded(prefix="catalog.items")
 public List&lt;Item&gt; getItems() {...}

 // ...
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_contained_in_definition"><div class="titlepage"><div><div><h3 class="title">4.7.7. Contained In definition</h3></div></div></div><p><code class="literal">@ContainedIn</code> can be defined as seen in the example below:</p><div class="example" id="d0e5553"><div class="example-title">Example 4.48. Programmatically defining <code class="literal">containedIn</code></div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping
    .entity(ProductCatalog.class)
        .indexed()
        .property("catalogId", ElementType.METHOD)
            .documentId()
        .property("title", ElementType.METHOD)
            .field()
        .property("description", ElementType.METHOD)
            .field()
        .property("items", ElementType.METHOD)
            .indexEmbedded()

    .entity(Item.class)
        .property("description", ElementType.METHOD)
            .field()
        .property("productCatalog", ElementType.METHOD)
            .containedIn();

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre></div></div><br class="example-break"/><p>This is equivalent to defining <code class="literal">@ContainedIn</code> in your entity:</p><div class="example" id="d0e5565"><div class="example-title">Example 4.49. Annotation approach for <code class="literal">@ContainedIn</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class ProductCatalog {

 @Id
 @GeneratedValue
 @DocumentId
 public Long getCatalogId() {...}

 @Field
 public String getTitle() {...}

 @Field
 public String getDescription() {...}

 @OneToMany(fetch = FetchType.LAZY)
 @IndexColumn(name = "list_position")
 @Cascade(org.hibernate.annotations.CascadeType.ALL)
 @IndexedEmbedded
 private List&lt;Item&gt; getItems() {...}

 // ...
}</code></pre><pre><code class="language-java">@Entity
public class Item {

 @Id
 @GeneratedValue
 private Long itemId;

 @Field
 public String getDescription() {...}

 @ManyToOne( cascade = { CascadeType.PERSIST, CascadeType.REMOVE } )
 @ContainedIn
 public ProductCatalog getProductCatalog() {...}

 // ...
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_date_calendar_bridge"><div class="titlepage"><div><div><h3 class="title">4.7.8. Date/Calendar Bridge</h3></div></div></div><p>In order to define a calendar or date bridge mapping, call the <code class="literal">dateBridge(Resolution resolution)</code> or
<code class="literal">calendarBridge(Resolution resolution)</code> methods after you have defined a <code class="literal">field()</code> in the <code class="literal">SearchMapping</code>
hierarchy.</p><div class="example" id="d0e5591"><div class="example-title">Example 4.50. Programmatic model for defining calendar/date bridge</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
    .property("street1", ElementType.FIELD()
        .field()
    .property("createdOn", ElementType.FIELD)
        .field()
        .dateBridge(Resolution.DAY)
    .property("lastUpdated", ElementType.FIELD)
        .calendarBridge(Resolution.DAY);

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre></div></div><br class="example-break"/><p>See below for defining the above using <code class="literal">@CalendarBridge</code> and <code class="literal">@DateBridge</code>:</p><div class="example" id="d0e5604"><div class="example-title">Example 4.51. <code class="literal">@CalendarBridge</code> and <code class="literal">@DateBridge</code> definition</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Address {

 @Id
 @GeneratedValue
 @DocumentId
 private Long addressId;

 @Field
 private String address1;

 @Field
 @DateBridge(resolution=Resolution.DAY)
 private Date createdOn;

 @CalendarBridge(resolution=Resolution.DAY)
 private Calendar lastUpdated;

 // ...
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_declaring_bridges"><div class="titlepage"><div><div><h3 class="title">4.7.9. Declaring bridges</h3></div></div></div><p>It is possible to associate bridges to programmatically defined fields. When you define a <code class="literal">field()</code>
programmatically you can use the <code class="literal">bridge(Class&lt;?&gt; impl)</code> to associate a <code class="literal">FieldBridge</code> implementation
class. The bridge method also provides optional methods to include any parameters required for the
bridge class. The below shows an example of programmatically defining a bridge:</p><div class="example" id="d0e5628"><div class="example-title">Example 4.52. Declaring field bridges programmatically</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Address.class)
        .indexed()
        .property("addressId", ElementType.FIELD)
            .documentId()
        .property("street1", ElementType.FIELD)
            .field()
            .field()
                .name("street1_abridged")
                .bridge( ConcatStringBridge.class )
                    .param( "size", "4" );

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre></div></div><br class="example-break"/><p>The above can equally be defined using annotations, as seen in the next example.</p><div class="example" id="d0e5635"><div class="example-title">Example 4.53. Declaring field bridges using annotation</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Address {

 @Id
 @GeneratedValue
 @DocumentId(name="id")
 private Long addressId;

 @Fields({
      @Field,
      @Field(name="street1_abridged",
             bridge = @FieldBridge( impl = ConcatStringBridge.class,
             params = @Parameter( name="size", value="4" ))
 })
 private String address1;

 // ...
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_mapping_class_bridge"><div class="titlepage"><div><div><h3 class="title">4.7.10. Mapping class bridge</h3></div></div></div><p>You can define class bridges on entities programmatically. This is shown in the next example:</p><div class="example" id="d0e5645"><div class="example-title">Example 4.54. Defining class bridges using API</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();

mapping
    .entity(Departments.class)
      .classBridge(CatDeptsFieldsClassBridge.class)
         .name("branchnetwork")
         .index(Index.YES)
         .store(Store.YES)
         .param("sepChar", " ")
      .classBridge(EquipmentType.class)
         .name("equiptype")
         .index(Index.YES)
         .store(Store.YES)
         .param("C", "Cisco")
         .param("D", "D-Link")
         .param("K", "Kingston")
         .param("3", "3Com")
      .indexed();

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre></div></div><br class="example-break"/><p>The above is similar to using <code class="literal">@ClassBridge</code> as seen in the next example:</p><div class="example" id="d0e5655"><div class="example-title">Example 4.55. Using <code class="literal">@ClassBridge</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@ClassBridges ( {
  @ClassBridge(name="branchnetwork",
     store= Store.YES,
     impl = CatDeptsFieldsClassBridge.class,
     params = @Parameter( name="sepChar", value=" " ) ),
  @ClassBridge(name="equiptype",
     store= Store.YES,
     impl = EquipmentType.class,
     params = {@Parameter( name="C", value="Cisco" ),
        @Parameter( name="D", value="D-Link" ),
        @Parameter( name="K", value="Kingston" ),
        @Parameter( name="3", value="3Com" )
   })
})
public class Departments {
   // ...
}</code></pre></div></div><br class="example-break"/></section><section class="section" id="_mapping_dynamic_boost"><div class="titlepage"><div><div><h3 class="title">4.7.11. Mapping dynamic boost</h3></div></div></div><p>You can apply a dynamic boost factor on either a field or a whole entity:</p><div class="example" id="d0e5667"><div class="example-title">Example 4.56. <code class="literal">dynamicBoost</code> mapping using programmatic model</div><div class="example-contents"><pre><code class="language-java">SearchMapping mapping = new SearchMapping();
mapping
  .entity(DynamicBoostedDescLibrary.class)
   .indexed()
   .dynamicBoost(CustomBoostStrategy.class)
  .property("libraryId", ElementType.FIELD)
    .documentId().name("id")
  .property("name", ElementType.FIELD)
    .dynamicBoost(CustomFieldBoostStrategy.class);
    .field()
      .store(Store.YES)

cfg.getProperties().put( "hibernate.search.model_mapping", mapping );</code></pre></div></div><br class="example-break"/><p>The next example shows the equivalent mapping using the <code class="literal">@DynamicBoost</code> annotation:</p><div class="example" id="d0e5679"><div class="example-title">Example 4.57. Using the <code class="literal">@DynamicBoost</code></div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@DynamicBoost(impl = CustomBoostStrategy.class)
public class DynamicBoostedDescriptionLibrary {

 @Id
 @GeneratedValue
 @DocumentId
 private int id;

 private float dynScore;

 @Field(store = Store.YES)
 @DynamicBoost(impl = CustomFieldBoostStrategy.class)
 private String name;

 public DynamicBoostedDescriptionLibrary() {
  dynScore = 1.0f;
 }

 // ...
}</code></pre></div></div><br class="example-break"/></section></section></section><section class="chapter" id="search-query"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Querying</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#section-building-lucene-queries">5.1. Building queries</a></span><ul><li><span class="section"><a href="#search-query-lucene-api">5.1.1. Building a Lucene query using the Lucene API</a></span></li><li><span class="section"><a href="#search-query-querydsl">5.1.2. Building a Lucene query with the Hibernate Search query DSL</a></span></li><li><span class="section"><a href="#_building_a_hibernate_search_query">5.1.3. Building a Hibernate Search query</a></span></li></ul></li><li><span class="section"><a href="#_retrieving_the_results">5.2. Retrieving the results</a></span><ul><li><span class="section"><a href="#_performance_considerations">5.2.1. Performance considerations</a></span></li><li><span class="section"><a href="#_result_size">5.2.2. Result size</a></span></li><li><span class="section"><a href="#_resulttransformer">5.2.3. ResultTransformer</a></span></li><li><span class="section"><a href="#_understanding_results">5.2.4. Understanding results</a></span></li></ul></li><li><span class="section"><a href="#query-filter">5.3. Filters</a></span><ul><li><span class="section"><a href="#query-filter-shard">5.3.1. Using filters in a sharded environment</a></span></li></ul></li><li><span class="section"><a href="#query-faceting">5.4. Faceting</a></span><ul><li><span class="section"><a href="#section-creating-faceting-request">5.4.1. Creating a faceting request</a></span></li><li><span class="section"><a href="#section-sorting-faceting-request">5.4.2. Setting the facet sort order</a></span></li><li><span class="section"><a href="#section-applying-faceting-request">5.4.3. Applying a faceting request</a></span></li><li><span class="section"><a href="#section-interpreting-facet-result">5.4.4. Interpreting a Facet result</a></span></li><li><span class="section"><a href="#_restricting_query_results">5.4.5. Restricting query results</a></span></li></ul></li><li><span class="section"><a href="#_optimizing_the_query_process">5.5. Optimizing the query process</a></span><ul><li><span class="section"><a href="#query-logging">5.5.1. Logging executed Lucene queries</a></span></li></ul></li></ul></div><p>The second most important capability of Hibernate Search is the ability to execute Lucene queries
and retrieve entities managed by a Hibernate session. The search provides the power of Lucene
without leaving the Hibernate paradigm, giving another dimension to the Hibernate classic search
mechanisms (HQL, Criteria query, native SQL query).</p><p>Preparing and executing a query consists of four simple steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Creating a <code class="literal">FullTextSession</code></li><li class="listitem">Creating a Lucene query either via the Hibernate Search query DSL (recommended) or by utilizing
the Lucene query API</li><li class="listitem">Wrapping the Lucene query using an <code class="literal">org.hibernate.Query</code></li><li class="listitem">Executing the search by calling for example <code class="literal">list()</code> or <code class="literal">scroll()</code></li></ul></div><p>To access the querying facilities, you have to use a <code class="literal">FullTextSession</code>. This Search specific session
wraps a regular <code class="literal">org.hibernate.Session</code> in order to provide query and indexing capabilities.</p><div class="example" id="d0e5723"><div class="example-title">Example 5.1. Creating a FullTextSession</div><div class="example-contents"><pre><code class="language-java">Session session = sessionFactory.openSession();
//...
FullTextSession fullTextSession = Search.getFullTextSession(session);</code></pre></div></div><br class="example-break"/><p>Once you have a <code class="literal">FullTextSession</code> you have two options to build the full-text query: the Hibernate
Search query DSL or the native Lucene query.</p><p>If you use the Hibernate Search query DSL, it will look like this:</p><div class="informalexample"><pre><code class="language-java">QueryBuilder b = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Myth.class).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects</code></pre></div><p>You can alternatively write your Lucene query either using the Lucene query parser or Lucene
programmatic API.</p><div class="example" id="d0e5740"><div class="example-title">Example 5.2. Creating a Lucene query via the QueryParser</div><div class="example-contents"><pre><code class="language-java">SearchFactory searchFactory = fullTextSession.getSearchFactory();
org.apache.lucene.queryparser.classic.QueryParser parser =
    new QueryParser("title", searchFactory.getAnalyzer(Myth.class));
try {
    org.apache.lucene.search.Query luceneQuery = parser.parse("history:storm^3");
}
catch (ParseException e) {
    //handle parsing failure
}

org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery);
List result = fullTextQuery.list(); //return a list of managed objects</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The Hibernate query built on top of the Lucene query is a regular <code class="literal">org.hibernate.Query</code>, which means
you are in the same paradigm as the other Hibernate query facilities (HQL, Native or Criteria). The
regular <code class="literal">list()</code> , <code class="literal">uniqueResult()</code>, <code class="literal">iterate()</code> and <code class="literal">scroll()</code> methods can be used.</p></div><p>In case you are using the Java Persistence APIs of Hibernate, the same extensions exist:</p><div class="example" id="d0e5765"><div class="example-title">Example 5.3. Creating a Search query using the JPA API</div><div class="example-contents"><pre><code class="language-java">EntityManager em = entityManagerFactory.createEntityManager();

FullTextEntityManager fullTextEntityManager =
    org.hibernate.search.jpa.Search.getFullTextEntityManager(em);

// ...
QueryBuilder b = fullTextEntityManager.getSearchFactory()
    .buildQueryBuilder().forEntity( Myth.class ).get();

org.apache.lucene.search.Query luceneQuery =
    b.keyword()
        .onField("history").boostedTo(3)
        .matching("storm")
        .createQuery();
javax.persistence.Query fullTextQuery =
    fullTextEntityManager.createFullTextQuery( luceneQuery );

List result = fullTextQuery.getResultList(); //return a list of managed objects</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The following examples we will use the Hibernate APIs but the same example can be easily rewritten
with the Java Persistence API by just adjusting the way the FullTextQuery is retrieved.</p></div><section class="section" id="section-building-lucene-queries"><div class="titlepage"><div><div><h2 class="title">5.1. Building queries</h2></div></div></div><p>Hibernate Search queries are built on top of Lucene queries which gives you total freedom on the
type of Lucene query you want to execute. However, once built, Hibernate Search wraps further query
processing using org.hibernate.Query as your primary query manipulation API.</p><section class="section" id="search-query-lucene-api"><div class="titlepage"><div><div><h3 class="title">5.1.1. Building a Lucene query using the Lucene API</h3></div></div></div><p>Using the Lucene API, you have several options. You can use the query parser (fine for simple
queries) or the Lucene programmatic API (for more complex use cases). It is out of the scope of this
documentation on how to exactly build a Lucene query. Please refer to the online Lucene
documentation or get hold of a copy of Lucene In Action or Hibernate Search in Action.</p></section><section class="section" id="search-query-querydsl"><div class="titlepage"><div><div><h3 class="title">5.1.2. Building a Lucene query with the Hibernate Search query DSL</h3></div></div></div><p>Writing full-text queries with the Lucene programmatic API is quite complex. It’s even more complex
to understand the code once written. Besides the inherent API complexity, you have to remember to
convert your parameters to their string equivalent as well as make sure to apply the correct
analyzer to the right field (a ngram analyzer will for example use several ngrams as the tokens for
a given word and should be searched as such).</p><p>The Hibernate Search query DSL makes use of a style of API called a fluent API. This API has a few
key characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">it has meaningful method names making a succession of operations reads almost like English</li><li class="listitem">it limits the options offered to what makes sense in a given context (thanks to strong typing and
IDE auto-completion).</li><li class="listitem">it often uses the chaining method pattern</li><li class="listitem">it’s easy to use and even easier to read</li></ul></div><p>Let’s see how to use the API. You first need to create a query builder that is attached to a given
indexed entity type. This QueryBuilder will know what analyzer to use and what field bridge to
apply. You can create several <code class="literal">QueryBuilder</code> instances (one for each entity type involved in the root
of your query). You get the <code class="literal">QueryBuilder</code> from the <code class="literal">SearchFactory</code>.</p><div class="informalexample"><pre><code class="language-java">QueryBuilder mythQB = searchFactory.buildQueryBuilder().forEntity( Myth.class ).get();</code></pre></div><p>You can also override the analyzer used for a given field or fields. This is rarely needed and should be avoided unless you know what you are doing.</p><div class="informalexample"><pre><code class="language-java">QueryBuilder mythQB = searchFactory.buildQueryBuilder()
    .forEntity( Myth.class )
        .overridesForField("history","stem_analyzer_definition")
    .get();</code></pre></div><p>Using the query builder, you can then build queries. It is important to realize that the end result
of a QueryBuilder is a Lucene query. For this reason you can easily mix and match queries generated
via Lucene’s query parser or Query objects you have assembled with the Lucene programmatic API and
use them with the Hibernate Search DSL. Just in case the DSL is missing some features.</p><section class="section" id="_keyword_queries"><div class="titlepage"><div><div><h4 class="title">5.1.2.1. Keyword queries</h4></div></div></div><p>Let’s start with the most basic use case - searching for a specific word:</p><div class="informalexample"><pre><code class="language-java">Query luceneQuery = mythQB.keyword().onField("history").matching("storm").createQuery();</code></pre></div><p><code class="literal">keyword()</code> means that you are trying to find a specific word. <code class="literal">onField()</code> specifies in which Lucene
field to look. <code class="literal">matching()</code> tells what to look for. And finally <code class="literal">createQuery()</code> creates the Lucene
query object. A lot is going on with this line of code.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The value storm is passed through the <code class="literal">history</code> FieldBridge: it does not matter here but you will
see that it’s quite handy when dealing with numbers or dates.</li><li class="listitem">The field bridge value is then passed to the analyzer used to index the field <code class="literal">history</code>. This
ensures that the query uses the same term transformation than the indexing (lower case, n-gram,
stemming and so on). If the analyzing process generates several terms for a given word, a boolean
query is used with the <code class="literal">SHOULD</code> logic (roughly an <code class="literal">OR</code> logic).</li></ul></div><p>We make the example a little more advanced now and have a look at how to search a field that uses
ngram analyzers. ngram analyzers index succession of ngrams of your words which helps to recover
from user typos. For example the 3-grams of the word hibernate are hib, ibe, ber, rna, nat, ate.</p><div class="informalexample"><pre><code class="language-java">@AnalyzerDef(name = "ngram",
  tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class ),
  filters = {
    @TokenFilterDef(factory = StandardFilterFactory.class),
    @TokenFilterDef(factory = LowerCaseFilterFactory.class),
    @TokenFilterDef(factory = StopFilterFactory.class),
    @TokenFilterDef(factory = NGramFilterFactory.class,
      params = {
        @Parameter(name = "minGramSize", value = "3"),
        @Parameter(name = "maxGramSize", value = "3") } )
  }
)
@Entity
@Indexed
public class Myth {
  @Field(analyzer=@Analyzer(definition="ngram")
  public String getName() { return name; }
  public String setName(String name) { this.name = name; }
  private String name;

  ...
}

Query luceneQuery = mythQb.keyword().onField("name").matching("Sisiphus")
   .createQuery();</code></pre></div><p>The matching word "Sisiphus" will be lower-cased and then split into 3-grams: sis, isi, sip, phu,
hus. Each of these n-gram will be part of the query. We will then be able to find the Sysiphus myth
(with a <code class="literal">y</code>). All that is transparently done for you.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>If for some reason you do not want a specific field to use the field bridge or the analyzer you can
call the <code class="literal">ignoreAnalyzer()</code> or <code class="literal">ignoreFieldBridge()</code> functions.</p></div><p>To search for multiple possible words in the same field, simply add them all in the matching clause.</p><div class="informalexample"><pre><code class="language-java">//search document with storm or lightning in their history
Query luceneQuery =
    mythQB.keyword().onField("history").matching("storm lightning").createQuery();</code></pre></div><p>To search the same word on multiple fields, use the onFields method.</p><div class="informalexample"><pre><code class="language-java">Query luceneQuery = mythQB
    .keyword()
    .onFields("history","description","name")
    .matching("storm")
    .createQuery();</code></pre></div><p>Sometimes, one field should be treated differently from another field even if searching the same
term, you can use the andField() method for that.</p><div class="informalexample"><pre><code class="language-java">Query luceneQuery = mythQB.keyword()
    .onField("history")
    .andField("name")
      .boostedTo(5)
    .andField("description")
    .matching("storm")
    .createQuery();</code></pre></div><p>In the previous example, only field name is boosted to 5.</p></section><section class="section" id="_fuzzy_queries"><div class="titlepage"><div><div><h4 class="title">5.1.2.2. Fuzzy queries</h4></div></div></div><p>To execute a fuzzy query (based on the Levenshtein distance algorithm), start like a <code class="literal">keyword</code> query
and add the fuzzy flag.</p><div class="informalexample"><pre><code class="language-java">Query luceneQuery = mythQB
    .keyword()
      .fuzzy()
        .withThreshold(.8f)
        .withPrefixLength(1)
    .onField("history")
    .matching("starm")
    .createQuery();</code></pre></div><p><code class="literal">threshold</code> is the limit above which two terms are considering matching. It’s a decimal between 0 and
1 and defaults to 0.5. <code class="literal">prefixLength</code> is the length of the prefix ignored by the "fuzzyness": while
it defaults to 0, a non zero value is recommended for indexes containing a huge amount of distinct
terms.</p></section><section class="section" id="_wildcard_queries"><div class="titlepage"><div><div><h4 class="title">5.1.2.3. Wildcard queries</h4></div></div></div><p>You can also execute wildcard queries (queries where some of parts of the word are unknown).
The character <code class="literal">?</code> represents a single character and <code class="literal">*</code> represents any character sequence.
Note that for performance purposes, it is recommended that the query does not start with either <code class="literal">?</code> or <code class="literal">*</code>.</p><div class="informalexample"><pre><code class="language-java">Query luceneQuery = mythQB
    .keyword()
      .wildcard()
    .onField("history")
    .matching("sto*")
    .createQuery();</code></pre></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Wildcard queries do not apply the analyzer on the matching terms. Otherwise the risk of <code class="literal">*</code> or <code class="literal">?</code>
being mangled is too high.</p></div></section><section class="section" id="_phrase_queries"><div class="titlepage"><div><div><h4 class="title">5.1.2.4. Phrase queries</h4></div></div></div><p>So far we have been looking for words or sets of words, you can also search exact or approximate
sentences. Use <code class="literal">phrase()</code> to do so.</p><div class="informalexample"><pre><code class="language-java">Query luceneQuery = mythQB
    .phrase()
    .onField("history")
    .sentence("Thou shalt not kill")
    .createQuery();</code></pre></div><p>You can search approximate sentences by adding a slop factor. The slop factor represents the number
of other words permitted in the sentence: this works like a within or near operator</p><div class="informalexample"><pre><code class="language-java">Query luceneQuery = mythQB
    .phrase()
      .withSlop(3)
    .onField("history")
    .sentence("Thou kill")
    .createQuery();</code></pre></div></section><section class="section" id="_range_queries"><div class="titlepage"><div><div><h4 class="title">5.1.2.5. Range queries</h4></div></div></div><p>After looking at all these query examples for searching for to a given word, it is time to introduce
range queries (on numbers, dates, strings etc). A range query searches for a value in between given
boundaries (included or not) or for a value below or above a given boundary (included or not).</p><div class="informalexample"><pre><code class="language-java">//look for 0 &lt;= starred &lt; 3
Query luceneQuery = mythQB
    .range()
    .onField("starred")
    .from(0).to(3).excludeLimit()
    .createQuery();

//look for myths strictly BC
Date beforeChrist = ...;
Query luceneQuery = mythQB
    .range()
    .onField("creationDate")
    .below(beforeChrist).excludeLimit()
    .createQuery();</code></pre></div></section><section class="section" id="search-query-querydsl-spatial"><div class="titlepage"><div><div><h4 class="title">5.1.2.6. Spatial (or geolocation) queries</h4></div></div></div><p>This set of queries has its own chapter, check out <a class="xref" href="#spatial" title="Chapter 9. Spatial">Chapter 9, <em>Spatial</em></a>.</p></section><section class="section" id="search-query-querydsl-mlt"><div class="titlepage"><div><div><h4 class="title">5.1.2.7. More Like This queries</h4></div></div></div><p>Have you ever looked at an article or document and thought: "I want to find more like this"? Have you ever
appreciated an e-commerce website that gives you similar articles to the one you are exploring?</p><p>More Like This queries are achieving just that. You feed it an entity (or its identifier) and
Hibernate Search returns the list of entities that are similar.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>How does it work?</h2><p>For each (selected) field of the targeted entity, we look at the most meaningful terms. Then we
create a query matching the most meaningful terms per field. This is a slight variation compared to
the original Lucene <code class="literal">MoreLikeThisQuery</code> implementation.</p></div><p>The query DSL API should be self explaining. Let’s look at some usage examples.</p><div class="informalexample"><pre><code class="language-java">QueryBuilder qb = fullTextSession.getSearchFactory()
        .buildQueryBuilder()
        .forEntity( Coffee.class )
        .get();

Query mltQuery = qb
        .moreLikeThis()
            .comparingAllFields()
            .toEntityWithId( coffeeId )
            .createQuery();
List&lt;Object[]&gt; results = (List&lt;Object[]&gt;) fullTextSession
        .createFullTextQuery( mltQuery, Coffee.class )
        .setProjection( ProjectionConstants.THIS, ProjectionConstants.SCORE )
        .list();</code></pre></div><p>This first example takes the id of an Coffee entity and finds the matching coffees across all fields. To be fair,
this is not across <span class="emphasis"><em>all</em></span> fields. To be included in the More Like This query, fields need to store term vectors or the
actual field value. Id fields (of the root entity as well as embedded entities) and numeric fields are excluded.
The latter exclusion might change in future versions.</p><p>Looking at the <code class="literal">Coffee</code> class, the following fields are considered: <code class="literal">name</code> as it is stored,
<code class="literal">description</code> as it stores the term vector. <code class="literal">id</code> and <code class="literal">internalDescription</code> are excluded.</p><div class="informalexample"><pre><code class="language-java">@Entity @Indexed
public class Coffee {

    @Id @GeneratedValue
    public Integer getId() { return id; }

    @Field(termVector = TermVector.NO, store = Store.YES)
    public String getName() { return name; }

    @Field(termVector = TermVector.YES)
    public String getSummary() { return summary; }

    @Column(length = 2000)
    @Field(termVector = TermVector.YES)
    public String getDescription() { return description; }

    public int getIntensity() { return intensity; }

    // Not stored nor term vector, i.e. cannot be used for More Like This
    @Field
    public String getInternalDescription() { return internalDescription; }

    // ...
}</code></pre></div><p>In the example above we used projection to retrieve the relative score of each element. We might use the
score to only display the results for which the score is high enough.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>For best performance and best results, store the term vectors for the fields you want to include in
a More Like This query.</p></div><p>Often, you are only interested in a few key fields to find similar entities. Plus some fields are
more important than others and should be boosted.</p><div class="informalexample"><pre><code class="language-java">Query mltQuery = qb
        .moreLikeThis()
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntityWithId( coffeeId )
            .createQuery();</code></pre></div><p>In this example, we look for similar entities by summary and description. But similar summaries are
more important than similar descriptions. This is a critical tool to make More Like This meaningful
for your data set.</p><p>Instead of providing the entity id, you can pass the full entity object. If the entity contains the
identifier, we will use it to find the term vectors or field values. This means that we will compare
the entity state as stored in the Lucene index. If the identifier cannot be retrieved (for example
if the entity has not been persisted yet), we will look at each of the entity properties to find the
most meaningful terms. The latter is slower and won’t give the best results - avoid it if possible.</p><p>Here is how you pass the entity instance you want to compare with:</p><div class="informalexample"><pre><code class="language-java">Coffee coffee = ...; //managed entity from somewhere

Query mltQuery = qb
        .moreLikeThis()
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntity( coffee )
            .createQuery();</code></pre></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>By default, the results contain at the top the entity you are comparing with. This is particularly
useful to compare relative scores. If you don’t need it, you can exclude it.</p></div><div class="informalexample"><pre><code class="language-java">Query mltQuery = qb
        .moreLikeThis()
            .excludeEntityUsedForComparison()
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntity( coffee )
            .createQuery();</code></pre></div><p>You can ask Hibernate Search to give a higher score to the very similar entities and downgrade the
score of mildly similar entities. We do that by boosting each meaningful terms by their individual
overall score. Start with a boost factor of <code class="literal">1</code> and adjust from there.</p><div class="informalexample"><pre><code class="language-java">Query mltQuery = qb
        .moreLikeThis()
            .favorSignificantTermsWithFactor(1f)
            .comparingField("summary").boostedTo(10f)
            .andField("description")
            .toEntity( coffee )
            .createQuery();</code></pre></div><p>Remember, more like this is a very subjective meaning and will vary depending on your data and the
rules of your domain. With the various options offered, Hibernate Search arms you with the tools to
adjust this weapon. Make sure to continuously test the results against your data set.</p></section><section class="section" id="_combining_queries"><div class="titlepage"><div><div><h4 class="title">5.1.2.8. Combining queries</h4></div></div></div><p>You can combine queries to create more complex queries.
The following aggregation operators are available:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">SHOULD</code>: the query should contain the matching elements of the subquery</li><li class="listitem"><code class="literal">MUST</code>: the query must contain the matching elements of the subquery</li><li class="listitem"><code class="literal">MUST NOT</code>: the query must not contain the matching elements of the subquery</li></ul></div><p>These aggregations have a similar effect as the classic boolean operators <code class="literal">AND</code>, <code class="literal">OR</code> and <code class="literal">NOT</code>,
but have different names to emphasise that they will have an impact on scoring.</p><p>For example the <code class="literal">SHOULD</code> operator between two queries will have an effect similar to the boolean <code class="literal">OR</code>:
if either of the two combined queries matches the entry, the entry will be included in the match;
though the entries which match both queries will have an higher score than those which only match one of them.</p><p>The sub-queries can be any Lucene query including a boolean query itself.</p><div class="example" id="d0e6100"><div class="example-title">Example 5.4. Structure of a boolean <code class="literal">AND</code> query: the <code class="literal">must</code> method.</div><div class="example-contents"><pre><code class="language-java">Query combinedQuery = querybuilder
    .bool()
        .must( queryA )
        .must( queryB )
    .createQuery();</code></pre></div></div><br class="example-break"/><div class="example" id="d0e6111"><div class="example-title">Example 5.5. Structure of boolean <code class="literal">OR</code> query: the <code class="literal">should</code> method.</div><div class="example-contents"><pre><code class="language-java">Query combinedQuery = querybuilder
    .bool()
        .should( queryA )
        .should( queryB )
    .createQuery();</code></pre></div></div><br class="example-break"/><div class="example" id="d0e6122"><div class="example-title">Example 5.6. Structure of a negation query: apply a <code class="literal">not</code> modifier to a <code class="literal">must</code>.</div><div class="example-contents"><pre><code class="language-java">Query combinedQuery = querybuilder
    .bool()
        .must( queryA )
        .must( queryB ).not()
    .createQuery();</code></pre></div></div><br class="example-break"/><p>Let’s look at a few more practical examples; note how the querybuilder usage can be nested
and how 'should', 'must', and 'not' can be combined in many ways:</p><div class="example" id="d0e6135"><div class="example-title">Example 5.7. Full example of combining fulltext queries</div><div class="example-contents"><pre><code class="language-java">//look for popular modern myths that are not urban
Date twentiethCentury = ...;
Query luceneQuery = mythQB
    .bool()
      .must( mythQB.keyword().onField("description").matching("urban").createQuery() )
        .not()
      .must( mythQB.range().onField("starred").above(4).createQuery() )
      .must( mythQB
        .range()
        .onField("creationDate")
        .above(twentiethCentury)
        .createQuery() )
    .createQuery();

//look for popular myths that are preferably urban
Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .must( mythQB.range().onField("starred").above(4).createQuery() )
    .createQuery();

//look for all myths except religious ones
Query luceneQuery = mythQB
    .all()
      .except( monthQb
        .keyword()
        .onField( "description_stem" )
        .matching( "religion" )
        .createQuery()
      )
    .createQuery();</code></pre></div></div><br class="example-break"/></section><section class="section" id="_query_options"><div class="titlepage"><div><div><h4 class="title">5.1.2.9. Query options</h4></div></div></div><p>We already have seen several query options in the previous example, but lets summarize again the
options for query types and fields:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">boostedTo</code> (on query type and on field): boost the whole query or the specific field to a given
factor</li><li class="listitem"><code class="literal">withConstantScore</code> (on query): all results matching the query have a constant score equals to the
boost</li><li class="listitem"><code class="literal">filteredBy(Filter)</code> (on query): filter query results using the Filter instance</li><li class="listitem"><code class="literal">ignoreAnalyzer</code> (on field): ignore the analyzer when processing this field</li><li class="listitem"><code class="literal">ignoreFieldBridge</code> (on field): ignore field bridge when processing this field</li></ul></div><p>Let’s check out an example using some of these options</p><div class="informalexample"><pre><code class="language-java">Query luceneQuery = mythQB
    .bool()
      .should( mythQB.keyword().onField("description").matching("urban").createQuery() )
      .should( mythQB
        .keyword()
        .onField("name")
          .boostedTo(3)
          .ignoreAnalyzer()
        .matching("urban").createQuery() )
      .must( mythQB
        .range()
          .boostedTo(5).withConstantScore()
        .onField("starred").above(4).createQuery() )
    .createQuery();</code></pre></div><p>As you can see, the Hibernate Search query DSL is an easy to use and easy to read query API and by
accepting and producing Lucene queries, you can easily incorporate query types not (yet) supported
by the DSL. Please give us feedback!</p></section></section><section class="section" id="_building_a_hibernate_search_query"><div class="titlepage"><div><div><h3 class="title">5.1.3. Building a Hibernate Search query</h3></div></div></div><p>So far we only covered the process of how to create your Lucene query (see <a class="xref" href="#section-building-lucene-queries" title="5.1. Building queries">Section 5.1, “Building queries”</a>).
However, this is only the first step in the chain of actions. Let’s now see how
to build the Hibernate Search query from the Lucene query.</p><section class="section" id="_generality"><div class="titlepage"><div><div><h4 class="title">5.1.3.1. Generality</h4></div></div></div><p>Once the Lucene query is built, it needs to be wrapped into an Hibernate Query. If not specified
otherwise, the query will be executed against all indexed entities, potentially returning all types
of indexed classes.</p><div class="example" id="d0e6190"><div class="example-title">Example 5.8. Wrapping a Lucene query into a Hibernate Query</div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession( session );
org.hibernate.Query fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery );</code></pre></div></div><br class="example-break"/><p>It is advised, from a performance point of view, to restrict the returned types:</p><div class="example" id="example-filtering-by-entity-type"><div class="example-title">Example 5.9. Filtering the search result by entity type</div><div class="example-contents"><pre><code class="language-java">fullTextQuery = fullTextSession
    .createFullTextQuery(luceneQuery, Customer.class);

// or

fullTextQuery = fullTextSession
    .createFullTextQuery(luceneQuery, Item.class, Actor.class);</code></pre></div></div><br class="example-break"/><p>In <a class="xref" href="#example-filtering-by-entity-type" title="Example 5.9. Filtering the search result by entity type">Example 5.9, “Filtering the search result by entity type”</a> the first example returns only matching <code class="literal">Customer</code> instances,
the second returns matching <code class="literal">Actor</code> and <code class="literal">Item</code> instances. The type restriction is fully polymorphic
which means that if there are two indexed subclasses <code class="literal">Salesman</code> and <code class="literal">Customer</code> of the baseclass
<code class="literal">Person</code>, it is possible to just specify <code class="literal">Person.class</code> in order to filter on result types.</p></section><section class="section" id="_pagination"><div class="titlepage"><div><div><h4 class="title">5.1.3.2. Pagination</h4></div></div></div><p>Out of performance reasons it is recommended to restrict the number of returned objects per query.
In fact is a very common use case anyway that the user navigates from one page to an other. The way
to define pagination is exactly the way you would define pagination in a plain HQL or Criteria
query.</p><div class="example" id="d0e6232"><div class="example-title">Example 5.10. Defining pagination for a search query</div><div class="example-contents"><pre><code class="language-java">org.hibernate.Query fullTextQuery =
    fullTextSession.createFullTextQuery(luceneQuery, Customer.class);
fullTextQuery.setFirstResult(15); //start from the 15th element
fullTextQuery.setMaxResults(10); //return 10 elements</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>It is still possible to get the total number of matching elements regardless of the pagination via
fulltextQuery.getResultSize()</p></div></section><section class="section" id="__anchor_xml_id_query_sorting_xreflabel_query_sorting_sorting"><div class="titlepage"><div><div><h4 class="title">5.1.3.3. <span id="query-sorting"/>Sorting</h4></div></div></div><p>Apache Lucene provides a very flexible and powerful way to sort results. While the default sorting
(by relevance) is appropriate most of the time, it can be interesting to sort by one or several
other properties.</p><p>In order to do so, you will have to build a Lucene <code class="literal">Sort</code> object, which can be done by using either the Hibernate Search sort DSL or the native Lucene <code class="literal">SortField</code> class.</p><p>If you use the Hibernate Search sort DSL, it will look like this:</p><div class="example" id="d0e6256"><div class="example-title">Example 5.11. Sorting the results with a DSL-built Lucene <code class="literal">Sort</code></div><div class="example-contents"><pre><code class="language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = builder
  .sort()
    .byField("author").desc() // Descending order
    .andByField("title") // Default order (ascending)
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>If you use the Sort DSL (like in the example above) to target fields indexed through <span class="strong"><strong>custom</strong></span> <code class="literal">FieldBridge</code>s,
then those field bridges must implement <a class="link" href="#metadata-providing-field-bridge"><code class="literal">MetadataProvidingFieldBridge</code></a>,
so as to define the type of those fields and to mention that they are sortable.</p></div><p>Alternatively, you may build your sort using the Lucene <code class="literal">SortField</code> class directly. Then you will have to always specify the sort field type manually.</p><div class="example" id="d0e6281"><div class="example-title">Example 5.12. Sorting the results with a custom-built Lucene <code class="literal">Sort</code></div><div class="example-contents"><pre><code class="language-java">FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
org.apache.lucene.search.Sort sort = new Sort(
    new SortField("author", SortField.Type.STRING),
    new SortField("title", SortField.Type.STRING));
query.setSort(sort);
List results = query.list();</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Be aware that fields used for sorting must not be tokenized (see <a class="xref" href="#field-annotation" title="4.1.1.2. @Field">Section 4.1.1.2, “@Field”</a>). Also they should
be marked as sortable field using the <code class="literal">@SortableField</code> annotation (see <a class="xref" href="#sortablefield-annotation" title="4.1.1.4. @SortableField">Section 4.1.1.4, “@SortableField”</a>).</p></div><section class="section" id="_handling_missing_values"><div class="titlepage"><div><div><h5 class="title">5.1.3.3.1. Handling missing values</h5></div></div></div><p>By default, Hibernate Search will expect every document to contain exactly one value for the given sort fields. If it’s not the case, you may decide whether documents with missing values will end up in first or last position in the result list:</p><div class="example" id="d0e6303"><div class="example-title">Example 5.13. Returning documents with missing values in first position when sorting</div><div class="example-contents"><pre><code class="language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = builder
  .sort()
    .byField("author")
      .onMissingValue().sortFirst()
    .andByField("title")
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre></div></div><br class="example-break"/><p>For numeric fields (and only numeric fields), you may even provide a default value to be used in case it’s missing:</p><div class="example" id="d0e6310"><div class="example-title">Example 5.14. Using a default value on a sort field</div><div class="example-contents"><pre><code class="language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = builder
  .sort()
    .byField("authorId")
      .onMissingValue().use(42L) // Assume the ID is 42 when it's missing
    .andByField("title")
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>The <code class="literal">use(Object)</code> method expects a value matching the actual type of the field. Field bridges, if any, are <span class="strong"><strong>not</strong></span> applied.
Thus, in the example above, providing an <code class="literal">Author</code> instead of the identifier directly would not work.</p></div></section><section class="section" id="_using_native_sorts_within_the_sort_dsl"><div class="titlepage"><div><div><h5 class="title">5.1.3.3.2. Using native sorts within the sort DSL</h5></div></div></div><p>If you happen to find a sorting feature that is supported by Lucene, but not yet implemented in Hibernate Search sort DSL. If so, you may still use the DSL to mix a native <code class="literal">SortField</code> with DSL-defined sorts:</p><div class="example" id="d0e6335"><div class="example-title">Example 5.15. Mixing DSL-defined sorts with native Lucene <code class="literal">SortField</code>s</div><div class="example-contents"><pre><code class="language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
SortField complexSortField = /* ... */;
Sort sort = builder
  .sort()
    .byField("author")
    .andByNative(complexSortField)
  .createSort();
query.setSort(sort);
List results = query.list();</code></pre></div></div><br class="example-break"/></section></section><section class="section" id="_fetching_strategy"><div class="titlepage"><div><div><h4 class="title">5.1.3.4. Fetching strategy</h4></div></div></div><p>When you restrict the return types to one class, Hibernate Search loads the objects using a single
query. It also respects the static fetching strategy defined in your domain model.</p><p>It is often useful, however, to refine the fetching strategy for a specific use case.</p><div class="example" id="d0e6350"><div class="example-title">Example 5.16. Specifying FetchMode on a query</div><div class="example-contents"><pre><code class="language-java">Criteria criteria =
    s.createCriteria(Book.class).setFetchMode("authors", FetchMode.JOIN);
s.createFullTextQuery(luceneQuery).setCriteriaQuery(criteria);</code></pre></div></div><br class="example-break"/><p>In this example, the query will return all Books matching the luceneQuery. The authors collection
will be loaded from the same query using an SQL outer join.</p><p>When defining a criteria query, it is not necessary to restrict the returned entity types when
creating the Hibernate Search query from the full text session: the type is guessed from the
criteria query itself.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>Only fetch mode can be adjusted, refrain from applying any other restriction. While it is known to
work as of Hibernate Search 4, using restriction (ie a where clause) on your Criteria query should
be avoided when possible. <code class="literal">getResultSize()</code> will throw a <code class="literal">SearchException</code> if used in conjunction with a
Criteria with restriction.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>You cannot use setCriteriaQuery if more than one entity type is expected to be returned.</p></div></section><section class="section" id="projections"><div class="titlepage"><div><div><h4 class="title">5.1.3.5. Projection</h4></div></div></div><p>For some use cases, returning the domain object (including its associations) is overkill. Only a
small subset of the properties is necessary. Hibernate Search allows you to return a subset of
properties:</p><div class="example" id="d0e6376"><div class="example-title">Example 5.17. Using projection instead of returning the full domain object</div><div class="example-contents"><pre><code class="language-java">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection("id", "summary", "body", "mainAuthor.name");
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
Integer id = firstResult[0];
String summary = firstResult[1];
String body = firstResult[2];
String authorName = firstResult[3];</code></pre></div></div><br class="example-break"/><p>Hibernate Search extracts the properties from the Lucene index and convert them back to their object
representation, returning a list of <code class="literal">Object[]</code>. Projections avoid a potential database round trip
(useful if the query response time is critical). However, it also has several constraints:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the properties projected must be stored in the index (<code class="literal">@Field(store=Store.YES)</code>), which
increases the index size</li><li class="listitem">the properties projected must use a <code class="literal">FieldBridge</code> implementing org.hibernate.search.bridge.TwoWayFieldBridge or <code class="literal">org.hibernate.search.bridge.TwoWayStringBridge</code>, the latter being the simpler version.</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>All Hibernate Search built-in types are two-way.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">you can only project simple properties of the indexed entity or its embedded associations.
This means you cannot project a whole embedded entity.</li><li class="listitem">projection does not work on collections or maps which are indexed via <code class="literal">@IndexedEmbedded</code></li></ul></div><p>Projection is also useful for another kind of use case. Lucene can provide metadata information
about the results. By using some special projection constants, the projection mechanism can retrieve
this metadata:</p><div class="example" id="d0e6416"><div class="example-title">Example 5.18. Using projection in order to retrieve meta data</div><div class="example-contents"><pre><code class="language-java">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection(
    FullTextQuery.SCORE,
    FullTextQuery.THIS,
    "mainAuthor.name" );
List results = query.list();
Object[] firstResult = (Object[]) results.get(0);
float score = firstResult[0];
Book book = firstResult[1];
String authorName = firstResult[2];</code></pre></div></div><br class="example-break"/><p>You can mix and match regular fields and projection constants. Here is the list of the available
constants:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">FullTextQuery.THIS</code>: returns the initialized and managed entity (as a non projected query would
have done).</li><li class="listitem"><code class="literal">FullTextQuery.DOCUMENT</code>: returns the Lucene Document related to the object projected.</li><li class="listitem"><code class="literal">FullTextQuery.OBJECT_CLASS</code>: returns the class of the indexed entity.</li><li class="listitem"><code class="literal">FullTextQuery.SCORE</code>: returns the document score in the query. Scores are handy to compare one
result against an other for a given query but are useless when comparing the result of different
queries.</li><li class="listitem"><code class="literal">FullTextQuery.ID</code>: the id property value of the projected object.</li><li class="listitem"><code class="literal">FullTextQuery.DOCUMENT_ID</code>: the Lucene document id. Careful, Lucene document id can change
overtime between two different IndexReader opening.</li><li class="listitem"><code class="literal">FullTextQuery.EXPLANATION</code>: returns the Lucene Explanation object for the matching object/document
in the given query. Do not use if you retrieve a lot of data. Running explanation typically is as
costly as running the whole Lucene query per matching element. Make sure you use projection!</li></ul></div></section><section class="section" id="_customizing_object_initialization_strategies"><div class="titlepage"><div><div><h4 class="title">5.1.3.6. Customizing object initialization strategies</h4></div></div></div><p>By default, Hibernate Search uses the most appropriate strategy to initialize entities matching your
full text query. It executes one (or several) queries to retrieve the required entities. This is the
best approach to minimize database round trips in a scenario where none / few of the retrieved
entities are present in the persistence context (ie the session) or the second level cache.</p><p>If most of your entities are present in the second level cache, you can force Hibernate Search to
look into the cache before retrieving an object from the database.</p><div class="example" id="d0e6466"><div class="example-title">Example 5.19. Check the second-level cache before using a query</div><div class="example-contents"><pre><code class="language-java">FullTextQuery query = session.createFullTextQuery(luceneQuery, User.class);
query.initializeObjectWith(
    ObjectLookupMethod.SECOND_LEVEL_CACHE,
    DatabaseRetrievalMethod.QUERY
);</code></pre></div></div><br class="example-break"/><p><code class="literal">ObjectLookupMethod</code> defines the strategy used to check if an object is easily accessible (without
database round trip). Other options are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">ObjectLookupMethod.PERSISTENCE_CONTEXT</code>: useful if most of the matching entities are
already in the persistence context (ie loaded in the Session or EntityManager)</li><li class="listitem"><code class="literal">ObjectLookupMethod.SECOND_LEVEL_CACHE</code>: check first the persistence context and then
the second-level cache.</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Note that to search in the second-level cache, several settings must be in place:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the second level cache must be properly configured and active</li><li class="listitem">the entity must have enabled second-level cache (eg via <code class="literal">@Cacheable</code>)</li><li class="listitem">the <code class="literal">Session</code>, <code class="literal">EntityManager</code> or <code class="literal">Query</code> must allow access to the second-level cache for
read access (ie <code class="literal">CacheMode.NORMAL</code> in Hibernate native APIs or <code class="literal">CacheRetrieveMode.USE</code> in JPA 2 APIs).</li></ul></div></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>Avoid using <code class="literal">ObjectLookupMethod.SECOND_LEVEL_CACHE</code> unless your second level cache
implementation is either EHCache or Infinispan; other second level cache providers don’t currently
implement this operation efficiently.</p></div><p>You can also customize how objects are loaded from the database (if not found before). Use
<code class="literal">DatabaseRetrievalMethod</code> for that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">QUERY</code> (default): use a (set of) queries to load several objects in batch. This is usually the
best approach.</li><li class="listitem"><code class="literal">FIND_BY_ID</code>: load objects one by one using the <code class="literal">Session.get</code> or <code class="literal">EntityManager.find</code> semantic.
This might be useful if batch-size is set on the entity (in which case, entities will be loaded in
batch by Hibernate Core). QUERY should be preferred almost all the time.</li></ul></div><p>The defaults for both methods, the object lookup as well as the database retrieval can also be
configured via configuration properties. This way you don’t have to specify your preferred methods on
each query creation. The property names are <code class="literal">hibernate.search.query.object_lookup_method</code>
and <code class="literal">hibernate.search.query.database_retrieval_method</code> respectively. As value use the name of the
method (upper- or lowercase). For example:</p><div class="example" id="d0e6553"><div class="example-title">Example 5.20. Setting object lookup and database retrieval methods via configuration properties</div><div class="example-contents"><pre class="screen">hibernate.search.query.object_lookup_method = second_level_cache
hibernate.search.query.database_retrieval_method = query</pre></div></div><br class="example-break"/></section><section class="section" id="_limiting_the_time_of_a_query"><div class="titlepage"><div><div><h4 class="title">5.1.3.7. Limiting the time of a query</h4></div></div></div><p>You can limit the time a query takes in Hibernate Search in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">raise an exception when the limit is reached</li><li class="listitem">limit to the number of results retrieved when the time limit is raised</li></ul></div><section class="section" id="_raise_an_exception_on_time_limit"><div class="titlepage"><div><div><h5 class="title">5.1.3.7.1. Raise an exception on time limit</h5></div></div></div><p>You can decide to stop a query if when it takes more than a predefined amount of time. Note that
this is a best effort basis but if Hibernate Search still has significant work to do and if we are
beyond the time limit, a QueryTimeoutException will be raised (org.hibernate.QueryTimeoutException
or javax.persistence.QueryTimeoutException depending on your programmatic API).</p><p>To define the limit when using the native Hibernate APIs, use one of the following approaches</p><div class="example" id="d0e6577"><div class="example-title">Example 5.21. Defining a timeout in query execution</div><div class="example-contents"><pre><code class="language-java">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.setTimeout(5);

//alternatively, define the timeout in any given time unit
query.setTimeout(450, TimeUnit.MILLISECONDS);

try {
    query.list();
}
catch (org.hibernate.QueryTimeoutException e) {
    //do something, too slow
}</code></pre></div></div><br class="example-break"/><p>Likewise <code class="literal">getResultSize()</code>, <code class="literal">iterate()</code> and <code class="literal">scroll()</code> honor the timeout but only until the end of
the method call. That simply means that the methods of Iterable or the ScrollableResults ignore the
timeout.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p><code class="literal">explain()</code> does not honor the timeout: this method is used for debug purposes and in particular to find out why a query is slow</p></div><p>When using JPA, simply use the standard way of limiting query execution time.</p><div class="example" id="d0e6600"><div class="example-title">Example 5.22. Defining a timeout in query execution</div><div class="example-contents"><pre><code class="language-java">Query luceneQuery = ...;
FullTextQuery query = fullTextEM.createFullTextQuery(luceneQuery, User.class);

//define the timeout in milliseconds
query.setHint( "javax.persistence.query.timeout", 450 );

try {
    query.getResultList();
}
catch (javax.persistence.QueryTimeoutException e) {
    //do something, too slow
}</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>Remember, this is a best effort approach and does not guarantee to stop exactly on the specified timeout.</p></div></section><section class="section" id="_limit_the_number_of_results_when_the_time_limit_is_reached"><div class="titlepage"><div><div><h5 class="title">5.1.3.7.2. Limit the number of results when the time limit is reached</h5></div></div></div><p>Alternatively, you can return the number of results which have already been fetched by the time the
limit is reached. Note that only the Lucene part of the query is influenced by this limit. It is
possible that, if you retrieve managed object, it takes longer to fetch these objects.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>This approach is not compatible with the setTimeout approach.</p></div><p>To define this soft limit, use the following approach</p><div class="example" id="d0e6618"><div class="example-title">Example 5.23. Defining a time limit in query execution</div><div class="example-contents"><pre><code class="language-java">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);
List results = query.list();</code></pre></div></div><br class="example-break"/><p>Likewise <code class="literal">getResultSize()</code>, <code class="literal">iterate()</code> and <code class="literal">scroll()</code> honor the time limit but only until the end
of the method call. That simply means that the methods of Iterable or the <code class="literal">ScrollableResults</code> ignore
the timeout.</p><p>You can determine if the results have been partially loaded by invoking the <code class="literal">hasPartialResults</code>
method.</p><div class="example" id="d0e6642"><div class="example-title">Example 5.24. Determines when a query returns partial results</div><div class="example-contents"><pre><code class="language-java">Query luceneQuery = ...;
FullTextQuery query = fullTextSession.createFullTextQuery(luceneQuery, User.class);

//define the timeout in seconds
query.limitExecutionTimeTo(500, TimeUnit.MILLISECONDS);
List results = query.list();

if ( query.hasPartialResults() ) {
    displayWarningToUser();
}</code></pre></div></div><br class="example-break"/><p>If you use the JPA API, limitExecutionTimeTo and hasPartialResults are also available to you.</p></section></section></section></section><section class="section" id="_retrieving_the_results"><div class="titlepage"><div><div><h2 class="title">5.2. Retrieving the results</h2></div></div></div><p>Once the Hibernate Search query is built, executing it is in no way different than executing a HQL
or Criteria query. The same paradigm and object semantic applies. All the common operations are
available: <code class="literal">list()</code>, <code class="literal">uniqueResult()</code>, <code class="literal">iterate()</code>, <code class="literal">scroll()</code>.</p><section class="section" id="_performance_considerations"><div class="titlepage"><div><div><h3 class="title">5.2.1. Performance considerations</h3></div></div></div><p>If you expect a reasonable number of results (for example using pagination) and expect to work on
all of them, <code class="literal">list()</code> or <code class="literal">uniqueResult()</code> are recommended. <code class="literal">list()</code> work best if the entity <code class="literal">batch-size</code>
is set up properly. Note that Hibernate Search has to process all Lucene Hits elements (within the
pagination) when using <code class="literal">list()</code> , <code class="literal">uniqueResult()</code> and <code class="literal">iterate()</code>.</p><p>If you wish to minimize Lucene document loading, <code class="literal">scroll()</code> is more appropriate. Don’t forget to close
the <code class="literal">ScrollableResults</code> object when you’re done, since it keeps Lucene resources. If you expect to use
scroll, but wish to load objects in batch, you can use <code class="literal">query.setFetchSize()</code>. When an object is
accessed, and if not already loaded, Hibernate Search will load the next <code class="literal">fetchSize</code> objects in one
pass.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>Pagination is preferred over scrolling.</p></div></section><section class="section" id="_result_size"><div class="titlepage"><div><div><h3 class="title">5.2.2. Result size</h3></div></div></div><p>It is sometimes useful to know the total number of matching documents:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">for the Google-like feature "1-10 of about 888,000,000"</li><li class="listitem">to implement a fast pagination navigation</li><li class="listitem">to implement a multi step search engine (adding approximation if the restricted query return no
or not enough results)</li></ul></div><p>Of course it would be too costly to retrieve all the matching documents. Hibernate Search allows you
to retrieve the total number of matching documents regardless of the pagination parameters. Even
more interesting, you can retrieve the number of matching elements without triggering a single
object load.</p><div class="example" id="d0e6726"><div class="example-title">Example 5.25. Determining the result size of a query</div><div class="example-contents"><pre><code class="language-java">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
//return the number of matching books without loading a single one
assert 3245 == query.getResultSize();

org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setMaxResult(10);
List results = query.list();
//return the total number of matching books regardless of pagination
assert 3245 == query.getResultSize();</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Like Google, the number of results is an approximation if the index is not fully up-to-date with the
database (asynchronous cluster for example).</p></div></section><section class="section" id="_resulttransformer"><div class="titlepage"><div><div><h3 class="title">5.2.3. ResultTransformer</h3></div></div></div><p>As seen in <a class="xref" href="#projections" title="5.1.3.5. Projection">Section 5.1.3.5, “Projection”</a> projection results are returns as Object arrays. This data structure is
not always matching the application needs. In this cases It is possible to apply a ResultTransformer
which post query execution can build the needed data structure:</p><div class="example" id="d0e6741"><div class="example-title">Example 5.26. Using ResultTransformer in conjunction with projections</div><div class="example-contents"><pre><code class="language-java">org.hibernate.search.FullTextQuery query =
    s.createFullTextQuery(luceneQuery, Book.class);
query.setProjection("title", "mainAuthor.name");

query.setResultTransformer(
    new StaticAliasToBeanResultTransformer(
        BookView.class,
        "title",
        "author" )
);
ListBookView&gt;; results = (List&lt;BookView&gt;) query.list();
for (BookView view : results) {
    log.info("Book: " + view.getTitle() + ", " + view.getAuthor());
}</code></pre></div></div><br class="example-break"/><p>Examples of ResultTransformer implementations can be found in the Hibernate Core codebase.</p></section><section class="section" id="_understanding_results"><div class="titlepage"><div><div><h3 class="title">5.2.4. Understanding results</h3></div></div></div><p>You will find yourself sometimes puzzled by a result showing up in a query or a result not showing
up in a query. Luke is a great tool to understand those mysteries. However, Hibernate Search also
gives you access to the Lucene Explanation object for a given result (in a given query). This class
is considered fairly advanced to Lucene users but can provide a good understanding of the scoring of
an object. You have two ways to access the Explanation object for a given result:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Use the fullTextQuery.explain(int) method</li><li class="listitem">Use projection</li></ul></div><p>The first approach takes a document id as a parameter and return the Explanation object. The
document id can be retrieved using projection and the <code class="literal">FullTextQuery.DOCUMENT_ID</code> constant.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>The Document id has nothing to do with the entity id. Do not mess up these two notions.</p></div><p>In the second approach you project the Explanation object using the <code class="literal">FullTextQuery.EXPLANATION</code>
constant.</p><div class="example" id="d0e6773"><div class="example-title">Example 5.27. Retrieving the Lucene Explanation object using projection</div><div class="example-contents"><pre><code class="language-java">FullTextQuery ftQuery = s.createFullTextQuery( luceneQuery, Dvd.class )
        .setProjection(
             FullTextQuery.DOCUMENT_ID,
             FullTextQuery.EXPLANATION,
             FullTextQuery.THIS );
@SuppressWarnings("unchecked") List&lt;Object[]&gt; results = ftQuery.list();
for (Object[] result : results) {
    Explanation e = (Explanation) result[1];
    display( e.toString() );
}</code></pre></div></div><br class="example-break"/><p>Be careful, building the explanation object is quite expensive, it is roughly as expensive as
running the Lucene query again. Don’t do it if you don’t need the object</p></section></section><section class="section" id="query-filter"><div class="titlepage"><div><div><h2 class="title">5.3. Filters</h2></div></div></div><p>Apache Lucene has a powerful feature that allows to filter query results according to a custom
filtering process. This is a very powerful way to apply additional data restrictions, especially
since filters can be cached and reused. Some interesting use cases are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">security</li><li class="listitem">temporal data (eg. view only last month’s data)</li><li class="listitem">population filter (eg. search limited to a given category)</li><li class="listitem">and many more</li></ul></div><p>Hibernate Search pushes the concept further by introducing the notion of parameterizable named
filters which are transparently cached. For people familiar with the notion of Hibernate Core
filters, the API is very similar:</p><div class="example" id="d0e6800"><div class="example-title">Example 5.28. Enabling fulltext filters for a given query</div><div class="example-contents"><pre><code class="language-java">fullTextQuery = s.createFullTextQuery(query, Driver.class);
fullTextQuery.enableFullTextFilter("bestDriver");
fullTextQuery.enableFullTextFilter("security").setParameter("login", "andre");
fullTextQuery.list(); //returns only best drivers where andre has credentials</code></pre></div></div><br class="example-break"/><p>In this example we enabled two filters on top of the query. You can enable (or disable) as many
filters as you like.</p><p>Declaring filters is done through the <code class="literal">@FullTextFilterDef</code> annotation.
You can use  <code class="literal">@FullTextFilterDef</code> or <code class="literal">@FullTextFilterDefs</code> on any:
*<code class="literal">@Indexed</code> entity regardless of the query the filter is later applied to
* Parent class of an <code class="literal">@Indexed</code> entity
* package-info.java of a package containing an <code class="literal">@Indexed</code> entity</p><p>This implies that filter definitions are global and their names must be unique.
A <code class="literal">SearchException</code> is thrown in case two different <code class="literal">@FullTextFilterDef</code> annotations
with the same name are defined. Each named filter has to
specify its actual filter implementation.</p><div class="example" id="d0e6835"><div class="example-title">Example 5.29. Defining and implementing a Filter</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@FullTextFilterDefs( {
    @FullTextFilterDef(name = "bestDriver", impl = BestDriversFilter.class),
    @FullTextFilterDef(name = "security", impl = SecurityFilterFactory.class)
})
public class Driver { ... }</code></pre><pre><code class="language-java">public class BestDriversFilter extends QueryWrapperFilter {

	public BestDriversFilter() {
		super( new TermQuery( new Term( "score", "5" ) ) );
	}

}</code></pre></div></div><br class="example-break"/><p><code class="literal">BestDriversFilter</code> is an example of a simple Lucene filter which reduces the result set to drivers
whose score is 5. In this example we use <code class="literal">org.apache.lucene.search.QueryWrapperFilter</code>, which extends
<code class="literal">org.apache.lucene.search.Filter</code>, as it’s a convenient way to wrap a Lucene Query.</p><p>Make sure the Filter has a public constructor which does not require any parameter.</p><p>If your Filter creation requires additional steps or if the filter you want to use does not have a
no-arg constructor, you can use the factory pattern:</p><div class="example" id="d0e6856"><div class="example-title">Example 5.30. Creating a filter using the factory pattern</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
@FullTextFilterDef(name = "bestDriver", impl = BestDriversFilterFactory.class)
public class Driver { ... }

public class BestDriversFilterFactory {

    @Factory
    public Filter getFilter() {
        //some additional steps to cache the filter results per IndexReader
        Filter bestDriversFilter = new BestDriversFilter();
        return new CachingWrapperFilter(bestDriversFilter);
    }
}</code></pre></div></div><br class="example-break"/><p>Hibernate Search will look for a <code class="literal">@Factory</code> annotated method and use it to build the filter
instance. The factory must have a no-arg constructor.</p><p>Named filters come in handy where parameters have to be passed to the filter. For example a security
filter might want to know which security level you want to apply:</p><div class="example" id="d0e6868"><div class="example-title">Example 5.31. Passing parameters to a defined filter</div><div class="example-contents"><pre><code class="language-java">fullTextQuery = s.createFullTextQuery(query, Driver.class);
fullTextQuery.enableFullTextFilter("security").setParameter("level", 5);</code></pre></div></div><br class="example-break"/><p>Each parameter must have an associated setter on either the filter or filter factory of the
targeted named filter definition.</p><div class="example" id="d0e6875"><div class="example-title">Example 5.32. Using parameters in the actual filter implementation</div><div class="example-contents"><pre><code class="language-java">public class SecurityFilterFactory {
    private Integer level;

    /**
     * injected parameter
     */
    public void setLevel(Integer level) {
        this.level = level;
    }

    @Factory
    public Filter getFilter() {
        Query query = new TermQuery( new Term( "level", level.toString() ) );
        return new CachingWrapperFilter( new QueryWrapperFilter(query) );
    }
}</code></pre></div></div><br class="example-break"/><p>Filters will be cached once created, based on all their parameter names and values.
Caching happens using a combination of
hard and soft references to allow disposal of memory when needed. The hard reference cache keeps
track of the most recently used filters and transforms the ones least used to SoftReferences when
needed. Once the limit of the hard reference cache is reached additional filters are cached as
SoftReferences. To adjust the size of the hard reference cache, use
<code class="literal">hibernate.search.filter.cache_strategy.size</code> (defaults to 128). For advanced use of filter
caching, you can implement your own FilterCachingStrategy. The classname is defined by
<code class="literal">hibernate.search.filter.cache_strategy</code>.</p><p>This filter caching mechanism should not be confused with caching the actual filter results. In
Lucene it is common practice to wrap filters using the IndexReader around a <code class="literal">CachingWrapperFilter</code>.
The wrapper will cache the DocIdSet returned from the <code class="literal">getDocIdSet(IndexReader reader)</code> method to
avoid expensive re-computation. It is important to mention that the computed <code class="literal">DocIdSet</code> is only
cachable for the same IndexReader instance, because the reader effectively represents the state of
the index at the moment it was opened. The document list cannot change within an opened
<code class="literal">IndexReader</code>. A different/new <code class="literal">IndexReader</code> instance, however, works potentially on a different set
of Documents (either from a different index or simply because the index has changed), hence the
cached DocIdSet has to be recomputed.</p><p>Hibernate Search also helps with this aspect of caching. Per default the <code class="literal">cache</code> flag of
<code class="literal">@FullTextFilterDef</code> is set to <code class="literal">FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</code> which will
automatically cache the filter instance as well as wrap the specified filter around a Hibernate
specific implementation of <code class="literal">CachingWrapperFilter</code>. In contrast to Lucene’s version of this class
<code class="literal">SoftReferences</code> are used together with a hard reference count (see discussion about filter cache).
The hard reference count can be adjusted using <code class="literal">hibernate.search.filter.cache_docidresults.size</code>
(defaults to 5). The wrapping behavior can be controlled using the <code class="literal">@FullTextFilterDef.cache</code>
parameter. There are three different values for this parameter:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Value</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Definition</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>FilterCacheModeType.NONE</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>No filter instance and no result is cached by Hibernate
              Search. For every filter call, a new filter instance is created.
              This setting might be useful for rapidly changing data sets or
              heavily memory constrained environments.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>FilterCacheModeType.INSTANCE_ONLY</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>The filter instance is cached and reused across
              concurrent Filter.getDocIdSet() calls.
              DocIdSet results are not cached. This
              setting is useful when a filter uses its own specific caching
              mechanism or the filter results change dynamically due to
              application specific events making
              DocIdSet caching in both cases
              unnecessary.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>FilterCacheModeType.INSTANCE_AND_DOCIDSETRESULTS</p></td><td style="text-align: left; vertical-align: top; "><p>Both the filter instance and the
              DocIdSet results are cached. This is the
              default value.</p></td></tr></tbody></table></div><p>Last but not least - why should filters be cached? There are two areas where filter caching shines:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the system does not update the targeted entity index often (in other words, the IndexReader is
reused a lot)</li><li class="listitem">the Filter’s DocIdSet is expensive to compute (compared to the time spent to execute the query)</li></ul></div><section class="section" id="query-filter-shard"><div class="titlepage"><div><div><h3 class="title">5.3.1. Using filters in a sharded environment</h3></div></div></div><p>It is possible, in a sharded environment to execute queries on a subset of the available shards.
This can be done in two steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">create a sharding strategy that does select a subset of IndexManagers depending on some filter configuration</li><li class="listitem">activate the proper filter at query time</li></ul></div><p>Let’s first look at an example of sharding strategy that query on a specific customer shard if the
customer filter is activated.</p><div class="informalexample"><pre><code class="language-java">public class CustomerShardingStrategy implements IndexShardingStrategy {

 // stored IndexManagers in a array indexed by customerID
 private IndexManager[] indexManagers;

 public void initialize(Properties properties, IndexManager[] indexManagers) {
   this.indexManagers = indexManagers;
 }

 public IndexManager[] getIndexManagersForAllShards() {
   return indexManagers;
 }

 public IndexManager getIndexManagerForAddition(
     Class&lt;?&gt; entity, Serializable id, String idInString, Document document) {
   Integer customerID = Integer.parseInt(document.getFieldable("customerID").stringValue());
   return indexManagers[customerID];
 }

 public IndexManager[] getIndexManagersForDeletion(
     Class&lt;?&gt; entity, Serializable id, String idInString) {
   return getIndexManagersForAllShards();
 }

  /**
  * Optimization; don't search ALL shards and union the results; in this case, we
  * can be certain that all the data for a particular customer Filter is in a single
  * shard; simply return that shard by customerID.
  */
 public IndexManager[] getIndexManagersForQuery(
     FullTextFilterImplementor[] filters) {
   FullTextFilter filter = getCustomerFilter(filters, "customer");
   if (filter == null) {
     return getIndexManagersForAllShards();
   }
   else {
     return new IndexManager[] { indexManagers[Integer.parseInt(
       filter.getParameter("customerID").toString())] };
   }
 }

 private FullTextFilter getCustomerFilter(FullTextFilterImplementor[] filters, String name) {
   for (FullTextFilterImplementor filter: filters) {
     if (filter.getName().equals(name)) return filter;
   }
   return null;
 }
}</code></pre></div><p>In this example, if the filter named <code class="literal">customer</code> is present, we make sure to only use the shard
dedicated to this customer. Otherwise, we return all shards. A given Sharding strategy can react to
one or more filters and depends on their parameters.</p><p>The second step is simply to activate the filter at query time. While the filter can be a regular
filter (as defined in <a class="xref" href="#query-filter" title="5.3. Filters">Section 5.3, “Filters”</a>) which also filters Lucene results after the query, you can
make use of a special filter that will only be passed to the sharding strategy and otherwise ignored
for the rest of the query. Simply use the <code class="literal">ShardSensitiveOnlyFilter</code> class when declaring your filter.</p><div class="informalexample"><pre><code class="language-java">@Entity @Indexed
@FullTextFilterDef(name="customer", impl=ShardSensitiveOnlyFilter.class)
public class Customer {
   // ...
}</code></pre></div><div class="informalexample"><pre><code class="language-java">FullTextQuery query = ftEm.createFullTextQuery(luceneQuery, Customer.class);
query.enableFulltextFilter("customer").setParameter("CustomerID", 5);
@SuppressWarnings("unchecked")
List&lt;Customer&gt; results = query.getResultList();</code></pre></div><p>Note that by using the <code class="literal">ShardSensitiveOnlyFilter</code>, you do not have to implement any Lucene filter.
Using filters and sharding strategy reacting to these filters is recommended to speed up queries in
a sharded environment.</p></section></section><section class="section" id="query-faceting"><div class="titlepage"><div><div><h2 class="title">5.4. Faceting</h2></div></div></div><p><a class="link" href="http://en.wikipedia.org/wiki/Faceted_search">Faceted search</a> is a technique which allows to
divide the results of a query into multiple categories. This categorization includes the calculation
of hit counts for each category and the ability to further restrict search results based on these
facets (categories). <a class="xref" href="#example-amazon-facets" title="Figure 5.1. Facets Example on Amazon">Figure 5.1, “Facets Example on Amazon”</a> shows a faceting example. The search for 'Hibernate
Search' results in fifteen hits which are displayed on the main part of the page. The navigation bar
on the left, however, shows the category<span class="emphasis"><em>Computers &amp; Internet</em></span> with its subcategories
<span class="emphasis"><em>Programming</em></span>, <span class="emphasis"><em>Computer Science</em></span>, <span class="emphasis"><em>Databases</em></span>, <span class="emphasis"><em>Software</em></span>, <span class="emphasis"><em>Web Development,</em></span>
<span class="emphasis"><em>Networking</em></span> and <span class="emphasis"><em>Home Computing</em></span>. For each of these subcategories the number of books is shown
matching the main search criteria and belonging to the respective subcategory. This division of the
category <span class="emphasis"><em>Computers &amp; Internet</em></span> is one facet of this search. Another one is for example the
average customer review rating.</p><div class="figure" id="example-amazon-facets"><div class="figure-title">Figure 5.1. Facets Example on Amazon</div><div class="figure-contents"><div class="mediaobject"><img src="images/faceting.png" alt="Search for _'Hibernate Search'_ on Amazon"/></div></div></div><br class="figure-break"/><p>In Hibernate Search the classes <code class="literal">QueryBuilder</code> and <code class="literal">FullTextQuery</code> are the entry point to the faceting
API. The former allows to create faceting requests whereas the latter gives access to the so called
<code class="literal">FacetManager</code>. With the help of the <code class="literal">FacetManager</code> faceting requests can be applied on a query and
selected facets can be added to an existing query in order to refine search results. The following
sections will describe the faceting process in more detail. The examples will use the entity <code class="literal">Cd</code> as
shown in <a class="xref" href="#example-faceting-entity" title="Example 5.33. Example entity for faceting">Example 5.33, “Example entity for faceting”</a>:</p><div class="example" id="example-faceting-entity"><div class="example-title">Example 5.33. Example entity for faceting</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Cd {

    @Id
    @GeneratedValue
    private int id;

    @Field,
    private String name;

    @Field(analyze = Analyze.NO)
    @Facet
    private int price;

    @Field(analyze = Analyze.NO)
    @DateBridge(resolution = Resolution.YEAR)
    @Facet
    private Date releaseYear;

    @Field(analyze = Analyze.NO)
    @Facet
    private String label;


// setter/getter
// ...</code></pre></div></div><br class="example-break"/><p>In order to facet on a given indexed field, the field needs to be configured with the <code class="literal">@Facet</code>
annotation. Also, the field itself cannot be analyzed.</p><p><code class="literal">@Facet</code> contains a <code class="literal">name</code> and <code class="literal">forField</code> parameter. The <code class="literal">name</code> is arbitrary and used to identify
the facet. Per default it matches the field name it belongs to. <code class="literal">forField</code> is relevant in case the
property is mapped to multiple fields using <code class="literal">@Fields</code> (see also <a class="xref" href="#fields-annotation" title="4.1.2. Mapping properties multiple times">Section 4.1.2, “Mapping properties multiple times”</a>). In this case
<code class="literal">forField</code> can be used to identify the index field to which it applies. Mirroring <code class="literal">@Fields</code> there
also exists a <code class="literal">@Facets</code> annotation in case multiple fields need to be targeted by faceting.</p><p>Last but not least, <code class="literal">@Facet</code> contains a
<code class="literal">encoding</code> parameter. Usually, Hibernate Search automatically selects the encoding:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">String fields are encoded as <code class="literal">FacetEncodingType.STRING</code></li><li class="listitem"><code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code> (including corresponding wrapper types) and <code class="literal">Date</code>
as <code class="literal">FacetEncodingType.LONG</code></li><li class="listitem">and <code class="literal">float</code> and <code class="literal">double</code> (including corresponding wrapper types) as FacetEncodingType.DOUBLE`</li></ul></div><p>In some cases it can make sense, however, to explicitly set the encoding.
<a class="link" href="#discrete-faceting-request" title="5.4.1.1. Discrete faceting request">Discrete faceting request</a>s for example only work for string encoded
facets. In order to use a discrete facet for numbers the encoding must be explicitly set to
<code class="literal">FacetEncodingType.STRING</code>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Pre Hibernate Search 5.2 there was no need to explicitly use a <code class="literal">@Facet</code> annotation. In 5.2 it became
necessary in order to use Lucene’s native faceting API.</p></div><section class="section" id="section-creating-faceting-request"><div class="titlepage"><div><div><h3 class="title">5.4.1. Creating a faceting request</h3></div></div></div><p>The first step towards a faceted search is to create the <code class="literal">FacetingRequest</code>. Currently two types of
faceting requests are supported. The first type is called <span class="emphasis"><em>discrete faceting</em></span> and the second type
<span class="emphasis"><em>range faceting</em></span> request.</p><section class="section" id="discrete-faceting-request"><div class="titlepage"><div><div><h4 class="title">5.4.1.1. Discrete faceting request</h4></div></div></div><p>In the case of a discrete faceting request, you start with giving the request a unique name. This
name will later be used to retrieve the facet values (see <a class="xref" href="#section-interpreting-facet-result" title="5.4.4. Interpreting a Facet result">Section 5.4.4, “Interpreting a Facet result”</a>).
Then you need to specify on which index field you want to categorize on and which faceting options
to apply. An example for a discrete faceting request can be seen in <a class="xref" href="#example-discrete-faceting" title="Example 5.34. Creating a discrete faceting request">Example 5.34, “Creating a discrete faceting request”</a>:</p><div class="example" id="example-discrete-faceting"><div class="example-title">Example 5.34. Creating a discrete faceting request</div><div class="example-contents"><pre><code class="language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Cd.class).get();

FacetingRequest labelFacetingRequest = builder.facet()
    .name("labelFacetRequest")
    .onField("label")
    .discrete()
    .orderedBy(FacetSortOrder.COUNT_DESC)
    .includeZeroCounts(false)
    .maxFacetCount(3)
    .createFacetingRequest();</code></pre></div></div><br class="example-break"/><p>When executing this faceting request a <code class="literal">Facet</code> instance will be created for each discrete value for
the indexed field <code class="literal">label</code>. The <code class="literal">Facet</code> instance will record the actual field value including how often
this particular field value occurs within the original query results. Parameters <code class="literal">orderedBy</code>,
<code class="literal">includeZeroCounts</code> and <code class="literal">maxFacetCount</code> are optional and can be applied on any faceting request.
Parameter <code class="literal">orderedBy</code> allows to specify in which order the created facets will be returned. The
default is <code class="literal">FacetSortOrder.COUNT_DESC</code>, but you can also sort on the field value. Parameter
<code class="literal">includeZeroCount</code> determines whether facets with a count of 0 will be included in the result (by
default they are not) and <code class="literal">maxFacetCount</code> allows to limit the maximum amount of facets returned.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>There are several preconditions an indexed field has to meet in order to categorize (facet) on it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The indexed property must be of type <code class="literal">String</code>, <code class="literal">Date</code> or of the numeric type byte, shirt, int,
long, double or float (or their respective Java wrapper types).</li><li class="listitem">The property has to be indexed with Analyze.NO.</li><li class="listitem"><span class="emphasis"><em>null</em></span> values should be avoided.</li></ul></div><p>When you need conflicting options, we suggest to index the property twice and use the appropriate
 field depending on the use case:</p><pre><code class="language-java">@Fields({
  @Field(name="price"),
  @Field(name="price_facet",
         analyze=Analyze.NO,
         bridge=@FieldBridge(impl = IntegerBridge.class))
})
private int price;</code></pre></div></section><section class="section" id="range-faceting-request"><div class="titlepage"><div><div><h4 class="title">5.4.1.2. Creating a range faceting request</h4></div></div></div><p>The creation of a range faceting request is similar. We also start with a name for the request and
the field to facet on. Then we have to specify ranges for the field values. A range faceting request
can be seen in <a class="xref" href="#example-range-faceting" title="Example 5.35. Creating a range faceting request">Example 5.35, “Creating a range faceting request”</a>. There, three different price ranges are specified. <code class="literal">below</code>
and <code class="literal">above</code> can only be specified once, but you can specify as many <code class="literal">from</code> - <code class="literal">to</code> ranges as you want.
For each range boundary you can also specify via <code class="literal">excludeLimit</code> whether it is included into the range
or not.</p><div class="example" id="example-range-faceting"><div class="example-title">Example 5.35. Creating a range faceting request</div><div class="example-contents"><pre><code class="language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
    .buildQueryBuilder()
        .forEntity(Cd.class)
            .get();
FacetingRequest priceFacetingRequest = builder.facet()
    .name("priceFaceting")
    .onField("price_facet")
    .range()
    .below(1000)
    .from(1001).to(1500)
    .above(1500).excludeLimit()
    .createFacetingRequest();</code></pre></div></div><br class="example-break"/></section></section><section class="section" id="section-sorting-faceting-request"><div class="titlepage"><div><div><h3 class="title">5.4.2. Setting the facet sort order</h3></div></div></div><p>The result of applying a faceting request is a list of <code class="literal">Facet</code> instances as seen in
<a class="xref" href="#example-applying-faceting" title="Example 5.36. Applying a faceting request">Example 5.36, “Applying a faceting request”</a>. The order within the list is given by the <code class="literal">FacetSortOrder</code> parameter
specified via <code class="literal">orderedBy</code> when creating the faceting request. The default value is
<code class="literal">FacetSortOrder.COUNT_DESC</code>, meaning facets are ordered by their count in descending order (highest
count first). Other values are <code class="literal">COUNT_ASC</code>, <code class="literal">FIELD_VALUE</code> and <code class="literal">RANGE_DEFINITION_ORDER</code>. <code class="literal">COUNT_ASC</code>
returns the facets in ascending count order whereas <code class="literal">FIELD_VALUE</code> will return them in alphabetical
order of the facet/category value (see <a class="xref" href="#section-interpreting-facet-result" title="5.4.4. Interpreting a Facet result">Section 5.4.4, “Interpreting a Facet result”</a>).
<code class="literal">RANGE_DEFINITION_ORDER</code> only applies for range faceting request and returns the facets in the same
order in which the ranges are defined. For <a class="xref" href="#example-range-faceting" title="Example 5.35. Creating a range faceting request">Example 5.35, “Creating a range faceting request”</a> this would mean the facet for
the range of below 1000 would be returned first, followed by the facet for the range 1001 to 1500
and finally the facet for above 1500.</p></section><section class="section" id="section-applying-faceting-request"><div class="titlepage"><div><div><h3 class="title">5.4.3. Applying a faceting request</h3></div></div></div><p>In <a class="xref" href="#section-creating-faceting-request" title="5.4.1. Creating a faceting request">Section 5.4.1, “Creating a faceting request”</a> we have seen how to create a faceting request. Now it is
time to apply it on a query. The key is the <code class="literal">FacetManager</code> which can be retrieved via the
<code class="literal">FullTextQuery</code> (see <a class="xref" href="#example-applying-faceting" title="Example 5.36. Applying a faceting request">Example 5.36, “Applying a faceting request”</a>).</p><div class="example" id="example-applying-faceting"><div class="example-title">Example 5.36. Applying a faceting request</div><div class="example-contents"><pre><code class="language-java">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery(luceneQuery, Cd.class);

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting(priceFacetingRequest);

// get the list of Cds
List&lt;Cd&gt; cds = fullTextQuery.list();
...

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets("priceFaceting");
...</code></pre></div></div><br class="example-break"/><p>You need to enable the faceting request before you execute the query. You do that via
<code class="literal">facetManager.enableFaceting(&lt;facetName&gt;)</code>. You can enable as many faceting requests as you
like. Then you execute the query and retrieve the facet results for a given request via
<code class="literal">facetManager.getFacets(&lt;facetname&gt;)</code>. For each request you will get a list of <code class="literal">Facet</code> instances.
Facet requests stay active and get applied to the fulltext query until they are either explicitly
disabled via <code class="literal">disableFaceting(&lt;facetName&gt;)</code> or the query is <code class="literal">discarded</code>.</p></section><section class="section" id="section-interpreting-facet-result"><div class="titlepage"><div><div><h3 class="title">5.4.4. Interpreting a Facet result</h3></div></div></div><p>Each facet request results in a list of <code class="literal">Facet</code> instances. Each instance represents one facet/category
value. In the CD example (<a class="xref" href="#example-discrete-faceting" title="Example 5.34. Creating a discrete faceting request">Example 5.34, “Creating a discrete faceting request”</a>) where we want to categorize on the CD
labels, there would for example be a <code class="literal">Facet</code> for each of the record labels Universal, Sony and Warner.
<a class="xref" href="#example-facet-api" title="Example 5.37. Facet API">Example 5.37, “Facet API”</a> shows the API of Facet.</p><div class="example" id="example-facet-api"><div class="example-title">Example 5.37. Facet API</div><div class="example-contents"><pre><code class="language-java">public interface Facet {
    /**
     * @return the faceting name this {@code Facet} belongs to.
     *
     * @see org.hibernate.search.query.facet.FacetingRequest#getFacetingName()
     */
    String getFacetingName();

    /**
     * Return the {@code Document} field name this facet is targeting.
     * The field needs to be indexed with {@code Analyze.NO}.
     *
     * @return the {@code Document} field name this facet is targeting.
     */
    String getFieldName();

    /**
     * @return the value of this facet. In case of a discrete facet it is the actual
     *         {@code Document} field value. In case of a range query the value is a
     *         string representation of the range.
     */
    String getValue();

    /**
     * @return the facet count.
     */
    int getCount();

    /**
     * @return a Lucene {@link Query} which can be executed to retrieve all
     *         documents matching the value of this facet.
     */
    Query getFacetQuery();
}</code></pre></div></div><br class="example-break"/><p><code class="literal">getFacetingName()</code> and <code class="literal">getFieldName()</code> are returning the facet request name and the targeted document
field name as specified by the underlying <code class="literal">FacetRequest</code>. For example "<a class="xref" href="#example-discrete-faceting" title="Example 5.34. Creating a discrete faceting request">Example 5.34, “Creating a discrete faceting request”</a>"
that would be <code class="literal">labelFacetRequest</code> and <code class="literal">label</code> respectively.
The interesting information is provided by <code class="literal">getValue()</code> and <code class="literal">getCount()</code>.
The former is the actual facet/category value, for example a concrete record label
like Universal. The latter returns the count for this value. To stick with the example again, the
count value tells you how many Cds are released under the Universal label. Last but not least,
<code class="literal">getFacetQuery()</code> returns a Lucene query which can be used to retrieve the entities counted in this
facet.</p></section><section class="section" id="_restricting_query_results"><div class="titlepage"><div><div><h3 class="title">5.4.5. Restricting query results</h3></div></div></div><p>A common use case for faceting is a "drill-down" functionality which allows you to narrow your
original search by applying a given facet on it. To do this, you can apply any of the returned
<code class="literal">Facet</code> instances as additional criteria on your original query via <code class="literal">FacetSelection</code>. <code class="literal">FacetSelection</code>
is available via the <code class="literal">FacetManager</code> and allow you to select a facet as query criteria (<code class="literal">selectFacets</code>),
remove a facet restriction (<code class="literal">deselectFacets</code>), remove all facet restrictions (<code class="literal">clearSelectedFacets</code>) and
retrieve all currently selected facets (<code class="literal">getSelectedFacets</code>). <a class="xref" href="#example-restricting-query-results" title="Example 5.38. Restricting query results via the application of a FacetSelection">Example 5.38, “Restricting query results via the application of a <code class="literal">FacetSelection</code>”</a>
shows an example.</p><div class="example" id="example-restricting-query-results"><div class="example-title">Example 5.38. Restricting query results via the application of a <code class="literal">FacetSelection</code></div><div class="example-contents"><pre><code class="language-java">// create a fulltext query
Query luceneQuery = builder.all().createQuery(); // match all query
FullTextQuery fullTextQuery = fullTextSession.createFullTextQuery( luceneQuery, clazz );

// retrieve facet manager and apply faceting request
FacetManager facetManager = fullTextQuery.getFacetManager();
facetManager.enableFaceting( priceFacetingRequest );

// get the list of Cd
List&lt;Cd&gt; cds = fullTextQuery.list();
assertTrue(cds.size() == 10);

// retrieve the faceting results
List&lt;Facet&gt; facets = facetManager.getFacets( "priceFaceting" );
assertTrue(facets.get(0).getCount() == 2)

// apply first facet as additional search criteria
FacetSelection facetSelection = facetManager.getFacetGroup( "priceFaceting" );
facetSelection.selectFacets( facets.get( 0 ) );

// re-execute the query
cds = fullTextQuery.list();
assertTrue(cds.size() == 2);</code></pre></div></div><br class="example-break"/><p>Per default selected facets are combined via  disjunction (OR). In case a field has multiple values,
like a potential <code class="literal">Cd.artists</code> association, you can also use  conjunction (AND) for the facet selection.</p><div class="example" id="example-using-conjunction-restricting-query-results"><div class="example-title">Example 5.39. Using conjunction in <code class="literal">FacetSelection</code></div><div class="example-contents"><pre><code class="language-java">FacetSelection facetSelection = facetManager.getFacetGroup( "artistsFaceting" );
facetSelection.selectFacets( FacetCombine.AND, facets.get( 0 ), facets.get( 1 ) );</code></pre></div></div><br class="example-break"/></section></section><section class="section" id="_optimizing_the_query_process"><div class="titlepage"><div><div><h2 class="title">5.5. Optimizing the query process</h2></div></div></div><p>Query performance depends on several criteria:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the Lucene query itself: read the literature on this subject.</li><li class="listitem">the number of loaded objects: use pagination and / or index projection (if needed).</li><li class="listitem">the way Hibernate Search interacts with the Lucene readers: defines the appropriate
<a class="xref" href="#search-architecture-readerstrategy" title="2.3. Reader strategy">Section 2.3, “Reader strategy”</a>.</li></ul></div><section class="section" id="query-logging"><div class="titlepage"><div><div><h3 class="title">5.5.1. Logging executed Lucene queries</h3></div></div></div><p>Knowing the executed queries is vital when working on performance optimizations. This is especially
the case if your application accepts queries passed in by the user or e.g. dynamically builds queries
using the Hibernate Search query DSL.</p><p>In order to log all Lucene queries executed by Hibernate Search, enable <code class="literal">DEBUG</code> logging for the log
category <code class="literal">org.hibernate.search.fulltext_query</code>.</p></section></section></section><section class="chapter" id="manual-index-changes"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Manual index changes</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#_adding_instances_to_the_index">6.1. Adding instances to the index</a></span></li><li><span class="section"><a href="#_deleting_instances_from_the_index">6.2. Deleting instances from the index</a></span></li><li><span class="section"><a href="#search-batchindex">6.3. Rebuilding the whole index</a></span><ul><li><span class="section"><a href="#search-batchindex-flushtoindexes">6.3.1. Using flushToIndexes()</a></span></li><li><span class="section"><a href="#search-batchindex-massindexer">6.3.2. Using a MassIndexer</a></span></li><li><span class="section"><a href="#_useful_parameters_for_batch_indexing">6.3.3. Useful parameters for batch indexing</a></span></li></ul></li></ul></div><p>As Hibernate core applies changes to the Database, Hibernate Search detects these changes and will
update the index automatically (unless the EventListeners are disabled). Sometimes changes are made
to the database without using Hibernate, as when backup is restored or your data is otherwise
affected; for these cases Hibernate Search exposes the Manual Index APIs to explicitly update or
remove a single entity from the index, or rebuild the index for the whole database, or remove all
references to a specific type.</p><p>All these methods affect the Lucene Index only, no changes are applied to the Database.</p><section class="section" id="_adding_instances_to_the_index"><div class="titlepage"><div><div><h2 class="title">6.1. Adding instances to the index</h2></div></div></div><p>Using <code class="literal">FullTextSession.index(T entity)</code> you can directly add or update a specific object instance to
the index. If this entity was already indexed, then the index will be updated. Changes to the index
are only applied at transaction commit.</p><div class="example" id="d0e7501"><div class="example-title">Example 6.1. Indexing an entity via <code class="literal">FullTextSession.index(T entity)</code></div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
Object customer = fullTextSession.load( Customer.class, 8 );
fullTextSession.index(customer);
tx.commit(); //index only updated at commit time</code></pre></div></div><br class="example-break"/><p>In case you want to add all instances for a type, or for all indexed types, the recommended approach
is to use a MassIndexer: see <a class="xref" href="#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a> for more details.</p><p>The method <code class="literal">FullTextSession.index(T entity)</code> is considered an explicit indexing operation, so any
registered EntityIndexingInterceptor won’t be applied in this case. For more information on
EntityIndexingInterceptor see <a class="xref" href="#search-mapping-indexinginterceptor" title="4.5. Conditional indexing">Section 4.5, “Conditional indexing”</a>.</p></section><section class="section" id="_deleting_instances_from_the_index"><div class="titlepage"><div><div><h2 class="title">6.2. Deleting instances from the index</h2></div></div></div><p>It is equally possible to remove an entity or all entities of a given type from a Lucene index
without the need to physically remove them from the database. This operation is named purging and is
also done through the <code class="literal">FullTextSession</code>.</p><div class="example" id="d0e7527"><div class="example-title">Example 6.2. Purging a specific instance of an entity from the index</div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
for (Customer customer : customers) {
    fullTextSession.purge( Customer.class, customer.getId() );
}
tx.commit(); //index is updated at commit time</code></pre></div></div><br class="example-break"/><p>Purging will remove the entity with the given id from the Lucene index but will not touch the
database.</p><p>If you need to remove all entities of a given type, you can use the purgeAll method. This operation
removes all entities of the type passed as a parameter as well as all its subtypes.</p><div class="example" id="d0e7536"><div class="example-title">Example 6.3. Purging all instances of an entity from the index</div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
Transaction tx = fullTextSession.beginTransaction();
fullTextSession.purgeAll( Customer.class );
//optionally optimize the index
//fullTextSession.getSearchFactory().optimize( Customer.class );
tx.commit(); //index changes are applied at commit time</code></pre></div></div><br class="example-break"/><p>As in the previous example, it is suggested to optimize the index after many purge operation to
actually free the used space.</p><p>As is the case with method <code class="literal">FullTextSession.index(T entity)</code>, also <code class="literal">purge</code> and <code class="literal">purgeAll</code> are
considered explicit indexing operations: any registered <code class="literal">EntityIndexingInterceptor</code> won’t be
applied. For more information on <code class="literal">EntityIndexingInterceptor</code> see
<a class="xref" href="#search-mapping-indexinginterceptor" title="4.5. Conditional indexing">Section 4.5, “Conditional indexing”</a>.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Methods index, purge and purgeAll are available on FullTextEntityManager as well.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>All manual indexing methods (index, purge and purgeAll) only affect the index, not the database,
nevertheless they are transactional and as such they won’t be applied until the transaction is
successfully committed, or you make use of flushToIndexes.</p></div></section><section class="section" id="search-batchindex"><div class="titlepage"><div><div><h2 class="title">6.3. Rebuilding the whole index</h2></div></div></div><p>If you change the entity mapping to the index, chances are that the whole index needs to be updated;
for example if you decide to index an existing field using a different analyzer you’ll need to
rebuild the index for affected types. Also if the Database is replaced (like restored from a backup,
imported from a legacy system) you’ll want to be able to rebuild the index from existing data.
Hibernate Search provides two main strategies to choose from:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Using <code class="literal">FullTextSession.flushToIndexes()</code> periodically, while using FullTextSession.index() on all
entities.</li><li class="listitem">Use a MassIndexer.</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>When you change the entity mapping to the index, if you don’t know whether the changes require
a full reindexing or not, you can follow this rule of thumb:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">Rebuilding the whole index is <span class="strong"><strong>not</strong></span> required if all you did was:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>adding</strong></span> new indexed entities that will not have any persisted instance,
e.g. adding an <code class="literal">@Indexed</code> annotation on an entity which has no rows in database.</li><li class="listitem"><span class="strong"><strong>adding</strong></span> new fields that will be empty for all currently persisted entities,
e.g. adding a new property on an entity type and mapping it to a field,
but with the guarantee that this property will initially be null for every instance of this entity;</li><li class="listitem">and/or <span class="strong"><strong>removing</strong></span> data from existing indexes/fields,
e.g. removing an index field, or removing the need for a field to be stored.</li></ul></div></li><li class="listitem">Rebuilding the whole index <span class="strong"><strong>is</strong></span> required if you made any change to the mapping that is not mentioned above.</li></ul></div></div><section class="section" id="search-batchindex-flushtoindexes"><div class="titlepage"><div><div><h3 class="title">6.3.1. Using flushToIndexes()</h3></div></div></div><p>This strategy consists in removing the existing index and then adding all entities back to the index
using <code class="literal">FullTextSession.purgeAll()</code> and <code class="literal">FullTextSession.index()</code>, however there are some memory and
efficiency constraints. For maximum efficiency Hibernate Search batches index operations and executes
them at commit time. If you expect to index a lot of data you need to be careful about memory
consumption since all documents are kept in a queue until the transaction commit. You can
potentially face an <code class="literal">OutOfMemoryException</code> if you don’t empty the queue periodically: to do this you
can use <code class="literal">fullTextSession.flushToIndexes()</code>. Every time <code class="literal">fullTextSession.flushToIndexes()</code> is called (or
if the transaction is committed), the batch queue is processed applying all index changes. Be aware
that, once flushed, the changes cannot be rolled back.</p><div class="example" id="d0e7639"><div class="example-title">Example 6.4. Index rebuilding using index() and flushToIndexes()</div><div class="example-contents"><pre><code class="language-java">fullTextSession.setFlushMode(FlushMode.MANUAL);
fullTextSession.setCacheMode(CacheMode.IGNORE);
transaction = fullTextSession.beginTransaction();
//Scrollable results will avoid loading too many objects in memory
ScrollableResults results = fullTextSession.createCriteria( Email.class )
    .setFetchSize(BATCH_SIZE)
    .scroll(ScrollMode.FORWARD_ONLY);
int index = 0;
while(results.next()) {
    index++;
    fullTextSession.index(results.get(0)); //index each element
    if (index % BATCH_SIZE == 0) {
        fullTextSession.flushToIndexes(); //apply changes to indexes
        fullTextSession.clear(); //free memory since the queue is processed
    }
}
transaction.commit();</code></pre></div></div><br class="example-break"/><p>Try to use a batch size that guarantees that your application will not run out of memory: with a
bigger batch size objects are fetched faster from database but more memory is needed.</p></section><section class="section" id="search-batchindex-massindexer"><div class="titlepage"><div><div><h3 class="title">6.3.2. Using a MassIndexer</h3></div></div></div><p>Hibernate Search’s MassIndexer uses several parallel threads to rebuild the index; you can
optionally select which entities need to be reloaded or have it reindex all entities. This approach
is optimized for best performance but requires to set the application in maintenance mode: making
queries to the index is not recommended when a MassIndexer is busy.</p><div class="example" id="d0e7651"><div class="example-title">Example 6.5. Index rebuilding using a MassIndexer</div><div class="example-contents"><pre><code class="language-java">fullTextSession.createIndexer().startAndWait();</code></pre></div></div><br class="example-break"/><p>This will rebuild the index, deleting it and then reloading all entities from the database. Although
it’s simple to use, some tweaking is recommended to speed up the process: there are several
parameters configurable.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>During the progress of a MassIndexer the content of the index is undefined! If a query is performed
while the MassIndexer is working most likely some results will be missing.</p></div><div class="example" id="d0e7661"><div class="example-title">Example 6.6. Using a tuned MassIndexer</div><div class="example-contents"><pre><code class="language-java">fullTextSession
 .createIndexer( User.class )
 .batchSizeToLoadObjects( 25 )
 .cacheMode( CacheMode.NORMAL )
 .threadsToLoadObjects( 12 )
 .idFetchSize( 150 )
 .transactionTimeout( 1800 )
 .progressMonitor( monitor ) //a MassIndexerProgressMonitor implementation
 .startAndWait();</code></pre></div></div><br class="example-break"/><p>This will rebuild the index of all <code class="literal">User</code> instances (and subtypes), and will create 12 parallel
threads to load the User instances using batches of 25 objects per query; these same 12 threads will
also need to process indexed embedded relations and custom FieldBridges or ClassBridges, to finally
output a Lucene document. In this conversion process these threads are likely going to need to
trigger lazy loading of additional attributes, so you will probably need a high number of threads
working in parallel. When run in a JTA environment such as the WildFly application server, the mass
indexer will use a timeout of 1800 seconds (= 30 minutes) for its transactions. Configure a timeout
value which is long enough to load and index all entities of the type with the most instances,
taking into account the configured batch size and number of threads to load objects. Note that
these transactions are read-only, so choosing a substantially large value should pose no problem in
general.</p><p>As of Hibernate Search 4.4.0, instead of indexing all the types in parallel, the MassIndexer is
configured by default to index only one type in parallel. It prevents resource exhaustion especially
database connections and usually does not slow down the indexing. You can however configure this
behavior using <code class="literal">MassIndexer.typesToIndexInParallel(int threadsToIndexObjects)</code>:</p><div class="example" id="d0e7676"><div class="example-title">Example 6.7. Configuring the MassIndexer to index several types in parallel</div><div class="example-contents"><pre><code class="language-java">fullTextSession
 .createIndexer( User.class, Customer.class )
 .typesToIndexInParallel( 2 )
 .batchSizeToLoadObjects( 25 )
 .cacheMode( CacheMode.NORMAL )
 .threadsToLoadObjects( 5 )
 .idFetchSize( 150 )
 .progressMonitor( monitor ) //a MassIndexerProgressMonitor implementation
 .startAndWait();</code></pre></div></div><br class="example-break"/><p>Generally we suggest to leave cacheMode to <code class="literal">CacheMode.IGNORE</code> (the default), as in most reindexing
situations the cache will be a useless additional overhead; it might be useful to enable some other
<code class="literal">CacheMode</code> depending on your data: it could increase performance if the main entity is relating to
enum-like data included in the index.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>The MassIndexer was designed for speed and is unaware of transactions, so there is no need to begin
one or committing. Also because it is not transactional it is not recommended to let users use the
system during its processing, as it is unlikely people will be able to find results and the system
load might be too high anyway.</p></div><section class="section" id="search-batchindexing-threadsandconnections"><div class="titlepage"><div><div><h4 class="title">6.3.2.1. MassIndexer using threads and JDBC connections</h4></div></div></div><p>The MassIndexer was designed to finish the re-indexing task as quickly as possible, but this requires
a bit of care in its configuration to behave fairly with your server resources.</p><p>There is a simple formula to understand how the different options applied to the MassIndexer affect
the number of used worker threads and connections: each thread will require a JDBC connection.</p><div class="informalexample"><pre class="screen">threads = typesToIndexInParallel * (threadsToLoadObjects + 1);
required JDBC connections = threads;</pre></div><p>Let’s see some suggestions for a roughly sane tuning starting point:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Option <code class="literal">typesToIndexInParallel</code> should probably be a low value, like 1 or 2, depending on how much
of your CPUs have spare cycles and how slow a database round trip will be.</li><li class="listitem">Before tuning a parallel run, experiment with options to tune your primary indexed entities in
isolation.</li><li class="listitem">Making <code class="literal">threadsToLoadObjects</code> higher increases the pre-loading rate for the picked entities from
the database, but also increases memory usage and the pressure on the threads working on subsequent
indexing.</li><li class="listitem">Increasing parallelism usually helps as the bottleneck usually is the latency to the database
connection: it’s probably worth it to experiment with values significantly higher than the number
of actual cores available, but make sure your database can handle all the multiple requests.</li><li class="listitem">This advice might not apply to you: always measure the effects! We’re providing this as a means to
help you understand how these options are related.</li></ol></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>Running the MassIndexer with many threads will require many connections to the database. If you
don’t have a sufficiently large connection pool, the MassIndexer itself and/or your other
applications could starve being unable to serve other requests: make sure you size your connection
pool accordingly to the options as explained in the above paragraph.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>The "sweet spot" of number of threads to achieve best performance is highly dependent on your
overall architecture, database design and even data values. All internal thread groups have
meaningful names so they should be easily identified with most diagnostic tools, including simply
thread dumps.</p></div></section><section class="section" id="search-batchindex-custommassindexer"><div class="titlepage"><div><div><h4 class="title">6.3.2.2. Using a custom MassIndexer implementation</h4></div></div></div><p>The provided MassIndexer is quite general purpose, and while we believe it’s a robust approach, you
might be able to squeeze some better performance by writing a custom implementation. To run your own
MassIndexer instead of using the one shipped with Hibernate Search you have to:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">create an implementation of the <code class="literal">org.hibernate.search.spi.MassIndexerFactory</code> interface;</li><li class="listitem">set the property <code class="literal">hibernate.search.massindexer.factoryclass</code> with the qualified class name of the
factory implementation.</li></ol></div><div class="example" id="d0e7750"><div class="example-title">Example 6.8. Custom MassIndexerFactory example</div><div class="example-contents"><pre><code class="language-java">package org.myproject
import org.hibernate.search.spi.MassIndexerFactory

// ...

public class CustomIndexerFactory implements MassIndexerFactory {

  public void initialize(Properties properties) {
  }

  public MassIndexer createMassIndexer(...) {
    return new CustomIndexer();
  }

}</code></pre><pre class="screen">hibernate.search.massindexer.factoryclass = org.myproject.CustomIndexerFactory</pre></div></div><br class="example-break"/></section></section><section class="section" id="_useful_parameters_for_batch_indexing"><div class="titlepage"><div><div><h3 class="title">6.3.3. Useful parameters for batch indexing</h3></div></div></div><p>Other parameters which affect indexing time and memory consumption are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_size</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code></li></ul></div><p>Previous versions also had a <code class="literal">max_field_length</code> but this was removed from Lucene, it’s possible
to obtain a similar effect by using a <code class="literal">LimitTokenCountAnalyzer</code>.</p><p>All <code class="literal">.indexwriter</code> parameters are Lucene specific and Hibernate Search is just passing these
parameters through - see <a class="xref" href="#lucene-indexing-performance" title="3.8.1. Tuning indexing performance">Section 3.8.1, “Tuning indexing performance”</a> for more details.</p><p>The MassIndexer uses a forward only scrollable result to iterate on the primary keys to be loaded,
but MySQL’s JDBC driver will load all values in memory; to avoid this "optimization" set
<code class="literal">idFetchSize</code> to <code class="literal">Integer.MIN_VALUE</code>.</p></section></section></section><section class="chapter" id="search-optimize"><div class="titlepage"><div><div><h1 class="title">Chapter 7. Index Optimization</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#_automatic_optimization">7.1. Automatic optimization</a></span></li><li><span class="section"><a href="#_manual_optimization">7.2. Manual optimization</a></span></li><li><span class="section"><a href="#_adjusting_optimization">7.3. Adjusting optimization</a></span></li></ul></div><p>This section explains some low level tricks to keep your indexes at peak performance. We cover some
Lucene details which in most cases you don’t have to know about: Hibernate Search will handle these
operations optimally and transparently in most cases without the need for further configuration.
Still, it is good to know that there are ways to configure the behavior, if the need arises.</p><p>The index is physically stored in several smaller segments. Each segment is immutable and represents
a generation of index writes. Index segments are periodically compacted, both to merge smaller
segments and to remove stale entries; this merging process happens constantly in the background and
can be tuned with the options specified in <a class="xref" href="#lucene-indexing-performance" title="3.8.1. Tuning indexing performance">Section 3.8.1, “Tuning indexing performance”</a>, but you can also define
policies to fully run index optimizations when it is most suited for your specific workload.</p><p>With older versions of Lucene it was important to frequently optimize the index to maintain good
performance, but with current Lucene versions this doesn’t apply anymore. The benefit of explicit
optimization is very low, and in certain cases even counter-productive. During an explicit
optimization the whole index is processed and rewritten inflicting a significant performance cost.
Optimization is for this reason a double-edged sword.</p><p>Another reason to avoid optimizing the index too often is that an optimization will, as a side
effect, invalidate cached filters and field caches and internal buffers need to be refreshed.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>Optimizing the index is often not needed, does not benefit write (update) performance at all, and is
a slow operation: make sure you need it before activating it.</p></div><p>Of course optimizing the index does not only present drawbacks: after the optimization process is
completed and new IndexReader instances have loaded their buffers, queries will perform at peak
performance and you will have reclaimed all disk space potentially used by stale entries.</p><p>It is recommended to not schedule any optimization, but if you wish to perform it periodically you
should run it:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">on an idle system or when the searches are less frequent</li><li class="listitem">after a lot of index modifications</li></ul></div><p>When using a MassIndexer (see <a class="xref" href="#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a>) it will optimize involved indexes
by default at the start and at the end of processing; you can change this behavior by using
MassIndexer.optimizeAfterPurge and MassIndexer.optimizeOnFinish respectively. The initial
optimization is actually very cheap as it is performed on an empty index: its purpose is to release
the storage space occupied by the old index.</p><section class="section" id="_automatic_optimization"><div class="titlepage"><div><div><h2 class="title">7.1. Automatic optimization</h2></div></div></div><p>While in most cases this is not needed, Hibernate Search can automatically optimize an index after:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">a certain amount of write operations</li><li class="listitem">or after a certain amount of transactions</li></ul></div><p>The configuration for automatic index optimization can be defined on a global level or per index:</p><div class="example" id="d0e7867"><div class="example-title">Example 7.1. Defining automatic optimization parameters</div><div class="example-contents"><pre class="screen">hibernate.search.default.optimizer.operation_limit.max = 1000
hibernate.search.default.optimizer.transaction_limit.max = 100
hibernate.search.Animal.optimizer.transaction_limit.max = 50</pre></div></div><br class="example-break"/><p>With the above example an optimization will be triggered to the <code class="literal">Animal</code> index as soon as either:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the number of additions and deletions reaches 1000</li><li class="listitem">the number of transactions reaches 50 (hibernate.search.Animal.optimizer.transaction_limit.max
having priority over hibernate.search.default.optimizer.transaction_limit.max)</li></ul></div><p>If none of these parameters are defined, no optimization is processed automatically.</p><p>The default implementation of OptimizerStrategy can be overridden by implementing
<code class="literal">org.hibernate.search.store.optimization.OptimizerStrategy</code> and setting the
<code class="literal">optimizer.implementation</code> property to the fully qualified name of your implementation. This
implementation must implement the interface, be a public class and have a public constructor taking
no arguments.</p><div class="example" id="d0e7894"><div class="example-title">Example 7.2. Loading a custom OptimizerStrategy</div><div class="example-contents"><pre class="screen">hibernate.search.default.optimizer.implementation = com.acme.worlddomination.SmartOptimizer
hibernate.search.default.optimizer.SomeOption = CustomConfigurationValue
hibernate.search.humans.optimizer.implementation = default</pre></div></div><br class="example-break"/><p>The keyword <code class="literal">default</code> can be used to select the Hibernate Search default implementation; all
properties after the <code class="literal">.optimizer</code> key separator will be passed to the implementation’s initialize
method at start.</p></section><section class="section" id="_manual_optimization"><div class="titlepage"><div><div><h2 class="title">7.2. Manual optimization</h2></div></div></div><p>You can programmatically optimize (defragment) a Lucene index from Hibernate Search through the
SearchFactory:</p><div class="example" id="d0e7912"><div class="example-title">Example 7.3. Programmatic index optimization</div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();

searchFactory.optimize(Order.class);
// or
searchFactory.optimize();</code></pre></div></div><br class="example-break"/><p>The first example optimizes the Lucene index holding Orders; the second, optimizes all indexes.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p><code class="literal">searchFactory.optimize()</code> has no effect on a JMS or JGroups backend: you must apply the optimize operation on the Master node.</p></div></section><section class="section" id="_adjusting_optimization"><div class="titlepage"><div><div><h2 class="title">7.3. Adjusting optimization</h2></div></div></div><p>The Lucene index is constantly being merged in the background to keep a good balance between write
and read performance; in a sense this is a form of background optimization which is always applied.</p><p>The following match attributes of Lucene’s IndexWriter and are commonly used to tune how often
merging occurs and how aggressive it is applied. They are exposed by Hibernate Search via:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</code></li><li class="listitem"><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</code></li></ul></div><p>See <a class="xref" href="#lucene-indexing-performance" title="3.8.1. Tuning indexing performance">Section 3.8.1, “Tuning indexing performance”</a> for a description of these properties.</p></section></section><section class="chapter" id="search-monitoring"><div class="titlepage"><div><div><h1 class="title">Chapter 8. Monitoring</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#_jmx">8.1. JMX</a></span><ul><li><span class="section"><a href="#_statisticsinfombean">8.1.1. StatisticsInfoMBean</a></span></li><li><span class="section"><a href="#_indexcontrolmbean">8.1.2. IndexControlMBean</a></span></li><li><span class="section"><a href="#_indexingprogressmonitormbean">8.1.3. IndexingProgressMonitorMBean</a></span></li></ul></li></ul></div><p>Hibernate Search offers access to a <code class="literal">Statistics</code> object via <code class="literal">SearchFactory.getStatistics()</code>.
It allows you for example to determine which classes are indexed and how many entities are in the index.
This information is always available. However, by specifying the
<code class="literal">hibernate.search.generate_statistics</code> property in your configuration you can also collect total
and average Lucene query and object loading timings.</p><section class="section" id="_jmx"><div class="titlepage"><div><div><h2 class="title">8.1. JMX</h2></div></div></div><p>You can also enable access to the statistics via JMX.
Setting the property <code class="literal">hibernate.search.jmx_enabled</code> will automatically register the <code class="literal">StatisticsInfoMBean</code>.
Depending on your the configuration the <code class="literal">IndexControlMBean</code> and <code class="literal">IndexingProgressMonitorMBean</code> will also be
registered. In case you are having more than one JMX enabled Hibernate Search instance running
within a single JVM, you should also set <code class="literal">hibernate.search.jmx_bean_suffix</code> to a different value for
each of the instances. The specified suffix will be used to distinguish between the different MBean
instances. Let’s have a closer look at the mentioned MBeans.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>If you want to access your JMX beans remotely via JConsole make sure to set the system property
<code class="literal">com.sun.management.jmxremote</code> to true.</p></div><section class="section" id="_statisticsinfombean"><div class="titlepage"><div><div><h3 class="title">8.1.1. StatisticsInfoMBean</h3></div></div></div><p>This MBean gives you access to Statistics object as described in the previous section.</p></section><section class="section" id="_indexcontrolmbean"><div class="titlepage"><div><div><h3 class="title">8.1.2. IndexControlMBean</h3></div></div></div><p>This MBean allows to build, optimize and purge the index for a given entity. Indexing occurs via the
mass indexing API (see <a class="xref" href="#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a>). A requirement for this bean to be
registered in JMX is, that the Hibernate SessionFactory is bound to JNDI via the
<code class="literal">hibernate.session_factory_name</code> property. Refer to the Hibernate Core manual for more
information on how to configure JNDI. The IndexControlMBean and its API are for now experimental.</p></section><section class="section" id="_indexingprogressmonitormbean"><div class="titlepage"><div><div><h3 class="title">8.1.3. IndexingProgressMonitorMBean</h3></div></div></div><p>This MBean is an implementation MassIndexerProgressMonitor interface.
If <code class="literal">hibernate.search.jmx_enabled</code> is enabled and the mass indexer API is used the indexing progress
can be followed via this bean. The bean will only be bound to JMX while indexing is in progress.
Once indexing is completed the MBean is not longer available.</p></section></section></section><section class="chapter" id="spatial"><div class="titlepage"><div><div><h1 class="title">Chapter 9. Spatial</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#spatial-indexing">9.1. Enable indexing of Spatial Coordinates</a></span><ul><li><span class="section"><a href="#spatial-indexing-range">9.1.1. Indexing coordinates for range queries</a></span></li><li><span class="section"><a href="#spatial-indexing-spatialHash">9.1.2. Indexing coordinates in a grid with spatial hashes</a></span></li><li><span class="section"><a href="#spatial-coordinatesinterface">9.1.3. Implementing the Coordinates interface</a></span></li></ul></li><li><span class="section"><a href="#spatial-queries">9.2. Performing Spatial Queries</a></span><ul><li><span class="section"><a href="#spatial-queries-distance">9.2.1. Returning distance to query point in the search results</a></span></li></ul></li><li><span class="section"><a href="#spatial-multiplecoordinates">9.3. Multiple Coordinate pairs</a></span></li><li><span class="section"><a href="#spatial-behind-curtain">9.4. Insight: implementation details of spatial hashes indexing</a></span><ul><li><span class="section"><a href="#_at_indexing_level">9.4.1. At indexing level</a></span></li><li><span class="section"><a href="#_at_search_level">9.4.2. At search level</a></span></li></ul></li></ul></div><p>With the spatial extensions you can combine full-text queries with distance restrictions, filter results based on distances
or sort results on such a distance criteria.</p><p>The spatial support of Hibernate Search has the following goals:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Enable spatial search on entities: find entities within x km from a given location (latitude, longitude) on Earth</li><li class="listitem">Provide an easy way to enable spatial indexing via expressive annotations</li><li class="listitem">Provide a simple way for querying</li><li class="listitem">Hide geographical complexity</li></ul></div><p>For example, you might search for restaurants somewhere in a 2 km radius around your office.</p><p>In order to use the spatial extensions for an indexed entity, you need to add the <code class="literal">@Spatial</code>
annotation (<code class="literal">org.hibernate.search.annotations.Spatial</code>) and specify one or more sets of coordinates.</p><section class="section" id="spatial-indexing"><div class="titlepage"><div><div><h2 class="title">9.1. Enable indexing of Spatial Coordinates</h2></div></div></div><p>There are different techniques to index point coordinates. Hibernate Search Spatial offers a choice between two strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">index as numbers</li><li class="listitem">index as labeled spatial hashes</li></ul></div><p>We will now describe both methods, so you can make a suitable choice. You can pick a different strategy for each set of
coordinates. The strategy is selected by specifying the <code class="literal">spatialMode</code> attribute of the <code class="literal">@Spatial</code> annotation.</p><section class="section" id="spatial-indexing-range"><div class="titlepage"><div><div><h3 class="title">9.1.1. Indexing coordinates for range queries</h3></div></div></div><p>When setting the <code class="literal">@Spatial.spatialMode</code> attribute to <code class="literal">SpatialMode.RANGE</code> (which is the default)
coordinates are indexed as numeric fields, so that range queries can be performed to narrow down the
initial area of interest.</p><p>Pros:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Is quick on small data sets (&lt; 100k entities)</li><li class="listitem">Is very simple: straightforward to debug/analyze</li><li class="listitem">Impact on index size is moderate</li></ul></div><p>Cons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Poor performance on large data sets</li><li class="listitem">Poor performance if your data set is distributed across the whole world (for example when
indexing points of interest in the United States, in Europe and in Asia, large areas collide because
they share the same latitude. The latitude range query returns large amounts of data that need to be
cross checked with those returned by the longitude range).</li></ul></div><p>To index your entities for range querying you have to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">add the <code class="literal">@Spatial</code> annotation on your entity</li><li class="listitem">add the <code class="literal">@Latitude</code> and <code class="literal">@Longitude</code> annotations on your properties representing the coordinates;
these must be of type <code class="literal">Double</code></li></ul></div><div class="example" id="d0e8117"><div class="example-title">Example 9.1. Sample Spatial indexing: Hotel class</div><div class="example-contents"><pre><code class="language-java">import org.hibernate.search.annotations.*;

@Entity
@Indexed
@Spatial
public class Hotel {

  @Latitude
  Double latitude

  @Longitude
  Double longitude

  // ...</code></pre></div></div><br class="example-break"/></section><section class="section" id="spatial-indexing-spatialHash"><div class="titlepage"><div><div><h3 class="title">9.1.2. Indexing coordinates in a grid with spatial hashes</h3></div></div></div><p>When setting <code class="literal">@Spatial.spatialMode</code> to <code class="literal">SpatialMode.HASH</code> the coordinates are encoded in several fields
representing different zoom levels. Each box for each level is labeled so coordinates are assigned
matching labels for each zoom level. This results in a grid encoding of labels called <code class="literal">spatial
hashes</code>.</p><p>Pros :</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Good performance even with large data sets</li><li class="listitem">World wide data distribution independent</li></ul></div><p>Cons :</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Index size is larger: need to encode multiple labels per pair of coordinates</li></ul></div><p>To index your entities you have to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">add the <code class="literal">@Spatial</code> annotation on the entity with the <code class="literal">SpatialMode</code> set to GRID :
@Spatial(spatialMode = SpatialMode.HASH)</li><li class="listitem">add the <code class="literal">@Latitude</code> and <code class="literal">@Longitude</code> annotations on the properties representing your coordinates;
these must be of type <code class="literal">Double</code></li></ul></div><div class="example" id="d0e8174"><div class="example-title">Example 9.2. Indexing coordinates in a grid using spatial hashes</div><div class="example-contents"><pre><code class="language-java">@Spatial(spatialMode = SpatialMode.HASH)
@Indexed
@Entity
public class Hotel {

  @Latitude
  Double latitude;

  @Longitude
  Double longitude;

  // ...</code></pre></div></div><br class="example-break"/></section><section class="section" id="spatial-coordinatesinterface"><div class="titlepage"><div><div><h3 class="title">9.1.3. Implementing the Coordinates interface</h3></div></div></div><p>Instead of using the <code class="literal">@Latitude</code> and <code class="literal">@Longitude</code> annotations you can choose to implement the
<code class="literal">org.hibernate.search.spatial.Coordinates</code> interface.</p><div class="example" id="d0e8193"><div class="example-title">Example 9.3. Implementing the Coordinates interface</div><div class="example-contents"><pre><code class="language-java">import org.hibernate.search.annotations.*;
import org.hibernate.search.spatial.Coordinates;

@Entity
@Indexed
@Spatial
public class Song implements Coordinates {

  @Id long id;
  double latitude;
  double longitude;
  // ...

  @Override
  Double getLatitude() {
    return latitude;
  }

  @Override
  Double getLongitude() {
    return longitude;
  }

  // ...</code></pre></div></div><br class="example-break"/><p>As we will see in the section <a class="xref" href="#spatial-multiplecoordinates" title="9.3. Multiple Coordinate pairs">Section 9.3, “Multiple Coordinate pairs”</a>, an entity can have multiple <code class="literal">@Spatial</code> annotations;
when having the entity implement <code class="literal">Coordinates</code>, the implemented methods refer to the default <code class="literal">@Spatial</code> annotation with
the default pair of coordinates.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>The default (field) name in case <code class="literal">@Spatial</code> is placed on the entity level is <code class="literal">org.hibernate.search.annotations.Spatial.COORDINATES_DEFAULT_FIELD</code>.</p></div><p>An alternative is to use properties implementing the <code class="literal">Coordinates</code> interface; this way you can have
multiple <code class="literal">Spatial</code> instances:</p><div class="example" id="d0e8228"><div class="example-title">Example 9.4. Using attributes of type Coordinates</div><div class="example-contents"><pre><code class="language-java">@Entity
@Indexed
public class Event {
  @Id
  Integer id;

  @Field(store = Store.YES)
  String name;

  double latitude;
  double longitude;

  @Spatial(spatialMode = SpatialMode.HASH)
  public Coordinates getLocation() {
    return new Coordinates() {
      @Override
      public Double getLatitude() {
        return latitude;
      }

      @Override
      public Double getLongitude() {
        return longitude;
      }
    };
  }

// ...</code></pre></div></div><br class="example-break"/><p>When using this form the <code class="literal">@Spatial.name</code> automatically defaults to the property name. In the above case to <code class="literal">location</code>.</p></section></section><section class="section" id="spatial-queries"><div class="titlepage"><div><div><h2 class="title">9.2. Performing Spatial Queries</h2></div></div></div><p>You can use the Hibernate Search query DSL to build a query to search around a pair of coordinates (latitude, longitude)
or around a bean implementing the <code class="literal">Coordinates</code> interface.</p><p>As with any full-text query, the spatial query creation flow looks like:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">retrieve a <code class="literal">QueryBuilder</code> from the <code class="literal">SearchFactory</code></li><li class="listitem">use the DSL to build a spatial query, defining search center and radius</li><li class="listitem">optionally combine the resulting <code class="literal">Query</code> with other filters</li><li class="listitem">call the <code class="literal">createFullTextQuery()</code> and use the resulting query like any standard Hibernate or JPA query</li></ol></div><div class="example" id="spatial-example-firstquery"><div class="example-title">Example 9.5. Search for an Hotel by distance</div><div class="example-contents"><pre><code class="language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity( Hotel.class ).get();

org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
  .within( radius, Unit.KM )
    .ofLatitude( centerLatitude )
    .andLongitude( centerLongitude )
  .createQuery();

org.hibernate.Query hibQuery = fullTextSession
  .createFullTextQuery( luceneQuery, Hotel.class );
List results = hibQuery.list();</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>In the above example we did not explicitly specify the field name to use. The default coordinates field name was used
implicitly. To target an alternative pair of coordinates at query time, we need to specify the field name as well.
See <a class="xref" href="#spatial-multiplecoordinates" title="9.3. Multiple Coordinate pairs">Section 9.3, “Multiple Coordinate pairs”</a>.</p></div><p>A fully working example can be found in the test-suite of the <a class="link" href="https://github.com/hibernate/hibernate-search">source code</a>.
Refer to <code class="literal">SpatialIndexingTest.testSpatialAnnotationOnClassLevel()</code> and its corresponding <code class="literal">Hotel</code> test class.</p><p>Alternatively to passing separate latitude and longitude values, you can also pass an instance implementing the
<code class="literal">Coordinates</code> interface:</p><div class="example" id="d0e8301"><div class="example-title">Example 9.6. DSL example with Coordinates</div><div class="example-contents"><pre><code class="language-java">Coordinates coordinates = Point.fromDegrees(24d, 31.5d);
Query query = builder
  .spatial()
    .within( 51, Unit.KM )
      .ofCoordinates( coordinates )
  .createQuery();

List results = fullTextSession.createFullTextQuery( query, POI.class ).list();</code></pre></div></div><br class="example-break"/><section class="section" id="spatial-queries-distance"><div class="titlepage"><div><div><h3 class="title">9.2.1. Returning distance to query point in the search results</h3></div></div></div><section class="section" id="spatial-distance-projection"><div class="titlepage"><div><div><h4 class="title">9.2.1.1. Returning distance to the center in the results</h4></div></div></div><p>To retrieve the actual distance values (in kilometers) you need to use projection (see <a class="xref" href="#projections" title="5.1.3.5. Projection">Section 5.1.3.5, “Projection”</a>):</p><div class="example" id="d0e8316"><div class="example-title">Example 9.7. Distance projection example</div><div class="example-contents"><pre><code class="language-java">double centerLatitude = 24.0d;
double centerLongitude= 32.0d;

QueryBuilder builder = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity(POI.class).get();
org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
     .onField("location")
     .within(100, Unit.KM)
       .ofLatitude(centerLatitude)
       .andLongitude(centerLongitude)
  .createQuery();

FullTextQuery hibQuery = fullTextSession.createFullTextQuery(luceneQuery, POI.class);
hibQuery.setProjection(FullTextQuery.SPATIAL_DISTANCE, FullTextQuery.THIS);
hibQuery.setSpatialParameters(centerLatitude, centerLongitude, "location");
List results = hibQuery.list();</code></pre></div></div><br class="example-break"/><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Use <code class="literal">FullTextQuery.setProjection</code> with <code class="literal">FullTextQuery.SPATIAL_DISTANCE</code> as one of the projected fields.</li><li class="listitem">Call <code class="literal">FullTextQuery.setSpatialParameters</code> with the latitude, longitude and the name of the
spatial field used to build the spatial query. Note that using coordinates different than the
center used for the query will have unexpected results.</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>The default (field) name in case <code class="literal">@Spatial</code> is placed on the entity level is <code class="literal">org.hibernate.search.annotations.Spatial.COORDINATES_DEFAULT_FIELD</code>.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Distance projection and null values</h2><p>When a spatial field on an entity has a <code class="literal">null</code> value for either its latitude or longitude (or both),
the resulting projected distance will always be <code class="literal">null</code>.</p></div></section><section class="section" id="spatial-distance-sort"><div class="titlepage"><div><div><h4 class="title">9.2.1.2. Sorting by distance</h4></div></div></div><p>To sort the results by distance to the center of the search you will have to build a <code class="literal">Sort</code> instance
using Hibernate Search sort DSL:</p><div class="example" id="d0e8365"><div class="example-title">Example 9.8. Distance sort example using the sort DSL</div><div class="example-contents"><pre><code class="language-java">double centerLatitude = 24.0d;
double centerLongitude = 32.0d;

QueryBuilder builder = fullTextSession.getSearchFactory()
   .buildQueryBuilder().forEntity( POI.class ).get();
org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
    .onField("location")
      .within(100, Unit.KM)
      .ofLatitude(centerLatitude)
      .andLongitude(centerLongitude)
  .createQuery();

FullTextQuery hibQuery = fullTextSession.createFullTextQuery(luceneQuery, POI.class);
List results = query.list();
Sort distanceSort = qb
  .sort()
    .byDistance()
      .onField("location")
      .fromLatitude(centerLatitude)
      .andLongitude(centerLongitude)
    .createSort();
hibQuery.setSort(distanceSort);</code></pre></div></div><br class="example-break"/><p>The sort must be constructed using the same coordinates on the same spatial field used
to build the spatial query, otherwise the sorting will occur with another center than the query. This
repetition is needed to allow you to define Queries with any tool.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Sorting and null values</h2><p>When a spatial field on an entity has a <code class="literal">null</code> value for either its latitude or longitude (or both):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">if you are filtering the results using a distance query, the entity with missing coordinates
will not appear in the query results and its rank in the sort is irrelevant.</li><li class="listitem">otherwise, the resulting distance will always be the greatest possible value,
which means the entity will be ranked last if the sort is ascending, or
first if the sort is descending.</li></ul></div></div><p>Alternatively, you may also use a <code class="literal">DistanceSortField</code> directly, as it was done before the introduction of Hibernate Search sort DSL:</p><div class="example" id="d0e8392"><div class="example-title">Example 9.9. Distance sort example without using the sort DSL</div><div class="example-contents"><pre><code class="language-java">double centerLatitude = 24.0d;
double centerLongitude = 32.0d;

QueryBuilder builder = fullTextSession.getSearchFactory()
   .buildQueryBuilder().forEntity( POI.class ).get();
org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
    .onField("location")
      .within(100, Unit.KM)
      .ofLatitude(centerLatitude)
      .andLongitude(centerLongitude)
  .createQuery();

FullTextQuery hibQuery = fullTextSession.createFullTextQuery(luceneQuery, POI.class);
Sort distanceSort = new Sort(
	new DistanceSortField(centerLatitude, centerLongitude, "location"));
hibQuery.setSort(distanceSort);</code></pre></div></div><br class="example-break"/></section></section></section><section class="section" id="spatial-multiplecoordinates"><div class="titlepage"><div><div><h2 class="title">9.3. Multiple Coordinate pairs</h2></div></div></div><p>You can associate multiple pairs of coordinates to the same entity, as long as each pair is
uniquely identified by using a different name. This is achieved by stacking multiple <code class="literal">@Spatial</code>
annotations within a single <code class="literal">@Spatials</code> annotation and specifying the <code class="literal">name</code> attribute on the individual <code class="literal">@Spatial</code>
annotations.</p><div class="example" id="d0e8414"><div class="example-title">Example 9.10. Multiple sets of coordinates</div><div class="example-contents"><pre><code class="language-java">import org.hibernate.search.annotations.*;

@Entity
@Indexed
@Spatials({
  @Spatial,
  @Spatial(name="work",  spatialMode = SpatialMode.HASH)
})
public class UserEx {

  @Id
  Integer id;

  @Latitude
  Double homeLatitude;

  @Longitude
  Double homeLongitude;

  @Latitude(of="work")
  Double workLatitude;

  @Longitude(of="work")
  Double workLongitude;</code></pre></div></div><br class="example-break"/><p>To target an alternative pair of coordinates at query time, we need to specify the pair by name using <code class="literal">onField(String)</code>:</p><div class="example" id="d0e8424"><div class="example-title">Example 9.11. Querying on non-default coordinate set</div><div class="example-contents"><pre><code class="language-java">QueryBuilder builder = fullTextSession.getSearchFactory()
  .buildQueryBuilder().forEntity( UserEx.class ).get();

org.apache.lucene.search.Query luceneQuery = builder
  .spatial()
  .onField( "work" )
  .within( radius, Unit.KM )
    .ofLatitude( centerLatitude )
    .andLongitude( centerLongitude )
  .createQuery();

org.hibernate.Query hibQuery = fullTextSession.createFullTextQuery( luceneQuery,
   Hotel.class );
List results = hibQuery.list();</code></pre></div></div><br class="example-break"/></section><section class="section" id="spatial-behind-curtain"><div class="titlepage"><div><div><h2 class="title">9.4. Insight: implementation details of spatial hashes indexing</h2></div></div></div><p>The following chapter is meant to provide a technical insight in spatial hash (grid) indexing. It discusses how
coordinates are mapped to the index and how queries are implemented.</p><section class="section" id="_at_indexing_level"><div class="titlepage"><div><div><h3 class="title">9.4.1. At indexing level</h3></div></div></div><p>When Hibernate Search indexes an entity annotated with <code class="literal">@Spatial</code>, it instantiates a
<code class="literal">SpatialFieldBridge</code> to transform the latitude and longitude fields accessed via the <code class="literal">Coordinates</code>
interface to the multiple index fields stored in the Lucene index.</p><p>Principle of the spatial index: the spatial index used in Hibernate Search is a
<a class="link" href="http://en.wikipedia.org/wiki/Grid_(spatial_index)#Grid-based_spatial_indexing">grid based spatial index</a> where grid ids
are hashes derived from latitude and longitude.</p><p>To make computations easier the latitude and longitude field values will be
projected into a flat coordinate system with the help of a <a class="link" href="http://en.wikipedia.org/wiki/Sinusoidal_projection">sinusoidal projection</a>.
Origin value space is :</p><p>[-90 → +90],]-180 →; 180]</p><p>for latitude,longitude coordinates and projected space is:</p><p>]-pi → +pi],[-pi/2 → +pi/2]</p><p>for Cartesian x,y coordinates (beware of fields order inversion: x is longitude and y is latitude).</p><p>The index is divided into n levels labeled from 0 to n-1.</p><p>At the level 0 the projected space is the whole Earth. At the level 1 the projected space is divided
into 4 rectangles (called boxes as in bounding box):</p><p>[-pi,-pi/2]→[0,0], [-pi,0]→[0,+pi/2], [0,-pi/2]→[+pi,0] and [0,0]→[+pi,+pi/2]</p><p>At level n+1 each box of level n is divided into 4 new boxes and so on. The numbers of boxes at a
given level is 4^n.</p><p>Each box is given an id, in this format: [Box index on the X axis]|[Box index on the Y axis]. To
calculate the index of a box on an axis we divide the axis range in 2^n slots and find the slot the
box belongs to. At the n level the indexes on an axis are from -(2^n)/2 to (2^n)/2. For instance,
the 5th level has 4^5 = 1024 boxes with 32 indexes on each axis (32x32 is 1024) and the box of Id
"0|8" is covering the [0,8/32*pi/2]→[1/32*pi,9/32*pi/2] rectangle is projected space.</p><p>Beware! The boxes are rectangles in projected space but the related area on Earth is not rectangular!</p><p>Now that we have all these boxes at all these levels, we index points "into" them.</p><p>For a point (lat,long) we calculate its projection (x,y) and then we calculate for each level of the
spatial index, the ids of the boxes it belongs to.</p><p>At each level the point is in one and only one box. For points on the edges the box are considered
exclusive n the left side and inclusive on the right i-e ]start,end] (the points are normalized
before projection to [-90,+90],]-180,+180]).</p><p>We store in the Lucene document corresponding to the entity to index one field for each level of the
spatial hash grid. The field is named: <span class="emphasis"><em><span class="spatial index fields name">HSSI</span></em></span>[n]. [spatial index fields
name] is given either by the parameter at class level annotation or derived from the name of the
spatial annotated method of the entity, HSSI stands for Hibernate Search Spatial Index and n is the
level of the spatial hashes grid.</p><p>We also store the latitude and longitude as a numeric field under [spatial index fields
name]_HSSI_Latitude and [spatial index fields name]_HSSI_Longitude fields. They will be used to
filter precisely results by distance in the second stage of the search.</p></section><section class="section" id="_at_search_level"><div class="titlepage"><div><div><h3 class="title">9.4.2. At search level</h3></div></div></div><p>Now that we have all these fields, what are they used for?</p><p>When you ask for a spatial search by providing a search discus (center+radius) we will calculate the
box ids that do cover the search discus in the projected space, fetch all the documents that
belong to these boxes (thus narrowing the number of documents for which we will have to calculate
distance to the center) and then filter this subset with a real distance calculation. This is called
two level spatial filtering.</p><section class="section" id="_step_1_compute_the_best_spatial_hashes_grid_level_for_the_search_discus"><div class="titlepage"><div><div><h4 class="title">9.4.2.1. Step 1: Compute the best spatial hashes grid level for the search discus</h4></div></div></div><p>For a given search radius there is an optimal hash grid level where the number of boxes to
retrieve shall be minimal without bringing back to many documents (level 0 has only 1 box but
retrieve all documents). The optimal hash grid level is the maximum level where the width of each
box is larger than the search area. Near the equator line where projection deformation is minimal,
this will lead to the retrieval of at most 4 boxes. Towards the poles where the deformation is more
significant, it might need to examine more boxes but as the sinusoidal projection has a simple
Tissot’s indicatrix (see <a class="link" href="http://en.wikipedia.org/wiki/Sinusoidal_projection">Sinusoidal projection</a>) in populated areas,
the overhead is minimal.</p></section><section class="section" id="_step_2_compute_ids_of_the_corresponding_covering_boxes_at_that_level"><div class="titlepage"><div><div><h4 class="title">9.4.2.2. Step 2: Compute ids of the corresponding covering boxes at that level</h4></div></div></div><p>Now that we have chosen the optimal level, we can compute the ids of the boxes covering the search
discus (which is not a discus in projected space anymore).</p><p>This is done by <code class="literal">org.hibernate.search.spatial.impl.SpatialHelper.getSpatialHashCellsIds(Point center,
double radius, int spatialHashLevel)</code></p><p>It will calculate the bounding box of the search discus and then call
<code class="literal">org.hibernate.search.spatial.impl.SpatialHelper.getSpatialHashCellsIds(Point lowerLeft, Point
upperRight, int spatialHashLevel)</code> that will do the actual computation. If the bounding box crosses
the meridian line it will cut the search in two and make two calls to <code class="literal">getSpatialHashCellsIds(Point
lowerLeft, Point upperRight, int spatialHashLevel)</code> with left and right parts of the box.</p><p>There are some geo related hacks (search radius too large, search radius crossing the poles) that
are handled in bounding box computations done by <code class="literal">Rectangle.fromBoundingCircle(Coordinates center,
double radius)</code> (see <a class="link" href="http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates">http://janmatuschek.de/LatitudeLongitudeBoundingCoordinates</a> for reference on
those subjects).</p><p>The <code class="literal">SpatialHelper.getSpatialHashCellsIds(Point lowerLeft, Point upperRight, int spatialHashLevel)</code>
project the defining points of the bounding box and compute the boxes they belong to. It returns all
the box Ids between the lower left to the upper right corners, thus covering the area.</p></section><section class="section" id="_step_3_lucene_index_lookup"><div class="titlepage"><div><div><h4 class="title">9.4.2.3. Step 3: Lucene index lookup</h4></div></div></div><p>The query is built with theses Ids searching for documents having a <span class="emphasis"><em><span class="spatial index fields name">HSSI</span></em></span>[n] (n the level found at Step 1) field valued with one of the ids of Step 2.</p><p>See also the implementation of <code class="literal">org.hibernate.search.spatial.impl.SpatialHashFilter</code>.</p><p>This query will return all documents in the boxes covering the projected bounding box of the search
discus. So it is too large and needs refining. But we have narrowed the distance calculation
problems to a subset of our data.</p></section><section class="section" id="_step_4_refine"><div class="titlepage"><div><div><h4 class="title">9.4.2.4. Step 4: Refine</h4></div></div></div><p>A distance calculation filter is set after the Lucene index lookup query of Step 3 to exclude false
candidates from the result list.</p><p>See <code class="literal">SpatialQueryBuilderFromCoordinates.buildSpatialQuery(Coordinates center, double radius, String
fieldName)</code></p></section></section></section></section><section class="chapter" id="search-lucene-native"><div class="titlepage"><div><div><h1 class="title">Chapter 10. Advanced features</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#AccessingSearchFactory">10.1. Accessing the <code class="literal">SearchFactory</code></a></span></li><li><span class="section"><a href="#AccessingSearchIntegrator">10.2. Accessing the <code class="literal">SearchIntegrator</code></a></span></li><li><span class="section"><a href="#IndexReaders">10.3. Using an <code class="literal">IndexReader</code></a></span></li><li><span class="section"><a href="#_accessing_a_lucene_directory">10.4. Accessing a Lucene Directory</a></span></li><li><span class="section"><a href="#advanced-features-sharding">10.5. Sharding indexes</a></span><ul><li><span class="section"><a href="#_static_sharding">10.5.1. Static sharding</a></span></li><li><span class="section"><a href="#advanced-features-dynamic-sharding">10.5.2. Dynamic sharding</a></span></li></ul></li><li><span class="section"><a href="#section-sharing-indexes">10.6. Sharing indexes</a></span></li><li><span class="section"><a href="#section-services">10.7. Using external services</a></span><ul><li><span class="section"><a href="#_using_a_service">10.7.1. Using a Service</a></span></li><li><span class="section"><a href="#_implementing_a_service">10.7.2. Implementing a Service</a></span></li></ul></li><li><span class="section"><a href="#_customizing_lucene_s_scoring_formula">10.8. Customizing Lucene’s scoring formula</a></span></li><li><span class="section"><a href="#section-multi-tenancy">10.9. Multi-tenancy</a></span><ul><li><span class="section"><a href="#_what_is_multi_tenancy">10.9.1. What is multi-tenancy?</a></span></li><li><span class="section"><a href="#_using_a_tenant_aware_literal_fulltextsession_literal">10.9.2. Using a tenant-aware <code class="literal">FullTextSession</code></a></span></li></ul></li></ul></div><p>In this final chapter we are offering a smörgåsbord of tips and tricks which might become useful as
you dive deeper and deeper into Hibernate Search.</p><section class="section" id="AccessingSearchFactory"><div class="titlepage"><div><div><h2 class="title">10.1. Accessing the <code class="literal">SearchFactory</code></h2></div></div></div><p>The <code class="literal">SearchFactory</code> object keeps track of the underlying Lucene resources for Hibernate Search. It is
a convenient way to access Lucene natively. The <code class="literal">SearchFactory</code> can be accessed from a
FullTextSession:</p><div class="example" id="d0e8580"><div class="example-title">Example 10.1. Accessing the <code class="literal">SearchFactory</code></div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(regularSession);
SearchFactory searchFactory = fullTextSession.getSearchFactory();</code></pre></div></div><br class="example-break"/></section><section class="section" id="AccessingSearchIntegrator"><div class="titlepage"><div><div><h2 class="title">10.2. Accessing the <code class="literal">SearchIntegrator</code></h2></div></div></div><p>The interface <code class="literal">SearchIntegrator</code> gives access to lower level APIs of Hibernate Search.
You can access the <code class="literal">SearchIntegrator</code> SPI using the SearchFactory (<a class="xref" href="#AccessingSearchFactory" title="10.1. Accessing the SearchFactory">Section 10.1, “Accessing the <code class="literal">SearchFactory</code>”</a>):</p><div class="example" id="d0e8602"><div class="example-title">Example 10.2. Accessing the <code class="literal">SearchIntegrator</code></div><div class="example-contents"><pre><code class="language-java">SearchIntegrator searchIntegrator = searchFactory.unwrap(SearchIntegrator.class);</code></pre></div></div><br class="example-break"/></section><section class="section" id="IndexReaders"><div class="titlepage"><div><div><h2 class="title">10.3. Using an <code class="literal">IndexReader</code></h2></div></div></div><p>Queries in Lucene are executed on an <code class="literal">IndexReader</code>. Hibernate Search caches index readers to maximize
performance and implements other strategies to retrieve updated IndexReaders in order to minimize IO
operations. Your code can access these cached resources, but you have to follow some "good citizen"
rules.</p><div class="example" id="d0e8619"><div class="example-title">Example 10.3. Accessing an <code class="literal">IndexReader</code></div><div class="example-contents"><pre><code class="language-java">IndexReader reader = searchFactory.getIndexReaderAccessor().open(Order.class);
try {
   //perform read-only operations on the reader
}
finally {
   searchFactory.getIndexReaderAccessor().close(reader);
}</code></pre></div></div><br class="example-break"/><p>In this example the SearchFactory figures out which indexes are needed to query this entity. Using
the configured ReaderProvider (described in <a class="xref" href="#search-architecture-readerstrategy" title="2.3. Reader strategy">Section 2.3, “Reader strategy”</a>) on each index,
it returns a compound <code class="literal">IndexReader</code> on top of all involved indexes. Because this <code class="literal">IndexReader</code> is
shared amongst several clients, you must adhere to the following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Never call <code class="literal">indexReader.close()</code>, but always call <code class="literal">readerProvider.closeReader(reader)</code>, using a
finally block.</li><li class="listitem">Don’t use this <code class="literal">IndexReader</code> for modification operations: it’s a read-only instace, you would
get an exception.</li></ul></div><p>Aside from those rules, you can use the <code class="literal">IndexReader</code> freely, especially to do native Lucene queries.
Using this shared IndexReaders will be more efficient than by opening one directly from - for
example - the filesystem.</p><p>As an alternative to the method <code class="literal">open(Class…​ types)</code> you can use <code class="literal">open(String…​ indexNames)</code>
in this case you pass in one or more index names; using this strategy you can also select a subset
of the indexes for any indexed type if sharding is used.</p><div class="example" id="d0e8665"><div class="example-title">Example 10.4. Accessing an <code class="literal">IndexReader</code> by index names</div><div class="example-contents"><pre><code class="language-java">IndexReader reader = searchFactory
      .getIndexReaderAccessor()
      .open("Products.1", "Products.3");</code></pre></div></div><br class="example-break"/></section><section class="section" id="_accessing_a_lucene_directory"><div class="titlepage"><div><div><h2 class="title">10.4. Accessing a Lucene Directory</h2></div></div></div><p>A Directory is the most common abstraction used by Lucene to represent the index storage; Hibernate
Search doesn’t interact directly with a Lucene Directory but abstracts these interactions via an
IndexManager: an index does not necessarily need to be implemented by a Directory.</p><p>If you are certain that your index is represented as a Directory and need to access it, you can get
a reference to the Directory via the IndexManager. You will have to cast the IndexManager instance
to a DirectoryBasedIndexManager and then use <code class="literal">getDirectoryProvider().getDirectory()</code> to get a
reference to the underlying Directory. This is not recommended, if you need low level access to the
index using Lucene APIs we suggest to see <a class="xref" href="#IndexReaders" title="10.3. Using an IndexReader">Section 10.3, “Using an <code class="literal">IndexReader</code>”</a> instead.</p></section><section class="section" id="advanced-features-sharding"><div class="titlepage"><div><div><h2 class="title">10.5. Sharding indexes</h2></div></div></div><p>In some cases it can be useful to split (shard) the data into several Lucene indexes. There are two
main use use cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A single index is so big that index update times are slowing the application down. In this case
static sharding can be used to split the data into a pre-defined number of shards.</li><li class="listitem">Data is naturally segmented by customer, region, language or other application parameter and the
index should be split according to these segments. This is a use case for dynamic sharding.</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="tip"><h2>Tip</h2><p>By default sharding is not enabled.</p></div><section class="section" id="_static_sharding"><div class="titlepage"><div><div><h3 class="title">10.5.1. Static sharding</h3></div></div></div><p>To enable static sharding set the hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards
property as seen in <a class="xref" href="#example-index-sharding" title="Example 10.5. Enabling index sharding">Example 10.5, “Enabling index sharding”</a>.</p><div class="example" id="example-index-sharding"><div class="example-title">Example 10.5. Enabling index sharding</div><div class="example-contents"><pre class="screen">hibernate.search.[default|&lt;indexName&gt;].sharding_strategy.nbr_of_shards = 5</pre></div></div><br class="example-break"/><p>The default sharding strategy which gets enabled by setting this property, splits the data according
to the hash value of the document id (generated by the FieldBridge). This ensures a fairly balanced
sharding. You can replace the default strategy by implementing a custom IndexShardingStrategy. To
use your custom strategy you have to set the
hibernate.search.[default|&lt;indexName&gt;].sharding_strategy property to the fully qualified class
name of your custom IndexShardingStrategy.</p><div class="example" id="example-index-sharding-strategy"><div class="example-title">Example 10.6. Registering a custom IndexShardingStrategy</div><div class="example-contents"><pre class="screen">hibernate.search.[default|&lt;indexName&gt;].sharding_strategy = my.custom.RandomShardingStrategy</pre></div></div><br class="example-break"/></section><section class="section" id="advanced-features-dynamic-sharding"><div class="titlepage"><div><div><h3 class="title">10.5.2. Dynamic sharding</h3></div></div></div><p>Dynamic sharding allows you to manage the shards yourself and even create new shards on the fly. To
do so you need to implement the interface ShardIdentifierProvider and set the
hibernate.search.[default|&lt;indexName&gt;].sharding_strategy property to the fully qualified name
of this class. Note that instead of implementing the interface directly, you should rather derive
your implementation from org.hibernate.search.store.ShardIdentifierProviderTemplate which provides a
basic implementation. Let’s look at <a class="xref" href="#example-custom-shard-identifier-provider" title="Example 10.7. Custom ShardIdentifierProvider">Example 10.7, “Custom ShardIdentifierProvider”</a> for an example.</p><div class="example" id="example-custom-shard-identifier-provider"><div class="example-title">Example 10.7. Custom ShardIdentifierProvider</div><div class="example-contents"><pre><code class="language-java">public static class AnimalShardIdentifierProvider extends ShardIdentifierProviderTemplate {

 @Override
 public String getShardIdentifier(Class&lt;?&gt; entityType, Serializable id,
         String idAsString, Document document) {
    if (entityType.equals(Animal.class)) {
       String typeValue = document.getField("type").stringValue();
       addShard(typeValue);
       return typeValue;
    }
    throw new RuntimeException("Animal expected but found " + entityType);
 }

 @Override
 protected Set&lt;String&gt; loadInitialShardNames(Properties properties, BuildContext buildContext) {
    ServiceManager serviceManager = buildContext.getServiceManager();
    SessionFactory sessionFactory = serviceManager.requestService(
        HibernateSessionFactoryService.class).getSessionFactory();
    Session session = sessionFactory.openSession();
    try {
       Criteria initialShardsCriteria = session.createCriteria(Animal.class);
       initialShardsCriteria.setProjection(Projections.distinct(Property.forName("type")));
       List&lt;String&gt; initialTypes = initialShardsCriteria.list();
       return new HashSet&lt;String&gt;(initialTypes);
    }
    finally {
       session.close();
    }
 }
}</code></pre></div></div><br class="example-break"/><p>The are several things happening in <code class="literal">AnimalShardIdentifierProvider</code>. First off its purpose is to
create one shard per animal type (e.g. mammal, insect, etc.). It does so by inspecting the class
type and the Lucene document passed to the <code class="literal">getShardIdentifier()</code> method. It extracts the type field
from the document and uses it as shard name. <code class="literal">getShardIdentifier()</code> is called for every addition to
the index and a new shard will be created with every new animal type encountered. The base class
<code class="literal">ShardIdentifierProviderTemplate</code> maintains a set with all known shards to which any identifier must
be added by calling <code class="literal">addShard()</code>.</p><p>It is important to understand that Hibernate Search cannot know which shards already exist when the
application starts. When using <code class="literal">ShardIdentifierProviderTemplate</code> as base class of a
<code class="literal">ShardIdentifierProvider</code> implementation, the initial set of shard identifiers must be returned by the
<code class="literal">loadInitialShardNames()</code> method. How this is done will depend on the use case. However, a common case
in combination with Hibernate ORM is that the initial shard set is defined by the distinct
values of a given database column. <a class="xref" href="#example-custom-shard-identifier-provider" title="Example 10.7. Custom ShardIdentifierProvider">Example 10.7, “Custom ShardIdentifierProvider”</a> shows how to handle
such a case. <code class="literal">AnimalShardIdentifierProvider</code> makes in its <code class="literal">loadInitialShardNames()</code> implementation use
of a service called <code class="literal">HibernateSessionFactoryService</code> (see also <a class="xref" href="#section-services" title="10.7. Using external services">Section 10.7, “Using external services”</a>) which is
available within an ORM environment. It allows to request a Hibernate <code class="literal">SessionFactory</code> instance which
can be used to run a Criteria query in order to determine the initial set of shard identifiers.</p><p>Last but not least, the <code class="literal">ShardIdentifierProvider</code> also allows for optimizing searches by selecting
which shard to run a query against. By activating a filter (see <a class="xref" href="#query-filter-shard" title="5.3.1. Using filters in a sharded environment">Section 5.3.1, “Using filters in a sharded environment”</a>), a sharding
strategy can select a subset of the shards used to answer a query (<code class="literal">getShardIdentifiersForQuery()</code>,
not shown in the example) and thus speed up the query execution.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>This ShardIdentifierProvider is considered experimental. We might need to apply some changes to the
defined method signatures to accommodate for unforeseen use cases. Please provide feedback if you
have ideas, or just to let us know how you’re using this API.</p></div></section></section><section class="section" id="section-sharing-indexes"><div class="titlepage"><div><div><h2 class="title">10.6. Sharing indexes</h2></div></div></div><p>It is technically possible to store the information of more than one entity into a single Lucene
index. There are two ways to accomplish this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Configuring the underlying directory providers to point to the same physical index directory.
In practice, you set the property <code class="literal">hibernate.search.[fully qualified entity name].indexName</code> to the
same value. As an example, let’s use the same index (directory) for the <code class="literal">Furniture</code> and <code class="literal">Animal</code>
entities. We just set <code class="literal">indexName</code> for both entities to "Animal". Both entities will then be stored
in the Animal directory:</li></ul></div><div class="informalexample"><pre class="screen">hibernate.search.org.hibernate.search.test.shards.Furniture.indexName = Animal
hibernate.search.org.hibernate.search.test.shards.Animal.indexName = Animal</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Setting the @Indexed annotation’s index attribute of the entities you want to merge to the
same value. If we again wanted all Furniture instances to be indexed in the Animal index along with
all instances of Animal we would specify @Indexed(index="Animal") on both Animal and Furniture classes.</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>This is only presented here so that you know the option is available. There is really not much
benefit in sharing indexes.</p></div></section><section class="section" id="section-services"><div class="titlepage"><div><div><h2 class="title">10.7. Using external services</h2></div></div></div><p>A <code class="literal">Service</code> in Hibernate Search is a class implementing the interface
<code class="literal">org.hibernate.search.engine.service.spi.Service</code> and providing a default no-arg constructor.
Theoretically that’s all that is needed to request a given service type from the Hibernate Search
<code class="literal">ServiceManager</code>. In practice you want probably want to add some service life cycle methods
(implement <code class="literal">Startable</code> and <code class="literal">Stoppable</code>) as well as actual methods providing some functionality.</p><p>Hibernate Search uses the service approach to decouple different components of
the system. Let’s have a closer look at services and how they are used.</p><section class="section" id="_using_a_service"><div class="titlepage"><div><div><h3 class="title">10.7.1. Using a Service</h3></div></div></div><p>Many of of the pluggable contracts of Hibernate Search can use services. Services are accessible via
the <code class="literal">BuildContext</code> interface as in the following example.</p><div class="example" id="d0e8849"><div class="example-title">Example 10.8. Example of a custom DirectoryProvider using a ClassLoaderService</div><div class="example-contents"><pre><code class="language-java">public CustomDirectoryProvider implements DirectoryProvider&lt;RAMDirectory&gt; {
    private ServiceManager serviceManager;
    private ClassLoaderService classLoaderService;

    public void initialize(
        String directoryProviderName,
        Properties properties,
        BuildContext context) {
        //get a reference to the ServiceManager
        this.serviceManager = context.getServiceManager();
    }

    public void start() {
        //get the current ClassLoaderService
        classLoaderService = serviceManager.requestService(ClassLoaderService.class);
    }

    public RAMDirectory getDirectory() {
        //use the ClassLoaderService
    }

    public stop() {
        //make sure to release all services
        serviceManager.releaseService(ClassLoaderService.class);
    }
}</code></pre></div></div><br class="example-break"/><p>When you request a service, an instance of the requested service type is returned to you.
Make sure release the service via <code class="literal">ServiceManager.releaseService</code> once you don’t need it
anymore. Note that the service can be released in the <code class="literal">DirectoryProvider.stop</code> method if
the <code class="literal">DirectoryProvider</code> uses the service during its lifetime or could be released right away
if the service is only needed during initialization time.</p></section><section class="section" id="_implementing_a_service"><div class="titlepage"><div><div><h3 class="title">10.7.2. Implementing a Service</h3></div></div></div><p>To implement a service, you need to create an interface which identifies it and extends
<code class="literal">org.hibernate.search.engine.service.spi.Service</code>. You can then add additional methods to your service
interface as needed.</p><p>Naturally you will also need to provide an implementation of your service interface. This
implementation must have a public no-arg constructor. Optionally your service can also
implement the life cycle methods <code class="literal">org.hibernate.search.engine.service.spi.Startable</code>
and/or <code class="literal">org.hibernate.search.engine.service.spi.Stoppable</code>. These methods will be called by the
<code class="literal">ServiceManager</code> when the service is created respectively the last reference to a requested service
is released.</p><p>Services are retrieved from the <code class="literal">ServiceManager.requestService</code> using the <code class="literal">Class</code> object of the
interface you define as a key.</p><section class="section" id="_managed_services"><div class="titlepage"><div><div><h4 class="title">10.7.2.1. Managed services</h4></div></div></div><p>To transparently discover services Hibernate Search uses the Java ServiceLoader mechanism. This means
you need to add a service file to your jar under <code class="literal">/META-INF/services/</code> named after the fully qualified
classname of your service interface. The content of the file contains the fully qualified
classname of your service implementation.</p><div class="example" id="d0e8900"><div class="example-title">Example 10.9. Service file for the Infinispan CacheManagerService service</div><div class="example-contents"><pre class="screen">/META-INF/services/org.infinispan.hibernate.search.spi.CacheManagerService</pre></div></div><br class="example-break"/><div class="example" id="d0e8905"><div class="example-title">Example 10.10. Content of META-INF/services/org.infinispan.hibernate.search.spi.CacheManagerService</div><div class="example-contents"><pre class="screen">org.infinispan.hibernate.search.impl.DefaultCacheManagerService</pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Hibernate Search only supports a single service implementation of a given service. There is no
mechanism to select between multiple versions of a service. It is an
error to have multiple jars defining each a different implementation for the same service.
If you want to override the implementation of a already existing service at runtime you will need to
look at <a class="xref" href="#section-provided-services" title="10.7.2.2. Provided services">Section 10.7.2.2, “Provided services”</a>.</p></div></section><section class="section" id="section-provided-services"><div class="titlepage"><div><div><h4 class="title">10.7.2.2. Provided services</h4></div></div></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="important"><h2>Important</h2><p>Provided services are usually used by frameworks integrating with Hibernate
Search and not by library users themselves.</p></div><p>As an alternative to manages services, a service can be provided by the environment bootstrapping
Hibernate Search. For example, Infinispan which uses Hibernate Search as its internal search engine,
passes the <code class="literal">CacheContainer</code> to Hibernate Search.
In this case, the <code class="literal">CacheContainer</code> instance is not managed by Hibernate Search and the start/stop
methods defined by optional <code class="literal">Stoppable</code> and <code class="literal">Startable</code> interfaces will be ignored.</p><p>A Service implementation which is only used as a Provided Service doesn’t need to have a public
constructor taking no arguments.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Provided services have priority over managed services. If a provided service is registered with the
same <code class="literal">ServiceManager</code> instance as a managed service, the provided service will be used.</p></div><p>The provided services are passed to Hibernate Search via the <code class="literal">SearchConfiguration</code> interface: as
implementor of method <code class="literal">getProvidedServices</code> you can return a <code class="literal">Map</code> of all services you need to
provide.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>When implementing a custom <code class="literal">org.hibernate.search.cfg.spi.SearchConfiguration</code> we recommend you
extend the base class <code class="literal">org.hibernate.search.cfg.spi.SearchConfigurationBase</code>: that will improve
compatibility by not breaking your code when we need to add new methods to this interface.</p></div></section></section></section><section class="section" id="_customizing_lucene_s_scoring_formula"><div class="titlepage"><div><div><h2 class="title">10.8. Customizing Lucene’s scoring formula</h2></div></div></div><p>Lucene allows the user to customize its scoring formula by extending
org.apache.lucene.search.similarities.Similarity. The abstract methods defined in this class match
the factors of the following formula calculating the score of query q for document d:</p><p><span class="strong"><strong>score(q,d) = coord(q,d) · queryNorm(q) · ∑ ~t in q~ ( tf(t in d) · idf(t) <sup>2</sup> · t.getBoost() · norm(t,d) )</strong></span></p><div class="informaltable"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Factor</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Description</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>tf(t ind)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Term frequency factor for the term (t) in the document
              (d).</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>idf(t)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Inverse document frequency of the term.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>coord(q,d)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Score factor based on how many of the query terms are
              found in the specified document.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>queryNorm(q)</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Normalizing factor used to make scores between queries
              comparable.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p>t.getBoost()</p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Field boost.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p>norm(t,d)</p></td><td style="text-align: left; vertical-align: top; "><p>Encapsulates a few (indexing time) boost and length
              factors.</p></td></tr></tbody></table></div><p>It is beyond the scope of this manual to explain this formula in more detail. Please refer to
Similarity’s Javadocs for more information.</p><p>Hibernate Search provides two ways to modify Lucene’s similarity calculation.</p><p>First you can set the default similarity by specifying the fully specified classname of your
Similarity implementation using the property hibernate.search.similarity. The default value is
org.apache.lucene.search.similarities.ClassicSimilarity.</p><p>Secondly, you can override the similarity used for a specific index by setting the <code class="literal">similarity</code>
property for this index (see <a class="xref" href="#search-configuration-directory" title="3.3. Directory configuration">Section 3.3, “Directory configuration”</a> for more information about index
configuration):</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].similarity = my.custom.Similarity</pre></div><p>As an example, let’s assume it is not important how often a term appears in a document. Documents
with a single occurrence of the term should be scored the same as documents with multiple
occurrences. In this case your custom implementation of the method <code class="literal">tf(float freq)</code> should return 1.0.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>When two entities share the same index they must declare the same Similarity implementation.</p></div></section><section class="section" id="section-multi-tenancy"><div class="titlepage"><div><div><h2 class="title">10.9. Multi-tenancy</h2></div></div></div><section class="section" id="_what_is_multi_tenancy"><div class="titlepage"><div><div><h3 class="title">10.9.1. What is multi-tenancy?</h3></div></div></div><p>The term multi-tenancy in general is applied to software development to indicate an architecture in
which a single running instance of an application simultaneously serves multiple clients (tenants).
Isolating information (data, customizations, etc) pertaining to the various tenants is a particular
challenge in these systems.
This includes the data owned by each tenant stored in the database.
You will find more details on how to enable multi-tenancy with Hibernate in the
<a class="link" href="http://docs.jboss.org/hibernate/orm/4.3/devguide/en-US/html/ch16.html">Hibernate ORM developer’s guide</a>.</p></section><section class="section" id="_using_a_tenant_aware_literal_fulltextsession_literal"><div class="titlepage"><div><div><h3 class="title">10.9.2. Using a tenant-aware <code class="literal">FullTextSession</code></h3></div></div></div><p>Hibernate Search supports multi-tenancy on top of Hibernate ORM, it stores the tenant identifier in
the document and automatically filters the query results.</p><p>The <code class="literal">FullTextSession</code> will be bound to the specific tenant ("client-A" in the example)
and the mass indexer will only index the entities associated to that tenant identifier.</p><div class="example" id="d0e9074"><div class="example-title">Example 10.11. Bind the session to a tenant</div><div class="example-contents"><pre><code class="language-java">Session session = getSessionFactory()
                      .withOptions()
                          .tenantIdentifier( "client-A" )
                  .openSession();

FullTextSession session = Search.getFullTextSession( session );</code></pre></div></div><br class="example-break"/><p>The use of a tenant identifier will have the following effects:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Every document saved or updated in the index will have an additional field <code class="literal">__HSearch_TenantId</code>
containing the tenant identifier.</li><li class="listitem">Every search will be filtered using the tenant identifier.</li><li class="listitem">The MassIndexer (see <a class="xref" href="#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a>) will only affect the currently selected tenant.</li></ol></div><p>Note that not using a tenant will return all the matching results for all the tenants in the index.</p></section></section></section><section class="chapter" id="elasticsearch-integration"><div class="titlepage"><div><div><h1 class="title">Chapter 11. Integration with Elasticsearch</h1></div></div></div><div class="toc"><ul class="toc"><li><span class="section"><a href="#_status">11.1. Status</a></span></li><li><span class="section"><a href="#_goal_of_the_elasticsearch_integration">11.2. Goal of the Elasticsearch integration</a></span></li><li><span class="section"><a href="#_getting_started_and_configuration">11.3. Getting started and configuration</a></span><ul><li><span class="section"><a href="#_dependencies_in_your_java_application">11.3.1. Dependencies in your Java application</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_integration_server_configuration_xreflabel_elasticsearch_integration_server_configuration_elasticsearch_configuration">11.3.2.  Elasticsearch configuration</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_integration_configuration_xreflabel_elasticsearch_integration_configuration_hibernate_search_configuration">11.3.3.  Hibernate Search configuration</a></span></li></ul></li><li><span class="section"><a href="#_mapping_and_indexing">11.4. Mapping and indexing</a></span><ul><li><span class="section"><a href="#_annotation_specificities">11.4.1. Annotation specificities</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_mapping_analyzer_xreflabel_elasticsearch_mapping_analyzer_analyzers">11.4.2.  Analyzers</a></span></li><li><span class="section"><a href="#_custom_field_bridges">11.4.3. Custom field bridges</a></span></li><li><span class="section"><a href="#_tika_bridges">11.4.4. Tika bridges</a></span></li></ul></li><li><span class="section"><a href="#_queries">11.5. Queries</a></span><ul><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_query_spatial_xreflabel_elasticsearch_query_spatial_spatial_queries">11.5.1.  Spatial queries</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_scrolling_xreflabel_elasticsearch_scrolling_paging_and_scrolling">11.5.2.  Paging and scrolling</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_query_sorting_xreflabel_elasticsearch_query_sorting_sorting">11.5.3. Sorting</a></span></li><li><span class="section"><a href="#_projections">11.5.4. Projections</a></span></li><li><span class="section"><a href="#_filters">11.5.5. Filters</a></span></li></ul></li><li><span class="section"><a href="#_index_optimization">11.6. Index optimization</a></span></li><li><span class="section"><a href="#__anchor_xml_id_elasticsearch_limitations_xreflabel_elasticsearch_limitations_limitations">11.7. Limitations</a></span></li><li><span class="section"><a href="#_known_bugs_in_elasticsearch">11.8. Known bugs in Elasticsearch</a></span></li><li><span class="section"><a href="#_acknowledgment">11.9. Acknowledgment</a></span></li></ul></div><section class="section" id="_status"><div class="titlepage"><div><div><h2 class="title">11.1. Status</h2></div></div></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="caution"><h2>Caution</h2><p>This feature is a work in progress.
Make sure to read the <a class="link" href="#elasticsearch-limitations">Limitations</a> section!</p></div><p>The integration with Elasticsearch is in development and should be considered experimental.
We do think we have the basics covered and we are looking for feedback.</p><p>Patches can be sent as pull requests to the <a class="link" href="https://github.com/hibernate/hibernate-search">Github repository</a>,
but also general feedback, suggestions and questions are very welcome.
To get in touch or find other interesting links for contributors, see the <a class="link" href="http://hibernate.org/community/">Community page</a>
of the Hibernate website.</p></section><section class="section" id="_goal_of_the_elasticsearch_integration"><div class="titlepage"><div><div><h2 class="title">11.2. Goal of the Elasticsearch integration</h2></div></div></div><p>The goal of integrating with Elasticsearch is to allow Hibernate Search users to benefit
from the full-text capabilities integrated with Hibernate ORM
but replacing the local Lucene based index with a remote Elasticsearch service.</p><p>There could be various reasons to prefer this over an "embedded Lucene" approach:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">wish to separate the service running your application from the Search service</li><li class="listitem">integrate with an existing Elasticsearch instance</li><li class="listitem">benefit from Elasticsearch’s out of the box horizontal scalability features</li><li class="listitem">explore the data updated by an Hibernate powered application using the Elasticsearch dashboard integrations such as Kibana</li></ul></div><p>There are a couple of drawbacks compared to the embedded Lucene approach though:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">incur a performance penalty of remote RPCs both for index updates and to run queries</li><li class="listitem">need to manage an additional service</li><li class="listitem">possibly need to buy and manage additional servers</li></ul></div><p>Which solution is best will depend on the specific needs of your system and your organization.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Why not use Elasticsearch directly</h2><p>The #1 reason is that Hibernate Search integrates perfectly with Hibernate ORM.
All changes done to your objects will trigger the necessary index changes transparently.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">it will honor the transaction boundary - i.e. not do the indexing work if the transaction ends up in rollback</li><li class="listitem">changes to cascaded objects are handled</li><li class="listitem">changes to nested object embedded in a root indexed entity are handled</li><li class="listitem">changes will be sent in bulk - i.e. optimized systematically for you</li><li class="listitem">etc.</li></ul></div><p>There is no more paradigm shift in your code.
You are working on Hibernate ORM managed objects,
doing your queries on object properties with a nice DSL.</p></div></section><section class="section" id="_getting_started_and_configuration"><div class="titlepage"><div><div><h2 class="title">11.3. Getting started and configuration</h2></div></div></div><p>To experiment with the Elasticsearch integration you will have to download Elasticsearch and run it:
Hibernate Search connects to an Elasticsearch node but does not provide one.</p><p>One option is to use the <a class="link" href="https://hub.docker.com/r/library/elasticsearch/">Elasticsearch Docker image</a>.</p><p><span class="formalpara-title">Start an Elasticsearch node via Docker. </span>
</p><pre><code class="language-bash">docker pull elasticsearch
docker run -p 9200:9200 -d -v "$PWD/plugin_dir":/usr/share/elasticsearch/plugins \
    -v "$PWD/config/elasticsearch.yml":/usr/share/elasticsearch/config/elasticsearch.yml \
    elasticsearch</code></pre><p>
</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Elasticsearch version</h2><p>Hibernate Search expects an Elasticsearch node version 2.0 at least. 5.0 is not supported yet.
Hibernate Search internal tests run against Elasticsearch 2.4.4.</p></div><section class="section" id="_dependencies_in_your_java_application"><div class="titlepage"><div><div><h3 class="title">11.3.1. Dependencies in your Java application</h3></div></div></div><p>In addition to the usual dependencies like Hibernate ORM and Hibernate Search,
you will need the new <code class="literal">hibernate-search-elasticsearch</code> jar.</p><div class="example" id="d0e9208"><div class="example-title">Example 11.1. Maven dependencies for Hibernate Search with Elasticsearch</div><div class="example-contents"><pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-elasticsearch&lt;/artifactId&gt;
   &lt;version&gt;5.6.6.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div></div><br class="example-break"/></section><section class="section" id="__anchor_xml_id_elasticsearch_integration_server_configuration_xreflabel_elasticsearch_integration_server_configuration_elasticsearch_configuration"><div class="titlepage"><div><div><h3 class="title">11.3.2. <span id="elasticsearch-integration-server-configuration"/> Elasticsearch configuration</h3></div></div></div><p>Hibernate Search can work with an Elasticsearch server without altering its configuration.</p><p>However some features offered by Hibernate Search require specific configuration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">if you want to be able to use the Hibernate Search <a class="link" href="#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">MassIndexer</a>
with <code class="literal">purgeAllOnStart</code> enabled - which is enabled by default -, or to use <code class="literal">FullTextSession.purge()</code> or <code class="literal">FullTextSession.purgeAll()</code>,
  install the <a class="link" href="https://www.elastic.co/guide/en/elasticsearch/plugins/2.2/plugins-delete-by-query.html"><code class="literal">delete-by-query</code> plugin</a></li><li class="listitem">if you want to retrieve the distance in a geolocation query, enable the <code class="literal">lang-groovy</code> plugin,
see <a class="link" href="#elasticsearch-query-spatial">Elasticsearch Spatial queries</a></li><li class="listitem">if you want to use paging (as opposed to <a class="link" href="#elasticsearch-scrolling">scrolling</a>) on result sets larger than 10000 elements
(for instance access the 10001st result),
you may increase the value of the <code class="literal">index.max_result_window</code> property (default is 10000).</li></ul></div></section><section class="section" id="__anchor_xml_id_elasticsearch_integration_configuration_xreflabel_elasticsearch_integration_configuration_hibernate_search_configuration"><div class="titlepage"><div><div><h3 class="title">11.3.3. <span id="elasticsearch-integration-configuration"/> Hibernate Search configuration</h3></div></div></div><p>Configuration is minimal.
Add the configuration properties to your <code class="literal">persistence.xml</code> or where you put the rest of your Hibernate Search configuration.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Select Elasticsearch as the backend</span></dt><dd><code class="literal">hibernate.search.default.indexmanager elasticsearch</code></dd><dt><span class="term">Hostname and port for Elasticsearch</span></dt><dd><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.host http://127.0.0.1:9200</code> (default)</p><p class="simpara">You may also select multiple hosts (separated by whitespace characters), so that they are assigned requests in turns (load balancing):</p><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.host http://es1.mycompany.com:9200 http://es2.mycompany.com:9200</code></p><p class="simpara">In the example above, the first request will go to <code class="literal">es1</code>, the second to <code class="literal">es2</code>, the third to <code class="literal">es1</code>, and so on.</p></dd><dt><span class="term">Username for Elasticsearch connection</span></dt><dd><code class="literal">hibernate.search.default.elasticsearch.username ironman</code> (default is empty, meaning anonymous access)</dd><dt><span class="term">Password for Elasticsearch connection</span></dt><dd><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.password j@rV1s</code> (default is empty)</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="caution"><h2>Caution</h2><p>If you used HTTP instead of HTTPS in any of the Elasticsearch host URLs (see above),
your password will be transmitted in clear text over the network.</p></div></dd><dt><span class="term"><span id="elasticsearch-schema-management-strategy"/>Select the index creation strategy</span></dt><dd><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.index_schema_management_strategy CREATE</code> (default)</p><p class="simpara">Let’s see the options for the <code class="literal">index_schema_management_strategy</code> property:</p><div class="informaltable"><table style="border-collapse: collapse; border-top: 1px solid ; border-bottom: 1px solid ; border-left: 1px solid ; border-right: 1px solid ; "><colgroup><col style="width: 50*; " class="col_1"/><col style="width: 50*; " class="col_2"/></colgroup><thead><tr><th style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; ">Value</th><th style="text-align: left; vertical-align: top; border-bottom: 1px  ; ">Definition</th></tr></thead><tbody><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">NONE</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>The index, its mappings and the analyzer definitions will not be created, deleted nor altered.
Hibernate Search will <span class="strong"><strong>not even check</strong></span> that the index already exists.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">VALIDATE</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>The index, its mappings and analyzer definitions will be checked for conflicts with Hibernate Search’s metamodel.
The index, its mappings and analyzer definitions will not be created, deleted nor altered.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">MERGE</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>The index, its mappings and analyzer definitions will be created, existing mappings will be updated if there are no conflicts.
+
Caution: if analyzer definitions have to be updated, the index will be closed automatically during the update.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">CREATE</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p><span class="strong"><strong>The default</strong></span>: an existing index will not be altered, a missing index will be created along with their mappings and analyzer definitions.</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; border-bottom: 1px  ; "><p><code class="literal">RECREATE</code></p></td><td style="text-align: left; vertical-align: top; border-bottom: 1px  ; "><p>Indexes will be deleted if existing and then created along with their mappings and analyzer definitions.
This will delete all content from the indexes!</p></td></tr><tr><td style="text-align: left; vertical-align: top; border-right: 1px  ; "><p><code class="literal">RECREATE_DELETE</code></p></td><td style="text-align: left; vertical-align: top; "><p>Similarly to <code class="literal">RECREATE</code> but will also delete the index at shutdown. Commonly used for tests.</p></td></tr></tbody></table></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="caution"><h2>Strategies in production environments</h2><p>It is strongly recommended to use either <code class="literal">NONE</code> or <code class="literal">VALIDATE</code> in a production environment. <code class="literal">RECREATE</code> and <code class="literal">RECREATE_DELETE</code> are obviously unsuitable in this context (unless you want to reindex everything upon every startup), and <code class="literal">MERGE</code> may leave your mapping half-merged in case of conflict.</p><p>To be precise, if your mapping changed in an incompatible way, such as a field having its type changed, merging may be impossible. In this case, the <code class="literal">MERGE</code> strategy will prevent Hibernate Search from starting, but it may already have successfully merged another index, making a rollback difficult at best.</p><p>Also, when updating analyzer definitions, Hibernate Search will stop the affected indexes during the update.
This means the <code class="literal">MERGE</code> strategy should be used with caution when multiple clients use Elasticsearch indexes managed by Hibernate Search:
those clients should be synchronized in such a way that while Hibernate Search is starting, no other client tries to use the index.</p><p>For these reasons, migrating your mapping should be considered a part of your deployment process and be planned cautiously.</p></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Mapping validation is as permissive as possible. Fields or mappings that are unknown to Hibernate Search will be ignored, and settings that are more powerful than required (e.g. a field annotated with <code class="literal">@Field(index = Index.NO)</code> in Search but marked as <code class="literal">"index": analyzed</code> in Elasticsearch) will be deemed valid.</p><p>One exception should be noted, though: date formats must match exactly the formats specified by Hibernate Search, due to implementation constraints.</p></div></dd><dt><span class="term">Maximum time to wait for a connection to the Elasticsearch server before failing (in ms)</span></dt><dd><code class="literal">hibernate.search.default.elasticsearch.connection_timeout 3000</code> (default)</dd><dt><span class="term">Maximum time to wait for a response from the Elasticsearch server before failing (in ms)</span></dt><dd><code class="literal">hibernate.search.default.elasticsearch.read_timeout 60000</code> (default)</dd><dt><span class="term">Maximum number of simultaneous connections to the Elasticsearch cluster</span></dt><dd><code class="literal">hibernate.search.default.elasticsearch.max_total_connection 20</code> (default)</dd><dt><span class="term">Maximum number of simultaneous connections to a single Elasticsearch server</span></dt><dd><code class="literal">hibernate.search.default.elasticsearch.max_total_connection_per_route 2</code> (default)</dd><dt><span class="term">Whether to enable automatic discovery of servers in the Elasticsearch cluster (<code class="literal">true</code> or <code class="literal">false</code>)</span></dt><dd><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.discovery.enabled false</code> (default)</p><p class="simpara">When using automatic discovery, the Elasticsearch client will periodically probe for new nodes in the cluster,
and will add those to the server list (see <code class="literal">host</code> above).
Similarly, the client will periodically check whether registered servers still respond,
and will remove them from the server list if they don’t.</p></dd><dt><span class="term">Time interval between two executions of the automatic discovery (in seconds)</span></dt><dd><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.discovery.refresh_interval 10</code> (default)</p><p class="simpara">This setting will only be taken into account if automatic discovery is enabled (see above).</p></dd><dt><span class="term">Scheme to use when connecting to automatically discovered nodes (<code class="literal">http</code> or <code class="literal">https</code>)</span></dt><dd><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.discovery.default_scheme http</code> (default)</p><p class="simpara">This setting will only be taken into account if automatic discovery is enabled (see above).</p></dd><dt><span class="term">Maximum time to wait for the indexes to become available before failing (in ms)</span></dt><dd><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.index_management_wait_timeout 10000</code> (default)</p><p class="simpara">This value must be lower than the read timeout (see above).</p></dd><dt><span class="term">Status an index must at least have in order for Hibernate Search to work with it (one of "green", "yellow" or "red")</span></dt><dd><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.required_index_status green</code> (default)</p><p class="simpara">Only operate if the index is at this level or safer.
In development, set this value to <code class="literal">yellow</code> if the number of nodes started is below the number of expected replicas.</p></dd><dt><span class="term">Whether to perform an explicit refresh after a set of operations has been executed against a specific index (<code class="literal">true</code> or <code class="literal">false</code>)</span></dt><dd><p class="simpara"><code class="literal">hibernate.search.default.elasticsearch.refresh_after_write false</code> (default)</p><p class="simpara">This is useful in unit tests to ensure that a write is visible by a query immediately without delay.
This keeps unit tests simpler and faster.
But you should not rely on the synchronous behaviour for your production code.
Leave at <code class="literal">false</code> for optimal performance of your Elasticsearch cluster.</p></dd><dt><span class="term">When <a class="link" href="#elasticsearch-scrolling">scrolling</a>, the minimum number of previous results kept in memory at any time</span></dt><dd><code class="literal">hibernate.search.elasticsearch.scroll_backtracking_window_size 10000</code> (default)</dd><dt><span class="term">When <a class="link" href="#elasticsearch-scrolling">scrolling</a>, the number of results fetched by each Elasticsearch call</span></dt><dd><code class="literal">hibernate.search.elasticsearch.scroll_fetch_size 1000</code> (default)</dd><dt><span class="term">When <a class="link" href="#elasticsearch-scrolling">scrolling</a>, the maximum duration <code class="literal">ScrollableResults</code> will be usable if no other results are fetched from Elasticsearch, in seconds</span></dt><dd><code class="literal">hibernate.search.elasticsearch.scroll_timeout 60</code> (default)</dd></dl></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>Properties prefixed with <code class="literal">hibernate.search.default</code> can be given globally as shown above and/or be given for specific indexes:</p><p><code class="literal">hibernate.search.someindex.elasticsearch.index_schema_management_strategy MERGE</code></p><p>This excludes properties related to the internal Elasticsearch client, which at the moment is common to every index manager (but this will change in a future version).
Excluded properties are <code class="literal">host</code>, <code class="literal">username</code>, <code class="literal">password</code>, <code class="literal">read_timeout</code>, <code class="literal">connection_timeout</code>, <code class="literal">max_total_connection</code>, <code class="literal">max_total_connection_per_route</code>, <code class="literal">discovery.enabled</code>, <code class="literal">discovery.refresh_interval</code> and <code class="literal">discovery.scheme</code>.</p></div></section></section><section class="section" id="_mapping_and_indexing"><div class="titlepage"><div><div><h2 class="title">11.4. Mapping and indexing</h2></div></div></div><p>Like in Lucene embedded mode, indexes are transparently updated when you create or update
entities mapped to Hibernate Search.
Simply use familiar annotations from <a class="xref" href="#search-mapping" title="Chapter 4. Mapping entities to the index structure">Chapter 4, <em>Mapping entities to the index structure</em></a>.</p><p>The name of the index will be the lowercased name provided to <code class="literal">@Indexed</code> (non qualified class name by default).
Hibernate Search will map the fully qualified class name to the Elasticsearch type.</p><section class="section" id="_annotation_specificities"><div class="titlepage"><div><div><h3 class="title">11.4.1. Annotation specificities</h3></div></div></div><section class="section" id="_field_indexnullas"><div class="titlepage"><div><div><h4 class="title">11.4.1.1. Field.indexNullAs</h4></div></div></div><p>The <code class="literal">org.hibernate.search.annotations.Field</code> annotation allows you to provide a replacement value for null properties through the <code class="literal">indexNullAs</code> attribute (see <a class="xref" href="#field-annotation" title="4.1.1.2. @Field">Section 4.1.1.2, “@Field”</a>), but this value must be provided as a string.</p><p>In order for your value to be understood by Hibernate Search (and Elasticsearch), the provided string must follow one of those formats:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">For string values, no particular format is required.</li><li class="listitem">For numeric values, use formats accepted by <code class="literal">Double.parseDouble</code>, <code class="literal">Integer.parseInteger</code>, etc., depending on the actual type of your field.</li><li class="listitem">For booleans, use either <code class="literal">true</code> or <code class="literal">false</code>.</li><li class="listitem"><p class="simpara">For dates (<code class="literal">java.util.Calendar</code>, <code class="literal">java.util.Date</code>, <code class="literal">java.time.*</code>), use the ISO-8601 format.</p><p class="simpara">The full format is <code class="literal">yyyy-MM-dd’T’HH:mm:ss.nZ[ZZZ]</code> (for instance <code class="literal">2016-11-26T16:41:00.006+01:00[CET]</code>).
Please keep in mind that part of this format must be left out depending on the type of your field, though.
For a <code class="literal">java.time.LocalDateTime</code> field, for instance,
the provided string must not include the zone offset (<code class="literal">+01:00</code>) or the zone ID (<code class="literal">[UTC]</code>), because those don’t make sense.</p><p class="simpara">Even when they make sense for the type of your field, the time and time zone may be omitted
 (if omitted, the time zone will be interpreted as the default JVM time zone).</p></li></ul></div></section><section class="section" id="_dynamic_boosting"><div class="titlepage"><div><div><h4 class="title">11.4.1.2. Dynamic boosting</h4></div></div></div><p>The <code class="literal">org.hibernate.search.annotations.DynamicBoost</code> annotation is not (and cannot be) supported with Elasticsearch, because the platform lacks per-document, index-time boosting capabilities. Static boosts (<code class="literal">@Boost</code>) are, however, supported.</p></section></section><section class="section" id="__anchor_xml_id_elasticsearch_mapping_analyzer_xreflabel_elasticsearch_mapping_analyzer_analyzers"><div class="titlepage"><div><div><h3 class="title">11.4.2. <span id="elasticsearch-mapping-analyzer"/> Analyzers</h3></div></div></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>Analyzers are treated differently than in Lucene embedded mode.</p></div><section class="section" id="_built_in_or_server_defined_analyzers"><div class="titlepage"><div><div><h4 class="title">11.4.2.1. Built-in or server-defined analyzers</h4></div></div></div><p>Using the <code class="literal">definition</code> attribute in the <code class="literal">@Analyzer</code> annotation, you can refer to the name of the
built-in Elasticsearch analyzer, or custom analyzers already registered on your Elasticsearch instances.</p><p>More information on analyzers, in particular those already built in Elasticsearch, can be found
in <a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html">the Elasticsearch documentation</a>.</p><p><span class="formalpara-title">Example of custom analyzers defined in the elasticsearch.yml. </span>
</p><pre><code class="language-yml"># Custom analyzer
index.analysis:
  analyzer.custom-analyzer:
    type: custom
    tokenizer: standard
    filter: [custom-filter, lowercase]
  filter.custom-filter:
    type : stop
    stopwords : [test1, close]</code></pre><p>
</p><p>From there, you can use the custom analyzers by name in your entity mappings.</p><p><span class="formalpara-title">Example of mapping that refers to custom and built-in analyzers on Elasticsearch. </span>
</p><pre><code class="language-java">@Entity
@Indexed(index = "tweet")
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(definition = "english") // Elasticsearch built-in analyzer
    private String englishTweet;

    @Field
    @Analyzer(definition = "whitespace") // Elasticsearch built-in analyzer
    private String whitespaceTweet;

    @Fields({
        @Field(name = "tweetNotAnalyzed", analyzer = Analyze.NO, store = Store.YES),

        // Custom analyzer
        @Field(
            name = "tweetWithCustom",
            analyzer = @Analyzer(definition = "custom-analyzer")
        )
    })
    private String multipleTweets;
}</code></pre><p>
</p><p>You may also reference a built-in Lucene analyzer implementation using the <code class="literal">@Analyzer.impl</code> attribute:
Hibernate Search will translate the implementation to an equivalent Elasticsearch built-in type, if possible.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>Using the <code class="literal">@Analyzer.impl</code> attribute is not recommended with Elasticsearch because it will
never allow you to take full advantage of Elasticsearch analysis capabilities.
You cannot, for instance, use custom analyzer implementations: only built-in Lucene implementations are supported.</p><p>It should only be used when migrating an application that already used Hibernate Search,
moving from an embedded Lucene instance to an Elasticsearch cluster.</p></div><p><span class="formalpara-title">Example of mapping that refers to a built-in analyzer on Elasticsearch using a Lucene implementation class. </span>
</p><pre><code class="language-java">@Entity
@Indexed(index = "tweet")
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(impl = EnglishAnalyzer.class) // Elasticsearch built-in "english" analyzer
    private String englishTweet;

    @Field
    @Analyzer(impl = WhitespaceAnalyzer.class) // Elasticsearch built-in "whitespace" analyzer
    private String whitespaceTweet;

}</code></pre><p>
</p></section><section class="section" id="_custom_analyzers"><div class="titlepage"><div><div><h4 class="title">11.4.2.2. Custom analyzers</h4></div></div></div><p>You can also define analyzers within your Hibernate Search mapping using the <code class="literal">@AnalyzerDef</code> annotation,
like you would <a class="link" href="#section-named-analyzers" title="4.3.2. Named analyzers">do with an embedded Lucene instance</a>.
When Hibernate Search creates the Elasticsearch indexes, the relevant definitions will then be automatically added as a
<a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-custom-analyzer.html">custom analyzer</a>
in  the index settings.</p><p>Two different approaches allow you to define your analyzers with Elasticsearch.</p><p>The first, recommended approach is to use the factories provided by the <code class="literal">hibernate-search-elasticsearch</code> module:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">org.hibernate.search.elasticsearch.analyzer.ElasticsearchCharFilterFactory</code></li><li class="listitem"><code class="literal">org.hibernate.search.elasticsearch.analyzer.ElasticsearchTokenFilterFactory</code></li><li class="listitem"><code class="literal">org.hibernate.search.elasticsearch.analyzer.ElasticsearchTokenizerFactory</code></li></ul></div><p>Those classes can be passed to the <code class="literal">factory</code> attribute of
the <code class="literal">@CharFilterDef</code>, <code class="literal">@TokenFilterDef</code> and <code class="literal">@TokenizerDef</code> annotations.</p><p>The <code class="literal">params</code> attribute may be used to define the <code class="literal">type</code> parameter and any other parameter
accepted by Elasticsearch for this type.</p><p>The parameter values will be interpreted as JSON. The parser is not strict, though:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">quotes around strings may be left out in some cases, as when a string only contains letters.</li><li class="listitem">when quotes <span class="strong"><strong>are</strong></span> required (e.g. your string may be interpreted as a number, and you don’t want that),
you may use single quotes instead of double quotes (which are painful to write in Java).</li></ul></div><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>You may use the <code class="literal">name</code> attribute of the <code class="literal">@CharFilterDef</code>, <code class="literal">@TokenFilterDef</code> and <code class="literal">@TokenizerDef</code> annotations
to define the exact name to give to that definition in the Elasticsearch settings.</p></div><p><span class="formalpara-title">Example of mapping that defines analyzers on Elasticsearch using the <code class="literal">Elasticsearch*Factory</code> types. </span>
</p><pre><code class="language-java">@Entity
@Indexed(index = "tweet")
@AnalyzerDefs(
	@AnalyzerDef(
		name = "tweet_analyzer",
		charFilters = {
			@CharFilterDef(
				name = "custom_html_strip",
				factory = ElasticsearchCharFilterFactory.class,
				params = {
					@Parameter(name = "type", value = "'html_strip'"),
					// One can use Json arrays
					@Parameter(name = "escaped_tags", value = "['br', 'p']")
				}
			),
			@CharFilterDef(
				name = "p_br_as_space",
				factory = ElasticsearchCharFilterFactory.class,
				params = {
					@Parameter(name = "type", value = "'pattern_replace'"),
					@Parameter(name = "pattern", value = "'&lt;p/?&gt;|&lt;br/?&gt;'"),
					@Parameter(name = "replacement", value = "' '"),
					@Parameter(name = "tags", value = "'CASE_INSENSITIVE'")
				}
			)
		},
		tokenizer = @TokenizerDef(
			factory = ElasticsearchTokenizerFactory.class,
			params = {
				@Parameter(name = "type", value = "'whitespace'"),
			}
		)
	)
)
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(definition = "tweet_analyzer")
    private String content;
}</code></pre><p>
</p><p>The second approach is to configure everything as if you were using Lucene:
use the Lucene factories, their parameter names, and format the parameter values as required in Lucene.
Hibernate Search will automatically convert these definitions to the Elasticsearch equivalent.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="warning"><h2>Warning</h2><p>Referencing Lucene factories is not recommended with Elasticsearch because it will
never allow you to take full advantage of Elasticsearch analysis capabilities.</p><p>Here are the known limitations of the automatic translation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">a few factories have unsupported parameters, because those have no equivalent in Elasticsearch.
An exception will be raised on startup if a parameter is not supported.</li><li class="listitem">the <code class="literal">hyphenator</code> parameter for <code class="literal">HyphenatedWordsFilterFactory</code> must refer to
a file on the Elasticsearch servers, on the contrary to other factories
where the files are accessed by Hibernate Search directly.
This is due to an Elasticsearch limitation
(there is no way to forward the content of a local hyphenation pattern file).</li><li class="listitem">some built-in Lucene factories are not (and cannot) be translated, because of incompatible
parameters between the Lucene factory and the Elasticsearch equivalent.
This is in particular the case for <code class="literal">HunspellStemFilterFactory</code>.</li></ul></div><p>Therefore, Lucene factories should only be referenced within analyzer definitions
when migrating an application that already used Hibernate Search,
moving from an embedded Lucene instance to an Elasticsearch cluster.</p></div><p><span class="formalpara-title">Example of mapping that defines analyzers on Elasticsearch using Lucene factories. </span>
</p><pre><code class="language-java">@Entity
@Indexed(index = "tweet")
@AnalyzerDefs(
	@AnalyzerDef(
		name = "tweet_analyzer",
		charFilters = {
			@CharFilterDef(
				name = "custom_html_strip",
				factory = HTMLStripCharFilterFactory.class,
				params = {
					@Parameter(name = "escapedTags", value = "br,p")
				}
			),
			@CharFilterDef(
				name = "p_br_as_space",
				factory = PatternReplaceCharFilterFactory.class,
				params = {
					@Parameter(name = "pattern", value = "&lt;p/?&gt;|&lt;br/?&gt;"),
					@Parameter(name = "replacement", value = " ")
				}
			)
		},
		tokenizer = @TokenizerDef(
			factory = WhitespaceTokenizerFactory.class
		)
	)
)
public class Tweet {

    @Id
    @GeneratedValue
    private Integer id;

    @Field
    @Analyzer(definition = "tweet_analyzer")
    private String content;
}</code></pre><p>
</p></section></section><section class="section" id="_custom_field_bridges"><div class="titlepage"><div><div><h3 class="title">11.4.3. Custom field bridges</h3></div></div></div><p>You can write custom field bridges and class bridges.
For class bridges and field bridges creating multiple fields,
make sure to make your bridge implementation also implement the <code class="literal">MetadataProvidingFieldBridge</code> contract.</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="caution"><h2>Caution</h2><p>Creating sub-fields in custom field bridges is not supported.</p><p>You create a sub-field when your <code class="literal">MetadataProvidingFieldBridge</code> registers a field whose name is the name of an existing field, with a dot and another string appended, like <code class="literal">name + ".mySubField"</code>.</p><p>This lack of support is due to Elasticsearch not allowing a field to have multiple types. In the example above, the field would have both the <code class="literal">object</code> datatype and whatever datatype the original field has (<code class="literal">string</code> in the most common case).</p><p>As an alternative, you may append a suffix to the original field name in order to create a <span class="strong"><strong>sibling</strong></span> field, e.g. use <code class="literal">name + "_mySubField"</code> or <code class="literal">name + "_more.mySubField"</code> instead of <code class="literal">name + ".mySubField"</code>.</p><p>This limitation is true in particular for field bridges applied to the <code class="literal">@DocumentId</code>: fields added to the document must not be in the form <code class="literal">name + ".mySubField"</code>, in order to avoid mapping conflicts with the ID field.</p></div><pre><code class="language-java">/**
 * Used as class-level bridge for creating the "firstName" and "middleName" document and doc value fields.
 */
public static class FirstAndMiddleNamesFieldBridge implements MetadataProvidingFieldBridge {

    @Override
    public void set(String name, Object value, Document document, LuceneOptions luceneOptions) {
        Explorer explorer = (Explorer) value;

        String firstName = explorer.getNameParts().get( "firstName" );
        luceneOptions.addFieldToDocument( name + "_firstName", firstName, document );
        document.add( new SortedDocValuesField( name + "_firstName", new BytesRef( firstName ) ) );

        String middleName = explorer.getNameParts().get( "middleName" );
        luceneOptions.addFieldToDocument( name + "_middleName", middleName, document );
        document.add( new SortedDocValuesField( name + "_middleName", new BytesRef( middleName ) ) );
    }

    @Override
    public void configureFieldMetadata(String name, FieldMetadataBuilder builder) {
        builder
            .field( name + "_firstName", FieldType.STRING )
                .sortable( true )
            .field( name + "_middleName", FieldType.STRING )
                .sortable( true );
    }
}</code></pre><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Note</h2><p>This interface and <code class="literal">FieldBridge</code> in general are likely going to evolve in the next major version of Hibernate Search
to remove its adherence to Lucene specific classes like <code class="literal">Document</code>.</p></div></section><section class="section" id="_tika_bridges"><div class="titlepage"><div><div><h3 class="title">11.4.4. Tika bridges</h3></div></div></div><p>If your metadata processors create fields with a different name from the one passed as a parameter, make sure to make your processor also implement the <code class="literal">MetadataProvidingTikaMetadataProcessor</code> contract.</p></section></section><section class="section" id="_queries"><div class="titlepage"><div><div><h2 class="title">11.5. Queries</h2></div></div></div><p>You can write queries like you usually do in Hibernate Search: native Lucene queries and DSL queries (see <a class="xref" href="#search-query" title="Chapter 5. Querying">Chapter 5, <em>Querying</em></a>).
We do automatically translate the most common types of Apache Lucene queries
and all queries generated by the Hibernate Search DSL except more like this (see below).</p><div style="margin-left: 0.5in; margin-right: 0.5in;" class="note"><h2>Unsupported Query DSL features</h2><p>Queries written via the DSL work.
Open a JIRA otherwise.</p><p>The notable exception is more like this queries.
Hibernate Search has a more advanced algorithm than Lucene (or Elasticsearch/Solr)
which is not easily portable with what Elasticsearch exposes.</p><p>If you need this feature, contact us.</p></div><p>On top of translating Lucene queries,
you can directly create Elasticsearch queries by using either its String format or a JSON format:</p><div class="example" id="d0e10010"><div class="example-title">Example 11.2. Creating an Elasticsearch native query from a string</div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
QueryDescriptor query = ElasticsearchQueries.fromQueryString("title:tales");
List&lt;?&gt; result = fullTextSession.createFullTextQuery(query, ComicBook.class).list();</code></pre></div></div><br class="example-break"/><div class="example" id="d0e10015"><div class="example-title">Example 11.3. Creating an Elasticsearch native query from JSON</div><div class="example-contents"><pre><code class="language-java">FullTextSession fullTextSession = Search.getFullTextSession(session);
QueryDescriptor query = ElasticsearchQueries.fromJson(
      "{ 'query': { 'match' : { 'lastName' : 'Brand' } } }");
List&lt;?&gt; result = session.createFullTextQuery(query, GolfPlayer.class).list();</code></pre></div></div><br class="example-break"/><div style="margin-left: 0.5in; margin-right: 0.5in;" class="caution"><h2>Date/time in native Elasticsearch queries</h2><p>By default Elasticsearch interprets the date/time strings lacking the time zone as if they were represented using the UTC time zone. If overlooked, this can cause your native Elasticsearch queries to be completely off.</p><p>The simplest way to avoid issues is to always explicitly provide time zones IDs or offsets when building native Elasticsearch queries. This may be achieved either by directly adding the time zone ID or offset in date strings, or by using the <code class="literal">time_zone</code> parameter (range queries only). See Elasticsearch documentation for more information.</p></div><section class="section" id="__anchor_xml_id_elasticsearch_query_spatial_xreflabel_elasticsearch_query_spatial_spatial_queries"><div class="titlepage"><div><div><h3 class="title">11.5.1. <span id="elasticsearch-query-spatial"/> Spatial queries</h3></div></div></div><p>The Elasticsearch integration supports spatial queries by using either the DSL or native Elasticsearch queries.</p><p>For regular usage, there are no particular requirements for spatial support.</p><p>However, if you want to calculate the distance from your entities to a point without sorting by the distance to this point,
you need to enable the Groovy plugin by adding the following snippet to your Elasticsearch configuration:</p><p><span class="formalpara-title">Enabling Groovy support in your elasticsearch.yml. </span>
</p><pre class="screen">script.engine.groovy.inline.search: on</pre><p>
</p></section><section class="section" id="__anchor_xml_id_elasticsearch_scrolling_xreflabel_elasticsearch_scrolling_paging_and_scrolling"><div class="titlepage"><div><div><h3 class="title">11.5.2. <span id="elasticsearch-scrolling"/> Paging and scrolling</h3></div></div></div><p>You may handle large result sets in two different ways, with different limitations.</p><p>For (relatively) smaller result sets, you may use the traditional offset/limit querying provided by the <code class="literal">FullTextQuery</code> interfaces: <code class="literal">setFirstResult(int)</code> and <code class="literal">setMaxResults(int)</code>.
Limitations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">This will only get you as far as the 10000 first documents, i.e. when requesting a window that includes documents beyond the 10000th result, Elasticsearch will return an error. If you want to raise this limit, see the <code class="literal">index.max_result_window</code> property in <a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#dynamic-index-settings">Elasticsearch’s settings</a>.</li></ul></div><p>If your result set is bigger, you may take advantage of scrolling by using the <code class="literal">scroll</code> method on <code class="literal">org.hibernate.search.FullTextQuery</code>.
Limitations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">This method is not available in <code class="literal">org.hibernate.search.jpa.FullTextQuery</code>.</li><li class="listitem">The Elasticsearch implementation has poor performance when an offset has been defined (i.e. <code class="literal">setFirstResult(int)</code> has been called on the query before calling <code class="literal">scroll()</code>).
This is because Elasticsearch does not provide such feature, thus Hibernate Search has to scroll through every previous result under the hood.</li><li class="listitem">The Elasticsearch implementation allows only limited backtracking. Calling <code class="literal">scrollableResults.setRowNumber(4)</code> when currently positioned at index <code class="literal">1006</code>,
for example, may result in a <code class="literal">SearchException</code> being thrown, because only 1000 previous elements had been kept in memory.
You may work this around by tweaking the property: <code class="literal">hibernate.search.elasticsearch.scroll_backtracking_window_size</code> (see <a class="link" href="#elasticsearch-integration-configuration">Elasticsearch integration configuration</a>).</li><li class="listitem">The <code class="literal">ScrollableResults</code> will become stale and unusable after a given period of time spent without fetching results from Elasticsearch.
You may work this around by tweaking two properties: <code class="literal">hibernate.search.elasticsearch.scroll_timeout</code> and <code class="literal">hibernate.search.elasticsearch.scroll_fetch_size</code> (see <a class="link" href="#elasticsearch-integration-configuration">Elasticsearch integration configuration</a>).
Typically, you will solve timeout issues by reducing the fetch size and/or increasing the timeout limit, but this will also increase the performance hit on Elasticsearch.</li></ul></div></section><section class="section" id="__anchor_xml_id_elasticsearch_query_sorting_xreflabel_elasticsearch_query_sorting_sorting"><div class="titlepage"><div><div><h3 class="title">11.5.3. <span id="elasticsearch-query-sorting"/>Sorting</h3></div></div></div><p>Sorting is performed the same way as <a class="link" href="#query-sorting">with the Lucene backend</a>.</p><p>If you happen to need an advanced Elasticsearch sorting feature that is not natively supported in <code class="literal">SortField</code> or in Hibernate Search sort DSL, you may still create a sort from JSON, and even mix it with DSL-defined sorts:</p><div class="example" id="d0e10146"><div class="example-title">Example 11.4. Mixing DSL-defined sorts with native Elasticsearch JSON sorts</div><div class="example-contents"><pre><code class="language-java">QueryBuilder qb = fullTextSession.getSearchFactory()
    .buildQueryBuilder().forEntity(Book.class).get();
Query luceneQuery = /* ... */;
FullTextQuery query = s.createFullTextQuery( luceneQuery, Book.class );
Sort sort = qb.sort()
        .byNative( "authors.name", "{'order':'asc', 'mode': 'min'}" )
        .andByField("title")
        .createSort();
query.setSort(sort);
List results = query.list();</code></pre></div></div><br class="example-break"/></section><section class="section" id="_projections"><div class="titlepage"><div><div><h3 class="title">11.5.4. Projections</h3></div></div></div><p>All fields are stored by Elasticsearch in the JSON document it indexes,
there is no specific need to mark fields as stored when you want to project them.
The downside is that to project a field, Elasticsearch needs to read the whole JSON document.
If you want to avoid that, use the <code class="literal">Store.YES</code> marker.</p><p>You can also retrieve the full JSON document by using <code class="literal">org.hibernate.search.elasticsearch.ElasticsearchProjectionConstants.SOURCE</code>.</p><pre><code class="language-java">query = ftem.createFullTextQuery(
                    qb.keyword()
                    .onField( "tags" )
                    .matching( "round-based" )
                    .createQuery(),
                    VideoGame.class
            )
            .setProjection( ElasticsearchProjectionConstants.SCORE, ElasticsearchProjectionConstants.SOURCE );

projection = (Object[]) query.getSingleResult();</code></pre><p>If you’re looking for information about execution time, you may also use <code class="literal">org.hibernate.search.elasticsearch.ElasticsearchProjectionConstants.TOOK</code> and <code class="literal">org.hibernate.search.elasticsearch.ElasticsearchProjectionConstants.TIMED_OUT</code>:</p><pre><code class="language-java">query = ftem.createFullTextQuery(
                    qb.keyword()
                    .onField( "tags" )
                    .matching( "round-based" )
                    .createQuery(),
                    VideoGame.class
            )
            .setProjection(
                    ElasticsearchProjectionConstants.SOURCE,
                    ElasticsearchProjectionConstants.TOOK,
                    ElasticsearchProjectionConstants.TIMED_OUT
            );

projection = (Object[]) query.getSingleResult();
Integer took = (Integer) projection[1]; // Execution time (milliseconds)
Boolean timedOut = (Boolean) projection[2]; // Whether the query timed out</code></pre></section><section class="section" id="_filters"><div class="titlepage"><div><div><h3 class="title">11.5.5. Filters</h3></div></div></div><p>The Elasticsearch integration supports the definition of full text filters.</p><p>Your filters need to implement the <code class="literal">ElasticsearchFilter</code> interface.</p><pre><code class="language-java">public class DriversMatchingNameElasticsearchFilter implements ElasticsearchFilter {

    private String name;

    public DriversMatchingNameElasticsearchFilter() {
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String getJsonFilter() {
        return "{ 'term': { 'name': '" + name + "' } }";
    }

}</code></pre><p>You can then declare the filter in your entity.</p><pre><code class="language-java">@Entity
@Indexed
@FullTextFilterDefs({
        @FullTextFilterDef(name = "namedDriver",
                impl = DriversMatchingNameElasticsearchFilter.class)
})
public class Driver {
    @Id
    @DocumentId
    private int id;

    @Field(analyze = Analyze.YES)
    private String name;

    ...
}</code></pre><p>From then you can use it as usual.</p><pre><code class="language-java">ftQuery.enableFullTextFilter( "namedDriver" ).setParameter( "name", "liz" );</code></pre><p>For static filters, you can simply extend the <code class="literal">SimpleElasticsearchFilter</code> and provide an Elasticsearch filter in JSON form.</p></section></section><section class="section" id="_index_optimization"><div class="titlepage"><div><div><h2 class="title">11.6. Index optimization</h2></div></div></div><p>The optimization features documented in <a class="xref" href="#search-optimize" title="Chapter 7. Index Optimization">Chapter 7, <em>Index Optimization</em></a> are only partially implemented. That kind of optimization is rarely needed with recent versions of Lucene (on which Elasticsearch is based), but some of it is still provided for the very specific case of indexes meant to stay read-only for a long period of time:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The automatic optimization is not implemented and most probably never will be.</li><li class="listitem">The manual optimization (<code class="literal">searchFactory.optimize()</code>) is implemented.</li></ul></div></section><section class="section" id="__anchor_xml_id_elasticsearch_limitations_xreflabel_elasticsearch_limitations_limitations"><div class="titlepage"><div><div><h2 class="title">11.7. <span id="elasticsearch-limitations"/>Limitations</h2></div></div></div><p>Not everything is implemented yet.
Here is a list of known limitations.</p><p>Please check with JIRA and the mailing lists for updates, but at the time of writing this at least the following features are known to not work yet:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Query timeouts: <a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH-2399">HSEARCH-2399</a></li><li class="listitem">MoreLikeThis queries: <a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH-2395">HSEARCH-2395</a></li><li class="listitem"><code class="literal">@IndexedEmbedded.indexNullAs</code>: <a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH-2389">HSEARCH-2389</a></li><li class="listitem"><a class="link" href="#search-monitoring" title="Chapter 8. Monitoring">Statistics</a>: <a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH-2421">HSEARCH-2421</a></li><li class="listitem"><code class="literal">@AnalyzerDiscriminator</code>: <a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH-2428">HSEARCH-2428</a></li><li class="listitem">Mixing Lucene based indexes and Elasticsearch based indexes (partial support is here though)</li><li class="listitem">Hibernate Search does not make use of nested objects nor parent child relationship mapping <a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH-2263">HSEARCH-2263</a>.
This is largely mitigated by the fact that Hibernate Search does the denormalization itself and maintain data consistency when nested objects are updated.</li><li class="listitem">There is room for improvements in the performances of the MassIndexer implementation</li><li class="listitem">There is no failover to the next host when multiple hosts are configured and one host happens to fail: <a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH-2469">HSEARCH-2469</a></li><li class="listitem">Our new Elasticsearch integration module does not work in OSGi environments. If you need this, please vote for: <a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH-2524">HSEARCH-2524</a>.</li></ul></div></section><section class="section" id="_known_bugs_in_elasticsearch"><div class="titlepage"><div><div><h2 class="title">11.8. Known bugs in Elasticsearch</h2></div></div></div><p>Depending on the Elasticsearch version you use, you may encounter bugs that are specific to that version.
Here is a list of known Elasticsearch bugs, and what to do about it.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara">Mapping <code class="literal">java.time.ZonedDateTime</code> won’t work with Elasticsearch 2.4.1 because of <a class="link" href="https://github.com/elastic/elasticsearch/issues/20911">a JodaTime bug affecting Elasticsearch</a>: <a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH-2414">HSEARCH-2414</a>.</p><p class="simpara"><span class="strong"><strong>Fix:</strong></span> Upgrade to Elasticsearch 2.4.2.</p></li></ul></div></section><section class="section" id="_acknowledgment"><div class="titlepage"><div><div><h2 class="title">11.9. Acknowledgment</h2></div></div></div><p>More information about Elasticsearch can be found on the <a class="link" href="https://www.elastic.co/products/elasticsearch">Elasticsearch website</a>
and its <a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">reference documentation</a>.</p><p>Hibernate Search uses <a class="link" href="https://github.com/searchbox-io/Jest">Jest</a> to communicate with Elasticsearch.</p></section></section><section class="chapter" id="_further_reading"><div class="titlepage"><div><div><h1 class="title">Chapter 12. Further reading</h1></div></div></div><p>Last but not least, a few pointers to further information. We highly recommend you to get a copy of
<a class="link" href="http://www.manning.com/bernard/">Hibernate Search in Action</a>. This excellent book covers
Hibernate Search in much more depth than this online documentation can and has a great range of
additional examples. If you want to increase your knowledge of Lucene we recommend
<a class="link" href="http://www.manning.com/hatcher3/">Lucene in Action (Second Edition)</a>.</p><p>Because Hibernate Search’s functionality is tightly coupled to Hibernate ORM it is a good idea to understand
Hibernate. Start with the <a class="link" href="http://hibernate.org/orm/documentation/">online documentation</a> or get hold
of a copy of <a class="link" href="http://www.manning.com/bauer3/">Java Persistence with Hibernate, Second Edition</a>.</p><p>If you have any further questions regarding Hibernate Search or want to share some of your use cases
have a look at the <a class="link" href="https://community.jboss.org/en/hibernate/search">Hibernate Search Wiki</a>
and the <a class="link" href="https://forum.hibernate.org/viewforum.php?f=9">Hibernate Search Forum</a>. We are
looking forward hearing from you.</p><p>In case you would like to report a bug use the
<a class="link" href="https://hibernate.atlassian.net/browse/HSEARCH">Hibernate Search JIRA</a> instance. Feedback is
always welcome!</p></section></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><script type="text/javascript">
dataLayer = [{'channel' : 'Hibernate', 'additional_tracking_code' : 'UA-45270411-3'}];
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NJWS5L');</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NJWS5L" height="0" width="0" style="display:none;visibility:hidden"> </iframe></noscript><hr/><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("search"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>