<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 3. Configuration</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate Search, full text search for your entities - Reference Documentation" /><meta name="keywords" content="hibernate, search, hibernate search, full text, lucene, elasticsearch" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" type="text/css" href="css/hibernate.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Hibernate Search"/><link rel="up" href="index.html" title="Hibernate Search"/><link rel="prev" href="ch02.html" title="Chapter 2. Architecture"/><link rel="next" href="ch04.html" title="Chapter 4. Mapping entities to the index structure"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-282CVRCQHZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag(js, new Date());

  gtag(config, G-282CVRCQHZ);
</script>
<!-- /Google Analytics -->
</head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch02.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch04.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 3. Configuration"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration"/>Chapter 3. Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch03.html#search-configuration-event">3.1. Enabling Hibernate Search and automatic indexing</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#_enabling_hibernate_search">3.1.1. Enabling Hibernate Search</a></span></dt><dt><span class="section"><a href="ch03.html#_automatic_indexing">3.1.2. Automatic indexing</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#configuration-indexmanager">3.2. Configuring the IndexManager</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#_directory_based">3.2.1. directory-based</a></span></dt><dt><span class="section"><a href="ch03.html#_near_real_time">3.2.2. near-real-time</a></span></dt><dt><span class="section"><a href="ch03.html#_custom_2">3.2.3. Custom</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#search-configuration-directory">3.3. Directory configuration</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#infinispan-directories">3.3.1. Infinispan Directory configuration</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#configuration-worker">3.4. Worker configuration</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#jms-backend">3.4.1. JMS Master/Slave back end</a></span></dt><dt><span class="section"><a href="ch03.html#jgroups-backend">3.4.2. JGroups Master/Slave back end</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#configuration-reader-strategy">3.5. Reader strategy configuration</a></span></dt><dt><span class="section"><a href="ch03.html#_serialization">3.6. Serialization</a></span></dt><dt><span class="section"><a href="ch03.html#exception-handling">3.7. Exception handling</a></span></dt><dt><span class="section"><a href="ch03.html#_lucene_configuration">3.8. Lucene configuration</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#lucene-indexing-performance">3.8.1. Tuning indexing performance</a></span></dt><dt><span class="section"><a href="ch03.html#search-configuration-directory-lockfactories">3.8.2. LockFactory configuration</a></span></dt><dt><span class="section"><a href="ch03.html#_index_format_compatibility">3.8.3. Index format compatibility</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#_metadata_api">3.9. Metadata API</a></span></dt><dt><span class="section"><a href="ch03.html#search-configuration-deploy-on-wildfly">3.10. Hibernate Search as a WildFly module</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#using-wildfly-provided-hibernatesearch-versions">3.10.1. Use the Hibernate Search version included in WildFly</a></span></dt><dt><span class="section"><a href="ch03.html#_update_and_activate_latest_hibernate_search_version_in_wildfly">3.10.2. Update and activate latest Hibernate Search version in WildFly</a></span></dt><dt><span class="section"><a href="ch03.html#_more_about_modules">3.10.3. More about modules</a></span></dt><dt><span class="section"><a href="ch03.html#_using_infinispan_with_hibernate_search_on_wildfly">3.10.4. Using Infinispan with Hibernate Search on WildFly</a></span></dt></dl></dd></dl></div><div class="section" title="3.1. Enabling Hibernate Search and automatic indexing"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-event"/>3.1. Enabling Hibernate Search and automatic indexing</h2></div></div></div><p>Let’s start with the most basic configuration question - how do I enable Hibernate Search?</p><div class="section" title="3.1.1. Enabling Hibernate Search"><div class="titlepage"><div><div><h3 class="title"><a id="_enabling_hibernate_search"/>3.1.1. Enabling Hibernate Search</h3></div></div></div><p>The good news is that Hibernate Search is enabled out of the box when detected on the classpath by
Hibernate ORM. If, for some reason you need to disable it, set
<code class="literal">hibernate.search.autoregister_listeners</code> to false. Note that there is no performance penalty
when the listeners are enabled but no entities are annotated as indexed.</p></div><div class="section" title="3.1.2. Automatic indexing"><div class="titlepage"><div><div><h3 class="title"><a id="_automatic_indexing"/>3.1.2. Automatic indexing</h3></div></div></div><p>By default, every time an object is inserted, updated or deleted through Hibernate, Hibernate Search
updates the according Lucene index. It is sometimes desirable to disable that features if either
your index is read-only or if index updates are done in a batch way (see <a class="xref" href="ch06.html#search-batchindex" title="6.3. Rebuilding the whole index">Section 6.3, “Rebuilding the whole index”</a>).</p><p>To disable event based indexing, set</p><div class="informalexample"><pre class="screen">hibernate.search.indexing_strategy = manual</pre></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>In most case, the JMS backend provides the best of both world, a lightweight event based system
keeps track of all changes in the system, and the heavyweight indexing process is done by a separate
process or machine.</p></div></div></div><div class="section" title="3.2. Configuring the IndexManager"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-indexmanager"/>3.2. Configuring the IndexManager</h2></div></div></div><p>The role of the index manager component is described in <a class="xref" href="ch02.html" title="Chapter 2. Architecture">Chapter 2, <em>Architecture</em></a>. Hibernate Search
provides two possible implementations for this interface to choose from.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">directory-based</code>: the default implementation which uses the Lucene Directory abstraction to
manage index files.</li><li class="listitem"><code class="literal">near-real-time</code>: avoid flushing writes to disk at each commit. This index manager is also
Directory based, but also makes uses of Lucene’s NRT functionality.</li></ul></div><p>To select an alternative you specify the property:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexmanager = near-real-time</pre></div><div class="section" title="3.2.1. directory-based"><div class="titlepage"><div><div><h3 class="title"><a id="_directory_based"/>3.2.1. directory-based</h3></div></div></div><p>The default IndexManager implementation. This is the one mostly referred to in this documentation.
It is highly configurable and allows you to select different settings for the reader strategy, back
ends and directory providers. Refer to <a class="xref" href="ch03.html#search-configuration-directory" title="3.3. Directory configuration">Section 3.3, “Directory configuration”</a>, <a class="xref" href="ch03.html#configuration-worker" title="3.4. Worker configuration">Section 3.4, “Worker configuration”</a>
and <a class="xref" href="ch03.html#configuration-reader-strategy" title="3.5. Reader strategy configuration">Section 3.5, “Reader strategy configuration”</a> for more details.</p></div><div class="section" title="3.2.2. near-real-time"><div class="titlepage"><div><div><h3 class="title"><a id="_near_real_time"/>3.2.2. near-real-time</h3></div></div></div><p>The NRTIndexManager is an extension of the default IndexManager, leveraging the Lucene NRT (Near
Real Time) features for extreme low latency index writes. As a trade-off it requires a non-clustered
and non-shared index. In other words, it will ignore configuration settings for alternative back
ends other than <code class="literal">lucene</code> and will acquire exclusive write locks on the Directory.</p><p>To achieve this low latency writes, the IndexWriter will not flush every change to disk. Queries
will be allowed to read updated state from the unflushed index writer buffers; the downside of this
strategy is that if the application crashes or the IndexWriter is otherwise killed you’ll have to
rebuild the indexes as some updates might be lost.</p><p>Because of these downsides, and because a master node in cluster can be configured for good
performance as well, the NRT configuration is only recommended for non clustered websites with a
limited amount of data.</p></div><div class="section" title="3.2.3. Custom"><div class="titlepage"><div><div><h3 class="title"><a id="_custom_2"/>3.2.3. Custom</h3></div></div></div><p>It is also possible to configure a custom IndexManager implementation by specifying the fully
qualified class name of your custom implementation. This implementation must have a no-argument
constructor:</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexmanager = my.corp.myapp.CustomIndexManager</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Your custom index manager implementation doesn’t need to use the same components as the default
implementations. For example, you can delegate to a remote indexing service which doesn’t expose a
Directory interface.</p></div></div></div><div class="section" title="3.3. Directory configuration"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-directory"/>3.3. Directory configuration</h2></div></div></div><p>As we have seen in <a class="xref" href="ch03.html#configuration-indexmanager" title="3.2. Configuring the IndexManager">Section 3.2, “Configuring the IndexManager”</a> the default index manager uses Lucene’s notion of
a Directory to store the index files. The Directory implementation can be customized and Lucene
comes bundled with a file system and an in-memory implementation. DirectoryProvider is the Hibernate
Search abstraction around a Lucene Directory and handles the configuration and the initialization of
the underlying Lucene resources. <a class="xref" href="ch03.html#directory-provider-table" title="Table 3.1. List of built-in DirectoryProvider">Table 3.1, “List of built-in DirectoryProvider”</a> shows the list of the directory
providers available in Hibernate Search together with their corresponding options.</p><p>To configure your DirectoryProvider you have to understand that each indexed entity is associated to
a Lucene index (except of the case where multiple entities share the same index -
<a class="xref" href="ch10.html#section-sharing-indexes" title="10.6. Sharing indexes">Section 10.6, “Sharing indexes”</a>). The name of the index is given by the index property of the @Indexed
annotation. If the index property is not specified the fully qualified name of the indexed class
will be used as name (recommended).</p><p>Knowing the index name, you can configure the directory provider and any additional options by using
the prefix <code class="literal">hibernate.search.&lt;indexname&gt;</code>. The name default (<code class="literal">hibernate.search.default</code>) is
reserved and can be used to define properties which apply to all indexes.
<a class="xref" href="ch03.html#example-configuring-directory-providers" title="Example 3.2. Configuring directory providers">Example 3.2, “Configuring directory providers”</a> shows how <code class="literal">hibernate.search.default.directory_provider</code>
is used to set the default directory provider to be the filesystem one. <code class="literal">hibernate.search.default.indexBase</code>
sets then the default base directory for the indexes. As a result the index for the entity Status is
created in <code class="literal">/usr/lucene/indexes/org.hibernate.example.Status</code>.</p><p>The index for the Rule entity, however, is using an in-memory directory, because the default
directory provider for this entity is overridden by the property
<code class="literal">hibernate.search.Rules.directory_provider</code>.</p><p>Finally the Action entity uses a custom directory provider <code class="literal">CustomDirectoryProvider</code> specified via
<code class="literal">hibernate.search.Actions.directory_provider</code>.</p><div class="example"><a id="d0e882"/><p class="title"><strong>Example 3.1. Specifying the index name</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.example;

@Indexed
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }

@Indexed(index="Actions")
public class Action { ... }</code></pre></div></div><br class="example-break"/><div class="example"><a id="example-configuring-directory-providers"/><p class="title"><strong>Example 3.2. Configuring directory providers</strong></p><div class="example-contents"><pre class="screen">hibernate.search.default.directory_provider = filesystem
hibernate.search.default.indexBase = /usr/lucene/indexes
hibernate.search.Rules.directory_provider = ram
hibernate.search.Actions.directory_provider = com.acme.hibernate.CustomDirectoryProvider</pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Using the described configuration scheme you can easily define common rules like the directory
provider and base directory, and override those defaults later on on a per index basis.</p></div><div class="table"><a id="directory-provider-table"/><p class="title"><strong>Table 3.1. List of built-in DirectoryProvider</strong></p><div class="table-contents"><table summary="List of built-in DirectoryProvider" border="1"><colgroup><col width="50*" class="col_1"/><col width="50*" class="col_2"/></colgroup><thead><tr><th align="left" valign="top">Name and description</th><th align="left" valign="top">Properties</th></tr></thead><tbody><tr><td align="left" valign="top"><p>ram: Memory based directory.
</p><p>The directory will be uniquely identified (in the same deployment unit) by the <code class="literal">@Indexed.index</code> element</p></td><td align="left" valign="top"><p>none</p></td></tr><tr><td align="left" valign="top"><p>filesystem: File system based directory.
</p><p>The directory used will be &lt;indexBase&gt;/&lt;indexName&gt;</p></td><td align="left" valign="top"><p><code class="literal">indexBase</code> : base directory
<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
<code class="literal">locking_strategy</code> : optional, see <a class="xref" href="ch03.html#search-configuration-directory-lockfactories" title="3.8.2. LockFactory configuration">Section 3.8.2, “LockFactory configuration”</a>
<code class="literal">filesystem_access_type</code>: allows to determine the exact type of FSDirectory implementation used
by this DirectoryProvider. Allowed values are <code class="literal">auto</code> (the default value, selects NIOFSDirectory on
non Windows systems, SimpleFSDirectory on Windows), <code class="literal">simple</code> (SimpleFSDirectory),
<code class="literal">nio</code> (NIOFSDirectory), <code class="literal">mmap</code> (MMapDirectory). Make sure to refer to Javadocs of these Directory
implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory can bring
substantial performance boosts they also have their issues.</p></td></tr><tr><td align="left" valign="top"><p>filesystem-master: File system based directory.
</p><p>Like <code class="literal">filesystem</code>. It also copies the index to a source directory (aka copy directory) on a regular
basis.
</p><p>The recommended value for the refresh period is (at least) 50% higher that the time to copy the
information (default 3600 seconds - 60 minutes).
</p><p>Note that the copy is based on an incremental copy mechanism reducing the average copy time.
</p><p>DirectoryProvider typically used on the master node in a JMS back end cluster.
</p><p>The <code class="literal">buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most
people reported good results using values between 16 and 64MB.</p></td><td align="left" valign="top"><p><code class="literal">indexBase</code>: base directory
<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
<code class="literal">sourceBase</code>: source (copy) base directory.
<code class="literal">source</code>: source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory name
being <span class="emphasis"><em>&lt;sourceBase&gt;/&lt;source&gt;</em></span>
<code class="literal">refresh</code>: refresh period in seconds (the copy will take place every refresh seconds). If a copy
is still in progress when the following refresh period elapses, the second copy operation will be
skipped.
<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction;
defaults to 16MB.
<code class="literal">locking_strategy</code> : optional, see <a class="xref" href="ch03.html#search-configuration-directory-lockfactories" title="3.8.2. LockFactory configuration">Section 3.8.2, “LockFactory configuration”</a>
<code class="literal">filesystem_access_type</code>: allows to determine the exact type of FSDirectory implementation used by
this DirectoryProvider. Allowed values are <code class="literal">auto</code> (the default value, selects NIOFSDirectory on non
Windows systems, SimpleFSDirectory on Windows), <code class="literal">simple</code> (SimpleFSDirectory),
<code class="literal">nio</code> (NIOFSDirectory), <code class="literal">mmap</code> (MMapDirectory). Make sure to refer to Javadocs of these
Directory implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory
can bring substantial performance boosts they also have their issues.</p></td></tr><tr><td align="left" valign="top"><p>filesystem-slave: File system based directory.
</p><p>Like <code class="literal">filesystem</code>, but retrieves a master version
(source) on a regular basis. To avoid locking and inconsistent search results, 2 local copies are kept.
</p><p>The recommended value for the refresh period is (at least) 50% higher that the time to copy the
information (default 3600 seconds - 60 minutes).
</p><p>Note that the copy is based on an incremental copy mechanism reducing the average copy time.
If a copy is still in progress when refresh period elapses, the second copy operation will be skipped.
</p><p>DirectoryProvider typically used on slave nodes using a JMS back end.
</p><p>The <code class="literal">buffer_size_on_copy</code> optimum depends on your operating system and available RAM; most
people reported good results using values between 16 and 64MB.</p></td><td align="left" valign="top"><p><code class="literal">indexBase</code>: Base directory
<code class="literal">indexName</code>: override @Indexed.index (useful for sharded indexes)
<code class="literal">sourceBase</code>: Source (copy) base directory.
<code class="literal">source</code>: Source directory suffix (default to <code class="literal">@Indexed.index</code>). The actual source directory
name being <span class="emphasis"><em>&lt;sourceBase&gt;/&lt;source&gt;</em></span>
<code class="literal">refresh</code>: refresh period in second (the copy will take place every refresh seconds).
<code class="literal">buffer_size_on_copy</code>: The amount of MegaBytes to move in a single low level copy instruction;
defaults to 16MB.
<code class="literal">locking_strategy</code> : optional, see <a class="xref" href="ch03.html#search-configuration-directory-lockfactories" title="3.8.2. LockFactory configuration">Section 3.8.2, “LockFactory configuration”</a>
<code class="literal">retry_marker_lookup</code> : optional, default to 0. Defines how many times we look for the marker files
in the source directory before failing. Waiting 5 seconds between each try.
<code class="literal">retry_initialize_period</code> : optional, set an integer value in seconds to enable the retry initialize
feature: if the slave can’t find the master index it will try again until it’s found in background,
without preventing the application to start: full-text queries performed before the index is
initialized are not blocked but will return empty results. When not enabling the option or
explicitly setting it to zero it will fail with an exception instead of scheduling a retry timer.
To prevent the application from starting without an invalid index but still control an
initialization timeout, see <code class="literal">retry_marker_lookup</code> instead.
<code class="literal">filesystem_access_type</code>: allows to determine the exact type of FSDirectory implementation
used by this DirectoryProvider. Allowed values are <code class="literal">auto</code> (the default value, selects NIOFSDirectory
on non Windows systems, SimpleFSDirectory on Windows), <code class="literal">simple</code> (SimpleFSDirectory), <code class="literal">nio</code>
(NIOFSDirectory), <code class="literal">mmap</code> (MMapDirectory). Make sure to refer to Javadocs of these Directory
implementations before changing this setting. Even though NIOFSDirectory or MMapDirectory can bring
substantial performance boosts they also have their issues.</p></td></tr><tr><td align="left" valign="top"><p>infinispan: Infinispan based directory.
</p><p>Use it to store the index in a distributed grid, making
index changes visible to all elements of the cluster very quickly. Also see
<a class="xref" href="ch03.html#infinispan-directories" title="3.3.1. Infinispan Directory configuration">Section 3.3.1, “Infinispan Directory configuration”</a> for additional requirements and configuration settings.
Infinispan needs a global configuration and additional dependencies; the
settings defined here apply to each different index.</p></td><td align="left" valign="top"><p><code class="literal">locking_cachename</code>: name of the Infinispan cache to use to store locks. `
<code class="literal">data_cachename</code> : name of the Infinispan cache to use to store the largest data chunks; this area
will contain the largest objects, use replication if you have enough memory or switch to
distribution.
<code class="literal">metadata_cachename</code>: name of the Infinispan cache to use to store the metadata relating to the
index; this data is rather small and read very often, it’s recommended to have this cache setup
using replication.
<code class="literal">chunk_size</code>: large files of the index are split in smaller chunks, you might want to set the
highest value efficiently handled by your network. Networking tuning might be useful.</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>If the built-in directory providers do not fit your needs, you can write your own directory provider
by implementing the org.hibernate.store.DirectoryProvider interface. In this case, pass the fully
qualified class name of your provider into the <code class="literal">directory_provider</code> property. You can pass any
additional properties using the prefix <code class="literal">hibernate.search.&lt;indexname&gt;</code>.</p></div><div class="section" title="3.3.1. Infinispan Directory configuration"><div class="titlepage"><div><div><h3 class="title"><a id="infinispan-directories"/>3.3.1. Infinispan Directory configuration</h3></div></div></div><p>Infinispan is a distributed, scalable, cloud friendly data grid platform, which
Hibernate Search can use to store the Lucene index. Your application can benefits in this case
from Infinispan’s distribution capabilities making index updates available on all nodes with short
latency.</p><p>This section describes how to configure Hibernate Search to use an Infinispan Lucene Directory.</p><p>When using an Infinispan Directory the index is stored in memory and shared across multiple nodes.
It is considered a single directory distributed across all participating nodes: if a node updates
the index, all other nodes are updated as well. Updates on one node can be immediately searched
for in the whole cluster.</p><p>The default configuration replicates all data which defines the index across all nodes, thus
consuming a significant amount of memory but providing the best query performance.
For large indexes it’s suggested to enable data distribution, so that each piece of information is
replicated to a subset of all cluster members. The distribution option will reduce the amount of memory
required for each node but is less efficient as it will cause high network usage among the nodes.</p><p>It is also possible to offload part or most information to a <code class="literal">CacheStore</code>, such as plain filesystem,
Amazon S3, Cassandra, MongoDB or standard relational databases. You can configure it to have a
<code class="literal">CacheStore</code> on each node or have a single centralized one shared by each node.</p><p>A popular choice is to use a replicated index aiming to keep the whole index in memory, combined with
a <code class="literal">CacheStore</code> as safety valve in case the index gets larger than expected.</p><p>See the <a class="link" href="http://infinispan.org/documentation/">Infinispan documentation</a> for all Infinispan
configuration options.</p><div class="section" title="3.3.1.1. Requirements"><div class="titlepage"><div><div><h4 class="title"><a id="_requirements"/>3.3.1.1. Requirements</h4></div></div></div><p>To use the Infinispan directory via Maven, add the following dependencies:</p><div class="example"><a id="d0e1160"/><p class="title"><strong>Example 3.3. Maven dependencies for Hibernate Search using Infinispan</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
   &lt;artifactId&gt;hibernate-search-orm&lt;/artifactId&gt;
   &lt;version&gt;5.5.8.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.infinispan&lt;/groupId&gt;
   &lt;artifactId&gt;infinispan-directory-provider&lt;/artifactId&gt;
   &lt;version&gt;8.1.0.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div></div><br class="example-break"/><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>This dependency changed in Hibernate Search version 5.2.</p><p>Previously the DirectoryProvider was provided by the Hibernate Search project and had Maven coordinates
'org.hibernate:hibernate-search-infinispan', but the Infinispan team is now maintaining this extension point
so since this version please use the Maven definition as in the previous example.</p><p>The version printed above was the latest compatible at the time of publishing this Hibernate Search version:
it’s possible that more recently improved versions of Infinispan have been published which
are compatible with this same Hibernate Search version.</p></div></div><div class="section" title="3.3.1.2. Architecture"><div class="titlepage"><div><div><h4 class="title"><a id="_architecture"/>3.3.1.2. Architecture</h4></div></div></div><p>Even when using an Infinispan directory it’s still recommended to use the JMS Master/Slave or
JGroups backend, because in Infinispan all nodes will share the same index and it is likely that
<code class="literal">IndexWriter</code> instances being active on different nodes will try to acquire the lock on the same
index. So instead of sending updates directly to the index, send it to a JMS queue or JGroups
channel and have a single node apply all changes on behalf of all other nodes.</p><p>Configuring a non-default backend is not a requirement but a performance optimization as locks are
enabled to have a single node writing.</p><p>To configure a JMS slave only the backend must be replaced, the directory provider must be set to
<code class="literal">infinispan</code>; set the same directory provider on the master, they will connect without the need to
setup the copy job across nodes. Using the JGroups backend is very similar - just combine the
backend configuration with the <code class="literal">infinispan</code> directory provider.</p></div><div class="section" title="3.3.1.3. Infinispan Configuration"><div class="titlepage"><div><div><h4 class="title"><a id="_infinispan_configuration"/>3.3.1.3. Infinispan Configuration</h4></div></div></div><p>The most simple configuration only requires to enable the backend:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].directory_provider = infinispan</pre></div><p>That’s all what is needed to get a cluster-replicated index, but the default configuration does not
enable any form of permanent persistence for the index; to enable such a feature an Infinispan
configuration file should be provided.</p><p>To use Infinispan, Hibernate Search requires a CacheManager; it can lookup and reuse an existing
CacheManager, via JNDI, or start and manage a new one. In the latter case Hibernate Search will
start and stop it ( closing occurs when the Hibernate SessionFactory is closed).</p><p>To use and existing CacheManager via JNDI (optional parameter):</p><div class="informalexample"><pre class="screen">hibernate.search.infinispan.cachemanager_jndiname = [jndiname]</pre></div><p>To start a new CacheManager from a configuration file (optional parameter):</p><div class="informalexample"><pre class="screen">hibernate.search.infinispan.configuration_resourcename = [infinispan configuration filename]</pre></div><p>If both parameters are defined, JNDI will have priority. If none of these is defined, Hibernate
Search will use the default Infinispan configuration included in <code class="literal">infinispan-directory-provider.jar</code>.
This configuration should work fine in most cases but does not store the index in a persistent cache
store.</p><p>As mentioned in <a class="xref" href="ch03.html#directory-provider-table" title="Table 3.1. List of built-in DirectoryProvider">Table 3.1, “List of built-in DirectoryProvider”</a>, each index makes use of three caches, so three
different caches should be configured as shown in the <code class="literal">default-hibernatesearch-infinispan.xml</code>
provided in the <code class="literal">infinispan-directory-provider.jar</code>. Several indexes can share the same caches.</p><p>Infinispan relies on JGroups for its networking functionality, so unless you are using Infinispan on
a single node, an Infinispan configuration file will refer to a JGroups configuration file. This
coupling is not always practical and we provide a property to override the used JGroups
configuration file:</p><div class="informalexample"><pre class="screen">hibernate.search.infinispan.configuration.transport_override_resourcename = jgroups-ec2.xml</pre></div><p>This allows to just switch the JGroups configuration while keeping the rest of the Infinispan
configuration.</p><p>The file <code class="literal">jgroups-ec2.xml</code> used in the example above is one of the several JGroups configurations
included in Infinispan. It is a good starting point to run on Amazon EC2 networks. For more details
and examples see <a class="link" href="http://infinispan.org/docs/8.0.x/user_guide/user_guide.html#_use_one_of_the_pre_configured_jgroups_files">usage of pre-configured JGroups stacks</a>
in the Infinispan configuration guide.</p></div></div></div><div class="section" title="3.4. Worker configuration"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-worker"/>3.4. Worker configuration</h2></div></div></div><p>It is possible to refine how Hibernate Search interacts with Lucene through the worker
configuration. There exist several architectural components and possible extension points. Let’s
have a closer look.</p><p>First there is a Worker. An implementation of the Worker interface is responsible for receiving all
entity changes, queuing them by context and applying them once a context ends. The most intuitive
context, especially in connection with ORM, is the transaction. For this reason Hibernate Search
will per default use the TransactionalWorker to scope all changes per transaction. One can, however,
imagine a scenario where the context depends for example on the number of entity changes or some
other application (lifecycle) events. For this reason the Worker implementation is configurable as
shown in <a class="xref" href="ch03.html#table-worker-configuration" title="Table 3.2. Scope configuration">Table 3.2, “Scope configuration”</a>.</p><div class="table"><a id="table-worker-configuration"/><p class="title"><strong>Table 3.2. Scope configuration</strong></p><div class="table-contents"><table summary="Scope configuration" border="1"><colgroup><col width="50*" class="col_1"/><col width="50*" class="col_2"/></colgroup><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>Property</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.worker.scope</p></td><td align="left" valign="top"><p>The fully qualified class name of the
            Worker implementation to use. If this
            property is not set, empty or <code class="literal">transaction</code> the
            default TransactionalWorker is
            used.</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.default.worker.*</p></td><td align="left" valign="top"><p>All configuration properties prefixed with
            <code class="literal">hibernate.search.default.worker</code> are passed to the
            Worker during initialization. This allows adding custom, worker
            specific parameters.</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.worker.enlist_in_transaction</p></td><td align="left" valign="top"><p>Defaults to <code class="literal">false</code>. Set it to <code class="literal">true</code>
            to have all indexing work sent to the queue within the same transaction
            as the Hibernate ORM Session. This options should only be enabled when all
            backends use JMS and the queues are configured to be transactional, XA enabled.</p></td></tr></tbody></table></div></div><br class="table-break"/><p>Once a context ends it is time to prepare and apply the index changes. This can be done
synchronously or asynchronously from within a new thread. Synchronous updates have the advantage
that the index is at all times in sync with the databases. Asynchronous updates, on the other hand,
can help to minimize the user response time. The drawback is potential discrepancies between
database and index states. Lets look at the configuration options shown in
<a class="xref" href="ch03.html#table-work-execution-configuration" title="Table 3.3. Execution configuration">Table 3.3, “Execution configuration”</a>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The following options can be different on each index; in fact they need the indexName prefix or use
<code class="literal">default</code> to set the default value for all indexes.</p></div><div class="table"><a id="table-work-execution-configuration"/><p class="title"><strong>Table 3.3. Execution configuration</strong></p><div class="table-contents"><table summary="Execution configuration" border="1"><colgroup><col width="50*" class="col_1"/><col width="50*" class="col_2"/></colgroup><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>Property</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.worker.execution</p></td><td align="left" valign="top"><p><code class="literal">sync</code>: synchronous execution (default)
</p><p><code class="literal">async</code>: asynchronous execution</p></td></tr></tbody></table></div></div><br class="table-break"/><p>So far all work is done within the same Virtual Machine (VM), no matter which execution mode. The
total amount of work has not changed for the single VM. Luckily there is a better approach, namely
delegation. It is possible to send the indexing work to a different server by configuring
hibernate.search.default.worker.backend - see <a class="xref" href="ch03.html#table-backend-configuration" title="Table 3.4. Backend configuration">Table 3.4, “Backend configuration”</a>. Again this option can be
configured differently for each index.</p><div class="table"><a id="table-backend-configuration"/><p class="title"><strong>Table 3.4. Backend configuration</strong></p><div class="table-contents"><table summary="Backend configuration" border="1"><colgroup><col width="50*" class="col_1"/><col width="50*" class="col_2"/></colgroup><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>Property</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.worker.backend</p></td><td align="left" valign="top"><p><code class="literal">lucene</code>: The default backend which runs index updates in the same VM. Also used when the property is undefined or empty.
</p><p><code class="literal">jms</code>: JMS backend. Index updates are send to a JMS queue to be processed by an indexing master. See <a class="xref" href="ch03.html#table-jms-backend-configuration" title="Table 3.5. JMS backend configuration">Table 3.5, “JMS backend configuration”</a> for additional configuration options and <a class="xref" href="ch03.html#jms-backend" title="3.4.1. JMS Master/Slave back end">Section 3.4.1, “JMS Master/Slave back end”</a> for a more detailed description of this setup.
</p><p><code class="literal">jgroupsMaster</code>, <code class="literal">jgroupsSlave</code> or <code class="literal">jgroups</code>: Backend using <a class="link" href="http://www.jgroups.org/">JGroups</a> as communication layer. See <a class="xref" href="ch03.html#jgroups-backend" title="3.4.2. JGroups Master/Slave back end">Section 3.4.2, “JGroups Master/Slave back end”</a> for a more detailed description of this setup.
</p><p><code class="literal">blackhole</code>: Mainly a test/developer setting which ignores all indexing work
</p><p>You can also specify the fully qualified name of a class implementing BackendQueueProcessor. This way you can implement your own communication layer. The implementation is responsible for returning a Runnable instance which on execution will process the index work.</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="table-jms-backend-configuration"/><p class="title"><strong>Table 3.5. JMS backend configuration</strong></p><div class="table-contents"><table summary="JMS backend configuration" border="1"><colgroup><col width="50*" class="col_1"/><col width="50*" class="col_2"/></colgroup><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>Property</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.worker.jndi.*</p></td><td align="left" valign="top"><p>Defines the JNDI properties to initiate the InitialContext
            (if needed). JNDI is only used by the JMS back end.</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.worker.jms.connection_factory</p></td><td align="left" valign="top"><p>Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS connection factory from
            (<code class="literal">/ConnectionFactory</code> by default in JBoss
            AS)</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.worker.jms.queue</p></td><td align="left" valign="top"><p>Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS queue from. The queue will be used to post work
            messages.</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.worker.jms.login</p></td><td align="left" valign="top"><p>Optional for the JMS slaves. Use it when your queue
            requires login credentials to define your login.</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.worker.jms.login</p></td><td align="left" valign="top"><p>Optional for the JMS slaves. Use it when your queue
            requires login credentials to define your password.</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>As you probably noticed, some of the shown properties are correlated which means that not all
combinations of property values make sense. In fact you can end up with a non-functional
configuration. This is especially true for the case that you provide your own implementations of
some of the shown interfaces. Make sure to study the existing code before you write your own Worker
or BackendQueueProcessor implementation.</p></div><div class="section" title="3.4.1. JMS Master/Slave back end"><div class="titlepage"><div><div><h3 class="title"><a id="jms-backend"/>3.4.1. JMS Master/Slave back end</h3></div></div></div><p>This section describes in greater detail how to configure the Master/Slave Hibernate Search
architecture.</p><p>JMS back end configuration.</p><div class="section" title="3.4.1.1. Slave nodes"><div class="titlepage"><div><div><h4 class="title"><a id="_slave_nodes"/>3.4.1.1. Slave nodes</h4></div></div></div><p>Every index update operation is sent to a JMS queue. Index querying operations are executed on a
local index copy.</p><div class="example"><a id="d0e1466"/><p class="title"><strong>Example 3.4. JMS Slave configuration</strong></p><div class="example-contents"><pre class="screen">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-slave

## Backend configuration
hibernate.search.default.worker.backend = jms
hibernate.search.default.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.default.worker.jms.queue = queue/hibernatesearch
#optionally authentication credentials:
hibernate.search.default.worker.jms.login = myname
hibernate.search.default.worker.jms.password = wonttellyou
#optional jndi configuration (check your JMS provider for more information)

## Enqueue indexing tasks within an XA transaction with the database (optional)
hibernate.search.worker.enlist_in_transaction = true</pre></div></div><br class="example-break"/><p>The <code class="literal">enlist_in_transaction</code> option can be enabled if you need strict guarantees of
indexing work to be stored in the queue within the same transaction of the database
changes, however this will require both the RDBMs datasource and the JMS queue to be XA enabled.</p><p>Make sure to use a XA JMS queue
and that your database supports XA as we are talking about coordinated transactional systems.</p><p>The default for <code class="literal">enlist_in_transaction</code> is <code class="literal">false</code> as often it is desirable to not have
the database transaction fail in case there are issues with indexing.</p><p>It is possible to apply compensating operations to the index by implementing a custom
<code class="literal">ErrorHandler</code> (see <a class="xref" href="ch03.html#exception-handling" title="3.7. Exception handling">Section 3.7, “Exception handling”</a>), or simply re-synchronize the whole index
state by starting the MassIndexer (see <a class="xref" href="ch06.html#search-batchindex-massindexer" title="6.3.2. Using a MassIndexer">Section 6.3.2, “Using a MassIndexer”</a>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>A file system local copy is recommended for faster search results.</p></div></div><div class="section" title="3.4.1.2. Master node"><div class="titlepage"><div><div><h4 class="title"><a id="_master_node"/>3.4.1.2. Master node</h4></div></div></div><p>Every index update operation is taken from a JMS queue and executed. The master index is copied on a
regular basis.</p><div class="example"><a id="d0e1503"/><p class="title"><strong>Example 3.5. JMS Master configuration</strong></p><div class="example-contents"><pre class="screen">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-master

## Backend configuration
#Backend is the default lucene one</pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>It is recommended that the refresh period be higher than the expected copy time; if a copy operation
is still being performed when the next refresh triggers, the second refresh is skipped: it’s safe to
set this value low even when the copy time is not known.</p></div><p>In addition to the Hibernate Search framework configuration, a Message Driven Bean has to be written
and set up to process the index works queue through JMS.</p><div class="example"><a id="d0e1513"/><p class="title"><strong>Example 3.6. Message Driven Bean processing the indexing queue</strong></p><div class="example-contents"><pre><code class="language-java">@MessageDriven(activationConfig = {
      @ActivationConfigProperty(propertyName="destinationType",
                                propertyValue="javax.jms.Queue"),
      @ActivationConfigProperty(propertyName="destination",
                                propertyValue="queue/hibernatesearch")
   } )
public class MDBSearchController extends AbstractJMSHibernateSearchController
                                 implements MessageListener {

    @PersistenceContext EntityManager em;

    @Override
    protected SearchIntegrator getSearchIntegrator() {
        FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(em);
        return fullTextEntityManager.getSearchFactory().unwrap(SearchIntegrator.class);
    }
}</code></pre></div></div><br class="example-break"/><p>This example inherits from the abstract JMS controller class available in the Hibernate Search
source code and implements a JavaEE MDB. This implementation is given as an example and can be
adjusted to make use of non Java EE Message Driven Beans.
Essentially what you need to do is to connect the specific JMS Queue with the <code class="literal">SearchFactory</code>
instance of the EntityManager.
As an advanced alternative, you can implement your own logic by not extending <code class="literal">AbstractJMSHibernateSearchController</code>
but rather to use it as an implementation example.</p></div></div><div class="section" title="3.4.2. JGroups Master/Slave back end"><div class="titlepage"><div><div><h3 class="title"><a id="jgroups-backend"/>3.4.2. JGroups Master/Slave back end</h3></div></div></div><p>This section describes how to configure the JGroups Master/Slave back end. The master and slave
roles are similar to what is illustrated in <a class="xref" href="ch03.html#jms-backend" title="3.4.1. JMS Master/Slave back end">Section 3.4.1, “JMS Master/Slave back end”</a>, only a different backend
(hibernate.search.default.worker.backend) needs to be set.</p><p>A specific backend can be configured to act either as a slave using <code class="literal">jgroupsSlave</code>, as a master
using <code class="literal">jgroupsMaster</code>, or can automatically switch between the roles as needed by using <code class="literal">jgroups</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Either you specify a single <code class="literal">jgroupsMaster</code> and a set of <code class="literal">jgroupsSlave</code> instances, or you specify
all instances as <code class="literal">jgroups</code>. Never mix the two approaches!</p></div><p>All backends configured to use JGroups share the same channel. The JGroups JChannel is the main
communication link across all nodes participating in the same cluster group; since it is convenient
to have just one channel shared across all backends, the Channel configuration properties are not
defined on a per-worker section but are defined globally. See <a class="xref" href="ch03.html#jgroups-channel-configuration" title="3.4.2.4. JGroups channel configuration">Section 3.4.2.4, “JGroups channel configuration”</a>.</p><p>Table <a class="xref" href="ch03.html#table-jgroups-backend-configuration" title="Table 3.6. JGroups backend configuration properties">Table 3.6, “JGroups backend configuration properties”</a> contains all configuration options which can be set
independently on each index backend. These apply to all three variants of the backend:
<code class="literal">jgroupsSlave</code>, <code class="literal">jgroupsMaster</code>, <code class="literal">jgroups</code>. It is very unlikely that you need to change any of these
from their defaults.</p><div class="table"><a id="table-jgroups-backend-configuration"/><p class="title"><strong>Table 3.6. JGroups backend configuration properties</strong></p><div class="table-contents"><table summary="JGroups backend configuration properties" border="1"><colgroup><col width="50*" class="col_1"/><col width="50*" class="col_2"/></colgroup><tbody><tr><td align="left" valign="top"><p><span class="strong"><strong>Property</strong></span></p></td><td align="left" valign="top"><p><span class="strong"><strong>Description</strong></span></p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.jgroups.block_waiting_ack</p></td><td align="left" valign="top"><p>Set to either <code class="literal">true</code> or
              <code class="literal">false</code>. False is more efficient but will not
              wait for the operation to be delivered to the peers. Defaults to
              <code class="literal">true</code> when the backend is synchronous, to
              <code class="literal">false</code> when the backend is
              <code class="literal">async</code>.</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.jgroups.messages_timeout</p></td><td align="left" valign="top"><p>The timeout of waiting for a single command to be
              acknowledged and executed when
              <code class="literal">block_waiting_ack</code> is <code class="literal">true</code>,
              or just acknowledged otherwise. Value in milliseconds, defaults
              to <code class="literal">20000</code>.</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.&lt;indexName&gt;.jgroups.delegate_backend</p></td><td align="left" valign="top"><p>The master node receiving indexing operations forwards
              them to a standard backend to be performed. Defaults to
              <code class="literal">lucene</code>. See also <a class="xref" href="ch03.html#table-backend-configuration" title="Table 3.4. Backend configuration">Table 3.4, “Backend configuration”</a> for other options, but
              probably the only useful option is <code class="literal">blackhole</code>,
              or a custom implementation, to help isolating network latency
              problems.</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="section" title="3.4.2.1. Slave nodes"><div class="titlepage"><div><div><h4 class="title"><a id="_slave_nodes_2"/>3.4.2.1. Slave nodes</h4></div></div></div><p>Every index update operation is sent through a JGroups channel to the master node. Index querying
operations are executed on a local index copy. Enabling the JGroups worker only makes sure the index
operations are sent to the master, you still have to synchronize configuring an appropriate
directory (See <code class="literal">filesystem-master</code>, <code class="literal">filesystem-slave</code> or <code class="literal">infinispan</code> options in <a class="xref" href="ch03.html#search-configuration-directory" title="3.3. Directory configuration">Section 3.3, “Directory configuration”</a>).</p><div class="example"><a id="d0e1658"/><p class="title"><strong>Example 3.7. JGroups Slave configuration</strong></p><div class="example-contents"><pre class="screen">### slave configuration
hibernate.search.default.worker.backend = jgroupsSlave</pre></div></div><br class="example-break"/></div><div class="section" title="3.4.2.2. Master node"><div class="titlepage"><div><div><h4 class="title"><a id="_master_node_2"/>3.4.2.2. Master node</h4></div></div></div><p>Every index update operation is taken from a JGroups channel and executed. The master index is
copied on a regular basis.</p><div class="example"><a id="d0e1668"/><p class="title"><strong>Example 3.8. JGroups Master configuration</strong></p><div class="example-contents"><pre class="screen">### master configuration
hibernate.search.default.worker.backend = jgroupsMaster</pre></div></div><br class="example-break"/></div><div class="section" title="3.4.2.3. Automatic master election"><div class="titlepage"><div><div><h4 class="title"><a id="_automatic_master_election"/>3.4.2.3. Automatic master election</h4></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>This feature is considered experimental. In particular during a re-election process there is a small
window of time in which indexing requests could be lost.</p></div><p>In this mode the different nodes will autonomously elect a master node. When a master fails, a new
node is elected automatically.</p><p>When setting this backend it is expected that all Hibernate Search instances in the same cluster use
the same backend for each specific index: this configuration is an alternative to the static
<code class="literal">jgroupsMaster</code> and <code class="literal">jgroupsSlave</code> approach so make sure to not mix them.</p><p>To synchronize the indexes in this configuration avoid <code class="literal">filesystem-master</code> and <code class="literal">filesystem-slave</code>
directory providers as their behaviour can not be switched dynamically; use the Infinispan
<code class="literal">Directory</code> instead, which has no need for different configurations on each instance and allows
dynamic switching of writers; see also <a class="xref" href="ch03.html#infinispan-directories" title="3.3.1. Infinispan Directory configuration">Section 3.3.1, “Infinispan Directory configuration”</a>.</p><div class="example"><a id="d0e1702"/><p class="title"><strong>Example 3.9. JGroups configuration for automatic master configuration</strong></p><div class="example-contents"><pre class="screen">### automatic configuration
hibernate.search.default.worker.backend = jgroups</pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Should you use <code class="literal">jgroups</code> or the couple <code class="literal">jgroupsMaster</code>, <code class="literal">jgroupsSlave</code>?</p><p>The dynamic <code class="literal">jgroups</code> backend is better suited for environments in which your master is more likely
to need to failover to a different machine, as in clouds. The static configuration has the benefit
of keeping the master at a well known location: your architecture might take advantage of it by
sending most write requests to the known master. Also optimisation and MassIndexer operations need
to be triggered on the master node.</p></div></div><div class="section" title="3.4.2.4. JGroups channel configuration"><div class="titlepage"><div><div><h4 class="title"><a id="jgroups-channel-configuration"/>3.4.2.4. JGroups channel configuration</h4></div></div></div><p>Configuring the JGroups channel essentially entails specifying the transport in terms of a network
protocol stack. To configure the JGroups transport, point the configuration property
hibernate.search.services.jgroups.configurationFile to a JGroups configuration file; this can be
either a file path or a Java resource name.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>If no property is explicitly specified it is assumed that the JGroups default configuration file
<code class="literal">flush-udp.xml</code> is used. This example configuration is known to work in most scenarios, with the
notable exception of Amazon AWS; refer to the
<a class="link" href="http://www.jgroups.org/manual-3.x/html/">JGroups manual</a> for more examples and protocol
configuration details.</p></div><p>The default cluster name is <code class="literal">Hibernate Search Cluster</code> which can be configured as seen in <a class="xref" href="ch03.html#example-jgroups-cluster-name" title="Example 3.10. JGroups cluster name configuration">Example 3.10, “JGroups cluster name configuration”</a>.</p><div class="example"><a id="example-jgroups-cluster-name"/><p class="title"><strong>Example 3.10. JGroups cluster name configuration</strong></p><div class="example-contents"><pre class="screen">hibernate.search.services.jgroups.clusterName = My-Custom-Cluster-Id</pre></div></div><br class="example-break"/><p>The cluster name is what identifies a group: by changing the name you can run different clusters in
the same network in isolation.</p><div class="section" title="3.4.2.4.1. JGroups channel instance injection"><div class="titlepage"><div><div><h5 class="title"><a id="_jgroups_channel_instance_injection"/>3.4.2.4.1. JGroups channel instance injection</h5></div></div></div><p>For programmatic configurations, one additional option is available to configure the JGroups
channel: to pass an existing channel instance to Hibernate Search directly using the property
<code class="literal">hibernate.search.services.jgroups.providedChannel</code>, as shown in the following example.</p><div class="informalexample"><pre><code class="language-java">import org.hibernate.search.backend.impl.jgroups.JGroupsChannelProvider;

org.jgroups.JChannel channel = ...
Map&lt;String,String&gt; properties = new HashMap&lt;String,String)(1);
properties.put( JGroupsChannelProvider.CHANNEL_INJECT, channel );
EntityManagerFactory emf = Persistence.createEntityManagerFactory( "userPU", properties );</code></pre></div></div></div></div></div><div class="section" title="3.5. Reader strategy configuration"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-reader-strategy"/>3.5. Reader strategy configuration</h2></div></div></div><p>The different reader strategies are described in <a class="xref" href="ch02.html#search-architecture-readerstrategy" title="2.3. Reader strategy">Section 2.3, “Reader strategy”</a>. Out of the
box strategies are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">shared</code>: share index readers across several queries. This strategy is the most efficient.</li><li class="listitem"><code class="literal">not-shared</code>: create an index reader for each individual query</li></ul></div><p>The default reader strategy is <code class="literal">shared</code>. This can be adjusted:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].reader.strategy = not-shared</pre></div><p>Adding this property switches to the <code class="literal">not-shared</code> strategy.</p><p>Or if you have a custom reader strategy:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].reader.strategy = my.corp.myapp.CustomReaderProvider</pre></div><p>where my.corp.myapp.CustomReaderProvider is the custom strategy implementation.</p></div><div class="section" title="3.6. Serialization"><div class="titlepage"><div><div><h2 class="title"><a id="_serialization"/>3.6. Serialization</h2></div></div></div><p>When using clustering features, Hibernate Search needs to find an implementation of the
<code class="literal">SerializationProvider</code> service on the classpath.</p><p>An implementation of the service based on <a class="link" href="https://avro.apache.org">Apache Avro</a> can be found
using the following GAV coordinates:</p><p><code class="literal">org.hibernate:hibernate-search-serialization-avro:5.5.8.Final</code></p><p>You can add the coordinates to your pom file or download all the required dependecies and add them
to your classpath. Hibernate Search will find the service implementation without any additional
configuration.</p><p>Alternatively, you can create a custom service implementation:</p><div class="example"><a id="example-serialization-provider"/><p class="title"><strong>Example 3.11. Serialization strategy definition</strong></p><div class="example-contents"><pre><code class="language-java">package example.provider.serializer

import org.hibernate.search.indexes.serialization.spi.Deserializer;
import org.hibernate.search.indexes.serialization.spi.SerializationProvider;
import org.hibernate.search.indexes.serialization.spi.Serializer;

public class ExampleOfSerializationProvider implements SerializationProvider {

   @Override
    public Serializer getSerializer() {
        Serializer serializer = ...
        return serializer;
    }

    @Override
    public Deserializer getDeserializer() {
        Deserializer deserializer = ...
        return deserializer;
    }
}</code></pre></div></div><br class="example-break"/><p>Hibernate Search uses the Java ServiceLoader mechanism to transparently discover services.
In this case you will add the following file in your classpath:</p><div class="example"><a id="d0e1828"/><p class="title"><strong>Example 3.12. Service file for the SerializationProvider service</strong></p><div class="example-contents"><pre class="screen">/META-INF/services/org.hibernate.search.indexes.serialization.spi.SerializationProvider</pre></div></div><br class="example-break"/><div class="example"><a id="d0e1833"/><p class="title"><strong>Example 3.13. Content of /META-INF/services/org.hibernate.search.indexes.serialization.spi.SerializationProvider</strong></p><div class="example-contents"><pre class="screen">example.provider.serializer.ExampleOfSerializationProvider</pre></div></div><br class="example-break"/><p>You will find more details about services in the section <a class="xref" href="ch10.html#section-services" title="10.7. Using external services">Section 10.7, “Using external services”</a>.</p></div><div class="section" title="3.7. Exception handling"><div class="titlepage"><div><div><h2 class="title"><a id="exception-handling"/>3.7. Exception handling</h2></div></div></div><p>Hibernate Search allows you to configure how exceptions are handled during the indexing process. If
no configuration is provided then exceptions are logged to the log output by default. It is possible
to explicitly declare the exception logging mechanism as seen below:</p><div class="informalexample"><pre class="screen">hibernate.search.error_handler = log</pre></div><p>The default exception handling occurs for both synchronous and asynchronous indexing. Hibernate
Search provides an easy mechanism to override the default error handling implementation.</p><p>In order to provide your own implementation you must implement the ErrorHandler interface, which
provides the handle(ErrorContext context) method. ErrorContext provides a reference to the primary
LuceneWork instance, the underlying exception and any subsequent LuceneWork instances that could not
be processed due to the primary exception.</p><div class="informalexample"><pre><code class="language-java">public interface ErrorContext {
   List&lt;LuceneWork&gt; getFailingOperations();
   LuceneWork getOperationAtFault();
   Throwable getThrowable();
   boolean hasErrors();
}</code></pre></div><p>To register this error handler with Hibernate Search you must declare the fully qualified classname
of your ErrorHandler implementation in the configuration properties:</p><div class="informalexample"><pre class="screen">hibernate.search.error_handler = CustomerErrorHandler</pre></div><p>Alternatively, an ErrorHandler instance may be passed via the configuration value map used when bootstrapping Hibernate Search programmatically.</p></div><div class="section" title="3.8. Lucene configuration"><div class="titlepage"><div><div><h2 class="title"><a id="_lucene_configuration"/>3.8. Lucene configuration</h2></div></div></div><p>Even though Hibernate Search will try to shield you as much as possible from Lucene specifics, there
are several Lucene specifics which can be directly configured, either for performance reasons or for
satisfying a specific use case. The following sections discuss these configuration options.</p><div class="section" title="3.8.1. Tuning indexing performance"><div class="titlepage"><div><div><h3 class="title"><a id="lucene-indexing-performance"/>3.8.1. Tuning indexing performance</h3></div></div></div><p>Hibernate Search allows you to tune the Lucene indexing performance by specifying a set of
parameters which are passed through to underlying Lucene <code class="literal">IndexWriter</code> such as <code class="literal">mergeFactor</code>,
<code class="literal">maxMergeDocs</code> and <code class="literal">maxBufferedDocs</code>. You can specify these parameters either as default values
applying for all indexes, on a per index basis, or even per shard.</p><p>There are several low level <code class="literal">IndexWriter</code> settings which can be tuned for different use cases.
These parameters are grouped by the <code class="literal">indexwriter</code> keyword:</p><div class="informalexample"><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].indexwriter.&lt;parameter_name&gt;</pre></div><p>If no value is set for an <code class="literal">indexwriter</code> value in a specific shard configuration, Hibernate Search
will look at the index section, then at the default section.</p><div class="example"><a id="example-performance-option-configuration"/><p class="title"><strong>Example 3.14. Example performance option configuration</strong></p><div class="example-contents"><pre class="screen">hibernate.search.Animals.2.indexwriter.max_merge_docs = 10
hibernate.search.Animals.2.indexwriter.merge_factor = 20
hibernate.search.Animals.2.indexwriter.max_buffered_docs = default
hibernate.search.default.indexwriter.max_merge_docs = 100
hibernate.search.default.indexwriter.ram_buffer_size = 64</pre></div></div><br class="example-break"/><p>The configuration in <a class="xref" href="ch03.html#example-performance-option-configuration" title="Example 3.14. Example performance option configuration">Example 3.14, “Example performance option configuration”</a> will result in these settings
applied on the second shard of the Animal index:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">max_merge_docs</code> = 10</li><li class="listitem"><code class="literal">merge_factor</code> = 20</li><li class="listitem"><code class="literal">ram_buffer_size</code> = 64MB</li><li class="listitem"><code class="literal">max_buffered_docs</code> = Lucene default</li></ul></div><p>All other values will use the defaults defined in Lucene.</p><p>The default for all values is to leave them at Lucene’s own default. The values listed in
<a class="xref" href="ch03.html#table-performance-parameters" title="Table 3.7. List of indexing performance and behavior properties">Table 3.7, “List of indexing performance and behavior properties”</a> depend for this reason on the version of Lucene you are using.
The values shown are relative to version <code class="literal">2.4</code>. For more information about Lucene indexing performance,
please refer to the Lucene documentation.</p><div class="table"><a id="table-performance-parameters"/><p class="title"><strong>Table 3.7. List of indexing performance and behavior properties</strong></p><div class="table-contents"><table summary="List of indexing performance and behavior properties" border="1"><colgroup><col width="40*" class="col_1"/><col width="40*" class="col_2"/><col width="20*" class="col_3"/></colgroup><thead><tr><th align="left" valign="top">Property</th><th align="left" valign="top">Description</th><th align="left" valign="top">Default Value</th></tr></thead><tbody><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</p></td><td align="left" valign="top"><p>Set to <code class="literal">true</code> when no other process will need to write to the same index. This will enable
Hibernate Search to work in exclusive mode on the index and improve performance when writing changes
to the index.</p></td><td align="left" valign="top"><p><code class="literal">true</code> (improved performance, releases locks only at shutdown)</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].max_queue_length</p></td><td align="left" valign="top"><p>Each index has a separate "pipeline" which contains the updates to be applied to the index.
When this queue is full adding more operations to the queue becomes a blocking operation. Configuring
this setting doesn’t make much sense unless the <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.</p></td><td align="left" valign="top"><p><code class="literal">1000</code></p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].index_flush_interval</p></td><td align="left" valign="top"><p>The interval in milliseconds between flushes
of write operations to the index storage. Ignored unless <code class="literal">worker.execution</code> is configured as <code class="literal">async</code>.</p></td><td align="left" valign="top"><p><code class="literal">1000</code></p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_delete_terms</p></td><td align="left" valign="top"><p>Determines the minimal number of delete terms required before the buffered in-memory delete terms
are applied and flushed. If there are documents buffered in memory at the time, they are merged and
a new segment is created.</p></td><td align="left" valign="top"><p>Disabled (flushes by RAM usage)</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_buffered_docs</p></td><td align="left" valign="top"><p>Controls the amount of documents buffered in memory during indexing. The bigger the more RAM is
consumed.</p></td><td align="left" valign="top"><p>Disabled (flushes by RAM usage)</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.max_merge_docs</p></td><td align="left" valign="top"><p>Defines the largest number of documents allowed in a segment. Smaller values perform better on
frequently changing indexes, larger values provide better search performance if the index does not
change often.</p></td><td align="left" valign="top"><p>Unlimited (Integer.MAX_VALUE)</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_factor</p></td><td align="left" valign="top"><p>Controls segment merge frequency and size. Determines how often segment indexes are merged when
insertion occurs. With smaller values, less RAM is used while indexing, and searches on unoptimized
indexes are faster, but indexing speed is slower. With larger values, more RAM is used during
indexing, and while searches on unoptimized indexes are slower, indexing is faster. Thus larger
values (&gt; 10) are best for batch index creation, and smaller values (&lt; 10) for indexes that are
interactively maintained. The value must not be lower than 2.</p></td><td align="left" valign="top"><p>10</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_min_size</p></td><td align="left" valign="top"><p>Controls segment merge frequency and size. Segments smaller than this size (in MB) are always
considered for the next segment merge operation.
Setting this too large might result in expensive merge operations, even tough they are less frequent.
See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.minMergeSize</code>.</p></td><td align="left" valign="top"><p>0 MB (actually ~1K)</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_size</p></td><td align="left" valign="top"><p>Controls segment merge frequency and size. Segments larger than this size (in MB) are never merged
in bigger segments. This helps reduce memory requirements and avoids some merging operations at the
cost of optimal search speed. When optimizing an index this value is ignored.
See also <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSize</code>.</p></td><td align="left" valign="top"><p>Unlimited</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_max_optimize_size</p></td><td align="left" valign="top"><p>Controls segment merge frequency and size. Segments larger than this size (in MB) are not merged
in bigger segments even when optimizing the index (see <code class="literal">merge_max_size</code> setting as well).
Applied to <code class="literal">org.apache.lucene.index.LogDocMergePolicy.maxMergeSizeForOptimize</code>.</p></td><td align="left" valign="top"><p>Unlimited</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.merge_calibrate_by_deletes</p></td><td align="left" valign="top"><p>Controls segment merge frequency and size. Set to <code class="literal">false</code> to not consider deleted documents when
estimating the merge policy. Applied to <code class="literal">org.apache.lucene.index.LogMergePolicy.calibrateSizeByDeletes</code>.</p></td><td align="left" valign="top"><p><code class="literal">true</code></p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.ram_buffer_size</p></td><td align="left" valign="top"><p>Controls the amount of RAM in MB dedicated to document buffers. When used together max_buffered_docs
a flush occurs for whichever event happens first.
Generally for faster indexing performance it’s best to flush by RAM usage instead of document count
and use as large a RAM buffer as you can.</p></td><td align="left" valign="top"><p>16 MB</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.enable_dirty_check</p></td><td align="left" valign="top"><p>Not all entity changes require an update of the Lucene index. If all of the updated entity
properties (dirty properties) are not indexed Hibernate Search will skip the re-indexing work.
Disable this option if you use a custom <code class="literal">FieldBridge</code> which need to be invoked at each update
event (even though the property for which the field bridge is configured has not changed).
This optimization will not be applied on classes using a <code class="literal">@ClassBridge</code> or a <code class="literal">@DynamicBoost</code>.
Boolean parameter, use "true" or "false".</p></td><td align="left" valign="top"><p>true</p></td></tr><tr><td align="left" valign="top"><p>hibernate.search.[default|&lt;indexname&gt;].indexwriter.infostream</p></td><td align="left" valign="top"><p>Enable low level trace information about Lucene’s internal components.
Will cause significant performance degradation: should only be used for troubleshooting purposes.</p></td><td align="left" valign="top"><p>false</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>When your architecture permits it, always keep
<code class="literal">hibernate.search.default.exclusive_index_use=true</code> as it greatly improves efficiency in index
writing. This is the default since Hibernate Search version 4.</p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>To tune the indexing speed it might be useful to time the object loading from database in isolation
from the writes to the index. To achieve this set the <code class="literal">blackhole</code> as worker backend and start your
indexing routines. This backend does not disable Hibernate Search: it will still generate the needed
changesets to the index, but will discard them instead of flushing them to the index. In contrast to
setting the <code class="literal">hibernate.search.indexing_strategy</code> to <code class="literal">manual</code>, using <code class="literal">blackhole</code> will possibly
load more data from the database. because associated entities are re-indexed as well.</p><pre class="screen">hibernate.search.[default|&lt;indexname&gt;].worker.backend blackhole</pre><p>The recommended approach is to focus first on optimizing the object loading, and then use the timings you achieve as a baseline to tune the indexing process.</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>The <code class="literal">blackhole</code> backend is not meant to be used in production, only as a tool to identify indexing
bottlenecks.</p></div><div class="section" title="3.8.1.1. Control segment size"><div class="titlepage"><div><div><h4 class="title"><a id="lucene-segment-size"/>3.8.1.1. Control segment size</h4></div></div></div><p>The options <code class="literal">merge_max_size</code>, <code class="literal">merge_max_optimize_size</code>, <code class="literal">merge_calibrate_by_deletes</code>
give you control on the maximum size of the segments being created, but you need to understand how
they affect file sizes. If you need to hard limit the size, consider that merging a segment is about
adding it together with another existing segment to form a larger one, so you might want to set the
<code class="literal">max_size</code> for merge operations to less than half of your hard limit. Also segments might
initially be generated larger than your expected size at first creation time: before they are ever
merged. A segment is never created much larger than <code class="literal">ram_buffer_size</code>, but the threshold is
checked as an estimate.</p><p>Example:</p><div class="informalexample"><pre class="screen">//to be fairly confident no files grow above 15MB, use:
hibernate.search.default.indexwriter.ram_buffer_size = 10
hibernate.search.default.indexwriter.merge_max_optimize_size = 7
hibernate.search.default.indexwriter.merge_max_size = 7</pre></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>When using the Infinispan Directory to cluster indexes make sure that your segments are smaller than
the <code class="literal">chunk_size</code> so that you avoid fragmenting segments in the grid. Note that the
<code class="literal">chunk_size</code> of the Infinispan Directory is expressed in bytes, while the index tuning options
are in MB.</p></div></div><div class="section" title="3.8.1.2. Troubleshooting: enable Lucene’s Infostream"><div class="titlepage"><div><div><h4 class="title"><a id="lucene-infostream"/>3.8.1.2. Troubleshooting: enable Lucene’s Infostream</h4></div></div></div><p>Apache Lucene allows to log a very detailed trace log from its internals using a feature called "infostream".
To access these details, Hibernate Search can be configured to capture this internal trace from Apache Lucene and redirect it to your logger.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Enable <code class="literal">TRACE</code> level logging for the category <code class="literal">org.hibernate.search.backend.lucene.infostream</code></li><li class="listitem">Activate the feature on the index you want to inspect: <code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.infostream=true</code></li></ul></div><p>Keep in mind that this feature has a performance cost, and although most logger frameworks allow the <code class="literal">TRACE</code> level to be reconfigured at runtime,
enabling the <code class="literal">infostream</code> property will slow you down even if the logger is disabled.</p></div></div><div class="section" title="3.8.2. LockFactory configuration"><div class="titlepage"><div><div><h3 class="title"><a id="search-configuration-directory-lockfactories"/>3.8.2. LockFactory configuration</h3></div></div></div><p>Lucene Directorys have default locking strategies which work generally good enough for most cases,
but it’s possible to specify for each index managed by Hibernate Search a specific LockingFactory
you want to use. This is generally not needed but could be useful.</p><p>Some of these locking strategies require a filesystem level lock and may be used even on RAM based
indexes, this combination is valid but in this case the <code class="literal">indexBase</code> configuration option usually
needed only for filesystem based Directory instances must be specified to point to a filesystem
location where to store the lock marker files.</p><p>To select a locking factory, set the <code class="literal">hibernate.search.&lt;index&gt;.locking_strategy</code> option to
one of <code class="literal">simple</code>, <code class="literal">native</code>, <code class="literal">single</code> or <code class="literal">none</code>. Alternatively set it to the fully qualified name of
an implementation of <code class="literal">org.hibernate.search.store.LockFactoryProvider</code>.</p><div class="table"><a id="search-configuration-directory-lockfactories-table"/><p class="title"><strong>Table 3.8. List of available LockFactory implementations</strong></p><div class="table-contents"><table summary="List of available LockFactory implementations" border="1"><colgroup><col width="33*" class="col_1"/><col width="33*" class="col_2"/><col width="33*" class="col_3"/></colgroup><thead><tr><th align="left" valign="top">name</th><th align="left" valign="top">Class</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p>simple</p></td><td align="left" valign="top"><p>org.apache.lucene.store.SimpleFSLockFactory</p></td><td align="left" valign="top"><p>Safe implementation based on Java’s File API, it marks the usage of the index by creating a marker file.
</p><p>If for some reason you had to kill your application, you will need to remove this file before restarting it.</p></td></tr><tr><td align="left" valign="top"><p>native</p></td><td align="left" valign="top"><p>org.apache.lucene.store.NativeFSLockFactory</p></td><td align="left" valign="top"><p>As does <code class="literal">simple</code> this also marks the usage of the index by creating a marker file, but this one is using native OS file locks so that even if the JVM is terminated the locks will be cleaned up.
</p><p>This implementation has known problems on NFS, avoid it on network shares.
</p><p><code class="literal">native</code> is the default implementation for the <code class="literal">filesystem</code>, <code class="literal">filesystem-master</code> and <code class="literal">filesystem-slave</code> directory providers.</p></td></tr><tr><td align="left" valign="top"><p>single</p></td><td align="left" valign="top"><p>org.apache.lucene.store.SingleInstanceLockFactory</p></td><td align="left" valign="top"><p>This LockFactory doesn’t use a file marker but is a Java object lock held in memory; therefore it’s possible to use it only when you are sure the index is not going to be shared by any other process.
</p><p>This is the default implementation for the <code class="literal">ram</code> directory provider.</p></td></tr><tr><td align="left" valign="top"><p>none</p></td><td align="left" valign="top"><p>org.apache.lucene.store.NoLockFactory</p></td><td align="left" valign="top"><p>All changes to this index are not coordinated by any lock; test your application carefully and make sure you know what it means.</p></td></tr></tbody></table></div></div><br class="table-break"/><p>Configuration example:</p><div class="informalexample"><pre class="screen">hibernate.search.default.locking_strategy = simple
hibernate.search.Animals.locking_strategy = native
hibernate.search.Books.locking_strategy = org.custom.components.MyLockingFactory</pre></div><p>The Infinispan Directory uses a custom implementation; it’s still possible to override it but make
sure you understand how that will work, especially with clustered indexes.</p></div><div class="section" title="3.8.3. Index format compatibility"><div class="titlepage"><div><div><h3 class="title"><a id="_index_format_compatibility"/>3.8.3. Index format compatibility</h3></div></div></div><p>While Hibernate Search strives to offer a backwards compatible API making it easy to port your
application to newer versions, it still delegates to Apache Lucene to handle the index writing and
searching. This creates a dependency to the Lucene index format. The Lucene developers of course
attempt to keep a stable index format, but sometimes a change in the format can not be avoided. In
those cases you either have to re-index all your data or use an index upgrade tool. Sometimes Lucene
is also able to read the old format so you don’t need to take specific actions (besides making
backup of your index).</p><p>While an index format incompatibility is a rare event, it can happen more often that Lucene’s
Analyzer implementations might slightly change its behavior. This can lead to a poor recall score,
possibly missing many hits from the results.</p><p>Hibernate Search exposes a configuration property <code class="literal">hibernate.search.lucene_version</code> which
instructs the analyzers and other Lucene classes to conform to their behavior as defined in an
(older) specific version of Lucene. See also <code class="literal">org.apache.lucene.util.Version</code> contained in the
<span class="emphasis"><em>lucene-core.jar</em></span>. Depending on the specific version of Lucene you’re using you might have different
options available. When this option is not specified, Hibernate Search will instruct Lucene to use
the default version, which is usually the best option for new projects. Still it’s recommended to
define the version you’re using explicitly in the configuration so that when you happen to upgrade
Lucene the analyzers will not change behavior. You can then choose to update this value at a later
time, when you for example have the chance to rebuild the index from scratch.</p><div class="example"><a id="d0e2372"/><p class="title"><strong>Example 3.15. Force Analyzers to be compatible with a Lucene 4.7 created index</strong></p><div class="example-contents"><pre class="screen">hibernate.search.lucene_version = LUCENE_47</pre></div></div><br class="example-break"/><p>This option is global for the configured SearchFactory and affects all Lucene APIs having such a
parameter, as this should be applied consistently. So if you are also making use of Lucene bypassing
Hibernate Search, make sure to apply the same value too.</p></div></div><div class="section" title="3.9. Metadata API"><div class="titlepage"><div><div><h2 class="title"><a id="_metadata_api"/>3.9. Metadata API</h2></div></div></div><p>After looking at all these different configuration options, it is time to have a look at an API
which allows you to programmatically access parts of the configuration. Via the metadata API you can
determine the indexed types and also how they are mapped (see <a class="xref" href="ch04.html" title="Chapter 4. Mapping entities to the index structure">Chapter 4, <em>Mapping entities to the index structure</em></a>) to the index
structure. The entry point into this API is the SearchFactory. It offers two methods, namely
<code class="literal">getIndexedTypes()</code> and <code class="literal">getIndexedTypeDescriptor(Class&lt;?&gt;)</code>. The former returns a set of all
indexed type, where as the latter allows to retrieve a so called IndexedTypeDescriptorfor a given
type. This descriptor allows you determine whether the type is indexed at all and, if so, whether
the index is for example sharded or not (see <a class="xref" href="ch10.html#advanced-features-sharding" title="10.5. Sharding indexes">Section 10.5, “Sharding indexes”</a>). It also allows you to
determine the static boost of the type (see <a class="xref" href="ch04.html#section-boost-annotation" title="4.2.1. Static index time boosting">Section 4.2.1, “Static index time boosting”</a>) as well as its dynamic
boost strategy (see <a class="xref" href="ch04.html#section-dynamic-boost" title="4.2.2. Dynamic index time boosting">Section 4.2.2, “Dynamic index time boosting”</a>). Most importantly, however, you get information about
the indexed properties and generated Lucene Document fields. This is exposed via PropertyDescriptors
respectively FieldDescriptors. The easiest way to get to know the API is to explore it via the IDE
or its javadocs.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>All descriptor instances of the metadata API are read only. They do not allow to change any runtime
configuration.</p></div></div><div class="section" title="3.10. Hibernate Search as a WildFly module"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-deploy-on-wildfly"/>3.10. Hibernate Search as a WildFly module</h2></div></div></div><p>Hibernate Search is included in the WildFly application server, and since WildFly 10 the module
is automatically activated (added to the classpath of your deployment) if you have any indexed entities.</p><p>Alternatively you can opt to use a different version of the module by downloading and unzipping a different
moduleset and setting the <code class="literal">wildfly.jpa.hibernate.search.module</code> property in your <code class="literal">persistence.xml</code>.</p><p>The modules system in WildFly allows to safely run multiple versions of Hibernate ORM and
Hibernate Search in parallel, but if you download an alternative version make sure the Hibernate Search version you choose
is compatible with the Hibernate ORM version you choose.</p><div class="section" title="3.10.1. Use the Hibernate Search version included in WildFly"><div class="titlepage"><div><div><h3 class="title"><a id="using-wildfly-provided-hibernatesearch-versions"/>3.10.1. Use the Hibernate Search version included in WildFly</h3></div></div></div><p>The activation of the Hibernate Search modules in wildfly is automatic, provided you’re having at least one
entity annotated with <code class="literal">org.hibernate.search.annotations.Indexed</code>.</p><p>You can control this behaviour of the JPA deployer explicitly; for example to make sure Hibernate Search
and Apache Lucene classes are available to your application even though you haven’t annotated any entity,
set the following property in your <code class="literal">persistence.xml</code>:</p><div class="informalexample"><pre class="screen">wildfly.jpa.hibernate.search.module=org.hibernate.search.orm:main</pre></div></div><div class="section" title="3.10.2. Update and activate latest Hibernate Search version in WildFly"><div class="titlepage"><div><div><h3 class="title"><a id="_update_and_activate_latest_hibernate_search_version_in_wildfly"/>3.10.2. Update and activate latest Hibernate Search version in WildFly</h3></div></div></div><p>You can also download the latest Hibernate Search provided module and install it. This is often the
best approach as you will benefit from all the latest improvements of
Hibernate Search. Because of the modular design in WildFly, these additional modules can
coexist with the embedded modules and won’t affect any other application, unless you
explicitly reconfigure it to use the newer module.</p><p>You can download the latest pre-packaged Hibernate Search modules from
<a class="link" href="http://sourceforge.net/projects/hibernate/files/hibernate-search/5.5.8.Final/hibernate-search-modules-5.5.8.Final-wildfly-10-dist.zip/download">Sourceforge</a>.
As a convenience these zip files are also distributed as Maven artifacts:
<a class="link" href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.hibernate~hibernate-search-modules~{hibernateSearchVersion}~~">org.hibernate:hibernate-search-modules-5.5.8.Final-wildfly-10-dist:zip</a>.</p><p>Unpack the modules in your WildFly <code class="literal">modules</code> directory: this will create modules for Hibernate Search and Apache Lucene.
The Hibernate Search modules are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="emphasis"><em>org.hibernate.search.orm</em></span>, for users of Hibernate Search with Hibernate; this will transitively include Hibernate ORM.</li><li class="listitem"><span class="emphasis"><em>org.hibernate.search.engine</em></span>, for projects depending on the internal indexing engine that don’t require other dependencies to Hibernate.</li><li class="listitem"><span class="emphasis"><em>org.hibernate.search.backend-jms</em></span>, in case you want to use the JMS backend described in <a class="link" href="ch02.html#search-architecture-jms" title="2.2.2. JMS">JMS Architecture</a>.</li></ul></div><p>Next you will need to make sure the JPA deployer of WildFly provides you with the version you have chosen, instead of the default version
bundled with the application server.
Set the following property in your <code class="literal">persistence.xml</code>:</p><div class="informalexample"><pre class="screen">wildfly.jpa.hibernate.search.module=org.hibernate.search.orm:5.5.8.Final</pre></div><p>See also <a class="link" href="https://docs.jboss.org/author/display/WFLY10/JPA+Reference+Guide#JPAReferenceGuide-UsingHibernateSearch">the WildFly JPA configuration</a></p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>This version of Hibernate Search <code class="literal">5.5.8.Final</code> requires Hibernate ORM 5.
At the time of writing this paragraph the only version of WildFly compatible with Hibernate ORM 5 is WildFly version 10.</p><p>If you need an Hibernate Search version for WildFly versions 9 or earlier, you can either include
a version of Hibernate ORM 5 in custom modules, but this requires some expertise with the modules system;
In such a scenario it might be easier to use a previous version of Hibernate Search, or simply use the
Hibernate Search version included in each WildFly release (see <a class="xref" href="ch03.html#using-wildfly-provided-hibernatesearch-versions" title="3.10.1. Use the Hibernate Search version included in WildFly">Section 3.10.1, “Use the Hibernate Search version included in WildFly”</a>).</p></div></div><div class="section" title="3.10.3. More about modules"><div class="titlepage"><div><div><h3 class="title"><a id="_more_about_modules"/>3.10.3. More about modules</h3></div></div></div><p>More information about the modules configuration in WildFly can be found in the
<a class="link" href="https://docs.jboss.org/author/display/WFLY10/Class+Loading+in+WildFly">Class Loading in WildFly 10</a> wiki.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Modular classloading is a feature of JBoss EAP 6 as well, but if you are using JBoss EAP, you’re
reading the wrong version of the user guide! JBoss EAP subscriptions include official support for
Hibernate Search and come with a different edition of this guide specifically tailored for EAP users.</p></div></div><div class="section" title="3.10.4. Using Infinispan with Hibernate Search on WildFly"><div class="titlepage"><div><div><h3 class="title"><a id="_using_infinispan_with_hibernate_search_on_wildfly"/>3.10.4. Using Infinispan with Hibernate Search on WildFly</h3></div></div></div><p>The Infinispan project is also included in WildFly so you can use the feature without
additional downloads.</p><p>If you are updating the version of Hibernate Search in WildFly as described in the previous paragraph,
you might need to update Infinispan as well.
The process is very similar: download the modules from
<a class="link" href="http://infinispan.org/download/">Infinispan project downloads</a>, picking a compatible version,
and decompress the modules into the <code class="literal">modules</code> directory of your WildFly installation.</p><p>Hibernate Search version <code class="literal">5.5.8.Final</code> was compiled and tested with Infinispan version
<code class="literal">8.1.0.Final</code>; generally a more recent version of either project is expected to be backwards
compatible for cross-project integration purposes as long as they have the same "major.minor" family
version.</p><p>For example for a version of Hibernate Search depending on Infinispan <code class="literal">7.0.3.Final</code> it should be
safe to upgrade Infinispan to <code class="literal">7.0.6.Final</code>, but an upgrade to <code class="literal">7.1.0.Final</code> might not work.</p></div></div></div><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">hljs.initHighlightingOnLoad();</script><hr xmlns="" xmlns:d="http://docbook.org/ns/docbook"/><a xmlns="" xmlns:d="http://docbook.org/ns/docbook" href="legalnotice.html"/><ul class="docnav"><li class="previous"><a accesskey="p" href="ch02.html"><strong>Prev</strong>Chapter 2. Architecture</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch04.html"><strong>Next</strong>Chapter 4. Mapping entities to the index structure</a></li></ul><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("search"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>