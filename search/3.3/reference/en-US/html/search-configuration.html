<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 3. Configuration</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate Search, full text search for your entities - Reference Documentation" /><meta name="keywords" content="hibernate, search, hibernate search, full text, lucene" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="Hibernate Search"/><link rel="up" href="index.html" title="Hibernate Search"/><link rel="prev" href="search-architecture.html" title="Chapter 2. Architecture"/><link rel="next" href="search-mapping.html" title="Chapter 4. Mapping entities to the index structure"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="search-architecture.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="search-mapping.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration"/>Chapter 3. Configuration</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="search-configuration.html#search-configuration-event">3.1. Enabling Hibernate Search and automatic indexing</a></span></dt><dd><dl><dt><span class="section"><a href="search-configuration.html#d0e667">3.1.1. Enabling Hibernate Search</a></span></dt><dt><span class="section"><a href="search-configuration.html#d0e675">3.1.2. Automatic indexing</a></span></dt></dl></dd><dt><span class="section"><a href="search-configuration.html#search-configuration-directory">3.2. Directory configuration</a></span></dt><dt><span class="section"><a href="search-configuration.html#search-configuration-directory-sharding">3.3. Sharding indexes</a></span></dt><dt><span class="section"><a href="search-configuration.html#section-sharing-indexes">3.4. Sharing indexes</a></span></dt><dt><span class="section"><a href="search-configuration.html#d0e1301">3.5. Worker configuration</a></span></dt><dt><span class="section"><a href="search-configuration.html#jms-backend">3.6. JMS Master/Slave configuration</a></span></dt><dd><dl><dt><span class="section"><a href="search-configuration.html#d0e1561">3.6.1. Slave nodes</a></span></dt><dt><span class="section"><a href="search-configuration.html#d0e1577">3.6.2. Master node</a></span></dt></dl></dd><dt><span class="section"><a href="search-configuration.html#jgroups-backend">3.7. JGroups Master/Slave configuration</a></span></dt><dd><dl><dt><span class="section"><a href="search-configuration.html#d0e1618">3.7.1. Slave nodes</a></span></dt><dt><span class="section"><a href="search-configuration.html#d0e1628">3.7.2. Master node</a></span></dt><dt><span class="section"><a href="search-configuration.html#d0e1638">3.7.3. JGroups channel configuration</a></span></dt></dl></dd><dt><span class="section"><a href="search-configuration.html#infinispan-directories">3.8. Infinispan Directory configuration</a></span></dt><dd><dl><dt><span class="section"><a href="search-configuration.html#d0e1699">3.8.1. Requirements</a></span></dt><dt><span class="section"><a href="search-configuration.html#d0e1723">3.8.2. Architecture</a></span></dt><dt><span class="section"><a href="search-configuration.html#d0e1739">3.8.3. Infinispan Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="search-configuration.html#configuration-reader-strategy">3.9. Reader strategy configuration</a></span></dt><dt><span class="section"><a href="search-configuration.html#lucene-indexing-performance">3.10. Tuning Lucene indexing performance</a></span></dt><dt><span class="section"><a href="search-configuration.html#search-configuration-directory-lockfactories">3.11. LockFactory configuration</a></span></dt><dt><span class="section"><a href="search-configuration.html#d0e2189">3.12. Exception Handling Configuration</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-event"/>3.1. Enabling Hibernate Search and automatic indexing</h2></div></div></div><p>Let's start with the most basic configuration question - how to
    enable Hibernate Search in your system.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e667"/>3.1.1. Enabling Hibernate Search</h3></div></div></div><p>The good news is that Hibernate Search is enabled out of the box
      when detected on the classpath by Hibernate Core. If, for some reason
      you need to disable it, set
      <code class="literal">hibernate.search.autoregister_listeners</code> to false.
      Note that there is no performance penalty when the listeners are enabled
      but no entities are annotated as indexed.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e675"/>3.1.2. Automatic indexing</h3></div></div></div><p>By default, every time an object is inserted, updated or deleted
      through Hibernate, Hibernate Search updates the according Lucene index.
      It is sometimes desirable to disable that features if either your index
      is read-only or if index updates are done in a batch way (see <a class="xref" href="manual-index-changes.html#search-batchindex" title="6.3. Rebuilding the whole index">Section 6.3, “Rebuilding the whole index”</a>).</p><p>To disable event based indexing, set</p><pre class="programlisting">hibernate.search.indexing_strategy = manual</pre><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>In most case, the JMS backend provides the best of both world, a
        lightweight event based system keeps track of all changes in the
        system, and the heavyweight indexing process is done by a separate
        process or machine.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-directory"/>3.2. Directory configuration</h2></div></div></div><p>Apache Lucene has a notion of a <code class="classname">Directory</code> to
    store the index files. The <code class="classname">Directory</code> implementation
    can be customized and Lucene comes bundled with a file system and an
    in-memory implementation. <code class="classname">DirectoryProvider</code> is the
    Hibernate Search abstraction around a Lucene
    <code class="classname">Directory</code> and handles the configuration and the
    initialization of the underlying Lucene resources. <a class="xref" href="search-configuration.html#directory-provider-table" title="Table 3.1. List of built-in DirectoryProviders">Table 3.1, “List of built-in
      DirectoryProviders”</a> shows the list of the directory
    providers available in Hibernate Search together with their corresponding
    options. </p><p>To configure your <code class="classname">DirectoryProvider</code> you have
    to understand that each indexed entity is associated to a Lucene index
    (except of the case where multiple entities share the same index - <a class="xref" href="search-configuration.html#section-sharing-indexes" title="3.4. Sharing indexes">Section 3.4, “Sharing indexes”</a>). The name of the index is given by
    the <code class="constant">index</code> property of the
    <code class="classname">@Indexed</code> annotation. If the
    <code class="constant">index</code> property is not specified the fully qualified
    name of the indexed class will be used as name. </p><p>Knowing the index name, you can configure the directory provider and
    any additional options by using the prefix
    <code class="constant">hibernate.search.</code><em class="replaceable"><code>&lt;indexname&gt;</code></em>.
    The name <code class="constant">default</code>
    (<code class="constant">hibernate.search.default</code>) is reserved and can be
    used to define properties which apply to all indexes. <a class="xref" href="search-configuration.html#example-configuring-directory-providers" title="Example 3.2. Configuring directory providers">Example 3.2, “Configuring directory providers”</a> shows how
    <code class="constant">hibernate.search.default.directory_provider</code> is used
    to set the default directory provider to be the filesystem one.
    <code class="constant">hibernate.search.default.indexBase</code> sets then the
    default base directory for the indexes. As a result the index for the
    entity <code class="classname">Status</code> is created in
    <code class="filename">/usr/lucene/indexes/org.hibernate.example.Status</code>.</p><p>The index for the <code class="classname">Rule</code> entity, however, is
    using an in-memory directory, because the default directory provider for
    this entity is overriden by the property
    <code class="constant">hibernate.search.Rules.directory_provider</code>.</p><p>Finally the <code class="classname">Action</code> entity uses a custom
    directory provider <code class="classname">CustomDirectoryProvider</code>
    specified via
    <code class="constant">hibernate.search.Actions.directory_provider</code>.</p><div class="example"><a id="d0e770"/><p class="title"><b>Example 3.1. Specifying the index name</b></p><div class="example-contents"><pre class="programlisting">package org.hibernate.example;

@Indexed
public class Status { ... }

@Indexed(index="Rules")
public class Rule { ... }

@Indexed(index="Actions")
public class Action { ... }</pre></div></div><br class="example-break"/><div class="example"><a id="example-configuring-directory-providers"/><p class="title"><b>Example 3.2. Configuring directory providers</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.directory_provider filesystem
hibernate.search.default.indexBase=/usr/lucene/indexes
hibernate.search.Rules.directory_provider ram
hibernate.search.Actions.directory_provider com.acme.hibernate.provider.CustomDirectoryProvider</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>Using the described configuration scheme you can easily define
      common rules like the directory provider and base directory, and
      override those defaults later on on a per index basis.</p></div><div class="table"><a id="directory-provider-table"/><p class="title"><b>Table 3.1. List of built-in
      <code class="classname">DirectoryProvider</code>s</b></p><div class="table-contents"><table summary="List of built-in&#xA;      DirectoryProviders" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">Class or shortcut name</th><th align="center">Description</th><th align="center">Properties</th></tr></thead><tbody><tr><td>ram</td><td>Memory based directory, the directory will be uniquely
            identified (in the same deployment unit) by the
            <code class="literal">@Indexed.index</code> element</td><td>none</td></tr><tr><td>filesystem</td><td>File system based directory. The directory used will be
            &lt;indexBase&gt;/&lt; indexName &gt;</td><td><p><code class="literal">indexBase</code> : Base
            directory</p><p><code class="literal">indexName</code>: override
            @Indexed.index (useful for sharded
            indexes)</p><p><code class="literal">locking_strategy</code> :
            optional, see <a class="xref" href="search-configuration.html#search-configuration-directory-lockfactories" title="3.11. LockFactory configuration">Section 3.11, “LockFactory configuration”</a>
            </p><p><code class="literal">filesystem_access_type</code>: allows to
            determine the exact type of <code class="classname">FSDirectory</code>
            implementation used by this
            <code class="classname">DirectoryProvider</code>. Allowed values are
            <code class="literal">auto</code> (the default value, selects
            <code class="classname">NIOFSDirectory</code> on non Windows systems,
            <code class="classname">SimpleFSDirectory</code> on Windows),
            <code class="literal">simple</code>
            (<code class="classname">SimpleFSDirectory</code>), <code class="literal">nio</code>
            (<code class="classname">NIOFSDirectory</code>), <code class="literal">mmap</code>
            (<code class="classname">MMapDirectory</code>). Make sure to refer to
            Javadocs of these <code class="classname">Directory</code> implementations
            before changing this setting. Even though
            <code class="classname">NIOFSDirectory</code> or
            <code class="classname">MMapDirectory</code> can bring substantial
            performace boosts they also have their issues.</p></td></tr><tr><td>filesystem-master</td><td><p>File system based directory. Like
            <code class="literal">filesystem</code>. It also copies the index to a
            source directory (aka copy directory) on a regular basis.
            </p><p>The recommended value for the refresh period is (at
            least) 50% higher that the time to copy the information (default
            3600 seconds - 60 minutes).</p><p>Note that the copy is
            based on an incremental copy mechanism reducing the average copy
            time.</p><p>DirectoryProvider typically used on the master
            node in a JMS back end cluster.</p><p>The <code class="literal">
            buffer_size_on_copy</code> optimum depends on your operating
            system and available RAM; most people reported good results using
            values between 16 and 64MB.</p></td><td><p><code class="literal">indexBase</code>: Base
            directory</p><p><code class="literal">indexName</code>: override
            @Indexed.index (useful for sharded
            indexes)</p><p><code class="literal">sourceBase</code>: Source (copy)
            base directory.</p><p><code class="literal">source</code>: Source
            directory suffix (default to <code class="literal">@Indexed.index</code>).
            The actual source directory name being
            <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
            </p><p><code class="literal">refresh</code>: refresh period in second
            (the copy will take place every refresh
            seconds).</p><p><code class="literal">buffer_size_on_copy</code>: The
            amount of MegaBytes to move in a single low level copy
            instruction; defaults to
            16MB.</p><p><code class="literal">locking_strategy</code> : optional,
            see <a class="xref" href="search-configuration.html#search-configuration-directory-lockfactories" title="3.11. LockFactory configuration">Section 3.11, “LockFactory configuration”</a>
            </p><p><code class="literal">filesystem_access_type</code>: allows to
            determine the exact type of <code class="classname">FSDirectory</code>
            implementation used by this
            <code class="classname">DirectoryProvider</code>. Allowed values are
            <code class="literal">auto</code> (the default value, selects
            <code class="classname">NIOFSDirectory</code> on non Windows systems,
            <code class="classname">SimpleFSDirectory</code> on Windows),
            <code class="literal">simple</code>
            (<code class="classname">SimpleFSDirectory</code>), <code class="literal">nio</code>
            (<code class="classname">NIOFSDirectory</code>), <code class="literal">mmap</code>
            (<code class="classname">MMapDirectory</code>). Make sure to refer to
            Javadocs of these <code class="classname">Directory</code> implementations
            before changing this setting. Even though
            <code class="classname">NIOFSDirectory</code> or
            <code class="classname">MMapDirectory</code> can bring substantial
            performace boosts they also have their issues.</p></td></tr><tr><td>filesystem-slave</td><td><p>File system based directory. Like
            <code class="literal">filesystem</code>, but retrieves a master version
            (source) on a regular basis. To avoid locking and inconsistent
            search results, 2 local copies are kept. </p><p>The
            recommended value for the refresh period is (at least) 50% higher
            that the time to copy the information (default 3600 seconds - 60
            minutes).</p><p>Note that the copy is based on an
            incremental copy mechanism reducing the average copy
            time.</p><p>DirectoryProvider typically used on slave nodes
            using a JMS back end.</p><p>The <code class="literal">
            buffer_size_on_copy</code> optimum depends on your operating
            system and available RAM; most people reported good results using
            values between 16 and 64MB.</p></td><td><p><code class="literal">indexBase</code>: Base
            directory</p><p><code class="literal">indexName</code>: override
            @Indexed.index (useful for sharded
            indexes)</p><p><code class="literal">sourceBase</code>: Source (copy)
            base directory.</p><p><code class="literal">source</code>: Source
            directory suffix (default to <code class="literal">@Indexed.index</code>).
            The actual source directory name being
            <code class="filename">&lt;sourceBase&gt;/&lt;source&gt;</code>
            </p><p><code class="literal">refresh</code>: refresh period in second
            (the copy will take place every refresh
            seconds).</p><p><code class="literal">buffer_size_on_copy</code>: The
            amount of MegaBytes to move in a single low level copy
            instruction; defaults to
            16MB.</p><p><code class="literal">locking_strategy</code> : optional,
            see <a class="xref" href="search-configuration.html#search-configuration-directory-lockfactories" title="3.11. LockFactory configuration">Section 3.11, “LockFactory configuration”</a>
            </p><p><code class="literal">retry_marker_lookup</code> : optional,
            default to 0. Defines how many times, we look for the marker files
            in the source directory before failing. Waiting 5 seconds between
            each try. </p><p><code class="literal">filesystem_access_type</code>:
            allows to determine the exact type of
            <code class="classname">FSDirectory</code> implementation used by this
            <code class="classname">DirectoryProvider</code>. Allowed values are
            <code class="literal">auto</code> (the default value, selects
            <code class="classname">NIOFSDirectory</code> on non Windows systems,
            <code class="classname">SimpleFSDirectory</code> on Windows),
            <code class="literal">simple</code>
            (<code class="classname">SimpleFSDirectory</code>), <code class="literal">nio</code>
            (<code class="classname">NIOFSDirectory</code>), <code class="literal">mmap</code>
            (<code class="classname">MMapDirectory</code>). Make sure to refer to
            Javadocs of these <code class="classname">Directory</code> implementations
            before changing this setting. Even though
            <code class="classname">NIOFSDirectory</code> or
            <code class="classname">MMapDirectory</code> can bring substantial
            performace boosts they also have their issues.</p></td></tr><tr><td>infinispan</td><td><p>Infinispan based directory. Use it to store the index
            in a distributed grid, making index changes visible to all
            elements of the cluster very quickly. Also see <a class="xref" href="search-configuration.html#infinispan-directories" title="3.8. Infinispan Directory configuration">Section 3.8, “Infinispan Directory configuration”</a> for additional requirements
            and configuration settings. Infinispan needs a global
            configuration and additional dependencies; the settings defined
            here apply to each different index.</p></td><td><p><code class="literal">locking_cachename</code>: name of the
            Infinispan cache to use to store
            locks.</p><p><code class="literal">data_cachename</code> : name of the
            Infinispan cache to use to store the largest data chunks; this
            area will contain the largest objects, use replication if you have
            enough memory or switch to distribution.</p>
            <p><code class="literal">metadata_cachename</code>: name of the
            Infinispan cache to use to store the metadata relating to the
            index; this data is rather small and read very often, it's
            recommended to have this cache setup using replication.</p>
            <p><code class="literal">chunk_size</code>: large files of the index are
            split in smaller chunks, you might want to set the highest value
            efficiently handled by your network. Networking tuning might be
            useful.</p></td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>If the built-in directory providers do not fit your needs, you can
      write your own directory provider by implementing the
      <code class="classname">org.hibernate.store.DirectoryProvider</code> interface.
      In this case, pass the fully qualified class name of your provider into
      the <code class="literal">directory_provider</code> property. You can pass any
      additional properties using the prefix
      <code class="constant">hibernate.search.</code><em class="replaceable"><code>&lt;indexname&gt;</code></em>.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-directory-sharding"/>3.3. Sharding indexes</h2></div></div></div><p>In some cases it can be useful to split (shard) the indexed data of
    a given entity into several Lucene indexes.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p> This solution is not recommended unless there is a pressing need.
      Searches will be slower as all shards have to be opened for a single
      search. Don't do it until you have a real use case!</p></div><p>Possible use cases for sharding are:</p><div class="itemizedlist"><ul><li><p>A single index is so huge that index update times are slowing
        the application down.</p></li><li><p>A typical search will only hit a sub-set of the index, such as
        when data is naturally segmented by customer, region or
        application.</p></li></ul></div><p>By default sharding is not enabled unless the number of shards is
    configured. To do this use the
    <code class="constant">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards</code>
    property as seen in <a class="xref" href="search-configuration.html#example-index-sharding" title="Example 3.3. Enabling index sharding">Example 3.3, “Enabling index sharding”</a>. In this
    example 5 shards are enabled.</p><div class="example"><a id="example-index-sharding"/><p class="title"><b>Example 3.3. Enabling index sharding</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy.nbr_of_shards 5</pre></div></div><br class="example-break"/><p>Responsible for splitting the data into sub-indexes is the
    <code class="classname">IndexShardingStrategy</code>. The default sharding
    strategy splits the data according to the hash value of the id string
    representation (generated by the <code class="classname">FieldBridge</code>). This
    ensures a fairly balanced sharding. You can replace the default strategy
    by implementing a custom <code class="classname">IndexShardingStrategy</code>. To
    use your custom strategy you have to set the
    <code class="constant">hibernate.search.&lt;indexName&gt;.sharding_strategy</code>
    property.</p><div class="example"><a id="d0e1169"/><p class="title"><b>Example 3.4. Specifying a custom sharding strategy</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.&lt;indexName&gt;.sharding_strategy my.shardingstrategy.Implementation</pre></div></div><br class="example-break"/><p>The <code class="classname"> IndexShardingStrategy</code> also allows for
    optimizing searches by selecting which shard to run the query against. By
    activating a filter (see <a class="xref" href="search-query.html#query-filter-shard" title="5.3.1. Using filters in a sharded environment">Section 5.3.1, “Using filters in a sharded environment”</a>), a
    sharding strategy can select a subset of the shards used to answer a query
    (<code class="classname">IndexShardingStrategy.getDirectoryProvidersForQuery</code>)
    and thus speed up the query execution.</p><p>Each shard has an independent directory provider configuration. The
    <code class="classname">DirectoryProvider</code> index names for the Animal entity
    in <a class="xref" href="search-configuration.html#example-sharding-configuration" title="Example 3.5. Sharding configuration for entity Animal">Example 3.5, “Sharding configuration for entity
      Animal”</a> are
    <code class="literal">Animal.0</code> to <code class="literal">Animal.4</code>. In other
    words, each shard has the name of it's owning index followed by
    <code class="constant">.</code> (dot) and its index number (see also <a class="xref" href="search-configuration.html#search-configuration-directory" title="3.2. Directory configuration">Section 3.2, “Directory configuration”</a>).</p><div class="example"><a id="example-sharding-configuration"/><p class="title"><b>Example 3.5. Sharding configuration for entity
      <code class="classname">Animal</code></b></p><div class="example-contents"><pre class="programlisting">hibernate.search.default.indexBase /usr/lucene/indexes

hibernate.search.Animal.sharding_strategy.nbr_of_shards 5
hibernate.search.Animal.directory_provider filesystem
hibernate.search.Animal.0.indexName Animal00
hibernate.search.Animal.3.indexBase /usr/lucene/sharded
hibernate.search.Animal.3.indexName Animal03</pre></div></div><br class="example-break"/><p>In <a class="xref" href="search-configuration.html#example-sharding-configuration" title="Example 3.5. Sharding configuration for entity Animal">Example 3.5, “Sharding configuration for entity
      Animal”</a>, the
    configuration uses the default id string hashing strategy and shards the
    <code class="classname">Animal</code> index into 5 sub-indexes. All sub-indexes
    are filesystem instances and the directory where each sub-index is stored
    is as followed:</p><div class="itemizedlist"><ul><li><p>for sub-index 0:
        <code class="filename">/usr/lucene/indexes/Animal00</code> (shared indexBase
        but overridden indexName)</p></li><li><p>for sub-index 1:
        <code class="filename">/usr/lucene/indexes/Animal.1</code> (shared indexBase,
        default indexName)</p></li><li><p>for sub-index 2:
        <code class="filename">/usr/lucene/indexes/Animal.2</code> (shared indexBase,
        default indexName)</p></li><li><p>for sub-index 3:
        <code class="filename">/usr/lucene/shared/Animal03</code> (overridden
        indexBase, overridden indexName)</p></li><li><p>for sub-index 4:
        <code class="filename">/usr/lucene/indexes/Animal.4</code> (shared indexBase,
        default indexName)</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="section-sharing-indexes"/>3.4. Sharing indexes</h2></div></div></div><p>It is technically possible to store the information of more than one
    entity into a single Lucene index. There are two ways to accomplish
    this:</p><div class="itemizedlist"><ul><li><p>Configuring the underlying directory providers to point to the
        same physical index directory. In practice, you set the property
        <code class="literal">hibernate.search.[fully qualified entity
        name].indexName</code> to the same value. As an example let’s use
        the same index (directory) for the <code class="classname">Furniture</code>
        and <code class="classname">Animal</code> entity. We just set
        <code class="literal">indexName</code> for both entities to for example
        “Animal”. Both entities will then be stored in the Animal
        directory.</p><pre class="programlisting">hibernate.search.org.hibernate.search.test.shards.Furniture.indexName = Animal
hibernate.search.org.hibernate.search.test.shards.Animal.indexName = Animal</pre></li><li><p>Setting the <code class="code">@Indexed</code> annotation’s
        <code class="methodname">index</code> attribute of the entities you want to
        merge to the same value. If we again wanted all
        <code class="classname">Furniture</code> instances to be indexed in the
        <code class="classname">Animal</code> index along with all instances of
        <code class="classname">Animal</code> we would specify
        <code class="code">@Indexed(index="Animal")</code> on both
        <code class="classname">Animal</code> and <code class="classname">Furniture</code>
        classes.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>This is only presented here so that you know the option is
            available. There is really not much benefit in sharing
            indexes.</p></div></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1301"/>3.5. Worker configuration</h2></div></div></div><p>It is possible to refine how Hibernate Search interacts with Lucene
    through the worker configuration. There exist several architectural
    components and possible extension points. Let's have a closer look.</p><p>First there is a <code class="classname">Worker</code>. An implementation of
    the <code class="classname">Worker</code> interface is reponsible for receiving
    all entity changes, queuing them by context and applying them once a
    context ends. The most intuative context, especially in connection with
    ORM, is the transaction. For this reason Hibernate Search will per default
    use the <code class="classname">TransactionalWorker</code> to scope all changes
    per transaction. One can, however, imagine a scenario where the context
    depends for example on the number of entity changes or some other
    application (lifecycle) events. For this reason the
    <code class="classname">Worker</code> implementation is configurable as shown in
    <a class="xref" href="search-configuration.html#table-worker-configuration" title="Table 3.2. Scope configuration">Table 3.2, “Scope configuration”</a>.</p><div class="table"><a id="table-worker-configuration"/><p class="title"><b>Table 3.2. Scope configuration</b></p><div class="table-contents"><table summary="Scope configuration" border="1"><colgroup><col/><col/></colgroup><tbody><tr><td><span class="bold"><strong>Property</strong></span></td><td><span class="bold"><strong>Description</strong></span></td></tr><tr><td><code class="literal">hibernate.search.worker.scope</code></td><td>The fully qualifed class name of the
            <code class="classname">Worker</code> implementation to use. If this
            property is not set, empty or <code class="literal">transaction</code> the
            default <code class="classname">TransactionalWorker</code> is
            used.</td></tr><tr><td><code class="literal">hibernate.search.worker.*</code></td><td>All configuration properties prefixed with
            <code class="literal">hibernate.search.worker</code> are passed to the
            Worker during initialization. This allows adding custom, worker
            specific parameters.</td></tr><tr><td><code class="literal">hibernate.search.worker.batch_size</code></td><td>Defines the maximum number of indexing operation batched
            per context. Once the limit is reached indexing will be triggered
            even though the context has not ended yet. This property only
            works if the <code class="classname">Worker</code> implementation
            delegates the queued work to BatchedQueueingProcessor (which is
            what the <code class="classname">TransactionalWorker</code> does)</td></tr></tbody></table></div></div><br class="table-break"/><p>Once a context ends it is time to prepare and apply the index
    changes. This can be done synchronously or asynchronously from within a
    new thread. Synchronous updates have the advantage that the index is at
    all times in sync with the databases. Asynchronous updates, on the other
    hand, can help to minimize the user response time. The drawback is
    potential discrepancies between database and index states. Lets look at
    the configuration options shown in <a class="xref" href="search-configuration.html#table-work-execution-configuration" title="Table 3.3. Execution configuration">Table 3.3, “Execution configuration”</a>.</p><div class="table"><a id="table-work-execution-configuration"/><p class="title"><b>Table 3.3. Execution configuration</b></p><div class="table-contents"><table summary="Execution configuration" border="1"><colgroup><col/><col/></colgroup><tbody><tr><td><span class="bold"><strong>Property</strong></span></td><td><span class="bold"><strong>Description</strong></span></td></tr><tr><td><code class="literal">hibernate.search.worker.execution</code></td><td><p><code class="literal">sync</code>: synchronous execution
            (default)</p><p><code class="literal">async</code>: asynchronous
            execution</p></td></tr><tr><td><code class="literal">hibernate.search.worker.thread_pool.size</code></td><td>Defines the number of threads in the pool for asynchronous
            execution. Defaults to 1.</td></tr><tr><td><code class="literal">hibernate.search.worker.buffer_queue.max</code></td><td>Defines the maximal number of work queue if the thread poll
            is starved. Useful only for asynchronous execution. Default to
            infinite. If the limit is reached, the work is done by the main
            thread.</td></tr></tbody></table></div></div><br class="table-break"/><p>So far all work is done within the same Virtual Machine (VM), no
    matter which execution mode. The total amount of work has not changed for
    the single VM. Luckily there is a better approach, namely delegation. It
    is possible to send the indexing work to a different server by configuring
    hibernate.search.worker.backend - see <a class="xref" href="search-configuration.html#table-backend-configuration" title="Table 3.4. Backend configuration">Table 3.4, “Backend configuration”</a>.</p><div class="table"><a id="table-backend-configuration"/><p class="title"><b>Table 3.4. Backend configuration</b></p><div class="table-contents"><table summary="Backend configuration" border="1"><colgroup><col/><col/></colgroup><tbody><tr><td><span class="bold"><strong>Property</strong></span></td><td><span class="bold"><strong>Description</strong></span></td></tr><tr><td><code class="literal">hibernate.search.worker.backend</code></td><td><p><code class="literal">lucene</code>: The default backend which
            runs index updates in the same VM. Also used when the property is
            undefined or empty.</p><p><code class="literal">jms</code>: JMS
            backend. Index updates are send to a JMS queue to be processed by
            an indexing master. See <a class="xref" href="search-configuration.html#table-jms-backend-configuration" title="Table 3.5. JMS backend configuration">Table 3.5, “JMS backend configuration”</a> for additional
            configuration options and <a class="xref" href="search-configuration.html#jms-backend" title="3.6. JMS Master/Slave configuration">Section 3.6, “JMS Master/Slave configuration”</a> for a
            more detailed descripton of this
            setup.</p><p><code class="literal">jgroupsMaster</code> or
            <code class="literal">jgroupsSlave</code>: Backend using <a class="ulink" href="http://www.jgroups.org/">JGroups</a> as communication
            layer. See <a class="xref" href="search-configuration.html#table-jgroups-backend-configuration" title="Table 3.6. JGroups backend configuration">Table 3.6, “JGroups backend configuration”</a>
            for additional configuration options and <a class="xref" href="search-configuration.html#jgroups-backend" title="3.7. JGroups Master/Slave configuration">Section 3.7, “JGroups Master/Slave configuration”</a> for a more detailed description of
            this setup.</p><p><code class="literal">blackhole</code>: Mainly a
            test/developer setting which ignores all indexing
            work</p><p>You can also specify the fully qualified name of
            a class implementing
            <code class="classname">BackendQueueProcessorFactory</code>. This way you
            can implement your own communication layer. The implementation is
            responsilbe for returning a <code class="classname">Runnable</code>
            instance which on execution will process the index
            work.</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="table-jms-backend-configuration"/><p class="title"><b>Table 3.5. JMS backend configuration</b></p><div class="table-contents"><table summary="JMS backend configuration" border="1"><colgroup><col/><col/></colgroup><tbody><tr><td><span class="bold"><strong>Property</strong></span></td><td><span class="bold"><strong>Description</strong></span></td></tr><tr><td><code class="literal">hibernate.search.worker.jndi.*</code></td><td>Defines the JNDI properties to initiate the InitialContext
            (if needed). JNDI is only used by the JMS back end.</td></tr><tr><td><code class="literal">hibernate.search.worker.jms.connection_factory</code></td><td>Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS connection factory from
            (<code class="literal">/ConnectionFactory</code> by default in JBoss
            AS)</td></tr><tr><td><code class="literal">hibernate.search.worker.jms.queue</code></td><td>Mandatory for the JMS back end. Defines the JNDI name to
            lookup the JMS queue from. The queue will be used to post work
            messages.</td></tr></tbody></table></div></div><br class="table-break"/><div class="table"><a id="table-jgroups-backend-configuration"/><p class="title"><b>Table 3.6. JGroups backend configuration</b></p><div class="table-contents"><table summary="JGroups backend configuration" border="1"><colgroup><col/><col/></colgroup><tbody><tr><td><span class="bold"><strong>Property</strong></span></td><td><span class="bold"><strong>Description</strong></span></td></tr><tr><td><code class="literal">hibernate.search.worker.jgroups.clusterName</code></td><td>Optional for JGroups back end. Defines the name of JGroups
            channel.</td></tr><tr><td><code class="literal">hibernate.search.worker.jgroups.configurationFile</code></td><td>Optional JGroups network stack configuration. Defines the
            name of a JGroups configuration file, which must exist on
            classpath.</td></tr><tr><td><code class="literal">hibernate.search.worker.jgroups.configurationXml</code></td><td>Optional JGroups network stack configuration. Defines a
            String representing JGroups configuration as XML.</td></tr><tr><td><code class="literal">hibernate.search.worker.jgroups.configurationString</code></td><td>Optional JGroups network stack configuration. Provides
            JGroups configuration in plain text.</td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>As you probably noticed, some of the shown properties are
      correlated which means that not all combinations of property values make
      sense. In fact you can end up with a non-functional configuration. This
      is especially true for the case that you provide your own
      implementations of some of the shown interfaces. Make sure to study the
      existing code before you write your own <code class="classname">Worker</code> or
      <code class="classname">BackendQueueProcessorFactory</code>
      implementation.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="jms-backend"/>3.6. JMS Master/Slave configuration</h2></div></div></div><p>This section describes in greater detail how to configure the
    Master/Slave Hibernate Search architecture.</p><div class="mediaobject" align="center"><img src="jms-backend.png" align="middle"/><div class="caption"><p>JMS back end configuration.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1561"/>3.6.1. Slave nodes</h3></div></div></div><p>Every index update operation is sent to a JMS queue. Index
      querying operations are executed on a local index copy.</p><div class="example"><a id="d0e1566"/><p class="title"><b>Example 3.6. JMS Slave configuration</b></p><div class="example-contents"><pre class="programlisting">### slave configuration

## DirectoryProvider
# (remote) master location
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local copy location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-slave

## Backend configuration
hibernate.search.worker.backend = jms
hibernate.search.worker.jms.connection_factory = /ConnectionFactory
hibernate.search.worker.jms.queue = queue/hibernatesearch
#optional jndi configuration (check your JMS provider for more information)

## Optional asynchronous execution strategy
# hibernate.search.worker.execution = async
# hibernate.search.worker.thread_pool.size = 2
# hibernate.search.worker.buffer_queue.max = 50</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>A file system local copy is recommended for faster search
        results.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>The refresh period should be higher that the expected copy
        time.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1577"/>3.6.2. Master node</h3></div></div></div><p>Every index update operation is taken from a JMS queue and
      executed. The master index is copied on a regular basis.</p><div class="example"><a id="d0e1582"/><p class="title"><b>Example 3.7. JMS Master configuration</b></p><div class="example-contents"><pre class="programlisting">### master configuration

## DirectoryProvider
# (remote) master location where information is copied to
hibernate.search.default.sourceBase = /mnt/mastervolume/lucenedirs/mastercopy

# local master location
hibernate.search.default.indexBase = /Users/prod/lucenedirs

# refresh every half hour
hibernate.search.default.refresh = 1800

# appropriate directory provider
hibernate.search.default.directory_provider = filesystem-master

## Backend configuration
#Backend is the default lucene one</pre></div></div><br class="example-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>The refresh period should be higher that the expected time
        copy.</p></div><p>In addition to the Hibernate Search framework configuration, a
      Message Driven Bean has to be written and set up to process the index
      works queue through JMS.</p><div class="example"><a id="d0e1592"/><p class="title"><b>Example 3.8. Message Driven Bean processing the indexing queue</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">MessageDriven</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">activationConfig&nbsp;</span><!-- <br/> --><span class="java_operator">=</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">ActivationConfigProperty</span><span class="java_separator">(</span><span class="java_plain">propertyName</span><span class="java_operator">=</span><span class="java_literal">&quot;destinationType&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;propertyValue</span><span class="java_operator">=</span><span class="java_literal">&quot;javax.jms.Queue&quot;</span><span class="java_separator">),</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">ActivationConfigProperty</span><span class="java_separator">(</span><span class="java_plain">propertyName</span><span class="java_operator">=</span><span class="java_literal">&quot;destination&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;propertyValue</span><span class="java_operator">=</span><span class="java_literal">&quot;queue/hibernatesearch&quot;</span><span class="java_separator">),</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">ActivationConfigProperty</span><span class="java_separator">(</span><span class="java_plain">propertyName</span><span class="java_operator">=</span><span class="java_literal">&quot;DLQMaxResent&quot;</span><span class="java_separator">,</span><span class="java_plain">&nbsp;propertyValue</span><span class="java_operator">=</span><span class="java_literal">&quot;1&quot;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_keyword">class</span><span class="java_plain">&nbsp;</span><span class="java_type">MDBSearchController</span><span class="java_plain">&nbsp;</span><span class="java_keyword">extends</span><span class="java_plain">&nbsp;</span><span class="java_type">AbstractJMSHibernateSearchController</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">implements</span><span class="java_plain">&nbsp;</span><span class="java_type">MessageListener</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;@</span><span class="java_type">PersistenceContext</span><span class="java_plain">&nbsp;</span><span class="java_type">EntityManager</span><span class="java_plain">&nbsp;em</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">method&nbsp;retrieving&nbsp;the&nbsp;appropriate&nbsp;session</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">protected</span><span class="java_plain">&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;getSession</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">return</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">Session</span><span class="java_separator">)</span><span class="java_plain">&nbsp;em</span><span class="java_separator">.</span><span class="java_plain">getDelegate</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">potentially&nbsp;close&nbsp;the&nbsp;session&nbsp;opened&nbsp;in&nbsp;#getSession</span><span class="java_separator">(),</span><span class="java_plain">&nbsp;not&nbsp;needed&nbsp;here</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">protected</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;cleanSessionIfNeeded</span><span class="java_separator">(</span><span class="java_type">Session</span><span class="java_plain">&nbsp;session</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">}</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>This example inherits from the abstract JMS controller class
      available in the Hibernate Search source code and implements a JavaEE 5
      MDB. This implementation is given as an example and can be adjusted to
      make use of non Java EE Message Driven Beans. For more information about
      the <code class="methodname">getSession()</code> and
      <code class="methodname">cleanSessionIfNeeded()</code>, please check
      <code class="classname">AbstractJMSHibernateSearchController</code>'s
      javadoc.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="jgroups-backend"/>3.7. JGroups Master/Slave configuration</h2></div></div></div><p>This section describes how to configure the JGroups Master/Slave
    back end. The configuration examples illustrated in <a class="xref" href="search-configuration.html#jms-backend" title="3.6. JMS Master/Slave configuration">Section 3.6, “JMS Master/Slave configuration”</a> also apply here, only a different backend
    (<code class="constant">hibernate.search.worker.backend</code>) needs to be
    set.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1618"/>3.7.1. Slave nodes</h3></div></div></div><p>Every index update operation is sent through a JGroups channel to
      the master node. Index querying operations are executed on a local index
      copy.</p><div class="example"><a id="d0e1623"/><p class="title"><b>Example 3.9. JGroups Slave configuration</b></p><div class="example-contents"><pre class="programlisting">### slave configuration
hibernate.search.worker.backend = jgroupsSlave     </pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1628"/>3.7.2. Master node</h3></div></div></div><p>Every index update operation is taken from a JGroups channel and
      executed. The master index is copied on a regular basis.</p><div class="example"><a id="d0e1633"/><p class="title"><b>Example 3.10. JGroups Master configuration</b></p><div class="example-contents"><pre class="programlisting">### master configuration
hibernate.search.worker.backend = jgroupsMaster   </pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1638"/>3.7.3. JGroups channel configuration</h3></div></div></div><p>Optionally the configuration for the JGroups transport protocols
      and channel name can be defined and applied to master and slave nodes.
      There are several ways to configure the JGroups transport details. You
      can either set the
      <code class="constant">hibernate.search.worker.backend.jgroups.configurationFile</code>
      property and specify a file containing the JGroups configuration or you
      can use the property
      <code class="constant">hibernate.search.worker.backend.jgroups.configurationXml</code>
      or
      <code class="constant">hibernate.search.worker.backend.jgroups.configurationString</code>
      to directly embed either the xml or string JGroups configuration into
      your Hibernate configuration file. All three options are shown in <a class="xref" href="search-configuration.html#example-jgroup-xml-configuration" title="Example 3.11. JGroups transport protocol configuration">Example 3.11, “JGroups transport protocol configuration”</a>.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>If no property is explicitly specified it is assumed that the
        JGroups default configuration file <code class="literal">flush-udp.xml</code> is
        used. </p></div><div class="example"><a id="example-jgroup-xml-configuration"/><p class="title"><b>Example 3.11. JGroups transport protocol configuration</b></p><div class="example-contents"><pre class="programlisting">## JGroups configuration options
# OPTION 1 - udp.xml file needs to be located in the classpath
hibernate.search.worker.backend.jgroups.configurationFile = udp.xml

# OPTION 2 - protocol stack configuration provided in XML format
hibernate.search.worker.backend.jgroups.configurationXml =

&lt;config xmlns="urn:org:jgroups"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="urn:org:jgroups file:schema/JGroups-2.8.xsd"&gt;
&lt;UDP
mcast_addr="${jgroups.udp.mcast_addr:228.10.10.10}"
mcast_port="${jgroups.udp.mcast_port:45588}"
tos="8"
thread_naming_pattern="pl"
thread_pool.enabled="true"
thread_pool.min_threads="2"
thread_pool.max_threads="8"
thread_pool.keep_alive_time="5000"
thread_pool.queue_enabled="false"
thread_pool.queue_max_size="100"
thread_pool.rejection_policy="Run"/&gt;
&lt;PING timeout="1000" num_initial_members="3"/&gt;
&lt;MERGE2 max_interval="30000" min_interval="10000"/&gt;
&lt;FD_SOCK/&gt;
&lt;FD timeout="3000" max_tries="3"/&gt;
&lt;VERIFY_SUSPECT timeout="1500"/&gt;
&lt;pbcast.STREAMING_STATE_TRANSFER/&gt;
&lt;pbcast.FLUSH timeout="0"/&gt;
&lt;/config&gt;

# OPTION 3 - protocol stack configuration provided in "old style" jgroups format
hibernate.search.worker.backend.jgroups.configurationString =

UDP(mcast_addr=228.1.2.3;mcast_port=45566;ip_ttl=32):PING(timeout=3000;
num_initial_members=6):FD(timeout=5000):VERIFY_SUSPECT(timeout=1500):
pbcast.NAKACK(gc_lag=10;retransmit_timeout=3000):UNICAST(timeout=5000):
FRAG:pbcast.GMS(join_timeout=3000;shun=false;print_local_addr=true) </pre></div></div><br class="example-break"/><p>In this JGroups master/slave configuration nodes communicate over
      a JGroups channel. The default channel name is
      <code class="literal">HSearchCluster</code> which can be configured as seen in
      <a class="xref" href="search-configuration.html#example-jgroups-channel-name" title="Example 3.12. JGroups channel name configuration">Example 3.12, “JGroups channel name configuration”</a>.</p><div class="example"><a id="example-jgroups-channel-name"/><p class="title"><b>Example 3.12. JGroups channel name configuration</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.worker.backend.jgroups.clusterName = Hibernate-Search-Cluster       </pre></div></div><br class="example-break"/></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="infinispan-directories"/>3.8. Infinispan Directory configuration</h2></div></div></div><p>Infinispan is a distributed scalable, highly available data grid
    platform which supports autodiscovery of peer nodes. It is possible to
    store the Lucene index in Infinispan, making it easy to setup a clustering
    configuration with Hibernate Search and having updates to the index
    available on other nodes very quickly.</p><p>This section describes in greater detail how to configure Hibernate
    Search to use an Infinispan Lucene Directory.</p><p>Using an Infinispan Directory the index is stored in memory and
    shared across multiple nodes. It is considered a single directory across
    all participating nodes. If a node updates the index, all other nodes are
    affected as well. Updates on one node can be immediately searched for in
    the whole cluster.</p><p>The default configuration replicates all data defining the index
    across all nodes, thus consuming a significant amount of memory. For large
    indexes it's suggested to enable data distribution, so that each piece of
    information is replicated to a subset of all cluster members. </p><p>It is also possible to offload part or most information to a single
    centralized <code class="literal">CacheStore</code>, such as plain filesystem,
    Amazon S3, Cassandra, Berkley DB, JDBC standard databases. You can also
    have a <code class="literal">CacheStore</code> on each node or chain cachestores.
    See the <a class="ulink" href="http://www.jboss.org/infinispan/"> Infinispan
    documentation</a> for all options and configuration details.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1699"/>3.8.1. Requirements</h3></div></div></div><p>Infinispan requires Java 6 and an updated version of JGroups. To
      use the Infinispan directory via maven, add the following
      dependencies:</p><div class="example"><a id="d0e1704"/><p class="title"><b>Example 3.13. Maven dependencies for Hibernate Search</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="XML"><!-- XML : generated by JHighlight v1.0 (http://jhighlight.dev.java.net) -->
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dependency</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">groupId</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.hibernate</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">groupId</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">artifactId</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">hibernate-search</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">artifactId</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">version</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">3.3.0.Final</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">version</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dependency</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">dependency</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">groupId</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">org.hibernate</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">groupId</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">artifactId</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">hibernate-search-infinispan</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">artifactId</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_plain">&nbsp;&nbsp;&nbsp;</span><span class="xml_tag_symbols">&lt;</span><span class="xml_tag_name">version</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain">3.3.0.Final</span><span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">version</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
<span class="xml_tag_symbols">&lt;/</span><span class="xml_tag_name">dependency</span><span class="xml_tag_symbols">&gt;</span><span class="xml_plain"></span><br />
</pre></div></div><br class="example-break"/><p>For the non-maven users, add
      <code class="literal">hibernate-search-infinispan.jar</code>,
      <code class="literal">infinispan-lucene-directory.jar</code> and
      <code class="literal">infinispan-core.jar</code> to your application classpath.
      These last two jars are distributed by <a class="ulink" href="http://sourceforge.net/projects/infinispan/files/">Infinispan</a>.
      Also make sure to update JGroups to a version matching the Infinispan
      package. The version normally distributed with Hibernate Search is older
      to maintain Java 5 compatibility.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1723"/>3.8.2. Architecture</h3></div></div></div><p>Even when using an Infinispan directory it's still recommended to
      use the JMS Master/Slave or JGroups backend, because in Infinispan all
      nodes will share the same index and it is likely that
      <code class="classname">IndexWriter</code>s being active on different nodes will
      try to acquire the lock on the same index. So instead of sending updates
      directly to the index, it is recommended to send it to a JMS queue or
      JGroups channel and have a single node apply all changes on behalf of
      all other nodes.</p><p>To configure a JMS slave only the backend must be replaced, the
      directory provider must be set to <code class="literal">infinispan</code>; set the
      same directory provider on the master, they will connect without the
      need to setup the copy job across nodes. Using the JGroups backend is
      very similar, just combine the backend configuration with the
      <code class="literal">infinispan</code> directory provider.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1739"/>3.8.3. Infinispan Configuration</h3></div></div></div><p>To use Infinispan, a <code class="classname">CacheManager</code> must be
      started from an Infinispan configuration file. Hibernate Search can take
      and reuse an existing <code class="classname">CacheManager,</code> look it up
      via JNDI, or start a new one. In the latter case Hibernate Search will
      start and stop it ( closing occurs at
      <code class="classname">SessionFactory</code> close).</p><p>To use and existing <code class="classname">CacheManager</code> from JNDI
      (optional parameter):</p><pre class="programlisting">hibernate.search.infinispan.cachemanager_jndiname = [jndiname]</pre><p>To start a new <code class="classname">CacheManager</code> from a
      configuration file (optional parameter):</p><pre class="programlisting">hibernate.search.infinispan.configuration_resourcename = [infinispan configuration filename]</pre><p>If both parameters are defined, JNDI will have priority. If none
      of these is defined, Hibernate Search will use the example Infinispan
      configuration provided in the
      <code class="literal">hibernate-search-infinispan.jar</code></p><p>As mentioned in infinispan configuration in <a class="xref" href="search-configuration.html#directory-provider-table" title="Table 3.1. List of built-in DirectoryProviders">Table 3.1, “List of built-in
      DirectoryProviders”</a>, each index actually makes use of
      three caches, so three different caches should be configured as shown in
      the <code class="literal"> default-hibernatesearch-infinispan.xml</code> provided
      in the <code class="literal">hibernate-search-infinispan.jar</code>. Several
      indexes can share the same caches, they are differentiated by using the
      index name as it is the case with the other Directory
      implementations.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="configuration-reader-strategy"/>3.9. Reader strategy configuration</h2></div></div></div><p>The different reader strategies are described in <a class="xref" href="search-architecture.html#search-architecture-readerstrategy" title="2.3. Reader strategy">Reader strategy</a>. Out of the box strategies
    are:</p><div class="itemizedlist"><ul><li><p><code class="literal">shared</code>: share index readers across several
        queries. This strategy is the most efficient.</p></li><li><p><code class="literal">not-shared</code>: create an index reader for each
        individual query</p></li></ul></div><p>The default reader strategy is <code class="literal">shared</code>. This can
    be adjusted:</p><pre class="programlisting">hibernate.search.reader.strategy = not-shared</pre><p>Adding this property switches to the <code class="literal">not-shared</code>
    strategy.</p><p>Or if you have a custom reader strategy:</p><pre class="programlisting">hibernate.search.reader.strategy = my.corp.myapp.CustomReaderProvider</pre><p>where <code class="classname">my.corp.myapp.CustomReaderProvider</code> is
    the custom strategy implementation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="lucene-indexing-performance"/>3.10. Tuning Lucene indexing performance</h2></div></div></div><p>Hibernate Search allows you to tune the Lucene indexing performance
    by specifying a set of parameters which are passed through to underlying
    Lucene <code class="literal">IndexWriter</code> such as
    <code class="literal">mergeFactor</code>, <code class="literal">maxMergeDocs</code> and
    <code class="literal">maxBufferedDocs</code>. You can specify these parameters
    either as default values applying for all indexes, on a per index basis,
    or even per shard.</p><p>There are two sets of parameters allowing for different performance
    settings depending on the use case. During indexing operations triggered
    by database modifications, the parameters are grouped by the
    <code class="literal">transaction</code> keyword: </p><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.transaction.&lt;parameter_name&gt;</pre><p>
    When indexing occurs via <code class="literal">FullTextSession.index()</code> or via
    a <code class="classname">MassIndexer</code> (see <a class="xref" href="manual-index-changes.html#search-batchindex" title="6.3. Rebuilding the whole index">Section 6.3, “Rebuilding the whole index”</a>), the used properties are those grouped
    under the <code class="literal">batch</code> keyword: </p><pre class="programlisting">hibernate.search.[default|&lt;indexname&gt;].indexwriter.batch.&lt;parameter_name&gt;</pre><p>If no value is set for a <code class="literal">batch</code> value in a
    specific shard configuration, Hibernate Search will look at the index
    section, then at the default section.</p><div class="example"><a id="example-performamce-option-configuration"/><p class="title"><b>Example 3.14. Example performance option configuration</b></p><div class="example-contents"><pre class="programlisting">hibernate.search.Animals.2.indexwriter.transaction.max_merge_docs 10
hibernate.search.Animals.2.indexwriter.transaction.merge_factor 20
hibernate.search.default.indexwriter.batch.max_merge_docs 100</pre></div></div><p><br class="example-break"/> The configuration in <a class="xref" href="search-configuration.html#example-performamce-option-configuration" title="Example 3.14. Example performance option configuration">Example 3.14, “Example performance option configuration”</a> will result in these
    settings applied on the second shard of the <code class="classname">Animal</code>
    index:</p><div class="itemizedlist"><ul><li><p><code class="literal">transaction.max_merge_docs</code> = 10</p></li><li><p><code class="literal">batch.max_merge_docs</code> = 100</p></li><li><p><code class="literal">transaction.merge_factor</code> = 20</p></li><li><p><code class="literal">batch.merge_factor</code> = Lucene default</p></li></ul></div><p>All other values will use the defaults defined in Lucene.</p><p>The default for all values is to leave them at Lucene's own default.
    The values listed in <a class="xref" href="search-configuration.html#table-performance-parameters" title="Table 3.7. List of indexing performance and behavior properties">Table 3.7, “List of indexing performance and behavior properties”</a>
    depend for this reason on the version of Lucene you are using. The values
    shown are relative to version <code class="literal">2.4</code>. For more information
    about Lucene indexing performance, please refer to the Lucene
    documentation.</p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>Previous versions had the <code class="literal">batch</code> parameters
      inherit from <code class="literal">transaction</code> properties. This needs now
      to be explicitly set.</p></div><div class="table"><a id="table-performance-parameters"/><p class="title"><b>Table 3.7. List of indexing performance and behavior properties</b></p><div class="table-contents"><table summary="List of indexing performance and behavior properties" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">Property</th><th align="center">Description</th><th align="center">Default Value</th></tr></thead><tbody><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].exclusive_index_use</code></td><td><p>Set to <code class="literal">true</code> when no other process
            will need to write to the same index. This will enable Hibernate
            Search to work in exlusive mode on the index and improve
            performance when writing changes to the index.</p></td><td><code class="literal">false</code> (releases locks as soon as
            possible)</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_delete_terms</code></td><td><p>Determines the minimal number of delete terms
            required before the buffered in-memory delete terms are applied
            and flushed. If there are documents buffered in memory at the
            time, they are merged and a new segment is created.</p></td><td>Disabled (flushes by RAM usage)</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_buffered_docs</code></td><td><p>Controls the amount of documents buffered in memory
            during indexing. The bigger the more RAM is
            consumed.</p></td><td>Disabled (flushes by RAM usage)</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_field_length</code></td><td><p>The maximum number of terms that will be indexed for
            a single field. This limits the amount of memory required for
            indexing so that very large data will not crash the indexing
            process by running out of memory. This setting refers to the
            number of running terms, not to the number of different
            terms.</p> <p>This silently truncates large documents,
            excluding from the index all terms that occur further in the
            document. If you know your source documents are large, be sure to
            set this value high enough to accommodate the expected size. If
            you set it to Integer.MAX_VALUE, then the only limit is your
            memory, but you should anticipate an OutOfMemoryError. </p>
            <p>If setting this value in <code class="literal">batch</code>
            differently than in <code class="literal">transaction</code> you may get
            different data (and results) in your index depending on the
            indexing mode.</p></td><td>10000</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].max_merge_docs</code></td><td><p>Defines the largest number of documents allowed in a
            segment. Larger values are best for batched indexing and speedier
            searches. Small values are best for transaction
            indexing.</p></td><td>Unlimited (Integer.MAX_VALUE)</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].merge_factor</code></td><td><p>Controls segment merge frequency and size. </p>
            <p>Determines how often segment indexes are merged when
            insertion occurs. With smaller values, less RAM is used while
            indexing, and searches on unoptimized indexes are faster, but
            indexing speed is slower. With larger values, more RAM is used
            during indexing, and while searches on unoptimized indexes are
            slower, indexing is faster. Thus larger values (&gt; 10) are best
            for batch index creation, and smaller values (&lt; 10) for indexes
            that are interactively maintained. The value must no be lower than
            2.</p></td><td>10</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].ram_buffer_size</code></td><td><p>Controls the amount of RAM in MB dedicated to
            document buffers. When used together max_buffered_docs a flush
            occurs for whichever event happens first.</p> <p>Generally
            for faster indexing performance it's best to flush by RAM usage
            instead of document count and use as large a RAM buffer as you
            can.</p></td><td>16 MB</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].term_index_interval</code></td><td><p>Expert: Set the interval between indexed
            terms.</p> <p>Large values cause less memory to be used by
            IndexReader, but slow random-access to terms. Small values cause
            more memory to be used by an IndexReader, and speed random-access
            to terms. See Lucene documentation for more
            details.</p></td><td>128</td></tr><tr><td><code class="literal">hibernate.search.[default|&lt;indexname&gt;].indexwriter.[transaction|batch].use_compound_file</code></td><td>The advantage of using the compound file format is that
            less file descriptors are used. The disadvantage is that indexing
            takes more time and temporary disk space. You can set this
            parameter to <code class="literal">false</code> in an attempt to improve the
            indexing time, but you could run out of file descriptors if
            <code class="literal">mergeFactor</code> is also large.<p>Boolean
            parameter, use "<code class="literal">true</code>" or
            "<code class="literal">false</code>". The default value for this option is
            <code class="literal">true</code>.</p></td><td>true</td></tr></tbody></table></div></div><br class="table-break"/><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>When your architecture permits it, always set
      <code class="literal">hibernate.search.default.exclusive_index_use=true</code> as
      it greatly improves efficiency in index writing.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="tip"><h2>Tip</h2><p>To tune the indexing speed it might be useful to time the object
      loading from database in isolation from the writes to the index. To
      achieve this set the <code class="literal">blackhole</code> as worker backend and
      start you indexing routines. This backend does not disable Hibernate
      Search: it will still generate the needed changesets to the index, but
      will discard them instead of flushing them to the index. In contrast to
      setting the <code class="literal">hibernate.search.indexing_strategy</code> to
      <code class="literal">manual</code>, using <code class="literal">blackhole</code> will
      possibly load more data from the database. because associated entities
      are re-indexed as well.</p><pre class="programlisting">hibernate.search.worker.backend blackhole</pre><p>The recommended approach is to focus first on optimizing the
      object loading, and then use the timings you achieve as a baseline to
      tune the indexing process.</p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="warning"><h2>Warning</h2><p>The <code class="literal">blackhole</code> backend is not meant to be used
      in production, only as a tool to identify indexing bottlenecks.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="search-configuration-directory-lockfactories"/>3.11. LockFactory configuration</h2></div></div></div><p>Lucene <code class="classname">Directory</code>s have default locking
    strategies which work well for most cases, but it's possible to specify
    for each index managed by Hibernate Search which
    <code class="classname">LockingFactory</code> you want to use.</p><p>Some of these locking strategies require a filesystem level lock and
    may be used even on RAM based indexes, but this is not recommended and of
    no practical use.</p><p>To select a locking factory, set the
    <code class="literal">hibernate.search.&lt;index&gt;.locking_strategy</code> option
    to one of <code class="literal">simple</code>, <code class="literal">native</code>,
    <code class="literal">single</code> or <code class="literal">none</code>. Alternatively set it
    to the fully qualified name of an implementation of
    <code class="literal">org.hibernate.search.store.LockFactoryFactory</code>.</p><div class="table"><a id="search-configuration-directory-lockfactories-table"/><p class="title"><b>Table 3.8. List of available LockFactory implementations</b></p><div class="table-contents"><table summary="List of available LockFactory implementations" border="1"><colgroup><col/><col/><col/></colgroup><thead><tr><th align="center">name</th><th align="center">Class</th><th align="center">Description</th></tr></thead><tbody><tr><td>simple</td><td>org.apache.lucene.store.SimpleFSLockFactory</td><td><p>Safe implementation based on Java's File API, it
            marks the usage of the index by creating a marker file.</p>
            <p>If for some reason you had to kill your application, you
            will need to remove this file before restarting it.</p>
            <p>This is the default implementation for the
            <code class="literal">filesystem</code>,
            <code class="literal">filesystem-master</code> and
            <code class="literal">filesystem-slave</code> directory
            providers.</p></td></tr><tr><td>native</td><td>org.apache.lucene.store.NativeFSLockFactory</td><td><p>As does <code class="literal">simple</code> this also marks the
            usage of the index by creating a marker file, but this one is
            using native OS file locks so that even if your application
            crashes the locks will be cleaned up.</p> <p>This
            implementation has known problems on NFS.</p></td></tr><tr><td>single</td><td>org.apache.lucene.store.SingleInstanceLockFactory</td><td><p>This LockFactory doesn't use a file marker but is a
            Java object lock held in memory; therefore it's possible to use it
            only when you are sure the index is not going to be shared by any
            other process.</p> <p>This is the default implementation for
            the <code class="literal">ram</code> directory provider.</p></td></tr><tr><td>none</td><td>org.apache.lucene.store.NoLockFactory</td><td><p>All changes to this index are not coordinated by any
            lock; test your application carefully and make sure you know what
            it means.</p></td></tr></tbody></table></div></div><br class="table-break"/><p>Configuration example:</p><pre class="programlisting">hibernate.search.default.locking_strategy simple
hibernate.search.Animals.locking_strategy native
hibernate.search.Books.locking_strategy org.custom.components.MyLockingFactory</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2189"/>3.12. Exception Handling Configuration</h2></div></div></div><p>Hibernate Search allows you to configure how exceptions are handled
    during the indexing process. If no configuration is provided then
    exceptions are logged to the log output by default. It is possible to
    explicitly declare the exception logging mechanism as seen below:</p><pre class="programlisting">hibernate.search.error_handler log</pre><p>The
    default exception handling occurs for both synchronous and asynchronous
    indexing. Hibernate Search provides an easy mechanism to override the
    default error handling implementation.</p><p>In order to provide your own implementation you must implement the
    <code class="classname">ErrorHandler</code> interface, which provides the
    <code class="code">handle(ErrorContext context)</code> method.
    <code class="code">ErrorContext</code> provides a reference to the primary
    <code class="code">LuceneWork</code> instance, the underlying exception and any
    subsequent <code class="code">LuceneWork</code> instances that could not be processed
    due to the primary exception.</p><pre class="programlisting">public interface ErrorContext  {
   List&lt;LuceneWork&gt; getFailingOperations();
   LuceneWork getOperationAtFault();
   Throwable getThrowable();
   boolean hasErrors();
}</pre><p> To register this error handler with Hibernate Search you must
    declare the fully qualified classname of your
    <code class="classname">ErrorHandler</code> implementation in the configuration
    properties:</p><pre class="programlisting">hibernate.search.error_handler CustomerErrorHandler</pre></div></div><HR xmlns=""/><a xmlns="" href=""/><ul class="docnav"><li class="previous"><a accesskey="p" href="search-architecture.html"><strong>Prev</strong>Chapter 2. Architecture</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="search-mapping.html"><strong>Next</strong>Chapter 4. Mapping entities to the index structure</a></li></ul><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("search"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>