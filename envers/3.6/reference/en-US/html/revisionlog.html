<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 4. Logging data for revisions</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="Hibernate Envers - Easy Entity Auditing"/><link rel="up" href="index.html" title="Hibernate Envers - Easy Entity Auditing"/><link rel="prev" href="configuration.html" title="Chapter 3. Configuration"/><link rel="next" href="queries.html" title="Chapter 5. Queries"/><link rel="copyright" href="Legal_Notice.html" title="Legal Notice"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="configuration.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="queries.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="revisionlog"/>Chapter 4. Logging data for revisions</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="revisionlog.html#envers-tracking-modified-entities-revchanges">4.1. Tracking entity names modified during revisions</a></span></dt></dl></div><p>
        Envers provides an easy way to log additional data for each revision. You simply need
        to annotate one entity with <code class="literal">@RevisionEntity</code>, and a new instance of
        this entity will be persisted when a new revision is created (that is, whenever an
        audited entity is modified). As revisions are global, you can have at most one revisions entity.
    </p><p>
        Please note that the revision entity must be a mapped Hibernate entity.
    </p><p>
        This entity must have at least two properties:
    </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="orderedlist"><ol><li><p>
                an integer- or long-valued property, annotated with <code class="literal">@RevisionNumber</code>. Most
                often, this will be an auto-generated primary key.
            </p></li><li><p>
                a long- or j.u.Date- valued property, annotated with <code class="literal">@RevisionTimestamp</code>. Value of
                this property will be automatically set by Envers.
            </p></li></ol></div><p>
        You can either add these properties to your entity, or extend
        <code class="literal">org.hibernate.envers.DefaultRevisionEntity</code>, which already has those two properties.
    </p><p>
        When using a <code class="literal">Date</code>, instead of a <code class="literal">long/Long</code> for the revision timestamp,
        take care not to use a mapping of the property which will loose precision (for example, using
        <code class="literal">@Temporal(DATE)</code> is wrong, as it doesn't store the time information, so many of your
        revisions will appear to happen at exactly the same time). A good choice is a
        <code class="literal">@Temporal(TIMESTAMP)</code>.
    </p><p>
        To fill the entity with additional data, you'll need to implement the
        <code class="literal">org.jboss.envers.RevisionListener</code> interface. Its newRevision method will
        be called when a new revision is created, before persisting the revision entity.
        The implementation should be stateless and thread-safe. The listener then has to be
        attached to the revisions entity by specifying it as a parameter to the
        <code class="literal">@RevisionEntity</code> annotation.
    </p><p>
        Alternatively, you can use the <code class="literal">getCurrentRevision</code> method of the 
        <code class="literal">AuditReader</code> interface to obtain the current revision, and fill it with desired information.
        The method has a <code class="literal">persist</code> parameter specifying, if the revision entity should be persisted
        before returning. If set to <code class="literal">true</code>, the revision number will be available in the returned
        revision entity (as it is normally generated by the database), but the revision entity will be persisted
        regardless of wheter there are any audited entities changed. If set to <code class="literal">false</code>, the revision
        number will be <code class="literal">null</code>, but the revision entity will be persisted only if some audited entities
        have changed.
    </p><p>
        A simplest example of a revisions entity, which with each revision associates the
        username of the user making the change is:
    </p><pre class="programlisting">package org.jboss.envers.example;

import org.hibernate.envers.RevisionEntity;
import org.hibernate.envers.DefaultRevisionEntity;

import javax.persistence.Entity;

@Entity
@RevisionEntity(ExampleListener.class)
public class ExampleRevEntity extends DefaultRevisionEntity {
	private String username;

	public String getUsername() { return username; }
	public void setUsername(String username) { this.username = username; }
}</pre><p>
        Or, if you don't want to extend any class:
    </p><pre class="programlisting">package org.hibernate.envers.example;

import org.hibernate.envers.RevisionNumber;
import org.hibernate.envers.RevisionTimestamp;
import org.hibernate.envers.RevisionEntity;

import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.Entity;

@Entity
@RevisionEntity(ExampleListener.class)
public class ExampleRevEntity {
    @Id
    @GeneratedValue
    @RevisionNumber
    private int id;

    @RevisionTimestamp
    private long timestamp;

    private String username;

    // Getters, setters, equals, hashCode ...
}</pre><p>
        An example listener, which, if used in a JBoss Seam application, stores the
        currently logged in user username:
    </p><pre class="programlisting">package org.hibernate.envers.example;

import org.hibernate.envers.RevisionListener;
import org.jboss.seam.security.Identity;
import org.jboss.seam.Component;

public class ExampleListener implements RevisionListener {
    public void newRevision(Object revisionEntity) {
        ExampleRevEntity exampleRevEntity = (ExampleRevEntity) revisionEntity;
        Identity identity = (Identity) Component.getInstance("org.jboss.seam.security.identity");

        exampleRevEntity.setUsername(identity.getUsername());
    }
}</pre><p>
        Having an "empty" revision entity - that is, with no additional properties except the
        two mandatory ones - is also an easy way to change the names of the table and of the
        properties in the revisions table automatically generated by Envers.
    </p><p>
        In case there is no entity annotated with <code class="literal">@RevisionEntity</code>, a default
        table will be generated, with the name <code class="literal">REVINFO</code>.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="envers-tracking-modified-entities-revchanges"/>4.1. Tracking entity names modified during revisions</h2></div></div></div><p>
            By default entity types that have been changed in each revision are not being tracked. This implies the
            necessity to query all tables storing audited data in order to retrieve changes made during
            specified revision. Users are allowed to implement custom mechanism of tracking modified entity names.
            In this case, they shall pass their own implementation of
            <code class="interfacename">org.hibernate.envers.EntityTrackingRevisionListener</code> interface as the value
            of <code class="interfacename">@org.hibernate.envers.RevisionEntity</code> annotation.
            <code class="interfacename">EntityTrackingRevisionListener</code> interface exposes one method that notifies
            whenever audited entity instance has been added, modified or removed within current revision boundaries.
        </p><div class="example"><a id="d0e604"/><p class="title"><b>Example 4.1. Custom implementation of tracking entity classes modified during revisions</b></p><div class="example-contents"><pre class="programlisting">
                <code class="filename">CustomEntityTrackingRevisionListener.java</code>

public class CustomEntityTrackingRevisionListener
             implements EntityTrackingRevisionListener {
    @Override
    public void entityChanged(Class entityClass, String entityName,
                              Serializable entityId, RevisionType revisionType,
                              Object revisionEntity) {
        String type = entityClass.getName();
        ((CustomTrackingRevisionEntity)revisionEntity).addModifiedEntityType(type);
    }

    @Override
    public void newRevision(Object revisionEntity) {
    }
}</pre><pre class="programlisting">
                <code class="filename">CustomTrackingRevisionEntity.java</code>

@Entity
@RevisionEntity(CustomEntityTrackingRevisionListener.class)
public class CustomTrackingRevisionEntity {
    @Id
    @GeneratedValue
    @RevisionNumber
    private int customId;

    @RevisionTimestamp
    private long customTimestamp;

    @OneToMany(mappedBy="revision", cascade={CascadeType.PERSIST, CascadeType.REMOVE})
    private Set&lt;ModifiedEntityTypeEntity&gt; modifiedEntityTypes =
                                              new HashSet&lt;ModifiedEntityTypeEntity&gt;();

    public void addModifiedEntityType(String entityClassName) {
        modifiedEntityTypes.add(new ModifiedEntityTypeEntity(this, entityClassName));
    }

    ...
}
</pre><pre class="programlisting">
                <code class="filename">ModifiedEntityTypeEntity.java</code>

@Entity
public class ModifiedEntityTypeEntity {
    @Id
    @GeneratedValue
    private Integer id;

    @ManyToOne
    private CustomTrackingRevisionEntity revision;

    private String entityClassName;

    ...
}
</pre><pre class="programlisting">CustomTrackingRevisionEntity revEntity =
    getAuditReader().findRevision(CustomTrackingRevisionEntity.class, revisionNumber);
Set&lt;ModifiedEntityTypeEntity&gt; modifiedEntityTypes = revEntity.getModifiedEntityTypes()</pre></div></div><br class="example-break"/></div></div><HR xmlns=""/><a xmlns="" href="legalnotice.html"><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2004 Red Hat Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="configuration.html"><strong>Prev</strong>Chapter 3. Configuration</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="queries.html"><strong>Next</strong>Chapter 5. Queries</a></li></ul></body></html>