<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 15. Redis (Experimental)</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate OGM, JPA for NoSQL datastores - Reference Documentation" /><meta name="keywords" content="hibernate, ogm, hibernate ogm, nosql, jpa, infinispan, mongodb, neo4j, cassandra, couchdb, ehcache, redis" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/ogm/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" type="text/css" href="css/hibernate.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Hibernate OGM Reference Guide"/><link rel="up" href="index.html" title="Hibernate OGM Reference Guide"/><link rel="prev" href="ch14.html" title="Chapter 14. Cassandra (Experimental)"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-282CVRCQHZ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag(js, new Date());

  gtag(config, G-282CVRCQHZ);
</script>
<!-- /Google Analytics -->
</head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch14.html"><strong>Prev</strong></a></li><li class="next"/></ul><div class="chapter" title="Chapter 15. Redis (Experimental)"><div class="titlepage"><div><div><h2 class="title"><a id="ogm-redis"/>Chapter 15. Redis (Experimental)</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch15.html#ogm-redis-configuration">15.1. Configuring Redis</a></span></dt><dd><dl><dt><span class="section"><a href="ch15.html#ogm-redis-annotation-configuration">15.1.1. Annotation based configuration</a></span></dt></dl></dd><dt><span class="section"><a href="ch15.html#ogm-redis-storage-principles">15.2. Storage principles</a></span></dt><dd><dl><dt><span class="section"><a href="ch15.html#redis-json-mapping">15.2.1. JSON mapping</a></span></dt><dt><span class="section"><a href="ch15.html#redis-hash-mapping">15.2.2. Hash mapping</a></span></dt><dt><span class="section"><a href="ch15.html#associations_6">15.2.3. Associations</a></span></dt></dl></dd><dt><span class="section"><a href="ch15.html#identifiers_5">15.3. Identifiers</a></span></dt><dd><dl><dt><span class="section"><a href="ch15.html#identifier_generation_strategies_6">15.3.1. Identifier generation strategies</a></span></dt></dl></dd><dt><span class="section"><a href="ch15.html#transactions_3">15.4. Transactions</a></span></dt><dt><span class="section"><a href="ch15.html#queries_2">15.5. Queries</a></span></dt><dt><span class="section"><a href="ch15.html#redis_cluster">15.6. Redis Cluster</a></span></dt></dl></div><p><a class="link" href="http://redis.io/">Redis</a> is a key-value datastore
which stores your data in a variety of data structures. Although there is no one-and-only style
how to map data between data structures and Redis, two major styles are are most common:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Storing entities using keys as JSON documents</li><li class="listitem">Storing entities using hashes as key-value pairs</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Support for Redis is considered an EXPERIMENTAL feature as of this release.
In particular you should be prepared for possible changes to the persistent representation of mapped objects in future releases.</p><p>Also be aware of the fact that partial updates using the JSON dialect are unsupported at the moment
Instead always the entire document will be replaced during updates.
This means that fields possibly written by other applications but not mapped to properties in your domain model will get lost.</p><p>The JSON dialect supports two modes for storing associations:
The <code class="literal">ASSOCIATION_DOCUMENT</code> mode should be used with care
as there is potential for lost updates (<a class="link" href="https://hibernate.atlassian.net/browse/OGM-461">OGM-461</a>).
It is recommended to use the <code class="literal">IN_ENTITY</code> mode (which is the default).</p><p>Should you find any bugs or have feature requests for this dialect,
then please open a ticket in the <a class="link" href="https://hibernate.atlassian.net/browse/OGM">OGM issue tracker</a>.</p></div><div class="section" title="15.1. Configuring Redis"><div class="titlepage"><div><div><h2 class="title"><a id="ogm-redis-configuration"/>15.1. Configuring Redis</h2></div></div></div><p>Hibernate OGM uses the <a class="link" href="https://github.com/mp911de/lettuce">lettuce</a> library to talk to Redis,
so you need the client libraries to use Hibernate OGM Redis.</p><p>The following properties are available to configure Redis support in Hibernate OGM:</p><div class="variablelist" title="Redis datastore configuration properties"><p class="title"><strong>Redis datastore configuration properties</strong></p><dl><dt><span class="term">hibernate.ogm.datastore.provider</span></dt><dd>To use Redis as a datastore provider, this property must be set to <code class="literal">redis_experimental</code></dd><dt><span class="term">hibernate.ogm.datastore.grid_dialect</span></dt><dd>The dialect type how Hibernate OGM Redis maps entities and associations within Redis.
The following two dialects exist:
<code class="literal">org.hibernate.ogm.datastore.redis.RedisJsonDialect</code> (store entities as JSON documents within Redis keys.
Associations are mapped to Redis lists/sets) and
<code class="literal">org.hibernate.ogm.datastore.redis.RedisHashDialect</code> (store entities as key-value pairs within Redis hashes.
Associations are mapped as JSON documents to Redis lists/sets)</dd><dt><span class="term">hibernate.ogm.datastore.host</span></dt><dd><p class="simpara">The hostname and port of the Redis instance.
The optional port is concatenated to the host and separated by a colon.
Let’s see a few valid examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">redis.example.com</code></li><li class="listitem"><p class="simpara"><code class="literal">redis.example.com:6379</code></p><p class="simpara">Listing multiple initial hosts for fault tolerance is not supported.
The default value is <code class="literal">127.0.0.1:6379</code>. If left undefined, the default port is <code class="literal">6379</code>.</p></li></ul></div></dd><dt><span class="term">hibernate.ogm.datastore.database</span></dt><dd>The database number to connect to. If left undefined, the default number is <code class="literal">0</code>.
Note that Redis databases are identified with a number from <code class="literal">0</code> to <code class="literal">16</code>.</dd><dt><span class="term">hibernate.ogm.datastore.password</span></dt><dd>The password used to connect to the Redis server.
This property has no default value.</dd><dt><span class="term">hibernate.ogm.redis.ssl</span></dt><dd>Boolean flag to enable SSL connections to Redis. Note that Redis does not support native SSL and SSL is provided
by tools like <a class="link" href="https://www.stunnel.org/">stunnel</a></dd><dt><span class="term">hibernate.ogm.redis.connection_timeout</span></dt><dd>Defines the timeout used by the driver
when the connection to the Redis instance is initiated.
This configuration is expressed in milliseconds.
The default value is <code class="literal">5000</code>.</dd><dt><span class="term">hibernate.ogm.redis.cluster</span></dt><dd>Boolean flag to enable Redis Cluster mode.
It’s strongly recommended to use simple primary and association keys
as composite keys are serialized as JSON which may interfere the slot distribution.
Curly braces within keys are used to denote <a class="link" href="http://redis.io/topics/cluster-spec#keys-hash-tags">hash tags</a> to group keys within one slot.</dd><dt><span class="term">hibernate.ogm.redis.ttl</span></dt><dd>Defines the TTL for entities and associations.
TTL can be configured on entity and association level (see <a class="xref" href="ch15.html#ogm-redis-annotation-configuration" title="15.1.1. Annotation based configuration">Section 15.1.1, “Annotation based configuration”</a>
This property has no default value.</dd><dt><span class="term">hibernate.ogm.error_handler</span></dt><dd>The fully-qualified class name, class object or an instance of <code class="literal">ErrorHandler</code> to get notified upon errors during flushes (see <a class="xref" href="ch06.html#ogm-api-error-handler" title="6.3.1. Acting upon errors during application of changes">Section 6.3.1, “Acting upon errors during application of changes”</a>)</dd><dt><span class="term">hibernate.ogm.datastore.redis.association_storage</span></dt><dd>Defines the way OGM stores association information in Redis.
The following two strategies exist for the JSON dialect (values of the <code class="literal">org.hibernate.ogm.datastore.document.options.AssociationStorageType</code> enum):
<code class="literal">IN_ENTITY</code> (store association information within the entity) and
<code class="literal">ASSOCIATION_DOCUMENT</code> (store association information in a dedicated document per association).
<code class="literal">IN_ENTITY</code> is the default and recommended option
unless the association navigation data is much bigger than the core of the document and leads to performance degradation. The Redis hash dialect supports only the <code class="literal">ASSOCIATION_DOCUMENT</code> strategy.</dd><dt><span class="term">hibernate.ogm.datastore.document.map_storage</span></dt><dd><p class="simpara">Defines the way OGM stores the contents of map-typed associations in Redis.
The following two strategies exist (values of the <code class="literal">org.hibernate.ogm.datastore.document.options.MapStorageType</code> enum):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">BY_KEY</code>: map-typed associations with a single key column which is of type <code class="literal">String</code> will be stored as a sub-document,
organized by the given key; Not applicable for other types of key columns, in which case always <code class="literal">AS_LIST</code> will be used</li><li class="listitem"><code class="literal">AS_LIST</code>: map-typed associations will be stored as an array containing a sub-document for each map entry.
All key and value columns will be contained within the array elements
The default value is <code class="literal">BY_KEY</code>.</li></ul></div></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>When bootstrapping a session factory or entity manager factory programmatically,
you should use the constants accessible via <code class="literal">RedisProperties</code>
when specifying the configuration properties listed above.
Common properties shared between stores are declared on <code class="literal">OgmProperties</code>.
To ease migration between stores, it is recommended to reference these constants directly from there.</p></div><div class="section" title="15.1.1. Annotation based configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ogm-redis-annotation-configuration"/>15.1.1. Annotation based configuration</h3></div></div></div><p>Hibernate OGM allows to configure store-specific options via Java annotations.
When working with the Redis backend, you can specify how associations should be stored
using the <code class="literal">AssociationStorage</code> annotation.
A strategy for storing the contents of map-typed associations can be defined using the <code class="literal">@MapStorage</code> annotation.</p><p>(refer to <a class="xref" href="ch15.html#ogm-redis-storage-principles" title="15.2. Storage principles">Section 15.2, “Storage principles”</a> to learn more about association storage strategies in general).</p><p>The following shows an example:</p><div class="example"><a id="d0e12884"/><p class="title"><strong>Example 15.1. Configuring the association storage strategy using annotations</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
@AssociationStorage(AssociationStorageType.ASSOCIATION_DOCUMENT)
public class Zoo {

    @OneToMany
    private Set&lt;Animal&gt; animals;

    @OneToMany
    private Set&lt;Person&gt; employees;

    @OneToMany
    @AssociationStorage(AssociationStorageType.IN_ENTITY)
    private Set&lt;Person&gt; visitors;

    //...
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e12889"/><p class="title"><strong>Example 15.2. Configuring the TTL/expiry using annotations</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
@TTL(value = 7, unit = TimeUnit.DAYS)
public class Zoo {

    @OneToMany
    private Set&lt;Animal&gt; animals;

    @OneToMany
    private Set&lt;Person&gt; employees;

    //...
}</code></pre></div></div><br class="example-break"/><p>Redis supports a native TTL/expiry mechanism. Keys can expire at a date or after a certain period.
Hibernate OGM allows to specify a TTL value on entities and associations. The TTL is set after persisting
the entity using the <a class="link" href="http://redis.io/commands/pexpire">PEXPIRE</a> command. Every write to Redis will
set a new TTL.</p><p>The annotation on the entity level expresses that all associations of the <code class="literal">Zoo</code>
class should be stored in separate assocation documents.
This setting applies to the <code class="literal">animals</code> and <code class="literal">employees</code> associations.
Only the elements of the <code class="literal">visitors</code> association will be stored in the document of the corresponding <code class="literal">Zoo</code> entity
as per the configuration of that specific property which takes precedence over the entity-level configuration.</p></div></div><div class="section" title="15.2. Storage principles"><div class="titlepage"><div><div><h2 class="title"><a id="ogm-redis-storage-principles"/>15.2. Storage principles</h2></div></div></div><p>Hibernate OGM tries to make the mapping to the underlying datastore as natural as possible
so that third party applications not using Hibernate OGM can still read
and update the same datastore. Hibernate OGM facilitates two styles of data mapping within Redis:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">JSON</li><li class="listitem">Redis Hash</li></ul></div><p>The following describe how entities and associations are mapped to Redis data structures by Hibernate OGM.</p><div class="section" title="15.2.1. JSON mapping"><div class="titlepage"><div><div><h3 class="title"><a id="redis-json-mapping"/>15.2.1. JSON mapping</h3></div></div></div><p>The JSON mapping dialect maps entities to JSON documents and stores the JSON data within Redis keys. A document is self-contained and does not support partial updates.</p><div class="section" title="15.2.1.1. Properties and built-in types"><div class="titlepage"><div><div><h4 class="title"><a id="redis-built-in-types-json"/>15.2.1.1. Properties and built-in types</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Hibernate OGM doesn’t store null values in Redis,
setting a value to null will be the same as removing the field
in the corresponding object in the db.</p></div><p>Hibernate OGM supports by default the following types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.String</code></li></ul></div><pre><code class="language-json">  { "text" : "Hello world!" }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Character</code> (or char primitive)</li></ul></div><pre><code class="language-json">  { "delimiter" : "/" }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Boolean</code> (or boolean primitive)</li></ul></div><pre><code class="language-json">  { "favorite" : true } # default mapping
  { "favorite" : "T" } # if @Type(type = "true_false") is given
  { "favorite" : "Y" } # if @Type(type = "yes_no") is given
  { "favorite" : 1 } # if @Type(type = "numeric_boolean") is given</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Byte</code> (or byte primitive)</li></ul></div><pre><code class="language-json">  { "display_mask" : "70" }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Short</code> (or short primitive)</li></ul></div><pre><code class="language-json">  { "urlPort" : 80 }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Integer</code> (or int primitive)</li></ul></div><pre><code class="language-json">  { "stockCount" : 12309 }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Long</code> (or long primitive)</li></ul></div><pre><code class="language-json">  { "userId" : -6718902786625749549 }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Float</code> (or float primitive)</li></ul></div><pre><code class="language-json">  { "visitRatio" : 10.4 }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Double</code> (or double primitive)</li></ul></div><pre><code class="language-json">  { "tax_percentage" : 12.34 }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.math.BigDecimal</code></li></ul></div><pre><code class="language-json">  { "site_weight" : "21.77" }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.math.BigInteger</code></li></ul></div><pre><code class="language-json">  { "site_weight" : "444" }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.util.Calendar</code></li></ul></div><pre><code class="language-json">  { "creation" : "2014-11-18T15:51:26.252Z" }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.util.Date</code></li></ul></div><pre><code class="language-json">  { "last_update" : "2014-11-18T15:51:26.252Z" }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.util.UUID</code></li></ul></div><pre><code class="language-json">  { "serialNumber" : "71f5713d-69c4-4b62-ad15-aed8ce8d10e0" }</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.util.URL</code></li></ul></div><pre><code class="language-json">  { "url" : "http://www.hibernate.org/" }</code></pre></div><div class="section" title="15.2.1.2. Entities"><div class="titlepage"><div><div><h4 class="title"><a id="entities_7"/>15.2.1.2. Entities</h4></div></div></div><p>Entities are stored as JSON documents and not as BLOBs
which means each entity property will be translated into a document field.
You can use the name property of the <code class="literal">@Table</code> and <code class="literal">@Column</code> annotations
to rename the collections and the document’s fields if you need to.</p><p>Redis has no built-in mechanism for detecting concurrent updates to one and the same document.</p><p>The following shows an example of an entity and its persistent representation in Redis.</p><div class="example"><a id="d0e13071"/><p class="title"><strong>Example 15.3. Example of an entity and its representation in Redis</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class News {

    @Id
    private String id;

    @Version
    @Column(name="version")
    private int version;

    private String title;

    private String description;

    //getters, setters ...
}</code></pre><pre><code class="language-json">{
    "version": 1,
    "title": "On the merits of NoSQL",
    "description": "This paper discuss why NoSQL will save the world for good"
}</code></pre></div></div><br class="example-break"/><p>Redis doesn’t have a concept of "tables";
Instead all values are stored in a unique key.
Thus Hibernate OGM needs to add two additional attributes:</p><div class="example"><a id="d0e13080"/><p class="title"><strong>Example 15.4. Rename field and collection using @Table and @Column</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
@Table(name="Article")
public class News {

    @Id
    @Column(name="code")
    private String id;

    @Version
    @Column(name="revision")
    private int revision;

    private String title;

    @Column(name="desc")
    private String description;

    //getters, setters ...
}</code></pre><pre><code class="language-json">{
    "revision": 1,
    "title": "On the merits of NoSQL",
    "desc": "This paper discuss why NoSQL will save the world for good"
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="15.2.1.3. Embedded objects and collections"><div class="titlepage"><div><div><h4 class="title"><a id="embedded_objects_and_collections_6"/>15.2.1.3. Embedded objects and collections</h4></div></div></div><p>Hibernate OGM stores elements annotated with <code class="literal">@Embedded</code>
or <code class="literal">@ElementCollection</code> as nested documents of the owning entity.</p><div class="example"><a id="d0e13098"/><p class="title"><strong>Example 15.5. Embedded object</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class News {

    @Id
    private String id;
    private String title;

    @Embedded
    private NewsPaper paper;

    // getters, setters ...
}

@Embeddable
public class NewsPaper {

    private String name;
    private String owner;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: News:939c892d-1129-4aff-abf8-e6c26e59dcb
{
    "title": "On the merits of NoSQL",
    "paper": {
        "name": "NoSQL journal of prophecies",
        "owner": "Delphy"
    }
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13105"/><p class="title"><strong>Example 15.6. @ElementCollection with primitive types</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class AccountWithPhone {

    @Id
    private String id;

    @ElementCollection
    private List&lt;String&gt; mobileNumbers;

    // getters, setters ...
}</code></pre><p>AccountWithPhone collection</p><pre><code class="language-json">Key: AccountWithPhone:2
{
   "mobileNumbers": [
       "+1-222-555-0222",
       "+1-202-555-0333"
   ]
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13114"/><p class="title"><strong>Example 15.7. @ElementCollection with one attribute</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class GrandMother {

    @Id
    private String id;

    @ElementCollection
    private List&lt;GrandChild&gt; grandChildren = new ArrayList&lt;GrandChild&gt;();

    // getters, setters ...
}

@Embeddable
public class GrandChild {

    private String name;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: GrandMother:86ada718-f2a2-4299-b6ac-3d90b1ef2331
{
    "grandChildren" : [ "Luke", "Leia" ]
}</code></pre></div></div><br class="example-break"/><p>The class <code class="literal">GrandChild</code> has only one attribute <code class="literal">name</code>,
this means that Hibernate OGM doesn’t need to store the name of the attribute.</p><p>If the nested document has two or more fields, like in the following example,
Hibernate OGM will store the name of the fields as well.</p><div class="example"><a id="d0e13131"/><p class="title"><strong>Example 15.8. @ElementCollection with @OrderColumn</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class GrandMother {

    @Id
    private String id;

    @ElementCollection
    @OrderColumn( name = "birth_order" )
    private List&lt;GrandChild&gt; grandChildren = new ArrayList&lt;GrandChild&gt;();

    // getters, setters ...
}

@Embeddable
public class GrandChild {

    private String name;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: GrandMother:86ada718-f2a2-4299-b6ac-3d90b1ef2331
{
    "grandChildren" : [
            {
                "birthorder" : 0
                "name" : "luke",
            },
            {
                "birthorder" : 1
                "name" : "leia",
            }
    ]
}</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="15.2.2. Hash mapping"><div class="titlepage"><div><div><h3 class="title"><a id="redis-hash-mapping"/>15.2.2. Hash mapping</h3></div></div></div><p>The Redis Hash mapping dialect maps entities to key-value pairs.
It stores the data within Redis hashes. Hashes support partial updates.
While the JSON dialect discards not mapped fields in the entity model the hash dialect
does not touch fields that are not mapped to the entity model.</p><div class="section" title="15.2.2.1. Properties and built-in types"><div class="titlepage"><div><div><h4 class="title"><a id="redis-built-in-types-hash"/>15.2.2.1. Properties and built-in types</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Hibernate OGM doesn’t store null values in Redis,
setting a value to null will be the same as removing the field
in the corresponding object in the db.</p></div><p>Hibernate OGM supports by default the following types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.String</code></li></ul></div><pre><code class="language-json">text=Hello world!</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Character</code> (or char primitive)</li></ul></div><pre><code class="language-json">delimiter=/</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Boolean</code> (or boolean primitive)</li></ul></div><pre><code class="language-json">favorite=true  # default mapping
favorite=T     # if @Type(type = "true_false") is given
favorite=Y     # if @Type(type = "yes_no") is given
favorite=1     # if @Type(type = "numeric_boolean") is given</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Byte</code> (or byte primitive)</li></ul></div><pre><code class="language-json"> display_mask=Rg==</code></pre><p><span class="emphasis"><em>Redis Hash stores byte data as base64-encoded string</em></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Short</code> (or short primitive)</li></ul></div><pre><code class="language-json">urlPort=80</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Integer</code> (or int primitive)</li></ul></div><pre><code class="language-json">stockCount=12309</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Long</code> (or long primitive)</li></ul></div><pre><code class="language-json">userId=-6718902786625749549</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Float</code> (or float primitive)</li></ul></div><pre><code class="language-json">visitRatio=10.4</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.lang.Double</code> (or double primitive)</li></ul></div><pre><code class="language-json">tax_percentage=12.34</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.math.BigDecimal</code></li></ul></div><pre><code class="language-json">site_weight=21.77</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.math.BigInteger</code></li></ul></div><pre><code class="language-json">site_weight=444</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.util.Calendar</code></li></ul></div><pre><code class="language-json">creation=2014-11-18T15:51:26.252Z</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.util.Date</code></li></ul></div><pre><code class="language-json">last_update=2014-11-18T15:51:26.252Z</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.util.UUID</code></li></ul></div><pre><code class="language-json">serialNumber=71f5713d-69c4-4b62-ad15-aed8ce8d10e0</code></pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">java.util.URL</code></li></ul></div><pre><code class="language-json">url=http://www.hibernate.org/</code></pre></div><div class="section" title="15.2.2.2. Entities"><div class="titlepage"><div><div><h4 class="title"><a id="entities_8"/>15.2.2.2. Entities</h4></div></div></div><p>Entities are stored as key-value pairs within Redis hashes.
Each entity property will be translated into a hash field and is represented as <code class="literal">java.lang.String</code>.
The Redis hash dialect supports only flat data structures hence nested entities and associations
are represented as JSON documents within the association documents in Redis lists/sets.
You can use the name property of the <code class="literal">@Table</code> and <code class="literal">@Column</code> annotations
to rename the collections and the document’s fields if you need to.</p><p>Redis has no built-in mechanism for detecting concurrent updates to one and the same document.</p><p>The following shows an example of an entity and its persistent representation in Redis.</p><div class="example"><a id="d0e13285"/><p class="title"><strong>Example 15.9. Example of an entity and its representation in Redis</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class News {

    @Id
    private String id;

    @Version
    @Column(name="version")
    private int version;

    private String title;

    private String description;

    //getters, setters ...
}</code></pre><pre><code class="language-json">version=1
title=On the merits of NoSQL
description=This paper discuss why NoSQL will save the world for good</code></pre></div></div><br class="example-break"/><p>Redis doesn’t have a concept of "tables";
Instead all values are stored in a hash as key values. The hash key contains the table name and the primary key of the entity.
Thus Hibernate OGM needs to add two additional attributes:</p><div class="example"><a id="d0e13294"/><p class="title"><strong>Example 15.10. Rename field and collection using @Table and @Column</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
@Table(name="Article")
public class News {

    @Id
    @Column(name="code")
    private String id;

    @Version
    @Column(name="revision")
    private int revision;

    private String title;

    @Column(name="desc")
    private String description;

    //getters, setters ...
}</code></pre><pre><code class="language-json">revision=1
title=On the merits of NoSQL
desc=This paper discuss why NoSQL will save the world for good</code></pre></div></div><br class="example-break"/></div><div class="section" title="15.2.2.3. Embedded objects and collections"><div class="titlepage"><div><div><h4 class="title"><a id="embedded_objects_and_collections_7"/>15.2.2.3. Embedded objects and collections</h4></div></div></div><p>Hibernate OGM stores elements annotated with <code class="literal">@Embedded</code>
or <code class="literal">@ElementCollection</code> as nested documents of the owning entity.</p><div class="example"><a id="d0e13312"/><p class="title"><strong>Example 15.11. Embedded object</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class News {

    @Id
    private String id;
    private String title;

    @Embedded
    private NewsPaper paper;

    // getters, setters ...
}

@Embeddable
public class NewsPaper {

    private String name;
    private String owner;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: News:939c892d-1129-4aff-abf8-e6c26e59dcb
paper.name=NoSQL journal of prophecies
paper.owner=Delphy</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13319"/><p class="title"><strong>Example 15.12. @ElementCollection with primitive types</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class AccountWithPhone {

    @Id
    private String id;

    @ElementCollection
    private List&lt;String&gt; mobileNumbers;

    // getters, setters ...
}</code></pre><p>AccountWithPhone collection</p><pre><code class="language-json">Key: AccountWithPhone:2
id=2

Key: Associations:AccountWithPhone:2:mobileNumbers
[
   "+1-222-555-0222",
   "+1-202-555-0333"
]</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13328"/><p class="title"><strong>Example 15.13. @ElementCollection with one attribute</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class GrandMother {

    @Id
    private String id;

    @ElementCollection
    private List&lt;GrandChild&gt; grandChildren = new ArrayList&lt;GrandChild&gt;();

    // getters, setters ...
}

@Embeddable
public class GrandChild {

    private String name;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Associations:GrandMother_grandChildren:86ada718-f2a2-4299-b6ac-3d90b1ef2331:grandChildren

[ "Luke", "Leia" ]</code></pre></div></div><br class="example-break"/><p>The class <code class="literal">GrandChild</code> has only one attribute <code class="literal">name</code>,
this means that Hibernate OGM doesn’t need to store the name of the attribute.</p><p>If the nested document has two or more fields, like in the following example,
Hibernate OGM will store the name of the fields as well.</p><div class="example"><a id="d0e13345"/><p class="title"><strong>Example 15.14. @ElementCollection with @OrderColumn</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class GrandMother {

    @Id
    private String id;

    @ElementCollection
    @OrderColumn( name = "birth_order" )
    private List&lt;GrandChild&gt; grandChildren = new ArrayList&lt;GrandChild&gt;();

    // getters, setters ...
}

@Embeddable
public class GrandChild {

    private String name;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Associations:GrandMother_grandChildren:86ada718-f2a2-4299-b6ac-3d90b1ef2331:grandChildren
[
    "{\"name\":\"Luke\",\"birthorder\":\"0\"}",
    "{\"name\":\"Leia\",\"birthorder\":\"1\"}"
]</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="15.2.3. Associations"><div class="titlepage"><div><div><h3 class="title"><a id="associations_6"/>15.2.3. Associations</h3></div></div></div><p>Hibernate OGM Redis provides two strategies to store navigation information for associations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">IN_ENTITY</code> (default)</li><li class="listitem"><code class="literal">ASSOCIATION_DOCUMENT</code></li></ul></div><p>You can switch between the two strategies using:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the <code class="literal">@AssociationStorage</code> annotation (see <a class="xref" href="ch15.html#ogm-redis-annotation-configuration" title="15.1.1. Annotation based configuration">Section 15.1.1, “Annotation based configuration”</a>)</li><li class="listitem">specifying a gloabl default strategy via the <code class="literal">hibernate.ogm.datastore.document.association_storage</code> configuration property</li></ul></div><div class="section" title="15.2.3.1. In Entity strategy"><div class="titlepage"><div><div><h4 class="title"><a id="in_entity_strategy_2"/>15.2.3.1. In Entity strategy</h4></div></div></div><p>With this strategy, Hibernate OGM directly stores the id(s)
of the other side of the association
into a field or an embedded document
depending if the mapping concerns a single object or a collection.
The field that stores the relationship information is named like the entity property.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>When using this strategy the annotations <code class="literal">@JoinTable</code> will be ignored because no collection is created
for associations. This strategy is supported only using the JSON dialect.</p><p>You can use <code class="literal">@JoinColumn</code> to change the name of the field that stores the foreign key (as an example, see
<a class="xref" href="ch15.html#redis-in-entity-one-to-one-join-column" title="Example 15.18. Unidirectional one-to-one with @JoinColumn">Example 15.18, “Unidirectional one-to-one with @JoinColumn”</a>).</p></div><div class="example"><a id="d0e13402"/><p class="title"><strong>Example 15.15. Java entity</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class AccountOwner {

    @Id
    private String id;

    @ManyToMany
    public Set&lt;BankAccount&gt; bankAccounts;

    // getters, setters, ...</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13407"/><p class="title"><strong>Example 15.16. JSON representation</strong></p><div class="example-contents"><pre><code class="language-json">Key: AccountOwner:owner0001
{
    "bankAccounts" : [
        "accountABC",
        "accountXYZ"
    ]
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13412"/><p class="title"><strong>Example 15.17. Unidirectional one-to-one</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Vehicule {

    @Id
    private String id;
    private String brand;

    // getters, setters ...
}


@Entity
public class Wheel {

    @Id
    private String id;
    private double diameter;

    @OneToOne
    private Vehicule vehicule;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Vehicule:V001
{
    "brand": "Mercedes"
}</code></pre><pre><code class="language-json">Key: Wheel:W1
{
  "diameter" : 0.0,
  "vehicule_id" : "V001"
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="redis-in-entity-one-to-one-join-column"/><p class="title"><strong>Example 15.18. Unidirectional one-to-one with @JoinColumn</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Vehicule {

    @Id
    private String id;
    private String brand;

    // getters, setters ...
}


@Entity
public class Wheel {

    @Id
    private String id;
    private double diameter;

    @OneToOne
    @JoinColumn( name = "part_of" )
    private Vehicule vehicule;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Vehicule:V001
{
    "brand": "Mercedes"
}</code></pre><pre><code class="language-json">Key: Wheel:W1
{
  "diameter" : 0.0,
  "part_of" : "V001"
}</code></pre></div></div><br class="example-break"/><p>In a true one-to-one association, it is possible to share the same id between the two entities
and therefore a foreign key is not required. You can see how to map this type of association in
the following example:</p><div class="example"><a id="d0e13432"/><p class="title"><strong>Example 15.19. Unidirectional one-to-one with @MapsId and @PrimaryKeyJoinColumn</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Vehicule {

    @Id
    private String id;
    private String brand;

    // getters, setters ...
}

@Entity
public class Wheel {

    @Id
    private String id;
    private double diameter;

    @OneToOne
    @PrimaryKeyJoinColumn
    @MapsId
    private Vehicule vehicule;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Vehicule:V001
{
    "brand": "Mercedes"
}</code></pre><pre><code class="language-json">Wheel:vehicule:V001
{
  "diameter" : 0.0,
  "vehicule_id" : "V001"
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13441"/><p class="title"><strong>Example 15.20. Bidirectional one-to-one</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Husband {

    @Id
    private String id;
    private String name;

    @OneToOne
    private Wife wife;

    // getters, setters ...
}

@Entity
public class Wife {

    @Id
    private String id;
    private String name;

    @OneToOne
    private Husband husband;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Husband:alex
{
  "name" : "Alex",
  "wife" : "bea"
}</code></pre><pre><code class="language-json">Key: Wife:bea
{
  "name" : "Bea",
  "husband" : "alex"
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13450"/><p class="title"><strong>Example 15.21. Unidirectional one-to-many</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Basket {

    @Id
    private String id;

    private String owner;

    @OneToMany
    private List&lt;Product&gt; products = new ArrayList&lt;Product&gt;();

    // getters, setters ...
}

@Entity
public class Product {

    @Id
    private String name;

    private String description;

    // getters, setters ...
}</code></pre><p>Basket collection</p><pre><code class="language-json">Key: Basket:davide_basket
{
  "owner" : "Davide",
  "products" : [ "Beer", "Pretzel" ]
}</code></pre><p>Product collection</p><pre><code class="language-json">Key: Product:Beer
{
  "name" : "Beer",
  "description" : "Tactical nuclear penguin"
}

Key: Product:Pretzel
{
  "name" : "Pretzel",
  "description" : "Glutino Pretzel Sticks"
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13463"/><p class="title"><strong>Example 15.22. Unidirectional one-to-many using one collection per strategy with @OrderColumn</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Basket {

    @Id
    private String id;

    private String owner;

    @OneToMany
    private List&lt;Product&gt; products = new ArrayList&lt;Product&gt;();

    // getters, setters ...
}

@Entity
public class Product {

    @Id
    private String name;

    private String description;

    // getters, setters ...
}</code></pre><p>Basket collection</p><pre><code class="language-json">Key: Basket:davide_basket
{
  "owner" : "Davide"
}</code></pre><p>Product collection</p><pre><code class="language-json">Key: Product:Pretzel
{
  "description" : "Glutino Pretzel Sticks"
}
Key: Product:Beer
{
  "description" : "Tactical nuclear penguin"
}</code></pre><p>Redis List Associations:davide_basket:Basket_Product</p><pre><code class="language-json">Rows:
[
{
  "products_name" : "Pretzel",
  "products_ORDER" : 1
},
{
  "products_name" : "Beer",
  "products_ORDER" : 0
}
]</code></pre></div></div><br class="example-break"/><p>A map can be used to represents an association,
in this case Hibernate OGM will store the key of the map
and the associated id.</p><div class="example"><a id="d0e13482"/><p class="title"><strong>Example 15.23. Unidirectional one-to-many using maps with defaults</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class User {

    @Id
    private String id;

    @OneToMany
    private Map&lt;String, Address&gt; addresses = new HashMap&lt;String, Address&gt;();

    // getters, setters ...
}

@Entity
public class Address {

    @Id
    private String id;
    private String city;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: User:user_001
{
  "addresses" : {
    "work" : "address_001",
    "home" : "address_002"
  }
}</code></pre><pre><code class="language-json">Key: Address:address_001
{
  "city" : "Rome"
}</code></pre><pre><code class="language-json">Key: Address:address_002
{
  "city" : "Paris"
}</code></pre></div></div><br class="example-break"/><p>If the map value cannot be represented by a single field (e.g. when referencing a type with a composite id
or using an embeddable type as map value type),
a sub-document containing all the required fields will be stored as value.</p><p>If the map key either is not of type <code class="literal">String</code> or it is made up of several columns (composite map key),
the optimized structure shown in the example above cannot be used.
In that case the association will be represented by a list of sub-documents, also containing the map key column(s).
You can use <code class="literal">@MapKeyColumn</code> to rename the field containing the key of the map,
otherwise it will default to "&lt;%COLLECTION_ROLE%&gt;_KEY", e.g. "addresses_KEY".</p><p>In case you want to enforce the list-style represention also for maps with a single key column of type <code class="literal">String</code>
you can use the option <code class="literal">hibernate.ogm.datastore.document.map_storage</code> to do so.</p><div class="example"><a id="d0e13511"/><p class="title"><strong>Example 15.24. Unidirectional one-to-many using maps with @MapKeyColumn</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class User {

    @Id
    private String id;

    @OneToMany
    @MapKeyColumn(name = "addressType")
    private Map&lt;String, Address&gt; addresses = new HashMap&lt;String, Address&gt;();

    // getters, setters ...
}

@Entity
public class Address {

    @Id
    private String id;
    private String city;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: User:user_001
{
  "addresses" : [
    {
      "addressType" : "work",
      "addresses_id" : "address_001"
    },
    {
      "addressType" : "home",
      "addresses_id" : "address_002"
    }
  ]
}</code></pre><pre><code class="language-json">Key: Address:address_001
{
  "city" : "Rome"
}</code></pre><pre><code class="language-json">Key: Address:address_002
{
  "city" : "Paris"
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13522"/><p class="title"><strong>Example 15.25. Unidirectional many-to-one</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class JavaUserGroup {

    @Id
    private String jugId;
    private String name;

    // getters, setters ...
}

@Entity
public class Member {

    @Id
    private String id;
    private String name;

    @ManyToOne
    private JavaUserGroup memberOf;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: JavaUserGroups:summer_camp
{
  "name" : "JUG Summer Camp"
}</code></pre><pre><code class="language-json">Key: Member:jerome
{
  "name" : "Jerome"
  "memberOf_jugId" : "summer_camp"
}</code></pre><pre><code class="language-json">Key: Member:emmanuel
{
  "name" : "Emmanuel Bernard"
  "memberOf_jugId" : "summer_camp"
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13533"/><p class="title"><strong>Example 15.26. Bidirectional many-to-one</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class SalesForce {

    @Id
    private String id;
    private String corporation;

    @OneToMany(mappedBy = "salesForce")
    private Set&lt;SalesGuy&gt; salesGuys = new HashSet&lt;SalesGuy&gt;();

    // getters, setters ...
}

@Entity
public class SalesGuy {

    private String id;
    private String name;

    @ManyToOne
    private SalesForce salesForce;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: SalesForce:red_hat
{
  "corporation": "Red Hat",
  "salesGuys": [ "eric", "simon" ]
}</code></pre><pre><code class="language-json">Key: SalesGuy:eric
{
  "name": "Eric"
  "salesForce_id": "red_hat",
}</code></pre><pre><code class="language-json">Key: SalesGuy:simon
{
  "name": "Simon",
  "salesForce_id": "red_hat"
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13544"/><p class="title"><strong>Example 15.27. Unidirectional many-to-many using in entity strategy</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Student {

    @Id
    private String id;
    private String name;

    // getters, setters ...
}

@Entity
public class ClassRoom {

    @Id
    private Long id;
    private String lesson;

    @ManyToMany
    private List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: ClassRoom:1
{
   "students": [
       "mario",
       "john"
   ],
   "name": "Math"
}</code></pre><pre><code class="language-json">Key: ClassRoom:2
{
   "students": [
       "kate",
       "mario"
   ],
   "name": "English"
}</code></pre><pre><code class="language-json">Key: Student:john
{
   "name": "John Doe"
}</code></pre><pre><code class="language-json">Key: Student:kate
{
   "name": "Kate Doe"
}</code></pre><pre><code class="language-json">Key: Student:mario
{
   "name": "Mario Rossi"
}</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13559"/><p class="title"><strong>Example 15.28. Bidirectional many-to-many</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class AccountOwner {

    @Id
    private String id;

    private String SSN;

    @ManyToMany
    private Set&lt;BankAccount&gt; bankAccounts;

    // getters, setters ...
}

@Entity
public class BankAccount {

    @Id
    private String id;

    private String accountNumber;

    @ManyToMany( mappedBy = "bankAccounts" )
    private Set&lt;AccountOwner&gt; owners = new HashSet&lt;AccountOwner&gt;();

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: AccountOwner:owner_1
{
   "SSN": "0123456",
   "bankAccounts": [
       "account_1",
       "account_2"
   ]
}</code></pre><pre><code class="language-json">Key: BankAccount:account_1
{
   "accountNumber": "X2345000",
   "owners": [
       "owner_1"
   ]
}</code></pre><pre><code class="language-json">Key: BankAccount:account_2
{
   "accountNumber": "ZZZ-009",
   "owners": [
       "owner_1"
   ]
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="15.2.3.2. Association document strategy"><div class="titlepage"><div><div><h4 class="title"><a id="redis-association-document-strategy"/>15.2.3.2. Association document strategy</h4></div></div></div><p>With this strategy, Hibernate OGM uses separate association data structures
to store all navigation information. The association data structure depends on
the type of the association:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Bag, List, Map, One-to-one: Redis List</li><li class="listitem">Set: Redis Set</li></ul></div><p>Each association has 2 parts.
The first is the key. The key consists of a prefix, the identifier information
of the association owner, and the name of the association table.</p><p><span class="guimenu">Associations:&lt;%ASSOCIATION_TABLE%</span> → <span class="guisubmenu">:&lt;%ASSOCIATION_ID%</span> → <span class="guimenuitem">:&lt;%COLLECTION_ROLE%</span>, e.g. "Associations:AccountOwner:4f5b48ad-f074-4a64-8cf4-1f9c54a33f76:BankAccount".</p><p>The second part is the <code class="literal">rows</code> field which stores (into an embedded collection) all ids
that the current instance is related to.</p><div class="example"><a id="d0e13598"/><p class="title"><strong>Example 15.29. Unidirectional relationship</strong></p><div class="example-contents"><pre><code class="language-json">Key: Associations:AccountOwner:4f5b48ad-f074-4a64-8cf4-1f9c54a33f76:BankAccount
[
    "7873a2a7-c77c-447c-b000-890f0a4dfa9a"
]</code></pre></div></div><br class="example-break"/><p>For a bidirectional relationship, another list is created where ids are reversed.
Don’t worry, Hibernate OGM takes care of keeping them in sync:</p><div class="example"><a id="d0e13605"/><p class="title"><strong>Example 15.30. Bidirectional relationship</strong></p><div class="example-contents"><pre><code class="language-json">Key: Associations:AccountOwner:4f5b48ad-f074-4a64-8cf4-1f9c54a33f76:BankAccount
[
    "7873a2a7-c77c-447c-b000-890f0a4dfa9a"
]

Key: Associations:AccountOwner:bankAccounts:7873a2a7-c77c-447c-b000-890f0a4dfa9a
[
    "4f5b48ad-f074-4a64-8cf4-1f9c54a33f76"
]</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>This strategy won’t affect *-to-one associations or embedded collections.</p></div><div class="example"><a id="d0e13613"/><p class="title"><strong>Example 15.31. Unidirectional one-to-many using document strategy</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Basket {

    @Id
    private String id;

    private String owner;

    @OneToMany
    private List&lt;Product&gt; products = new ArrayList&lt;Product&gt;();

    // getters, setters ...
}

@Entity
public class Product {

    @Id
    private String name;

    private String description;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Basket:davide_basket
{
   "owner": "Davide"
}</code></pre><pre><code class="language-json">Key: Basket:davide_basket
{
   "owner": "Davide"
}</code></pre><pre><code class="language-json">Key: Product:Pretzel
{
   "description": "Glutino Pretzel Sticks",
}</code></pre><pre><code class="language-json">Key: Associations:Basket_Product:davide_basket:products
[
   "Beer",
   "Pretzel"
]</code></pre></div></div><br class="example-break"/><p>Using the annotation <code class="literal">@JoinTable</code> it is possible to change the value of
the document containing the association.</p><div class="example"><a id="d0e13631"/><p class="title"><strong>Example 15.32. Unidirectional one-to-many using document strategy with <code class="literal">@JoinTable</code></strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Basket {

    @Id
    private String id;

    private String owner;

    @OneToMany
    @JoinTable( name = "BasketContent" )
    private List&lt;Product&gt; products = new ArrayList&lt;Product&gt;();

    // getters, setters ...
}

@Entity
public class Product {

    @Id
    private String name;

    private String description;

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Basket:davide_basket
{
   "owner": "Davide"
}</code></pre><pre><code class="language-json">Key: Basket:davide_basket
{
   "owner": "Davide"
}</code></pre><pre><code class="language-json">Key: Product:Pretzel
{
   "description": "Glutino Pretzel Sticks",
}</code></pre><pre><code class="language-json">Key: Association:BasketContent:Basket:davide_basket
[
   "Beer",
   "Pretzel"
]</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13646"/><p class="title"><strong>Example 15.33. Unidirectional many-to-many using document strategy</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Student {

    @Id
    private String id;
    private String name;

    // getters, setters ...
}

@Entity
public class ClassRoom {

    @Id
    private Long id;
    private String lesson;

    @ManyToMany
    private List&lt;Student&gt; students = new ArrayList&lt;Student&gt;();

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: ClassRoom:1
{
   "name": "Math"
}</code></pre><pre><code class="language-json">Key: ClassRoom:2
{
   "name": "English"
}</code></pre><pre><code class="language-json">Key: ClassStudent:john
{
   "name": "John Doe"
}</code></pre><pre><code class="language-json">Key: ClassStudent:kate
{
   "name": "Kate Doe"
}</code></pre><pre><code class="language-json">Key: ClassStudent:mario
{
   "name": "Mario Rossi"
}</code></pre><pre><code class="language-json">Key: Association:ClassRoom:Student:ClassRoom:1
[
   "mario",
   "john"
]</code></pre><pre><code class="language-json">Key: Association:ClassRoom:Student:ClassRoom:2
[
   "kate"
]</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13665"/><p class="title"><strong>Example 15.34. Bidirectional many-to-many using document strategy</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class AccountOwner {

    @Id
    private String id;

    private String SSN;

    @ManyToMany
    private Set&lt;BankAccount&gt; bankAccounts;

    // getters, setters ...
}

@Entity
public class BankAccount {

    @Id
    private String id;

    private String accountNumber;

    @ManyToMany(mappedBy = "bankAccounts")
    private Set&lt;AccountOwner&gt; owners = new HashSet&lt;AccountOwner&gt;();

    // getters, setters ...
}</code></pre><pre><code class="language-json">Key: AccountOwner:owner_1
{
   "SSN": "0123456",
}</code></pre><pre><code class="language-json">Key: BankAccount:account_1
{
   "accountNumber": "X2345000",
}</code></pre><pre><code class="language-json">Key: BankAccount:account_2
{
   "accountNumber": "ZZZ-009",
}</code></pre><pre><code class="language-json">Key: Association:AccountOwner:BankAccount:account_1
[
   "owner_1"
]</code></pre><pre><code class="language-json">Key: Association:AccountOwner:BankAccount:bankAccounts:account_2
[
   "owner_1"
]</code></pre><pre><code class="language-json">Key: Association:AccountOwner:BankAccount:owners:account_1
[
   "account_1",
   "account_2"
]</code></pre></div></div><br class="example-break"/></div></div></div><div class="section" title="15.3. Identifiers"><div class="titlepage"><div><div><h2 class="title"><a id="identifiers_5"/>15.3. Identifiers</h2></div></div></div><p>Redis keys are derived from the Entity name and its Id separated by a colon (<code class="literal">:</code>).
String-based Id’s are used directly within the key, non-string keys are encoded to JSON.
You can use any persistable Java type as identifier type, e.g. <code class="literal">String</code> or <code class="literal">long</code>.
Hibernate OGM will convert the <code class="literal">@Id</code> property into a part of the key name
so you can name the entity id like you want.</p><div class="informalexample"><pre><code class="language-java">@Entity
public class News {

    @Id
    @Column
    private long id;

    // fields, getters, setters ...
}</code></pre><p>Key-Scheme for <code class="literal">News</code> entity with an Id of <code class="literal">42</code></p><pre><code class="language-json">  News:42</code></pre><pre><code class="language-java">@Entity
@Table(name="Article")
public class News {

    @Id
    @Column(name="code")
    private String id;

    // fields, getters, setters ...
}</code></pre><p>Key-Scheme for <code class="literal">News</code> entity with an Id of <code class="literal">breaking-news</code></p><pre><code class="language-json">Article:breaking-news</code></pre></div><p>Note that you also can work with embedded ids (via <code class="literal">@EmbeddedId</code>),
Composite Id’s are mapped to a JSON object containing keys and values.
Hibernate OGM thus will create a concatenated representation of the embedded id’s properties in this case.
The columns are sorted in alphabetical order to guarantee the same order.</p><div class="example"><a id="d0e13727"/><p class="title"><strong>Example 15.35. Entity with @EmbeddedId</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class News {

    @EmbeddedId
    private NewsID newsId;

    // getters, setters ...
}

@Embeddable
public class NewsID implements Serializable {

    private String title;
    private String author;

    // getters, setters ...
}</code></pre><p>Resulting key:</p><pre><code class="language-json">News:{"newsId.author": "Guillaume, "newsId.title": "How to use Hibernate OGM ?"},</code></pre></div></div><br class="example-break"/><div class="section" title="15.3.1. Identifier generation strategies"><div class="titlepage"><div><div><h3 class="title"><a id="identifier_generation_strategies_6"/>15.3.1. Identifier generation strategies</h3></div></div></div><p>You can assign id values yourself or let Hibernate OGM generate the value using the
<code class="literal">@GeneratedValue</code> annotation.</p><p>Two main strategies are supported:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><a class="link" href="ch15.html#redis-table-id-generation-strategy">TABLE</a></li><li class="listitem"><a class="link" href="ch15.html#redis-sequence-id-generation-strategy">SEQUENCE</a></li></ol></div><p>Both strategies will operate in the keys starting with <code class="literal">Identifiers</code> containing the last value of the id. The difference
between the two strategies is the name of the key containing the values.</p><p>The <code class="literal">AUTO</code> strategy is the same as the <a class="link" href="ch15.html#redis-sequence-id-generation-strategy">SEQUENCE</a> one.</p><p>The next value is obtained using Redis' <a class="link" href="http://redis.io/commands/hincrby">HINCRBY</a> command
that guarantees to create atomic updates to the underlying data structure.</p><p><a id="redis-table-id-generation-strategy"/><span class="strong"><strong>1) TABLE generation strategy</strong></span></p><div class="example"><a id="d0e13776"/><p class="title"><strong>Example 15.36. Id generation strategy TABLE using default values</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Video {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE)
    private Integer id;
    private String name

    // getters, setters, ...
}</code></pre><pre><code class="language-json">Key: Video:1
{
   "name": "Scream",
   "director": "Wes Craven"
}</code></pre><pre><code class="language-json">Key: Identifiers:hibernate_sequences:default
Value: 1</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13785"/><p class="title"><strong>Example 15.37. Id generation strategy TABLE using a custom table</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Video {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "video")
    @TableGenerator(
            name = "video",
            table = "sequences",
            pkColumnName = "key",
            pkColumnValue = "video",
            valueColumnName = "seed"
    )
    private Integer id;

    private String name;

    // getter, setters, ...
}</code></pre><pre><code class="language-json">Key: Identifiers:sequences:video
Value: 2</code></pre></div></div><br class="example-break"/><p><a id="redis-sequence-id-generation-strategy"/><span class="strong"><strong>2) SEQUENCE generation strategy</strong></span></p><div class="example"><a id="d0e13795"/><p class="title"><strong>Example 15.38. SEQUENCE id generation strategy using default values</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Song {

  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE)
  private Long id;

  private String title;

  // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Song:2
{
   "title": "Ave Maria",
   "singer": "Charlotte Church"
}</code></pre><pre><code class="language-json">Key: Identifiers:hibernate_sequences
Value: 2</code></pre></div></div><br class="example-break"/><div class="example"><a id="d0e13804"/><p class="title"><strong>Example 15.39. SEQUENCE id generation strategy using custom values</strong></p><div class="example-contents"><pre><code class="language-java">@Entity
public class Song {

  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "songSequenceGenerator")
  @SequenceGenerator(
      name = "songSequenceGenerator",
      sequenceName = "song_sequence",
      initialValue = 2,
      allocationSize = 20
  )
  private Long id;

  private String title;

  // getters, setters ...
}</code></pre><pre><code class="language-json">Key: Song:2
{
   "title": "Ave Maria",
   "singer": "Charlotte Church"
}</code></pre><pre><code class="language-json">Key: Identifiers:song_sequence
Value: 21</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The value stored in Redis for the sequence is not the one the dialect will return as next number
in the sequence. Instead, Hibernate OGM will use it as seed to generate the correct value
in the sequence.</p></div></div></div><div class="section" title="15.4. Transactions"><div class="titlepage"><div><div><h2 class="title"><a id="transactions_3"/>15.4. Transactions</h2></div></div></div><p>The Redis dialect does not support transactions for now.
Only changes applied to the same document are done atomically.
A change applied to more than one document will not be applied atomically.
This problem is slightly mitigated by the fact that Hibernate OGM queues all changes
before applying them during flush time.
So the window of time used to write to Redis is smaller than what you would have done manually.</p><p>We recommend that you still use transaction demarcations with Hibernate OGM
to trigger the flush operation transparently (on commit).
But do not consider rollback as a possibility, this won’t work.</p></div><div class="section" title="15.5. Queries"><div class="titlepage"><div><div><h2 class="title"><a id="queries_2"/>15.5. Queries</h2></div></div></div><p>Hibernate OGM is a work in progress
and we are actively working on JP-QL query support.</p><p>In the mean time, you can use Hibernate Search to query entities stored by Hibernate OGM.</p></div><div class="section" title="15.6. Redis Cluster"><div class="titlepage"><div><div><h2 class="title"><a id="redis_cluster"/>15.6. Redis Cluster</h2></div></div></div><p>Using Hibernate OGM with Redis Cluster is a matter of enabling Redis Cluster mode (see <a class="xref" href="ch15.html#ogm-redis-configuration" title="15.1. Configuring Redis">Section 15.1, “Configuring Redis”</a>).
Data stored with Hibernate OGM Redis is distributed across Redis Cluster nodes
according to the <a class="link" href="http://redis.io/topics/cluster-spec#keys-distribution-model">Redis key distribution model</a>
based on the hash slot of the key of each entity.</p></div></div><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">hljs.initHighlightingOnLoad();</script><hr xmlns="" xmlns:d="http://docbook.org/ns/docbook"/><a xmlns="" xmlns:d="http://docbook.org/ns/docbook" href="legalnotice.html"/><ul class="docnav"><li class="previous"><a accesskey="p" href="ch14.html"><strong>Prev</strong>Chapter 14. Cassandra (Experimental)</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li></ul><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("ogm"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>