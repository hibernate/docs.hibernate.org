<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 1. How to get help and contribute on Hibernate OGM</title><!-- HibernateDoc.Meta --><meta name="description" content="Hibernate OGM, JPA for NoSQL datastores - Reference Documentation" /><meta name="keywords" content="hibernate, ogm, hibernate ogm, nosql, jpa, infinispan, mongodb, neo4j, cassandra, couchdb, ehcache, redis" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://docs.jboss.org/hibernate/stable/ogm/reference/en-US/html_single/" /><!-- /HibernateDoc.Meta --><link rel="stylesheet" type="text/css" href="css/hibernate.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Hibernate OGM Reference Guide"/><link rel="up" href="index.html" title="Hibernate OGM Reference Guide"/><link rel="prev" href="pr01.html" title="Preface"/><link rel="next" href="ch02.html" title="Chapter 2. Getting started with Hibernate OGM"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="pr01.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch02.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 1. How to get help and contribute on Hibernate OGM"><div class="titlepage"><div><div><h2 class="title"><a id="ogm-howtocontribute"/>Chapter 1. How to get help and contribute on Hibernate OGM</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch01.html#ogm-howtocontribute-help">1.1. How to get help</a></span></dt><dt><span class="section"><a href="ch01.html#ogm-howtocontribute-contribute">1.2. How to contribute</a></span></dt><dd><dl><dt><span class="section"><a href="ch01.html#how_to_build_hibernate_ogm">1.2.1. How to build Hibernate OGM</a></span></dt><dt><span class="section"><a href="ch01.html#how_to_contribute_code_effectively">1.2.2. How to contribute code effectively</a></span></dt></dl></dd><dt><span class="section"><a href="ch01.html#how_to_build_support_for_a_data_store">1.3. How to build support for a data store</a></span></dt><dd><dl><dt><span class="section"><a href="ch01.html#datastore_providers">1.3.1. DataStore providers</a></span></dt><dt><span class="section"><a href="ch01.html#dialects">1.3.2. Dialects</a></span></dt><dt><span class="section"><a href="ch01.html#entities">1.3.3. Entities</a></span></dt><dt><span class="section"><a href="ch01.html#associations">1.3.4. Associations</a></span></dt><dt><span class="section"><a href="ch01.html#configuration">1.3.5. Configuration</a></span></dt><dt><span class="section"><a href="ch01.html#types">1.3.6. Types</a></span></dt><dt><span class="section"><a href="ch01.html#tests">1.3.7. Tests</a></span></dt></dl></dd></dl></div><p>Hibernate OGM is a young project.
Join and help us shape it!</p><div class="section" title="1.1. How to get help"><div class="titlepage"><div><div><h2 class="title"><a id="ogm-howtocontribute-help"/>1.1. How to get help</h2></div></div></div><p>First of all, make sure to read this reference documentation.
This is the most comprehensive formal source of information.
Of course, it is not perfect:
feel free to come and ask for help,
comment or propose improvements in our
<a class="link" href="https://forum.hibernate.org/viewforum.php?f=31">Hibernate OGM forum</a>.</p><p>You can also:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">open bug reports in <a class="link" href="https://hibernate.atlassian.net/browse/OGM">JIRA</a></li><li class="listitem">propose improvements on the
<a class="link" href="http://www.hibernate.org/community/mailinglists">development mailing list</a></li><li class="listitem">join us on IRC to discuss developments and improvements
(<code class="literal">#hibernate-dev</code> on <code class="literal">freenode.net</code>;
you need to be registered on freenode:
the room does not accept "anonymous" users).</li></ul></div></div><div class="section" title="1.2. How to contribute"><div class="titlepage"><div><div><h2 class="title"><a id="ogm-howtocontribute-contribute"/>1.2. How to contribute</h2></div></div></div><p>Welcome!</p><p>There are many ways to contribute:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">report bugs in <a class="link" href="https://hibernate.atlassian.net/browse/OGM">JIRA</a></li><li class="listitem">give feedback in the forum, IRC or the development mailing list</li><li class="listitem">improve the documentation</li><li class="listitem">fix bugs or contribute new features</li><li class="listitem">propose and code a datastore dialect for your favorite NoSQL engine</li></ul></div><p>Hibernate OGM’s code is available on GitHub at
<a class="link" href="https://github.com/hibernate/hibernate-ogm">https://github.com/hibernate/hibernate-ogm</a>.</p><div class="section" title="1.2.1. How to build Hibernate OGM"><div class="titlepage"><div><div><h3 class="title"><a id="how_to_build_hibernate_ogm"/>1.2.1. How to build Hibernate OGM</h3></div></div></div><p>Hibernate OGM uses Git and Maven 3,
make sure to have both installed on your system.</p><p>Clone the git repository from GitHub:</p><pre><code class="language-bash">#get the sources
git clone https://github.com/hibernate/hibernate-ogm
cd hibernate-ogm</code></pre><p>Run maven</p><pre><code class="language-bash">#build project
mvn clean install -s settings-example.xml</code></pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Note that Hibernate OGM uses artifacts from the Maven repository hosted by JBoss.
Make sure to either use the <code class="literal">-s settings-example.xml</code> option
or adjust your <code class="literal">~/.m2/settings.xml</code>
according to the descriptions available
<a class="link" href="http://community.jboss.org/wiki/MavenGettingStarted-Users">on this jboss.org wiki page</a>.</p><p>These settings are required for development of Hibernate OGM but should not be needed to use it.</p></div><p>To skip building the documentation, set the <code class="literal">skipDocs</code> property to true:</p><pre><code class="language-bash">mvn clean install -DskipDocs=true -s settings-example.xml</code></pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>If you just want to build the documentation only,
run it from the <code class="literal">hibernate-ogm-documentation/manual</code> subdirectory.</p></div></div><div class="section" title="1.2.2. How to contribute code effectively"><div class="titlepage"><div><div><h3 class="title"><a id="how_to_contribute_code_effectively"/>1.2.2. How to contribute code effectively</h3></div></div></div><p>The best way to share code is to fork the Hibernate OGM repository on GitHub,
create a branch and open a pull request when you are ready.
Make sure to rebase your pull request
on the latest version of the master branch before offering it.</p><p>Here are a couple of approaches the team follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">We do small independent commits for each code change.
In particular, we do not mix stylistic code changes (import, typos, etc)
and new features in the same commit.</li><li class="listitem">Commit messages follow this convention:
the JIRA issue number, a short commit summary, an empty line,
a longer description if needed.
Make sure to limit line length to 80 characters, even at this day and age
it makes for more readable commit comments.</li></ul></div><pre class="screen">OGM-123 Summary of commit operation

Optional details on the commit
and a longer description can be
added here.</pre><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A pull request can contain several commits but should be self contained:
include the implementation, its unit tests, its documentation
and javadoc changes if needed.</li><li class="listitem">All commits are proposed via pull requests
and reviewed by another member of the team
before being pushed to the reference repository.
That’s right, we never commit directly upstream without code review.</li></ul></div></div></div><div class="section" title="1.3. How to build support for a data store"><div class="titlepage"><div><div><h2 class="title"><a id="how_to_build_support_for_a_data_store"/>1.3. How to build support for a data store</h2></div></div></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Advanced section</h2><p>This is an advanced subject, feel free to skip this section if you are not building a data store.</p></div><p>Hibernate OGM supports various data stores by abstracting them
with <code class="literal">DatastoreProvider</code> and <code class="literal">GridDialect</code>. The supported features vary between data stores,
and dialects do not have to implement all features. Hibernate OGM implements a TCK
(Technology Compatibility Kit) to verify interoperability and features of the dialect.
Hibernate OGM supports a variety of document- and key-value-stores and ships
with some abstraction and utility classes for document- and key-value-stores
(like <code class="literal">KeyValueStoreProperties</code> and <code class="literal">DocumentStoreProperties</code>).</p><div class="section" title="1.3.1. DataStore providers"><div class="titlepage"><div><div><h3 class="title"><a id="datastore_providers"/>1.3.1. DataStore providers</h3></div></div></div><p>Supporting a data store usually begins with a <code class="literal">DatastoreProvider</code>. Providers can
implement a lifecycle (<code class="literal">start</code>, <code class="literal">stop</code>) to initialize, configure and shutdown
resources. Taking a look at existing data store support such as MongoDB
(see <code class="literal">org.hibernate.ogm.datastore.mongodb.impl.MongoDBDatastoreProvider</code>)
is a good idea to get an impression of how to boot the data store support.
Providers are seen as services, they can implement various service interfaces
to activate certain features (see the <code class="literal">org.hibernate.service.spi</code> package for details).</p><p>A common issue to face then implementing new data stores is transactionality.
Some data stores provide transactional support that can be used in the context of Hibernate OGM wrapped by JTA.
If your data store does not support transactions, you
can enable transaction emulation within the <code class="literal">DatastoreProvider</code>.</p><p>Features of a <code class="literal">DatastoreProvider</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Resource lifecycle</li><li class="listitem">Managing connection resources</li><li class="listitem">Configuration</li><li class="listitem">Access to query parsers</li><li class="listitem">Define/Validate a schema</li></ul></div></div><div class="section" title="1.3.2. Dialects"><div class="titlepage"><div><div><h3 class="title"><a id="dialects"/>1.3.2. Dialects</h3></div></div></div><p>A data store can have one or more dialects. Dialects describe the style
how data is mapped to a particular data store. NoSQL data stores imply a
certain nature, how to map data. Document-oriented data stores encourage
an entity-as-document pattern where embedded data structures could be
stored within the document itself. Key-value data stores allow different
approaches, e.g. storing an entity as JSON document or event storing
individual key-value pairs that map the entity within a hash table
data structure. Hibernate OGM allows multiple dialects per data store
and users may choose the most appropriate one.</p><p>The most basic support is provided by implementing the <code class="literal">GridDialect</code>
interface. Implementing that interface is mandatory to support a
specific data store.</p><p>A <code class="literal">GridDialect</code> usually supports:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Create/Read/Update/Delete for entities</li><li class="listitem">Create/Read/Update/Delete for associations</li><li class="listitem">Id/Sequence generator</li><li class="listitem">Provides locking strategies</li></ul></div><p>A dialect <span class="emphasis"><em>may</em></span> optionally implement one or more additional facet
interfaces to provide a broader support for certain features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">QueryableGridDialect</code></li><li class="listitem"><code class="literal">BatchableGridDialect</code></li><li class="listitem"><code class="literal">IdentityColumnAwareGridDialect</code></li><li class="listitem"><code class="literal">OptimisticLockingAwareGridDialect</code></li><li class="listitem"><code class="literal">MultigetGridDialect</code></li></ul></div><p>Features of a <code class="literal">QueryableGridDialect</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Query execution</li><li class="listitem">Support for native queries</li></ul></div><p>Features of a <code class="literal">BatchableGridDialect</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Operation queueing</li><li class="listitem">Execution of queued Create/Update/Delete as a batch</li></ul></div><p>Features of a <code class="literal">IdentityColumnAwareGridDialect</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Supports the generation of identity values upon data insertion</li></ul></div><p>Features of an <code class="literal">OptimisticLockingAwareGridDialect</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Finding and altering versioned records in an atomic fashion</li></ul></div><p>Features of a <code class="literal">MultigetGridDialect</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Retrieve multiple tuples within one operation</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Before starting make a clear plan of how you think entities, relations and nested structures
are best represented in the NoSQL store you plan to implement.
It helps to have a clear picture about that, and this will require some experience with the
NoSQL database you plan to support.</p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Start with a small feature set to get a feeling for Hibernate OGM,
for example aim at implementing CRUD operations only and ignore relations and queries.
You can always extend the features as you proceed.</p><p>Starting from or studying existing dialects is also an interesting strategy.
It can be intimidating with complex dialects though.</p></div><p>Hibernate OGM is not opinionated by which means data is stored/loaded
for a particular data store, but the particular dialect is.
Hibernate OGM strives for the most natural mapping style.
The idea is to facilitate integration with other applications
of that database by sticking to established patterns and idioms of that store.</p></div><div class="section" title="1.3.3. Entities"><div class="titlepage"><div><div><h3 class="title"><a id="entities"/>1.3.3. Entities</h3></div></div></div><p>Entities are seen by a dialect as <code class="literal">Tuple</code>. A <code class="literal">Tuple</code> contains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">a snapshot (that’s the view of the data as loaded from your database),</li><li class="listitem">a set of key-value pairs that carry the actual data,</li><li class="listitem">and a list of operations to apply onto the original snapshot.
Tuple keys use dot-path
property identifiers to indicate nesting. That comes handy when working
with document stores because you can build a document structure based on that details.</li></ul></div></div><div class="section" title="1.3.4. Associations"><div class="titlepage"><div><div><h3 class="title"><a id="associations"/>1.3.4. Associations</h3></div></div></div><p>Most NoSQL data stores have no built-in support for associations
between entities (unless you’re using a graph database).</p><p>Hibernate OGM simulates associations for datastore with no support
by storing the navigational information to go from a given entity
to its (list of) associated entity.
This of it as query materialisation.
This navigational information data can be stored within the
entity itself or externally (as own documents or relation items).</p></div><div class="section" title="1.3.5. Configuration"><div class="titlepage"><div><div><h3 class="title"><a id="configuration"/>1.3.5. Configuration</h3></div></div></div><p>Hibernate OGM can read its configuration properties from various sources.
Most common configuration sources are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">hibernate.properties</code> file</li><li class="listitem"><code class="literal">persistence.xml</code> file</li><li class="listitem">environment variables override or integrate properties set in the above configuration files</li><li class="listitem">annotation configuration (entity classes)</li><li class="listitem">programmatic configuration</li></ul></div><p>The <code class="literal">org.hibernate.ogm.options</code> package provides the configuration infrastructure.</p><p>You might want to look at <code class="literal">MongoDBConfiguration</code> or <code class="literal">InfinispanConfiguration</code>
to get an idea how configuration works. Configuration is usually read
when starting a data store provider or while operating. A good example
of accessing configuration during runtime is the association storage
option, where users can define, how to store a particular association
(within the entity or as a separate collection/key/document/node).</p><p>The configuration and options context infrastructure allows to support
data store-specific options such as <code class="literal">ReadPreference</code> for MongoDB or <code class="literal">TTL</code> for Redis.</p><div class="section" title="1.3.5.1. Programmatic configuration"><div class="titlepage"><div><div><h4 class="title"><a id="programmatic_configuration"/>1.3.5.1. Programmatic configuration</h4></div></div></div><p>Data store support can implement programmatic configuration. The
configuration splits into three parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Global configuration</li><li class="listitem">Entity configuration</li><li class="listitem">Property configuration</li></ul></div><p>Programmatic configuration consists of two parts: configuration
interfaces (see <code class="literal">org.hibernate.ogm.options.navigation</code>) and partial (abstract)
implementation classes. These parts are merged at runtime using ASM class generation.</p></div></div><div class="section" title="1.3.6. Types"><div class="titlepage"><div><div><h3 class="title"><a id="types"/>1.3.6. Types</h3></div></div></div><p>Every data store supports a unique set of data types. Some stores support
floating point types and date types, others just strings. Hibernate OGM allows
users to utility a variety of data types (see JPA spec) for their data models.
On the other hand, that data needs to be stored within the data store and mapped back.</p><p>A dialect can provide a <code class="literal">GridType</code> to describe the handling of a particular
data type, meaning you can specify how dates, floating point types or even
byte arrays are handled. Whether they are mapped to other data types (e. g. use
<code class="literal">double</code> for <code class="literal">float</code> or use base64-encoded strings for byte arrays) or wrapped within strings.</p><p>Data store-specific types can be handled the same way, check out <code class="literal">StringAsObjectIdType</code>
 for the String-mapping of MongoDB’s <code class="literal">ObjectId</code> type.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Type-mapping can be an exhausting task. The whole type handling is in flux and is subject
to change as Hibernate OGM progresses. Ask, if you’re not sure about it.</p></div></div><div class="section" title="1.3.7. Tests"><div class="titlepage"><div><div><h3 class="title"><a id="tests"/>1.3.7. Tests</h3></div></div></div><p>Hibernate OGM brings a well suited infrastructure for tests. The test
infrastructure consists of generic base classes (<code class="literal">OgmTestCase</code> for OGM and
<code class="literal">JpaTestCase</code> for JPA) for tests and a test helper (see <code class="literal">TestableGridDialect</code>).
That classes are used to get a different view on data than the frontend-view
by the <code class="literal">Session</code> and the <code class="literal">EntityManager</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>It is always helpful to create a set of own test cases for different
scenarios to validate the data is mapped in the way it’s intended or
to verify data store-specific options such as <code class="literal">TTL</code>.</p></div><p>Another bunch of tests is called the backend TCK. That test classes test nearly
all aspects of Hibernate OGM viewed from a users' perspective. Tests contain
cases for simple/complex entities, associations, list- and map data types,
queries using Hibernate Search, and tests for data type support.</p><p>The backend TCK is included using classpath filters, just check one of the
current implementations (like <code class="literal">RedisBackendTckHelper</code>). When you’re developing a
core module, that is included in the distribution, you will have to add your
dialect to the <code class="literal">@SkipByGridDialect</code> annotation of some tests.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Running even 20% of the tests successfully is a great achievement. Proceed step-by-step.
Large numbers of tests can fail just because of one thing that is handled differently.
Don’t hesitate to ask for help.</p></div></div></div></div><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">hljs.initHighlightingOnLoad();</script><script type="text/javascript">
dataLayer = [{'channel' : 'Hibernate', 'additional_tracking_code' : 'UA-45270411-3'}];
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NJWS5L');</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NJWS5L" height="0" width="0" style="display:none;visibility:hidden"> </iframe></noscript><hr xmlns="" xmlns:d="http://docbook.org/ns/docbook"/><a xmlns="" xmlns:d="http://docbook.org/ns/docbook" href="legalnotice.html"/><ul class="docnav"><li class="previous"><a accesskey="p" href="pr01.html"><strong>Prev</strong>Preface</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch02.html"><strong>Next</strong>Chapter 2. Getting started with Hibernate OGM</a></li></ul><!-- HibernateDoc.OutdatedContent --><script src="//code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script><script src="/hibernate/_outdated-content/outdated-content.js" type="text/javascript"></script><script type="text/javascript">var jQuery_3_1 = $.noConflict(true); jQuery_3_1(document).ready(function() { HibernateDoc.OutdatedContent.install("ogm"); });</script><!-- /HibernateDoc.OutdatedContent --></body></html>